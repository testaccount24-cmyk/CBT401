         TITLE 'SPITBOL -- GENERAL DESCRIPTION'
*
*
*        S    P    I    T    B    O    L        3    6    0
*        --------------------------------------------------
*
*        SPEEDY  IMPLEMENTATION  OF  SNOBOL-4
*
*        VERSION 2.3
*
*        ILLINOIS INSTITUTE OF TECHNOLOGY
*
*        ROBERT B. K. DEWAR
*        KENNETH E. BELCHER
*
*    COPYRIGHT (C) 1971, 2001 ROBERT B. K. DEWAR AND KENNETH E. BELCHER
*
*
*        NEITHER AUTHOR IS CURRENTLY ASSOCIATED WITH ILLINOIS
*        INSTITUTE OF TECHNOLOGY. FOR CURRENT INFORMATION ABOUT
*        ABOUT SPITBOL 360 VISIT HTTP://WWW.SNOBOL4.COM
*        --------------------------------------------------------------
*
*
*        THIS FILE IS PART OF SPITBOL 360
*
*        SPITBOL 360 IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
*        MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE
*        AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2
*        OF THE LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.
*
*        SPITBOL 360 IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
*        BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
*        MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
*        GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
*
*        YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC
*        LICENSE ALONG WITH SPITBOL 360; IF NOT, WRITE TO THE FREE
*        SOFTWARE FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330,
*        BOSTON, MA  02111-1307  USA
*
*        --------------------------------------------------------------
*
*
*        CHANGE LOG:
*
*        2.3   8/14/2001 BOB GOLDBERG
*
*              PREPARED SOURCE FOR GPL DISTRIBUTION:
*              - UPDATED COMMENTS
*              - UPDATED SYSHEAD
*              - KEPT CSECT OFFSETS THE SAME AS V2.2 FOR TFS 1 TO 6
*
*        --------------------------------------------------------------
*
*
*        SPITBOL IS A FAST ONE PASS INCORE COMPILER ACCEPTING A
*        NEARLY COMPLETE VERSION OF THE SNOBOL-4 LANGUAGE WITH SOME
*        EXTENSIONS. THE FOLLOWING IS A BASIC DESCRIPTION OF THE
*        VARIOUS MODULES.
*
*        SPITBOLR
*        --------
*
*        IN MULTIPHASE ORGANIZATION, THIS IS THE ROOT PHASE. IT
*        CONTAINS A VARIETY OF ROUTINES WHICH ARE REQUIRED AT COMPILE
*        AND EXECUTE TIME AND ALSO CONTAINS THE CODE WHICH
*        HANDLES THE TRANSITION FROM COMPILATION TO EXECUTION.
*
*        SPITBOLC
*        --------
*
*        SPITBOLC IS THE COMPILER ITSELF WHICH IS DIVIDED INTO THE
*        FOLLOWING MAJOR SECTIONS --
*
*        CMPILE                   SUPERVISE STATEMENT COMPILATION
*        SCAN                     LEXICAL SCAN AND SYMBOL TABLE HANDLER
*        EXPAN                    BUILD TREE STRUCTURE FOR EXPRESSION
*        CODGEN                   GENERATE CODE FOR EXPRESSION
*        PRCODE                   PRINT GENERATED CODE
*        CONCPROC                 CONTROL CARD PROCESSOR
*        ERROR                    ERROR MESSAGE HANDLER
*        LISTER                   LIST SOURCE OUTPUT
*        READER                   READ SOURCE INPUT
*
         EJECT
*
*        SPITBOLP
*        --------
*
*        THIS CONTROL SECTION CONTAINS THE CODE FOR EXECUTION TIME
*        PATTERN MATCHING. IT IS DIVIDED INTO THREE SECTIONS --
*
*        A)    INDIVIDUAL PATTERN ROUTINES
*        B)    TRANSITION ROUTINES (QUICKSCAN MODE)
*        C)    TRANSITION ROUTINES (FULLSCAN MODE)
*
*        SPITBOLX
*        --------
*
*        SPITBOLX CONTAINS A WIDE VARIETY OF EXECUTION TIME ROUTINES
*        INCLUDING THE GARBAGE COLLECTOR. THERE ARE NO STANDARD BASE
*        REGISTERS COVERING THIS SECTION. EACH ROUTINE ESTABLISHES
*        ITS OWN BASE REGISTERS AS REQUIRED.
*
*        SPITBOLA
*        --------
*
*        SPITBOLA IS A 4K SECTION UNDER THE STANDARD EXECUTION BASE
*        REGISTER (SYS). IT CONTAINS FREQUENTLY USED EXECUTION
*        ROUTINES AND ALSO LINKAGES TO SPITBOLX FOR LESSER USED
*        ROUTINES. ENTRY POINTS FROM THE GENERATED CODE INTO THIS AREA
*        ARE BY CONVENTION PREFIXED WITH TWO $ SIGNS, E.G. $$ADD2
*
*        SPITBOLF
*        -------
*
*        SPITBOLF CONTAINS CODE FOR ALL SYSTEM FUNCTIONS. THOSE
*        FUNCTIONS WHICH ARE NORMALLY OPTIMIZED INTO SPITBOLA ENTRY
*        CALLS ARE GROUPED AT THE START OF SPITBOLF. THE REMAINING
*        SYSTEM FUNCTIONS WHICH ARE CALLED BY THE STANDARD SPITBOL
*        FUNCTION LINKAGE, ARE IN ALPHABETICAL ORDER. PART OF THE
*        STANDARD LINKAGE ESTABLISHES DB4 AS A BASE REGISTER.
*
*        SPITBOLD
*        --------
*
*        SPITBOLD IS A DUMMY SECTION WHICH SHOWS THE LAYOUT OF
*        STANDARD WORK AREAS AND MODIFIED CONSTANTS AT THE START OF
*        THE ALLOCATED DATA AREA.
         EJECT
*
*        USE OF MEMORY
*        -------------
*
*        THE USE OF MEMORY AT COMPILE TIME IS ILLUSTRATED BY THE
*        FOLLOWING PICTURE (LOW CORE AT THE TOP OF THE PICTURE)
*
*        +-------------------------------------------------------+
*        |             4K BLOCK UNDER BASE REG (DREG)            |
*        |             FIRST SECTION USED FOR STANDARD WORK      |
*        |             AREAS ETC., SEE SPITBOLD DSECT            |
*        |             REST USED FOR VARIABLE/CONSTANT BLKS      |
*        +-------------------------------------------------------+
*        |             GENERATED CODE, EXPANDS UPWARD            |
*        |             AS REQUIRED DURING COMPILATION            |
*        +-------------------------------------------------------+
*        |             2K SAFETY FOR CODE EXPANSION              |
*        +-------------------------------------------------------+
*        |             COMPILER WORK STACKS (3K)                 |
*        +-------------------------------------------------------+
*        |             2K SAFETY FOR CONSTANT CODE EXPANSION     |
*        +-------------------------------------------------------+
*        |             CODE TO COMPUTE VALUES OF                 |
*        |             CONSTANT SUBEXPRESSIONS, EXPANDS          |
*        |             DOWN AS REQUIRED.                         |
*        +-------------------------------------------------------+
*        |             SPACE FOR HIGH CORE DOWNWARD              |
*        |             EXPANSION, STARTS AT 2K EACH              |
*        |             TIME THE CONSTANT CODE IS MOVED           |
*        +-------------------------------------------------------+
*        |             HIGH CORE AREA, USED FOR STRINGS,         |
*        |             4K BLOCKS OF VARIABLES/CONSTANTS          |
*        +-------------------------------------------------------+
*        |             HASH TABLE FOR VARIABLES                  |
*        +-------------------------------------------------------+
*
*        THE COMPILER WORK STACKS ARE ESTABLISHED AT 2K ABOVE THE
*        CODE AT THE START OF EACH STATEMENT. NO STATEMENT CAN GENERATE
*        MORE THAN 2K CODE, SO NO CHECK IS REQUIRED.
*
*        SPACE IS ALLOCATED IN THE HIGH CORE REGION BY THE HIGHCORE
*        ROUTINE. CALLS TO THIS ROUTINE MAY RESULT IN MOVING THE
*        CODE FOR CONSTANT SUBEXPRESSIONS DOWN WITH AN APPROPRIATE
*        OVERLAP CHECK (2K MUST BE LEFT FOR CONSTANT CODE EXPANSION).
*        TO AVOID FREQUENT MOVEMENT OF THIS CODE, A 2K EXPANSION
*        SPACE IS ALLOCATED EACH TIME THE CODE IS MOVED.
         EJECT
*
*        USE OF MEMORY AT EXECUTION TIME
*
*        DYNAMIC MEMORY FOR EXECUTION USE STARTS JUST BEYOND THE
*        GENERATED CODE. BLOCKS FOR THE VARIOUS DATA STRUCTURES ARE
*        BUILT UPWARDS IN MEMORY FROM THIS POINT. THE GARBAGE COLLECTOR
*        COMPACTS THESE BLOCKS DOWN WHENEVER MEMORY IS EXHAUSTED.
*
*        THE MAIN EXECUTION STACK, FOR RECURSIVE PATTERN MATCHING
*        AND FUNCTION CALLS BUILDS DOWN IN MEMORY (PDR IS THE STACK
*        POINTER).
*
*        THE FIRST STEP AT EXECUTION TIME IS TO EXECUTE THE CODE
*        TO PRECALCULATE THE VALUES OF ALL CONSTANT SUBEXPRESSIONS.
*        FOR THIS PURPOSE, THE STACK POINTER IS INITIALIZED TO POINT
*        BELOW THE CONSTANT EXPRESSIONS CODE. NOTE THAT AN IMPORTANT
*        RESTRAINT AT THIS POINT IS THAT THE HIGH CORE CANNOT
*        EXPAND DURING THIS PROCESS.
*
*        WHEN THE CONSTANT CODE HAS BEEN EXECUTED, THE STACK POINTER
*        IS RESET TO JUST BELOW THE HIGH CORE AREA AND EXECUTION OF THE
*        MAIN CODE BEGINS.
*
*        AT THIS STAGE, CALLS TO THE HIGHCORE ROUTINE ARE PERMITTED,
*        (FOR EXAMPLE, TO BUILD NEW 4K BLOCKS FOR VARIABLES),
*        HIGHCORE RELOCATES THE STACK DOWNWARDS AS REQUIRED.
         EJECT
*
*        MODULE SELECTION CONTROL
*        -------------------------
*
*        THE VARIABLE &LMOD CONTROLS THE ASSEMBLY MODE.
*
*        WHEN &LMOD IS SET TO 0, THE STANDARD LOAD AND GO MODULES
*        ARE GENERATED. THESE MODULES INCLUDE ALL THE CODE WITH THE
*        EXCEPTION OF THE LINKUP ROUTINE FOR RESTART AFTER AN OBJECT
*        MODULE LOAD.
*
*        IF &LMOD IS SET TO 1, THE LIBRARY MODULES ARE GENERATED.
*        THESE MODULES ARE USED TO LINK WITH A GENERATED OBJECT
*        MODULE. SEVERAL SECTIONS OF CODE, PARTICULARLY IN THE COMPILER
*        ARE NOT NEEDED IN THE LIBRARY MODULES AND ARE DELETED FROM
*        THE ASSEMBLY
*
*        THE VARIABLE &LMOD IS DEFINED BY A SETA STATEMENT WHICH IS
*        COPIED FROM THE SYSLIB MEMBER 'DEFLMOD'. THUS TO ASSEMBLE
*        SPITBOL A MEMBER WITH THIS NAME MUST BE DEFINED IN SYSLIB
*        WITH ONE OF THE FOLLOWING TWO STATEMENTS --
*
*        &LMOD     SETA  0                  FOR STANDARD MODULES
*
*        &LMOD     SETA  1                  FOR LIBRARY MODULES
*
*        NOTE THAT THE SPITBOL ASSEMBLY MODULE MAKES NO OTHER SYSLIB
*        REFERENCES EXCEPT FOR THIS SINGLE REFERENCE TO 'DEFLMOD',
*        THUS SYSLIB MAY SIMPLY BE POINTED AT A SUITABLE PDS
*
*        IN ENVIRONMENTS NOT PERMITTING THE COPY DIRECTIVE, IT MUST
*        BE PHYSICALLY REPLACED WITH ONE OF THE ABOVE TWO IMAGES.
         TITLE 'SPITBOL -- COMPILER MACRO DEFINITIONS'
*
*        ERROR MESSAGE MACROS
*
*
*        ERR   NUMBER
*
*              IS USED TO GENERATE A CALL TO THE ERROR ROUTINE TO
*              PRINT THE ERROR MESSAGE WITH THE GIVEN NUMBER
*
*NUMBER  ERRM  'MESSAGE'
*
*              IS USED TO GENERATE ERROR MESSAGE NUMBER
*
         MACRO
&LABL    ERR   &NUM
         GBLA  &LMOD
&LABL    BALR  R7,CB1
         AIF   (&LMOD EQ 1).ERRL
         DC    Y(ERR&NUM-SPITBOLC)
         MEXIT
.ERRL    DC    Y(0)
         MEND
*
*
         MACRO
&NUM     ERRM  &MSG
         LCLA  &CNT
&CNT     SETA  K'&MSG-2-1
ERR&NUM  DC    YL1(&CNT)
         DC    C&MSG
         MEND
         EJECT
*
*        MACRO USED BY CONTROL CARD ROUTINE TO SET UP DICTIONARY
*
*        CALL OF --
*        CONC  NAME
*
*        SETS UP AN ENTRY FOR A CONTROL CARD WHOSE NAME BEGINS WITH
*        THE CHARACTERS 'NAME' AND WHOSE PROCESSING ROUTINE IS AT
*        CONC'NAME'
*
         MACRO
         CONC  &NAME
         DC    CL4'&NAME'
         DC    Y(CONC&NAME-CONCPROC)
         MEND
*
*
*        MACRO TO GENERATE HEADING LINES (SEE SYSHEAD & INTERFACE)
*
         MACRO
         HEDR  &LINE
         LCLA  &L
&L       SETA  K'&LINE-2
         DC    AL1(&L)
         DC    C&LINE
         MEND
*
*        MACRO TO GENERATE PROPER CSECT NAMES DEPENDING ON MODULE
*
         MACRO
         BEGIN &LTR
         GBLA  &LMOD
         AIF   (&LMOD EQ 1).LSECT
SPITBOL&LTR CSECT
         MEXIT
.LSECT   ANOP
SPITBLL&LTR CSECT
SPITBOL&LTR EQU SPITBLL&LTR
         MEND
         EJECT
*
*        INITV -- BUILD STANDARD VARIABLE ENTRY, SEE VARLOC
*
         MACRO
         INITV &NAME,&TYPE
         LCLC  &NAME6,&TYPEL
         LCLA  &CTR,&FLAGS,&LENGTH,&P,&K,&F,&O,&L
&NAME6   SETC  '&NAME'
         AIF   (K'&NAME LE 6).NOK
&NAME6   SETC  '&NAME6'(1,6)
.NOK     ANOP
E$&NAME6 EQU *
&LENGTH  SETA  1+1+K'&NAME
&CTR     SETA  1
.LOOP    AIF (&CTR GT K'&TYPE).ENDL
&TYPEL   SETC  '&TYPE'(&CTR,1)
&CTR     SETA  &CTR+1
         AIF   ('&TYPEL' EQ 'K').KK
         AIF   ('&TYPEL' EQ 'P').PP
         AIF   ('&TYPEL' EQ 'F').FF
         AIF   ('&TYPEL' EQ 'O').OO
         AIF   ('&TYPEL' EQ 'L').LL
         MNOTE 12,'ERROR IN TYPE PARAMETER'
.KK      ANOP
&K       SETA  1
&LENGTH  SETA  &LENGTH+1
&FLAGS   SETA  &FLAGS+1
         AGO   .LOOP
.PP      ANOP
&P       SETA  1
&FLAGS   SETA  &FLAGS+2
&LENGTH  SETA  &LENGTH+2
         AGO   .LOOP
.FF      ANOP
&F       SETA  1
&FLAGS   SETA  &FLAGS+4
&LENGTH  SETA  &LENGTH+3
         AGO   .LOOP
.OO      ANOP
&O       SETA  1
&FLAGS   SETA  &FLAGS+8
&LENGTH  SETA  &LENGTH+2
         AGO   .LOOP
.LL      ANOP
&L       SETA  1
&FLAGS   SETA  &FLAGS+16
&LENGTH  SETA  &LENGTH+2
         AGO   .LOOP
.ENDL    DC    AL1(&LENGTH)
         DC    C'&NAME'
         DC    AL1(&FLAGS)
         AIF   (&K EQ 0).KS
         DC    AL1(K$&NAME6)
.KS      AIF   (&P EQ 0).PS
         DC    AL2(P$&NAME6-SPITBOLX)
.PS      AIF   (&F EQ 0).FS
         DC    AL3(F$&NAME6-FCODE)
.FS      AIF   (&O EQ 0).OS
         DC    AL2(O$&NAME6-SPITBOLC)
.OS      AIF   (&L EQ 0).LS
         DC    AL2(L$&NAME6-SPITBOLX)
.LS      MEND
         EJECT
*
*        MACROS USED TO GENERATE TRANSLATE TABLES
*
*
*LABL    TABL  DFLT
*
*              INITIALIZES THE TABLE WITH NAME LABL TO CONTAIN
*              DFLT FOR ALL ENTRIES NOT SET WITH A 'FOR' MACRO CALL
*
*LABL    FOR   'CHARS',VALUE,FLAG
*
*              IN THE TABLE WITH NAME LABL, THE ENTRIES CORRESPONDING
*              TO THE CHARACTERS IN CHARS (WHICH MUST HAVE SEQUENTIAL
*              INTERNAL REPRESENTATIONS) ARE SET TO VALUE
*              THE FOLLOWING ARE USED IN PLACE OF THE FIRST PARAMETER
*              FOR SPECIAL CHARACTER CASES
*              FOR ' USE QT
*              FOR & USE AM
*              FOR X'00' USE ZR
*
*              IF A SINGLE CHARACTER IS TO BE SET, THEN FLAG MAY BE
*              SET TO X TO INDICATE THAT THE ENTRY IMMEDIATELY
*              FOLLOWS THE PREVIOUS ONE -- I.E. THAT NO ORG IS NEEDED
*              (THIS WILL MINIMIZE THE NUMBER OF TEXT CARDS GENERATED)
*
*        NOTE THAT AN ORG SHOULD BE ISSUED AFTER EACH SEQUENCE OF
*        FOR CALLS FOLLOWING A TABL MACRO TO RESET THE LOCATION COUNTER
*
*
         MACRO
&NAME    TABL  &DFLT
&NAME    DC    256AL1(&DFLT)
         MEND
         EJECT
*
*
         MACRO
&NAME    FOR   &CHARS,&VAL,&K
         LCLC  &FC
         LCLA  &NM
         AIF   ('&K' EQ 'X').F8
         AIF   (K'&CHARS EQ 2).F5
&FC      SETC  '&CHARS'(2,1)
&NM      SETA  K'&CHARS-2
         ORG   &NAME+C'&FC'
         DC    &NM.AL1(&VAL)
         MEXIT
.F5      AIF   ('&CHARS' EQ 'QT').F7
         AIF   ('&CHARS' EQ 'ZR').F6
         AIF   ('&CHARS' EQ 'AM').F9
         MNOTE 0,'ERROR IN LOCATION PARAMETER'
         MEXIT
.F6      ORG   &NAME
         AGO   .F8
.F7      ORG   &NAME+C''''
         AGO   .F8
.F9      ORG   &NAME+C'&&'
.F8      DC    AL1(&VAL)
         MEND
         EJECT
*
*        OPERATOR DOPE VECTOR GENERATION MACROS
*        THE FORMAT OF THESE CALLS IS DESCIBED IN THE SCAN ROUTINE
*        WHERE THE CALLS APPEAR
*
         MACRO
&LBL     BINOP &PRI,&VAL,&NAM,&FLG
         AIF   ('&NAM' EQ '').B4
         AIF   ('&FLG' EQ '').B2
&LBL     BINP1 &PRI,&VAL,YNAME+BNOP+&FLG
         BINP1 &PRI,&NAM,&FLG+BNOP
         MEXIT
.B2      ANOP
&LBL     BINP1 &PRI,&VAL,YNAME+BNOP
         BINP1 &PRI,&NAM,BNOP
         MEXIT
.B4      AIF   ('&FLG' EQ '').B6
&LBL     BINP1 &PRI,&VAL,&FLG+BNOP
         MEXIT
.B6      ANOP
&LBL     BINP1 &PRI,&VAL,BNOP
         MEND
*
*
         MACRO
&LBL     BINP1 &PRI,&RTN,&FLG
         CNOP  0,4
&LBL     DC    AL1(&PRI)
         AIF   (N'&RTN EQ 1).B6
         AIF   ('&RTN(2)' EQ 'N').B3
         AIF   ('&RTN(3)' EQ 'N').B1
.B6      DC    AL1(&FLG)
         AGO   .B9
.B1      DC    AL1(&FLG+RITNAM)
         AGO   .B9
.B3      AIF   ('&RTN(3)' EQ 'N').B4
         DC    AL1(&FLG+LEFNAM)
         AGO   .B9
.B4      DC    AL1(&FLG+LEFNAM+RITNAM)
.B9      DC    S(&RTN(1))
         MEND
         EJECT
         MACRO
&LBL     UNOP  &VAL,&NAM,&FLG
         AIF   ('&NAM' EQ '').U4
         AIF   ('&FLG' EQ '').U2
&LBL     UNOP1 &VAL,YNAME+RASS+&FLG
         UNOP1 &NAM,RASS+&FLG
         MEXIT
.U2      ANOP
&LBL     UNOP1 &VAL,YNAME+RASS
         UNOP1 &NAM,RASS
         MEXIT
.U4      AIF   ('&FLG' EQ '').U6
&LBL     UNOP1 &VAL,RASS+&FLG
         MEXIT
.U6      ANOP
&LBL     UNOP1 &VAL,RASS
         MEND
*
*
         MACRO
&LBL     UNOP1 &RTN,&FLG
         CNOP  0,4
&LBL     DC    AL1(15)
         AIF   (N'&RTN EQ 1).U6
         AIF   ('&RTN(2)' EQ 'N').U3
         DC    AL1(&FLG)
         AGO   .U4
.U3      DC    AL1(&FLG+RITNAM)
.U4      DC    S(&RTN(1))
         MEXIT
.U6      DC    AL1(&FLG)
         DC    S(&RTN)
         MEND
         EJECT
*
*        MACRO TO GENERATE TABLE OF SYSTEM ROUTINE
*        S ADDRESSES AND NAMES FOR SYMBOLIC PRINTOUT
*
         MACRO
         NAME
         LCLA  &CTR
&CTR     SETA  1
.LOOP    ANOP
         AIF   ('&SYSLIST(&CTR)' EQ '').END
         DC    S($$&SYSLIST(&CTR))
         DC    C'&SYSLIST(&CTR)'
&CTR     SETA  &CTR+1
         AGO   .LOOP
.END     MEND
         TITLE 'SPITBOL -- EXECUTION PACKAGE MACRO DEFINITIONS'
*
*        MACRO TO GENERATE STANDARD (ONE NODE) PATTERNS WITH NO PARAMS
*
*        PATTERN   NAME= , EXTEND= , MIN=
*
*        NAME=NNN                 NAME OF PATTERN
*                                 (THE CHARS  PAT  ARE ADDED ON)
*        EXTEND=YES               INDICATES USE OF EXTEND ROUTINE
*        MIN=NNN                  SPECIFIES CONTENTS OF MINMATCH FIELD
*                                 (DEFAULT IS ZERO)
*
         MACRO
         PATTERN   &NAME=,&EXTEND=NO,&MIN=0
         CNOP  0,4
&NAME.PAT EQU  *
         DC    AL1(PBLOK)
         DC    AL3(0)
         DC    Y(28)
         DC    Y(ANCHEXT-QPATSUBS)
         DC    A(NOTHEN)
         DC    AL1(QF)
         DC    AL3(NOOR)
         DC    AL1(QF)
         DC    AL3(PN$&NAME)
         DC    Y(&MIN)
         AIF   ('&EXTEND' EQ 'YES').YX
         DC    Y(NOEXT-QPATSUBS)
         AGO   .YZ
.YX      DC    Y(&NAME.EXT-QPATSUBS)
.YZ      DC    AL2(PNOTHEN-PATS)
         DC    AL2(PNOOR-PATS)
         MEND
         EJECT
*
*        PORG -- MACRO USED TO POSITION FULL SCAN ROUTINES FOR PATTERN
*        MATCHING IN CORRECT LOCATION RELATIVE TO QUICKSCAN ROUTINES
*
         MACRO
&NAME    PORG
         LA    0,&NAME+FPATSUBS-QPATSUBS-*  CHECK FOR BACKWARDS
         ORG   &NAME+FPATSUBS-QPATSUBS
         MEND
         EJECT
*
*        MACRO TO GENERATE TABLE OF INTERRUPT LOCATIONS AND EXITS
*        FOR SPINTR
*
         MACRO
         INTRUP    &WHERE,&TYPE,&TRA
         DC    AL1(INT&TYPE)
         DC    AL2(IIN&TYPE)
         DC    AL3(&WHERE)
         DC    AL3(&TRA)
         MEND
*
*        MACRO TO GENERATE KEYWORD TABLE ENTRY FOR DUMP FUNCTION
*
         MACRO
&LBL     KEYOFF &N
         LCLA  &A
         LCLC  &C
&C       SETC  '&N'
&A       SETA  (K'&N-1)*4096
         AIF   (K'&N LE 6).NXT
&C       SETC  '&C'(1,6)
.NXT     ANOP
&LBL     DC    Y(&A+E$&C-INITVR1)
         MEND
         EJECT
*
*        MACROS FOR EXECUTION ERROR MESSAGES
*
*
*NUMBER  XERM  'ERROR MESSAGE'
*
*              SETS UP 'ERROR MESSAGE' AS MESSAGE NUMBER 'NUMBER'
*
         MACRO
&NO      XERM  &MSG
         GBLA  &XCNT
         LCLA  &K
&K       SETA  K'&MSG-3
XERR&NO  DC    AL1(&K)
         DC    C&MSG
&XCNT    SETA  &NO
         MEND
*
*        XETB
*
*        GENERATES A TABLE OF OFFSETS TO ERROR MESSAGES
*
         MACRO
         XETB
         GBLA  &XCNT
         LCLA  &CTR
EXERMA   DS    0H
&CTR     SETA  1
.LOOP    DC    AL2(XERR&CTR-EXMSGS)
&CTR     SETA  &CTR+1
         AIF   (&CTR LE &XCNT).LOOP
         MEND
         EJECT
*
*LABL    XERR  NUMBER,ID
*
*
*        GENERATES A CALL TO PRINT ERROR MESSAGE NUMBER WITH GIVEN ID
*
         MACRO
&LBL     XERR  &MAJOR,&MINOR,&S
XER&MAJOR&MINOR EQU *
         AIF   ('&S' EQ 'S').CALLS
&LBL     BALR  RETURN,SYS
         DC    AL1(&MAJOR,&MINOR)
         MEXIT
.CALLS   ANOP
&LBL     BAL   R1,EXERRS
         DC    AL1(&MAJOR,&MINOR)
         MEND
*
*
*        XERN IS LIKE XERR EXCEPT THAT THE ASSEMBLY SYMBOL GENERATED
*        IS XENXXYYY INSTEAD OF XERXXYYY. THIS IS USED WHERE THE
*        SAME ERROR MESSAGE MUST BE ISSUED FROM TWO LOCATIONS
*
         MACRO
&LBL     XERN  &MAJOR,&MINOR,&S
XEN&MAJOR&MINOR EQU *
         AIF   ('&S' EQ 'S').CALLS
&LBL     BALR  RETURN,SYS
         DC    AL1(&MAJOR,&MINOR)
         MEXIT
.CALLS   ANOP
&LBL     BAL   R1,EXERRS
         DC    AL1(&MAJOR,&MINOR)
         MEND
         EJECT
*
*
*        MACRO TO GENERATE ENTRY POINTS FOR INTRINSIC FUNCTIONS
*        WITH ONE ARGUMENT (SEE ANY ENTRY POINT)
*
         MACRO
&NAME    FUNC  &TRA
         LCLC  &NM
&NM      SETC  '&NAME'
         AIF   (K'&NAME LE 6).OKL
&NM      SETC  '&NM'(1,6)
.OKL     ANOP
         USING F$&NM-FCODE,DB4
F$&NM    BAL   R2,LOADARG
         DC    Y(&TRA-SPITBOLA)
         MEND
*
*        MACRO TO GENERATE STANDARD FUNCTION HEADER
*
         MACRO
&NAME    FUNCTION  &NARG,&FLAG
         LCLC  &NM
&NM      SETC  '&NAME'
         AIF   (K'&NAME LE 6).OKL
&NM      SETC  '&NM'(1,6)
.OKL     ANOP
F$&NM    DS    0H
         USING F$&NM-FCODE,DB4
         USING SPITBOLA,SYS
         AIF   (&NARG LT 2).S
         CH    R0,H&NARG
         BL    $$WNAG
.S       AIF   ('&FLAG' NE '').T
         ST    RETURN,RETLOC
.T       ANOP
         MEND
*
*        MACRO TO GENERATE STANDARD FUNCTION TERMINATION
*
         MACRO
&NAME    ENDFUNC
         LTORG
         MEND
         TITLE 'SPITBOL -- GLOBAL SET SYMBOL DEFINITIONS'
         GBLA  &XCNT              EXECUTION ERROR MESSAGE COUNT
         GBLA  &LMOD              GLOBAL MODULE SWITCH
*
&XCNT    SETA  0                  INITIALIZE EXECUTION MESSAGE COUNT
*
*        COPY EXTERNAL DEFINITION OF &LMOD
*
         COPY  DEFLMOD            (CONTAINS &LMOD SETA 0 OR 1)
*
         PRINT NOGEN              LET THE LISTING BE CLEAN & BEAUTIFUL
         TITLE 'SPITBOL -- DATA STRUCTURES -- ADDRESSABLE AREA'
FORMAT   DSECT ,                  FORMATS AND DEFINITIONS
*
*        THE ADDRESSABLE AREA IS DIVIDED INTO 4K BLOCKS EACH OF
*        WHICH IS ADDRESSABLE USING A BASE VALUE LOADED FROM THE
*        DATA BASE TABLE ($$BAS1,2,3...). THE DATA BASE TABLE IS
*        ALWAYS ADDRESSABLE SINCE IT IS UNDER THE STANDARD DATA
*        REGISTER (8 = DREG = DB1). THIS REGISTER ALSO POINTS
*        TO THE FIRST 4K BLOCK, WHICH IS ATYPICAL SINCE THE FIRST
*        SECTION IS USED FOR GENERAL WORK AREAS (SEE SPITBOLD DSECT)
*
*        WITHIN EACH 4K SEGMENT, VARIABLE BLOCKS (SEE NEXT PAGE)
*        ARE BUILT UPWARDS FROM THE BOTTOM, AND CONSTANT BLOCKS
*        ARE BUILT DOWN FROM THE TOP.
*
*        THE LAST 8 BYTES OF EACH BLOCK ARE USED FOR CONTROL
*        INFORMATION AS FOLLOWS
*
CBLKBOT  EQU   4096-8             ADDRESS OF LOWEST CONSTANT BLOCK
*                                 ACTUALLY ALLOCATED (NOTE THAT THE
*                                 UPPER BYTE MUST BE ZERO FOR GCOL)
*
VBLKNXT  EQU   4096-4             ADDRESS OF NEXT VARIABLE BLOCK TO
*                                 BE ALLOCATED (VBLKNXT<=CBLKBOT)
*
CBLKEND  EQU   4096-8             INITIAL OFFSET TO LAST CONSTANT BLK
*
*        NOTE THAT THE ADDRESSES STORED IN CBLKBOT AND VBLKNXT
*        DO NOT CONTAIN THE STANDARD (VALUE) BLOCK OFFSET
*
*        ADDRESSES OF 4K BLOCKS STORED AND REFERENCED IN VARIOUS PLACES
*        ARE ADDRESSES OF THE ACTUAL BLOCKS EXCEPT FOR THE ADDRESSES
*        IN THE BASE TABLE WHICH POINT (VALUE) IN FRONT OF THE 4K
*        BLOCK TO ENSURE ADDRESSABILITY OF THE FIRST VARIABLE BLOCK.
         EJECT
*
*        VARIABLE BLOCK
*        --------------
*
*
*     ->
*        +-------------------------------------------------------+
*        |                                                       |
*        +                         VALUE                         +
*        |                                                       |
*        +-------------+-----------------------------------------+
*        |   VFLAGS    |                 VLINK                   |
*        +-------------+-----------------------------------------+
*        |   VKEY      |                 VFUNC                   |
*        +-------------+-----------------------------------------+
*        |   VPHASE    |                 VLABL                   |
*        +-------------+-----------------------------------------+
*        |   //////    |                 VIOPTR                  |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        +                         VNAME                         +
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR VARIABLE BLOCK
*        ----------------------------------------------
*
*        NOTE THAT DATA AREA IS ALLIGNED SO THAT BOTH VALUE AND VNAME
*        LIE ON DOUBLE WORD BOUNDARIES. THIS SPEEDS REFERENCES ON
*        LARGER 360S SO IT SHOULD BE PRESERVED
*
VALUE    EQU   4                  OFFSET TO VALUE FIELD
VFLAGS   EQU   12                 FLAGS (SEE OVER)
VLINK    EQU   12                 LINK TO NEXT BLOCK ON HASH CHAIN
VKEY     EQU   16                 KEYWORD NUMBER (0 IF NOT KEYWORD)
*                                 LESS THAN X'80' SO VFUNC IS POSITIVE
VFUNC    EQU   16                 POINTER TO FUNCTION BLOCK (OR DV PTR)
VPHASE   EQU   20                 PHASE NUMBER FOR LABEL IN MULTIPHASE
VLABL    EQU   20                 POINTER TO LABEL
VDVPTR   EQU   VALUE+4            DOPE VECTOR POINTER FOR INTRINSIC FNC
VIOPTR   EQU   24                 PTR TO IOBLOK IF I/O ASSOCIATED
*                                 SET TO ZERO IF NOT ASSOCIATED
VNAME    EQU   28                 NAME OF BLOCK (STANDARD SCODE FORMAT)
VARSIZ   EQU   32                 LENGTH OF VARIABLE BLOCK
         EJECT
*
*        VARIABLE BLOCK -- CONTINUED
*
*        FLAGS IN VFLAGS
*
VINP     EQU   X'80'              ON -> INPUT CODE INTERCEPTS POSTED
VOUP     EQU   X'40'              ON -> OUTPUT CODE INTERCEPTS POSTED
VINA     EQU   X'20'              ON -> VARIABLE IS INPUT ASSOCIATED
VOUA     EQU   X'10'              ON -> VARIABLE IS OUTPUT ASSOCIATED
VTRC     EQU   X'08'              ON -> VARIABLE IS VALUE TRACED
VFTC     EQU   X'04'              ON -> FUNCTION IS CALL TRACED
VFTR     EQU   X'02'              ON -> FUNCTION IS RETURN TRACED
*
*
*        THE COMPILER BUILDS ONE OF THESE BLOCKS FOR EACH VARIABLE,
*        LABEL OR FUNCTION MENTIONED IN THE SOURCE PROGRAM.
*
*        IN ADDITION THE INDIRECT ADDRESSING ROUTINES $$DL1N,$$DL1S
*        ALSO BUILD VARIABLE BLOCKS IN THE ADDRESSABLE DATA AREA
*
*        NOTE THAT ALL THE OFFSETS ARE DEFINED WITH RESPECT TO A
*        PSEUDO-ORIGIN 4 BEHIND THE START OF THE BLOCK -- THIS IS FOR
*        COMPATABILITY WITH THE EXECUTE TIME STRUCTURES WHICH HAVE A
*        FOUR BYTE GARBAGE COLLECTION FIELD
*
*
*        RELOCATABLE FIELDS       VALUE
*                                 VNAME
*                                 VFUNC
         EJECT
*
*        REAL AND INTEGER CONSTANTS
*        --------------------------
*
*        (COMPILE TIME)
*
*     ->
*        +-------------+-----------------------------------------+
*        |   CONCODE   |                    CHASHL               |
*        +-------------+-----------------------------------------+
*        |                        CVALUE                         |
*        +-------------------------------------------------------+
*
CONCODE  EQU   VALUE              ICODE FOR INTEGER, RCODE FOR REAL
CHASHL   EQU   VALUE              PTR TO NEXT CONSTANT ON HASH CHAIN
CVALUE   EQU   VALUE+4            VALUE OF INTEGER OR REAL CONSTANT
*
*        AT EXECUTE TIME, THIS BLOCK IS CONVERTED TO STANDARD
*        VALUE FORMAT BY CLEARING THE CHASHL FIELD TO ZERO.
*        CHASHL IS USED TO LINK CONSTANTS INTO THE CONSTANT HASH TABLE
*        (CHASH) TO AVOID CREATING DUPLICATE CONSTANTS.
*
*
*        STRING CONSTANTS
*        ----------------
*
*        (COMPILE TIME)
*
*     ->
*        +-------------+-----------------------------------------+
*        |   CONCODE   |                    CHASHL               |
*        +-------------+-----------------------------------------+
*        |   CSLENGTH  |                    CSADR                |
*        +-------------+-----------------------------------------+
*
*CONCODE EQU   VALUE              SET TO SCODE TO INDICATE STRING
*CHASHL  EQU   VALUE              POINTER TO NEXT BLOCK ON HASH CHAIN
CSLENGTH EQU   VALUE+4            360 LENGTH OF STRING CONSTANT
CSADR    EQU   VALUE+4            ADDRESS OF STRING (- SCHARS)
*
*        BEFORE EXECUTION, THIS BLOCK IS REORGANIZED TO CONFORM
*        TO THE REQUIREMENTS FOR A STANDARD STRING SPECIFIER
*
*
*        DREALS, EXPRESSIONS AND CONSTANT SUBEXPRESSIONS CAUSE THE
*        CONSTRUCTION OF A BLOCK IN STANDARD VALUE FORMAT AS DESCRIBED
*        IN A FOLLOWING SECTION. THESE CONSTANTS ARE NOT HASHED.
         TITLE 'SPITBOL -- DATA FORMATS -- DYNAMIC AREA'
*
*        COMMON STRUCTURE
*        ----------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    DTYPE    |               GCOLPTR                   |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        +                 REMAINDER OF BLOCK                    +
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        OFFSET DEFINITIONS
*        ------------------
*
DTYPE    EQU   0                  CODE FOR DATA TYPE
GCOLPTR  EQU   0*4                POINTER FIELD USED BY GARBAGE
*                                 COLLECTOR
*
*
*        FUNCTION BLOCK FORMAT DESCRIPTION
*        ---------------------------------
*
*        FUNCTIONS WHICH ARE COMPILED AS BLOCKS IN DYNAMIC MEMORY
*        HAVE A CERTAIN COMMON STRUCTURE. NAMELY EXECUTION OF THE
*        FUNCTION STARTS WITH A BRANCH TO THE INSTRUCTION IN THE
*        FCODE FIELD. THE FOUR TYPES OF FUNCTION IN DYNAMIC MEMORY
*        CAN BE UNIQUELY IDENTIFIED BY THE FIRST INSTRUCTION IN
*        THIS CODE SEQUENCE (I.E. THE INSTRUCTION AT FCODE):
*
*        FBLOK     PROG DEFINED FUNC        B  $$FUNC
*        EFBLOK    EXTERNAL FUNCTION        B  $$LOAD
*        PDFBLOK   PROG DEF DATATYPE FUNC   CH R0,*-*(DB4)
*        FFBLOK    FIELD FUNCTION           CLI  TEM#1(PDR),DCODE
*
*        IT IS MOST IMPORTANT THAT NO SYSTEM FUNCTIONS START WITH ANY
*        OF THE ABOVE FOUR INSTRUCTIONS OR SERIOUS CONFUSION WILL ARISE
         EJECT
*
*        STRING BLOCK (SBLOK)
*        --------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    SBLOK    |                    ///////              |
*        +-------------+-------------+---------------------------+
*        |        STLENGTH           |                           |
*        +---------------------------+                           |
*        |                                                       |
*        |                       SCHARS                          |
*
*        /                                                       /
*        /                                                       /
*
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR SBLOK
*        -------------------------------------
*
SBLOK    EQU   0                  CODE FOR STRING BLOCK
STLENGTH EQU   4                  LENGTH OF BLOCK (PADDED TO 4 BT BDRY)
SCHARS   EQU   6                  START OF CHARACTER STRING
*
*        THIS BLOCK CONTAINS AN ARBITRARY STRING OF CHARACTERS OF
*        ANY LENGTH -- INDIVIDUAL SPECIFIERS MAY POINT TO A PART OR THE
*        WHOLE OF THIS STRING.
*
*        AN SBLOK IS CREATED BY ANY OPERATION WHICH FORMS A NEW STRING,
*        SUCH AS CONCATENATION, INPUT, PATTERN REPLACEMENT ETC.
*
*        RELOCATABLE FIELDS       NONE
         EJECT
*
*        CHARACTER TABLE BLOCK (TBLOK)
*        -----------------------------
*
*        +-------------+-----------------------------------------+
*     -> |    TBLOK    |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        +                        CTCHARS                        +
*
*        /                                                       /
*        /                                                       /
*
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTIONS FOR TBLOK
*        --------------------------------------
*
TBLOK    EQU   SBLOK+4            CODE FOR CHARACTER TABLE
CTCHARS  EQU   4                  OFFSET FOR 256 CHARACTER TABLE
*
*        THESE TABLES ARE USED BY THE SPAN,BREAK,ANY AND NOTANY
*        PATTERNS. FOR SPAN AND BREAK THEY ARE SIMPLY 360 TRANSLATE
*        AND TEST TABLES (ONE TABLE CORRESPONDS TO ONE PATTERN)
*        FOR ANY AND NOTANY, UP TO 8 PATTERNS CAN SHARE THE SAME TABLE
*        BY USING THE 8 AVAILABLE BIT POSITIONS IN EACH BYTE.
*
*        A TBLOK IS CREATED ON A CALL TO ONE OF THE ABOVE
*        FUNCTIONS WHEN NEEDED.
*
*        RELOCATABLE FIELDS       NONE
         EJECT
*
*        FUNCTION BLOCK (FBLOK)
*        ----------------------
*
*        +-------------+-----------------------------------------+
*     -> |    FBLOK    |                    ///////              |
*        +-------------+-------------+-------------+-------------+
*        |           FNLENG          |    FFLAGS   |    /////    |
*        +---------------------------+-------------+-------------+
*        |                        B    $$FUNC                    |
*        +---------------------------+---------------------------+
*        |           FNARGS          |           FNLOCS          |
*        +---------------------------+---------------------------+
*        |                         FLABEL                        |
*        +-------------------------------------------------------+
*        |                         FNAME                         |
*        +-------------------------------------------------------+
*        |                FARGS (FIRST ARG POINTER)              |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------------------------------------------------+
*        |                    LAST ARG POINTER                   |
*        +-------------------------------------------------------+
*        |                    FIRST LOCAL POINTER
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------------------------------------------------+
*        |                    LAST LOCAL POINTER                 |
*        +-------------------------------------------------------+
         EJECT
*
*        DEFINITIONS AND DESCRIPTION FOR FBLOK
*        -------------------------------------
*
FBLOK    EQU   TBLOK+4            CODE FOR FUNCTION BLOCK
FCODE    EQU   8                  ENTRY POINT TO CODE FOR FUNCTION
FNLENG   EQU   4                  LENGTH OF FBLOK (BYTES)
FFLAGS   EQU   6                  FUNCTION TRACE FLAGS
FNARGS   EQU   12                 NUMBER OF ARGUMENTS
FNLOCS   EQU   14                 NUMBER OF LOCALS
FLABEL   EQU   16                 ACTUAL LABEL POINTER FOR TRA
FNAME    EQU   20                 VBLOK POINTER FOR NAME OF FUNCTION
FARGS    EQU   24                 START OF ARGS/LOCALS VBLOK POINTERS
*
*        FUNCTION TRACE FLAGS
*
FTRCC    EQU   VFTC               FLAG FOR FUNCTION CALL TRACE
FTRCR    EQU   VFTR               FLAG FOR FUNCTION RETURN TRACE
*
*        THIS BLOCK CONTROLS ALL THE NECCESSARY STACK MANIPULATIONS
*        SAVES ETC. TO CALL USER DEFINED FUNCTIONS. SEE SECTION ON
*        PDR STACK ORGANIZATION FOR A DETAILED DESCRIPTION OF THE
*        USE OF THIS STACK.
*
*        AN FBLOK IS BUILT BY A CALL TO THE DEFINE ROUTINE
*
*        RELOCATABLE FIELDS       NONE
         EJECT
*
*        EXTERNAL FUNCTION CONTROL BLOCK (EFBLOK)
*        ----------------------------------------
*
*
*        +-------------+-----------------------------------------+
*        |    EFBLOK   |                    ///////              |
*        +-------------+-------------+---------------------------+
*        |           EFNARGS         |            EFLENG         |
*        +---------------------------+---------------------------+
*        |                  B     $$LOAD                         |
*        +-------------+-----------------------------------------+
*        |    EFUSE    |                 EFCODE                  |
*        +-------------+-----------------------------------------+
*        |                        EFNAME                         |
*        +-------------+-----------------------------------------+
*        |    EFTRSL   |                                         |
*        +-------------+                                         +
*
*        /                        EFTARGS                        /
*        /                                                       /
*
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR EFBLOK
*        --------------------------------------
*
EFBLOK   EQU   FBLOK+4            CODE FOR EXTERNAL FUNCTION CNTL BLOCK
EFNARGS  EQU   4                  NUMBER OF ARGS FOR EXTERNAL FUNCTION
EFLENG   EQU   6                  LENGTH OF THE EFBLOK IN BYTES
EFUSE    EQU   12                 USECOUNT = # OF FUNCS POINTING TO BLK
*                                 USED TO DETERMINE WHEN CODE SHOULD
*                                 BE UNLOADED BY SYSTEM
EFCODE   EQU   12                 FUNCTION CODE POINTER (SYSTEM AREA)
EFNAME   EQU   16                 POINTER TO VAR BLK WITH FUNCTION NAME
EFTRSL   EQU   20                 CODE FOR TYPE OF RESULT
*                                 REAL      LOADRRL-LOADRTNS
*                                 DREAL     LOADRDR-LOADRTNS
*                                 INTEGER   LOADRIN-LOADRTNS
*                                 STRING    LOADRST-LOADRTNS
*                                 NOCONVERT LOADRNC-LOADRTNS
         EJECT
*
EFTARGS  EQU   21                 ARGUMENT TYPES (ONE BYTE PER ARG)
*                                 REAL      LOADRL-LOADCL
*                                 DREAL     LOADDR-LOADCL
*                                 INTEGER   LOADIN-LOADCL
*                                 STRING    LOADST-LOADCL
*                                 NOCONVERT LOADCNC-LOADCL
*
*
*        AN EFBLOK IS CREATED WHEN AN EXTERNAL FUNCTION IS LOADED WITH
*        A CALL TO THE LOAD FUNCTION -- THE VFUNC FIELD OF THE CORRES-
*        PONDING VARIABLE BLOCK IS CHANGED TO POINT TO THE EFBLOK
*
*        RELOCATABLE FIELDS       NONE
*
HNRLBLOK EQU   EFBLOK             HIGHEST BLOK CODE WITH NO RELOC FLDS
         EJECT
*
*        I/O PARAMETER BLOCK (IOBLOK)
*        ----------------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |   IOBLOK    |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        +                        IOTAG                          +
*        |                                                       |
*        +-------------------------------------------------------+
*        |                        IOVBLK                         |
*        +-------------------------------------------------------+
*        |                        IOFUNC                         |
*        +-------------------------------------------------------+
*        |                                                       |
*        +                        IFORMAT                        |
*        |                                                       |
*        +-------------------------------------------------------+
*        |                        IFILE                          |
*        +-------------------------------------------------------+
*        |                                                       |
*        +                        OFORMAT                        |
*        |                                                       |
*        +-------------------------------------------------------+
*        |                        OFILE                          |
*        +-------------------------------------------------------+
         EJECT
*
*        DEFINITIONS AND DESCRIPTION FOR IOBLOK
*        --------------------------------------
*
IOBLOK   EQU   EFBLOK+4           CODE FOR I/O FORMAT BLOCK
IOTAG    EQU   4                  VALUE TO BE PASSED TO PROGRAMER'S
*                                 TRACE FUNCTION IF INVOKED ON VALUE TR
IOVBLK   EQU   IOTAG+8            ADDRESS OF VARIABLE BLOCK REFERING
*                                 TO THIS IOBLOK - ONLY IF TRACED
IOFUNC   EQU   IOVBLK+4           ADDRESS OF FUNCTION TO BE INVOKED FOR
*                                 VALUE TRACE - ZERO IF NO FUNCTION
IFORMAT  EQU   IOFUNC+4           INTEGER SPECIFIER FOR INPUT FORMAT
*                                 ZERO IF NO INPUT FORMAT
IFILE    EQU   IFORMAT+8          PTR TO SYSTEM INTERFACE I/O BLOCK
OFORMAT  EQU   IFILE+4            STRING SPECIFIER FOR OUTPUT FORMAT
*                                 ZERO IF NO OUTPUT FORMAT
OFILE    EQU   OFORMAT+8          PTR TO SYSTEM INTERFACE I/O BLOCK
IOBSIZE  EQU   OFILE+4            LENGTH OF IOBLOK
*
*        AN IOBLOK IS ALLOCATED FOR EACH VARIABLE WHICH IS INPUT
*        OR OUTPUT ASSOCIATED. THE OFORMAT AND IFORMAT FIELDS ARE
*        TAKEN FROM THE THIRD ARGUMENTS OF THE INPUT AND
*        OUTPUT FUNCTION CALLS WHICH PERFORMED THE ASSOCIATION(S).
*        IFILE AND OFILE ARE POINTERS TO THE SYSTEM INTERFACE
*        CONTROL BLOCKS FOR THE INPUT AND OUTPUT FILES. THESE POINTERS
*        ARE SUPPLIED BY THE SYSTEM INTERFACE ON AN IOPEN OR OOPEN CALL
*        AND THE FORMAT OF THESE BLOCKS IS A FUNCTION OF THE INTERFACE.
*        TRACE INFORMATION IS ALSO KEPT IN AN IOBLOK WHEN A PROGRAMER
*        DEFINED TRACE FUNCTION IS SPECIFIED ON A VALUE TRACE CALL
*        TRACE FIELD OFFSETS MUST BE THE SAME AS IN A TRBLOK
*
*        RELOCATABLE FIELDS       OFORMAT
*                                 IOTAG
         EJECT
*
*        ARRAY BLOCK (ABLOK)
*        -------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    ABLOK    |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                        NBYTESA                        |
*        +-------------+-----------------------------------------+
*        |    NSUBS    |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        |                      ASPEC                            |
*        |                                                       |
*        +-------------------------------------------------------+
*        |                      SUBFAC (1)                       |
*        +---------------------------+---------------------------+
*        |         SUBLBD (1)        |           SUBDIM (1)      |
*        +---------------------------+---------------------------+
*        |                                                       |
*        |         SUBLBD,SUBDIM,SUBFAC FOR SECOND SUBSCR        |
*        |                          ETC                          |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------------------------------------------------+
*        |                                                       |
*        |       CONTENTS OF FIRST ARRAY ELEMENT                 |
*        |                                                       |
*        +-------------------------------------------------------+
*        |                                                       |
*        |       CONTENTS OF SECOND ARRAY ELEMENT                |
*        |                          ETC                          |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------------------------------------------------+
*        |                                                       |
*        |       CONTENTS OF LAST ARRAY ELEMENT                  |
*        |                                                       |
*        +-------------------------------------------------------+
         EJECT
*
*        DEFINITIONS AND DESCRIPTION FOR ABLOK
*        -------------------------------------
*
ABLOK    EQU   IOBLOK+4           CODE FOR ARRAY BLOCK
NBYTESA  EQU   4                  NUMBER OF BYTES IN THIS BLOCK
NSUBS    EQU   NBYTESA+4          NUMBER OF SUBSCRIPTS IN THIS ARRAY
ASPEC    EQU   NBYTESA+8          STRING SPECIFIER FOR PROTOTYPE
SUBFAC   EQU   ASPEC+8            MULTIPLICATION FACTOR
SUBLBD   EQU   SUBFAC+4           SUBSCRIPT LOW BOUND
SUBDIM   EQU   SUBLBD+2           SUBSCRIPT DIMENSION (HBD-LBD+1)
AVALS    EQU   SUBFAC+8           PSEUDO OFFSET TO FIRST ELEMENT
*
*        NOTE THAT THE ARRAY ELEMENTS ARE STORED COLUMNWISE -- THUS
*        SUBFAC IS THE PRODUCT OF PREVIOUS SUBDIMS * 8 FOR BYTE FACTOR
*
*
*        ASPEC CONTAINS THE CONTENTS FIELD OF THE PROTOTYPE AS COPIED
*        FROM THE FIRST ARGUMENT IN THE CALL TO ARRAY WHICH GENERATED
*        THIS ABLOK -- THIS FIELD IS USED BY THE PROTOTYPE FUNCTION
*
*        AN ABLOK IS CREATED BY A CALL TO THE ARRAY FUNCTION
*
*        RELOCATABLE FIELDS       POINTER (IF ANY) IN ASPEC
*                                 POINTERS IN ALL VALUE FIELDS
*
*        NOTE THAT IF THE BLOCK STARTING WITH NBYTESA IS CONSIDERED
*        TO CONSIST ENTIRELY OF POINTERS PROCESSABLE BY THE GARBAGE
*        COLLECTOR  (PTRPROCV) NO PROBLEMS ARISE, SINCE THE 'TYPE CODE'
*        BYTE OF THE NON-VALUE ENTRIES IS ALWAYS 0, WHICH IS ICODE AND
*        IS NOT RELOCABLE  -- THIS TECHNIQUE IS USED IN GCOL
         EJECT
*
*        PROGRAM DEFINED DATATYPE BLOCK (PDBLOK)
*        ---------------------------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    PDBLOK   |                    ///////              |
*        +-------------+-----------------------------------------+
*        |   NBYTESD   |                    PDFPTR               |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        |                 PDFLDS(LAST FIELD VALUE)              |
*        |                                                       |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------------------------------------------------+
*        |                                                       |
*        |                        FIRST FIELD VALUE              |
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR PDBLOK
*        --------------------------------------
*
*
PDBLOK   EQU   ABLOK+4            CODE FOR PROG DEFINED DATATYPE
NBYTESD  EQU   4                  LENGTH OF PDBLOK IN BYTES
PDFPTR   EQU   4                  POINTER TO CORRESPONDING PDFBLOK
PDFLDS   EQU   8                  LAST FIELD VALUE
*
*
*        ONE OF THESE BLOCKS IS BUILT EACH TIME A PROGRAM DEFINED
*        DATATYPE IS CONTRUCTED BY A CALL TO ITS ASSOCIATED FUNCTION,
*        NOTE THAT THE FIELD CONTENTS ARE 'BACKWARDS', THIS IS BECAUSE
*        THE PDR BUILDS DOWN IN CORE AND SO FUNCTION ARGUMENT LISTS
*        ARE NATURALLY BUILT IN REVERSE ORDER.
*
*        A PDBLOK IS CREATED BY A CALL TO ITS ASSOCIATED FUNCTION
*        (SEE PDFBLOK).
*
*        RELOCATABLE FIELDS       PDFPTR
*                                 EACH VALUE FIELD (WHERE NEEDED)
         EJECT
*
*        FIELD FUNCTION BLOCK (FFBLOK)
*        -----------------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    FFBLOK   |                    ///////              |
*        +-------------+-----------------------------------------+
*        |   NBYTESD   |                    PDFPTR               |
*        +-------------+-----------------------------------------+
*        |     CLI   TEM#1,DCODE  CHECK FOR CORRECT POINTER      |
*        +-------------------------------------------------------+
*        |     LA    A1+1,OFFSET  LOAD CORRECT OFFSET FOR FLD    |
*        +-------------------------------------------------------+
*        |     BE    $$FLCN       IF OK, CALL FUNCTION TO CONT   |
*        +-------------------------------------------------------+
*        |     B     $$FLE1       ELSE GO GENERATE ERROR         |
*        +-------------------------------------------------------+
*        |                        FFBLNEXT                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR FFBLOK
*        --------------------------------------
*
*
FFBLOK   EQU   PDBLOK+4           CODE FOR FIELD FUNCTION BLOCK
*NBYTESD EQU   4                  LENGTH OF PDBLOK IN BYTES
*PDFPTR  EQU   4                  POINTER TO ASSOCIATED PDFBLOK
FFBLNEXT EQU   24                 POINTER TO NEXT FFBLOK WITH SAME
*                                 NAME (ZERO IF THIS IS THE LAST)
FFBSIZE  EQU   28                 LENGTH OF AN FFBLOCK
*
*        ONE OF THESE BLOCKS IS GENERATED FOR EVERY DEFINED
*        FIELD FUNCTION. LIKE ORDINARY FUNCTIONS, FIELD FUNCTIONS
*        CAUSE TRANSFER TO THE CODE AT FCODE (12) PAST THE START OF
*        THEIR ASSOCIATED BLOCKS.
*
*        SEE $$FLCN (IN SPITBOLX) FOR THE CONTINUATION OF THE CODE
*
*        AN FFBLOK IS SET UP BY A CALL TO THE DATA FUNCTION.
*
*        RELOCATABLE FIELDS       PDFPTR
*                                 FFBLNEXT
         EJECT
*
*        PROGRAM DEFINED DATATYPE FUNCTION BLOCK (PDFBLOK)
*        -------------------------------------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |   PDFBLOK   |                    ///////              |
*        +-------------+-------------+---------------------------+
*        |        NFLDSDF            |             NBYTESDF      |
*        +---------------------------+---------------------------+
*        |     CH    R0,NFLDSDF(DB4) CHECK FOR RIGHT NUMBER ARGS |
*        +-------------------------------------------------------+
*        |     BL    $$WNAG       CALL ADJUSTING FUNCTION IF NOT |
*        +-------------------------------------------------------+
*        |     LM    R0,R1,PDMODL(DB4)  LOAD INITIAL TWO WORDS   |
*        +-------------------------------------------------------+
*        |     STM   R0,R1,0(FR)  STORE IN PLACE                 |
*        +-------------------------------------------------------+
*        |     MVC   12(8*N,FR),TEM#N  MOVE CONTENTS INTO        |
*        +                           +---------------------------+
*        |        PLACE              | LR    A1,FR  SET ADDRESS  |
*        +---------------------------+---------------------------+
*        |       A      A1,DCODEBT       ADD CORRECT CODE        |
*        +-------------------------------------------------------+
*        |     LA    FR,12*8*N(FR)  BUMP FREE REG OVER NEW BLOK  |
*        +-------------------------------------------------------+
*        |     L     PDR,PDRLOC  RESET STACK POINTER             |
*        +---------------------------+---------------------------+
*        |  CR   FR,PDR  CHECK OVFLO |  BCR L,RETURN RETRN IF OK |
*        +---------------------------+---------------------------+
*        |     B     GBGCL1S      ELSE CALL GARBAGE COLLECTOR    |
*        +---------------------------+---------------------------+
*        |                        PDFNPTR                        |
*        +-------------+-----------------------------------------+
*        |   PDMODL    |                    0                    |
*        +-------------+-----------------------------------------+
*        |  (NFLDSD)   |            (PDFPTR)                     |
*        +-------------------------------------------------------+
*        |       FLDNPTR (POINTER TO NAME OF FIRST FIELD)        |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------------------------------------------------+
*        |          POINTER TO NAME OF LAST FIELD                |
*        +-------------------------------------------------------+
         EJECT
*
*        DEFINITIONS AND DESCRIPTION FOR PDFBLOK
*        ---------------------------------------
*
*
PDFBLOK  EQU   FFBLOK+4           CODE FOR PROG DEF DATTYPE BLOCK
NFLDSDF  EQU   4                  NUMBER OF FIELDS
NBYTESDF EQU   6                  LENGTH OF PDFBLOK (BYTES)
PDFNPTR  EQU   52                 POINTER TO NAME OF DATATYPE
PDMODL   EQU   56                 8 BYTES FOR PDBLOK (BYTE 1 = PDBLOK)
FLDNPTR  EQU   64                 POINTER TO VBLOK FOR FIRST FIELD FNC
*
*        ONE OF THESE BLOCKS IS CREATED FOR EACH DEFINED DATATYPE.
*        THIS BLOCK CREATES A PDBLOK WHEN THE FUNCTION IS CALLED, LIKE
*        OTHER FUNCTIONS, IT IS ENTERED BY SETTING DB4 TO THE START OF
*        THE BLOCK AND TRANSFERRING TO FCODE (4) BYTES PAST THIS POINT
*
*        NOTE THAT THE 8 BYTES AT PDMODL ARE FOR USE AS THE
*        FIRST 8 BYTES OF EACH CREATED PDBLOK.
*
*        A PDFBLOK IS CREATED BY A CALL TO THE DATA FUNCTION.
*
*        RELOCATABLE FIELDS       (PDFPTR) POINTS TO THIS BLOCK
         EJECT
*
*        PATTERN BLOCK (PBLOK)
*        ---------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    PBLOK    |                    ///////              |
*        +-------------+-----------------------------------------+
*        |           PTLENG          |          PANCHEXT         |
*        +---------------------------+---------------------------+
*        |                         PNOTHEN                       |
*        +-------------------------------------------------------+
*        |                         PNOOR                         |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------+-----------------------------------------+
*        |   PFLAGS    |                   CODELOC               |
*        +-------------+-------------+---------------------------+
*        |           MINMATCH        |           EXTEND          |
*        +---------------------------+---------------------------+
*        |           THEN            |           OR              |
*        +---------------------------+---------------------------+
*        |                         PARAM1                        |
*        +-------------------------------------------------------+
*        |                         PARAM2                        |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
         EJECT
*
*        PBLOK DEFINITIONS AND DESCRIPTION
*        ---------------------------------
*
PBLOK    EQU   PDFBLOK+4          CODE FOR PATTERN STRUCTURE BLOCK
PTLENG   EQU   4                  LENGTH OF PBLOK IN BYTES
PANCHEXT EQU   6                  ALWAYS HAS ANCHEXT OFFSET SO THAT
*                                 A DUMMY PO OF 0 PTS TO ANCHOR XTEND
PNOTHEN  EQU   8                  HOLDS THE POINTER TO NOTHEN
PNOOR    EQU   12                 HOLDS NOOR POINTER (PLUS A QF FLAG)
PATS     EQU   16                 START OF NODES
PFLAGS   EQU   0                  FLAGS FOR A NODE
CODELOC  EQU   0                  LOCATION OF PATTERN MATCH CODE
MINMATCH EQU   4                  MIN CHARS REQUIRED TO MATCH NODE
EXTEND   EQU   6                  OFFSET TO EXTENSION ROUTINE
THEN     EQU   8                  OFFSET TO NODE FOR "THEN"
OR       EQU   10                 OFFSET TO NODE FOR ALTERNATE
PARAM1   EQU   12                 FIRST PATTERN PARAMETER
PARAM2   EQU   16                 SECOND PATTERN PARAMETER
*
*        FLAGS USED IN PFLAGS
*
QF       EQU   X'80'              FORCES MINMATCH FOR NOTHEN,NOOR MINUS
PARM1    EQU   X'40'              PARAMETER 1 PRESENT
PARM2    EQU   X'20'              PARAMETER 2 PRESENT
PRELOC1  EQU   X'10'              FLAG FOR FIRST PARAMETER RELOCATABLE
PRELOC2  EQU   PRELOC1+X'08'      FLAG FOR 2ND PARAMETER RELOCATABLE
*                                 INCLUDES PRELOC1 FOR FAST GCOL TEST
*                                 NOTE RELOC PARAM2 IS ALWAYS EXPR PTR
PSPANFLG EQU   X'04'              FLAG FOR PTR TO MASTER SPAN TABLE
*                                 USED BY RELOAD ROUTINE
*
LPRM0    EQU   28                 PTLENG FOR ONE NODE -- NO PARAMS
LPRM1    EQU   32                 PTLENG FOR ONE NODE -- ONE PARAM
LPRM2    EQU   36                 PTLENG FOR ONE NODE -- TWO PARAMS
*
*
*        NOTE THAT PARAMETERS ARE ONLY ALLOCATED WHEN THEY ARE NEEDED
*        THE USAGE OF THE PARAMETERS VARIES AMONG THE DIFFERENT KINDS
*        OF PATTERN.
*
*        A PBLOK (OR PBLOK1,PBLOK2) IS CREATED BY A CALL TO ANY OF THE
*        PATTERN OPERATORS AND FUNCTIONS.
*
*        NOTE THAT THE OFFSETS TO "NOOR" AND "NOTHEN" ARE NEGATIVE
*
*        ONLY ONE NODE IS SHOWN HERE, TYPICALLY THERE WILL BE MANY
*        NODES IN ONE PBLOK -- NOTE THAT THE NODE OFFSETS ARE DEFINED
*        FROM THE START OF THE NODE
*
*        RELOCATABLE FIELDS                 PARAM1 (IF PRELOC1 ON)
*                                           PARAM2 (IF PRELOC2 ON)
*
*        NOTE THAT AT THE CURRENT TIME, ONLY ONE OF THE TWO
*        PARAMETERS CAN BE RELOCATABLE IN ANY GIVEN PATTERN NODE
         EJECT
*
*        TABLE BLOCK (TBBLOK)
*        --------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    TBBLOK   |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                        TBLENGTH                       |
*        +-------------------------------------------------------+
*        |                      TBDIVIDE                         |
*        +-------------------------------------------------------+
*        |             TBLPTRS (PTR TO 1ST HASH SLOT)            |
*        +-------------------------------------------------------+
*        |             PTR TO 2ND HASH SLOT                      |
*        +-------------------------------------------------------+
*
*        /                                                       /
*        /                                                       /
*
*        +-------------------------------------------------------+
*        |             PTR TO LAST HASH SLOT                     |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR TBBLOK
*        --------------------------------------
*
TBBLOK   EQU   PBLOK+4            BLOCK CODE FOR TABLE
TBLENGTH EQU   4                  LENGTH OF BLOCK
TBDIVIDE EQU   TBLENGTH+4         NUMBER OF POINTERS*4 USED IN HASH DIV
TBLPTRS  EQU   TBDIVIDE+4         START OF HASH SLOT POINTERS
*
*
*        A TABLE CONTAINS AN ARBITRARY NUMBER OF NAME/VALUE PAIRS
*        EACH ENTRY IS HASHED INTO ONE OF THE SLOT LOCATIONS
*        (SEE TBLOOK ROUTINE), EACH OF THE SLOT POINTERS
*        POINTS TO A CHAIN OF ENTRIES (SEE TEBLOK FORMAT)
*        ZERO IS USED TO SIGNAL THE END OF THE CHAIN
*
*        RELOCATABLE FIELDS                 ALL SLOT POINTERS
         EJECT
*
*        TABLE ELEMENT BLOCK (TEBLOK)
*        ----------------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    TEBLOK   |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        +                        TEVALUE                        +
*        |                                                       |
*        +-------------------------------------------------------+
*        |                        TLINK                          |
*        +-------------------------------------------------------+
*        |                                                       |
*        +                        TENAME                         +
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR TEBLOK
*        --------------------------------------
*
*
TEBLOK   EQU   TBBLOK+4           BLOCK CODE FOR TABLE ELEMENT
TEVALUE  EQU   VALUE              VALUE OF ELEMENT
TLINK    EQU   12                 LINK TO NEXT ELEMNT ON HASH CHAIN
TESIZE   EQU   24                 LENGTH OF TABLE ELEMENT BLOCK
TENAME   EQU   16                 NAME OF ELEMENT (NORMAL DATA FORMAT)
*
*        ONE OF THESE BLOCKS IS CREATED WHEN A NEW ENTRY IS ADDED TO
*        A TABLE, THE BLOCKS ARE LINKED TO GETHER ON CHAINS STARTING
*        FROM THE HASH SLOTS IN A TABLE BLOCK (TBBLOK)
*
*        RELOCATABLE FIELDS                 POINTER FIELD IN TEVALUE
*                                           POINTER FIELD IN TENAME
*                                           TLINK
         EJECT
*
*        CODE BLOCK (CBLOK)
*        ------------------
*
*
*        +-------------+-----------------------------------------+
*        |    CBLOK    |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                        CODNLEN                        |
*        +-------------------------------------------------------+
*        |                        CODNLOC                        |
*        +-------------------------------------------------------+
*        |                        CODECCHN                       |
*        +-------------------------------------------------------+
*        |                                                       |
*        +                        CODECODE                       +
*        |                                                       |
*
*        /                                                       /
*        /                                                       /
*
*        |                                                       |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR CBLOK
*        --------------------------------------
*
CBLOK    EQU   TEBLOK+4           BLOCK CODE FOR CODE BLOCK
CODNLEN  EQU   4                  LENGTH OF CODE BLOCK IN BYTES
CODNLOC  EQU   8                  PTR TO THIS CODE BLOCK (FOR GCOL USE)
CODECCHN EQU   12                 PTR TO CONSTANT CHAIN, SEE BELOW
CODECODE EQU   16                 GENERATED CODE
*                                 (TERMINATED BY X'0000' FOR IOASSOC)
*
*        ONE OF THESE BLOCKS IS CREATED FOR EACH CALL TO THE CODE OR
*        EVAL FUNCTIONS WITH STRING ARGUMENTS (OR EQUIVALENT
*        CONVERT CALLS). IN THE CASE OF AN EXPRESSION (EVAL), THE
*        CODE IS THE STANDARD EXPRESSION CODE (ENDED BY B $$EVLR).
*        IN THE CASE OF CODE, THE CODE IS IDENTICAL TO THAT NORMALLY
*        GENERATED BY THE COMPILER EXCEPT THAT EACH AUR INSTRUCTION
*        (AT THE START OF A STATEMENT), IS FOLLOWED BY X'4700' (NOP),
*        FOLLOWED BY A HALFWORD OFFSET OF THE AUR FROM THE START OF THE
*        CODE BLOCK (SEE GARBAGE COLLECTOR FOR USE OF THIS FIELD)
*
*        CODECCHN POINTS TO A CHAIN OF 32 BYTE BLOCKS USED FOR
*        CONSTANTS REFERENCED BY THE CODE. SEE FIND8 FOR DETAILS
*
*        RELOCATABLE FIELDS       CODNLOC
         EJECT
*
*        TRACE BLOCK (TRBLOK)
*        --------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    TRBLOK   |                    0                    |
*        +-------------+-----------------------------------------+
*        |                                                       |
*        +                        TRTAG                          +
*        |                                                       |
*        +-------------------------------------------------------+
*        |                        TRVBLK                         |
*        +-------------------------------------------------------+
*        |                        TRFUNC                         |
*        +-------------------------------------------------------+
*        |                        TRCLINK                        |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS AND DESCRIPTION FOR TRBLOK
*        --------------------------------------
*
TRBLOK   EQU   CBLOK+4            CODE FOR TRACE BLOCK
TRTAG    EQU   4                  TAG VALUE PASSED TO PROG DEF TRACE FN
TRVBLK   EQU   TRTAG+8            ADDRESS OF VARIABLE BEING TRACED
TRFUNC   EQU   TRVBLK+4           ADDRESS OF VARIABLE BLK FOR FUNCTION
*                                 WHICH IS INVOKED ON TRACE CALL
TRCLINK  EQU   TRFUNC+4           LINK FIELD USED TO CHAIN TRBLOKS
*                                 TOGETHER FOR CALL AND RETURN TRACING
TRBSIZE  EQU   TRCLINK+4          TOTAL LENGTH OF A TRBLOK
*
*        ONE OF THESE BLOCKS IS CREATED ON A TRACE CALL THAT SPECIFIES
*        THE NAME OF A PROGRAMER DEFINED TRACE FUNCTION TO BE USED
*        THIS INFORMATION IS FOUND IN IOBLOK FOR VALUE TRACING AND IN
*        AN LTBLOK FOR LABEL TRACING.  THESE BLOCKS ARE CHAINED
*        TOGETHER FROM A POINTER IN THE USER AREA FOR FUNCTION CASES
*
*        RELOCATABLE FIELDS       TRTAG
*                                 TRCLINK
         EJECT
*
*        LABEL TRACE BLOCK (LTBLOK)
*        --------------------------
*
*
*        +-------------+-----------------------------------------+
*     -> |    X'48'    |                    0                    |
*        +-------------+-----------------------------------------+
*        |                        BAL DB2,LABTRAC                |
*        +-------------------------------------------------------+
*        |                        LTGOTO                         |
*        +-------------------------------------------------------+
*        |                                                       |
*        +                        LTTAG                          +
*        |                                                       |
*        +-------------------------------------------------------+
*        |                        LTBLOCK                        |
*        +-------------------------------------------------------+
*        |                        LTFUNC                         |
*        +-------------------------------------------------------+
*        |                        LTLOC                          |
*        +-------------------------------------------------------+
*
*
*        DEFINTIONS AND DESCRIPTION FOR LTBLOK
*        -------------------------------------
*
LTBLOK   EQU   X'48'              CODE FOR LABEL TRACE BLOCK
LTOFFSET EQU   8                  OFFSET FOR SETTING OF DB2
LTGOTO   EQU   8                  REAL CODE ADDRESS FOR TRANSFER
LTTAG    EQU   12                 TAG VALUE FOR PROG DEF TRACE CALL
LTBLOCK  EQU   LTTAG+8            ADDRESS OF VARIABLE BLOCK
LTFUNC   EQU   LTBLOCK+4          ADDRESS OF VBLOK FOR FUNCTION OR 0
LTLOC    EQU   LTFUNC+4           PTR TO THIS LTBLOK (USED BY GCOL)
LTSIZE   EQU   LTLOC+4            LENGTH OF LTBLOK IN BYTES
*
*        ONE OF THESE BLOCKS IS CONSTRUCTED FOR EACH TRACED LABEL.
*        THE VLABL FIELD OF THE VARIABLE BLOCK IS SET TO POINT TO THE
*        BLOCK SO THAT WHEN A TRANSFER TO THE LABEL OCCURS, CONTROL
*        IS PASSED TO THE FIRST WORD OF THIS BLOCK. X'48' IS THE CODE
*        FOR A LH (LOAD HALFWORD) INSTRUCTION. THUS THE FIRST WORD
*        IS EFFECTIVELY  LH 0,0(,0)  WHICH ACTS AS A NOOP. THEN
*        CONTROL PASSES TO THE STANDARD LABEL TRACE ROUTINE WITH
*        (R2) POINTING TO THE PARAMETERS.
*        THE TAG,BLOCK AND FUNCTION FIELDS MUST BE SET UP AS IN TRBLOCK
*
*        NOTE THAT THE GARBAGE COLLECTOR HANDLES LTBLOK'S WITH
*        A SPECIAL PROCEDURE USING THE LTLOC FIELD (SEE PTRPROCL)
*        THE FACT THAT ONLY THE VLABL FIELD OF A VBLOK CAN POINT TO
*        AN LTBLOK IS IMPORTANT TO THE PROPER OPERATION OF GCOL.
*
*        RELOCATABLE FIELDS       LTTAG
*                                 LTGOTO
*                                 LTLOC
         TITLE 'SPITBOL -- DATA FORMATS -- VALUE (CONTENTS) BLOCKS'
*
*
*        IN THE PREVIOUS DATA STRUCTURES, ALL VALUE (OR CONTENTS)
*        FIELDS WERE 8 BYTES LONG. THESE 8 BYTES CONTAIN A DATATYPE
*        CODE AND EITHER THE DATA ITEM ITSELF OR A POINTER TO THE
*        DATA ITEM -- THIS SECTION DESCRIBES THE VARIOUS POSSIBLE
*        CONTENTS.
*
*
*        GENERAL FORMAT
*        --------------
*
*
*        +-------------+-----------------------------------------+
*        |   VALTYPE   |                  VALPTR                 |
*        +-------------+-----------------------------------------+
*        |                        VALCON                         |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS OF OFFSETS OF FIELDS IN CONTENTS BLOCK
*        --------------------------------------------------
*
VALTYPE  EQU   0                  CODE FOR CONTENT TYPE (SEE BELOW)
VALPTR   EQU   0*4                VALUE POINTER (VARIOUS USES)
VALCON   EQU   1*4                VALUE CONSTANT (VARIOUS USES)
         EJECT
*        THE FOLLOWING GIVES THE DETAILED FORMATS AND CODES FOR THE
*        VARIOUS CONTENT TYPES
*
*
*        INTEGER
*        -------
*
*
*        +-------------+-----------------------------------------+
*        |    X'00'    |                  0                      |
*        +-------------+-----------------------------------------+
*        |             VALUE OF INTEGER (NORMAL 360 FORM)        |
*        +-------------------------------------------------------+
*
*
ICODE    EQU   0                  CODE FOR INTEGER CONTENTS
*
*
*        STRING
*        ------
*
*
*        +-------------+-----------------------------------------+
*        |    X'01'    |        POINTER TO SBLOK                 |
*        +-------------+-------------+---------------------------+
*        |          SOFFSET          |          SLENGTH          |
*        +---------------------------+---------------------------+
*
*
SCODE    EQU   1                  CODE FOR STRING
SLENGTH  EQU   6                  360 LENGTH OF STRING
SOFFSET  EQU   4                  OFFSET -- FIRST CHARACTER IS AT
*                                 SCHARS+SOFFSET+SBLOKADR
*
*
*        REAL
*        ----
*
*
*        +-------------+-----------------------------------------+
*        |    X'80'    |                    0                    |
*        +-------------+-----------------------------------------+
*        |             VALUE OF REAL (NORMAL 360 SHORT FORM)     |
*        +-------------------------------------------------------+
*
*
RCODE    EQU   128                CODE FOR REAL (MUST BE NEGATIVE)
         EJECT
*
*        PATTERN
*        -------
*
*
*        +-------------+-----------------------------------------+
*        |    X'0B'    |        POINTER TO PBLOK WITH PAT        |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
PCODE    EQU   11                 CODE FOR PATTERN
*
*
*        EXPRESSION
*        ----------
*
*
*        +-------------+-----------------------------------------+
*        |    X'13'    |          POINTER TO EXPRESSION CODE     |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
ECODE    EQU   19                 CODE FOR EXPRESSION
*
*        NOTE THAT THE POINTER IS TO A CODE LOCATION
*        SEE SPECIAL PTRPROCL ROUTINE IN GARBAGE COLLECTOR
*        THE SECOND WORD OF THIS VALUE IS USED BY THE GARBAGE COLLECTOR
*        TO BUILD A CHAIN OF ACTIVE EXPRESSION PTRS (SEE PASS 3)
*
*
*        NAME
*        ----
*
*
*        +-------------+-----------------------------------------+
*        |    X'03'    |        POINTER TO START OF BLOCK        |
*        +-------------+-----------------------------------------+
*        |                        OFFSET                         |
*        +-------------------------------------------------------+
*
*
MCODE    EQU   3                  CODE FOR NAME
*        NOTE -- CONTENTS ARE TO BE FOUND AT VALUE +BASE+OFFSET
         EJECT
*
*        ARRAY
*        -----
*
*
*        +-------------+-----------------------------------------+
*        |    X'05'    |        POINTER TO ARRAY BLOCK (ABLOK)   |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
ACODE    EQU   5                  CODE FOR ARRAY
*
*
*        TABLE
*        ------
*
*
*        +-------------+-----------------------------------------+
*        |    X'09'    |          TBBLOK POINTER                 |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
TCODE    EQU   9                  CODE FOR TABLE
*
*
*        NULL STRING
*        -----------
*
*
*        +-------------+-----------------------------------------+
*        |    X'42'    |                    ///////              |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
NCODE    EQU   66                 CODE FOR NULL STRING
         EJECT
*
*        PROGRAM DEFINED DATATYPE
*        ------------------------
*
*        +-------------+-----------------------------------------+
*        |    X'07'    |        POINTER TO DATA BLOCK (PDBLOK)   |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
DCODE    EQU   7                  CODE FOR PROG DEFINED DATATYPE
*
*
*        VARIABLE (SIMPLE EXPRESSION)
*        ----------------------------
*
*
*        +-------------+-----------------------------------------+
*        |    X'10'    |          POINTER TO VARIABLE BLOCK      |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
VCODE    EQU   16                 CODE FOR EXPR WHICH IS SIMPLE VAR
*
*
*        DOUBLE PRECISION REAL
*        ---------------------
*
*
*        +-------------+-----------------------------------------+
*        |    X'C0'    |          7-BYTE DREAL                   |
*        +-------------+                                         +
*        |               (FIRST 7 BYTES OF 360 LONG FORM)        |
*        +-------------------------------------------------------+
*
*
WCODE    EQU   128+64             CODE FOR DREAL
*
*
*        CODE
*        ----
*
*        +-------------+-----------------------------------------+
*        |    X'0D'    |          POINTER TO GENERATED CODE      |
*        +-------------+-----------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
CCODE    EQU   13                 CODE FOR CODE
         EJECT
*
*
*        SOME IMPORTANT CONSIDERATIONS IN THE CHOICE OF CODES ARE AS
*        FOLLOWS --
*
*        1)    THE LAST BIT IS ON ONLY IF THE ITEM IS RELOCATABLE
*
*        2)    THE X'10' BIT IS ON ONLY FOR EXPRESSIONS
*
*        3)    ONLY INTEGER IS ZERO AND TWO CODES ADDED ARE ONLY ZERO
*              IF BOTH CODES ARE INTEGER
*
*        4)    ONLY REALS AND DREALS ARE NEGATIVE AND TWO CODES ADDED
*              TOGETHER LOGICALLY GIVE CARRY+ZERO ONLY ON REAL+REAL
*
*        5)    ECODE MUST BE LARGER THAN VCODE
*
*        6)    NCODE (CODE FOR NULL) IS THE LARGEST ALGEBRAIC CODE
*
*        7)    THE THREE SMALLEST POSITIVE CODES MUST BE SCODE,
*              MCODE, ACODE IN THAT ORDER (SEE IDENT,$$IDNT CODING)
*
RELOCBIT EQU   1                  BIT SIGNALLING RELOCATION
EXPRBIT  EQU   X'10'              BIT SIGNALLING EXPRESSION
*
*
*        CONSTANT SUBEXPRESSION VALUE
*        ----------------------------
*
*        ONE OF THESE BLOCKS IS ALLOCATED FOR EACH CONSTANT
*        SUBEXPRESSION. SINCE THE VALUE IS NOT LOADED UNTIL IT HAS
*        BEEN STORED, THE CONTENTS OF THIS BLOCK ARE NOT
*        RELEVANT AT EXECUTION TIME. HOWEVER, THE BLOCK IS SETUP
*        AS SHOWN BELOW TO ASSIST THE CODE PRINTING ROUTINE (PRCODE)
*
*        +-------------+-----------------------------------------+
*        |    X'02'    |     ADDR OF EXPR CODE - SUBEXTOP        |
*        +-------------+-----------------------------------------+
*        |       POINTER TO STM INSTRUCTION LOADING VALUE        |
*        +-------------------------------------------------------+
*
*
KCODE    EQU   2                  CODE FOR CONSTANT EXPR VALUE
*
*        NOTE THAT SINCE SUBEXTOP IS BEYOND THE ADDRESS OF THE CODE,
*        THE RELATIVE POINTER VALUE STORED IS ACTUALLY NEGATIVE
*
*        THE POINTER TO THE STM IS USED IF AN ERROR OCCURS DURING
*        EVALUATION OF A CONSTANT EXPRESSION. IN THIS CASE, THE STM
*        INSTRUCTION IS OVERWRITTEN WITH AN APPROPRIATE XERR CALL.
         TITLE 'SPITBOLC -- START OF CONTROL SECTION'
*
*        SPITBOLC IS THE CONTROL SECTION WHICH CONTAINS ALL THE COMPILE
*        TIME ROUTINES AND DATA -- IN TWO PHASE OPERATION, IT IS NOT
*        NEEDED AT EXECUTE TIME
*
*
         BEGIN C                  START OF SPITBOLC, SPITBLLC CSECT
         USING SPITBOLD,DREG      DATA BASE REG
         USING SPITBOLC,CB1,CB2,CB3         COMPILER BASE REGS
         USING SPITBOLR,CB4                 . . . .
         USING SPITBOLA,SYS       BASE REG FOR S CONSTANTS IN COMPILER
         AIF   (&LMOD EQ 1).SKIPSS1
*
*        THIS ROUTINE TO CALL FOR AN ERROR MESSAGE MUST BE AT THE START
*        OF SPITBOLC BECAUSE IT IS CALLED WITH A BR ON CB1
*
         LH    RE,0(,R7)          LOAD ERROR MESSAGE OFFSET
         AR    RE,CB1             POINT TO ERROR MSG (CB1 = SPITBOLC)
         TM    STAGE,$EXECUTE     ARE WE IN EXECUTE TIME? (CODE,EVAL)
         BNO   ERROR              JUMP TO ERROR ROUTINE IF NOT
.SKIPSS1 ANOP
*
*        COME HERE IF ERROR OCCURS AT EXECUTE TIME (CODE,EVAL)
*
ERRORE   L     R1,CODSVREG+4*RETURN         LOAD NORMAL RETURN POINT
         SH    R1,=H'4'           ADJUST TO GET ERROR RETURN
         B     CODXXITE           JUMP TO ERROR CASE EXIT
         TITLE 'SPITBOLC -- REGISTER DEFINITIONS FOR COMPILER'
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
DREG     EQU   8                  DATA AREA BASE REGISTER
R9       EQU   9
R10      EQU   10
CB1      EQU   9                  FIRST COMPILER BASE REG
CB2      EQU   10                 SECOND COMPILER BASE REG
CB3      EQU   11                 THIRD COMPILER BASE REG
CB4      EQU   12                 FOURTH COMPILER BASE REG
LC       EQU   13                 POINTER PAST CODE GENERATED SO FAR
RE       EQU   14
RF       EQU   15                 SUBROUTINE CALL REGISTER
SCNT     EQU   0                  FREG COUNTS STATEMENTS EXECUTED
SINC     EQU   2                  FREG CONTAINS INCREMENT FOR SCNT
FA       EQU   4                  FREG FOR ARITH ROUTINES
ZR       EQU   6                  FREG 6 (CONTAINS ZERO FOR COMPILER)
*
*        IN GENERAL, REGISTERS ARE NOT SAVED AND RESTORED BY THE
*        MAIN COMPILER ROUTINES
*
*        HOWEVER, LOW-LEVEL ROUTINES (CALLED ON R7) LIKE READER
*        ARE RESTRICTED TO USING REGISTERS R0,R1,R2,R3
*
         TITLE 'SPITBOLC -- JOB INITIALIZATION ROUTINE'
*
*        THIS ROUTINE PERFORMS ALL THE NECCESSARY STEPS
*        TO INITIALIZE THE COMPILATION OF EACH PROGRAM IN A BATCH
*        IT IS ONLY INCLUDED IN THE STANDARD MODULES
*
         AIF   (&LMOD EQ 1).SKIPS1
         ENTRY SYSSTART           ENTRY FROM INTERFACE
         USING SYSSTART,15        BASE REG SET BY INTERFACE
SYSSTART LM    CB1,CB4,CBASERGS   LOAD COMPILER BASE REGISTERS
         DROP  15                 DROP ENTRY BASE REG
         SR    R0,R0              GET ZERO
         SPM   R0                 AND USE IT TO MASK ALL INTERRUPTS
         LR    R0,DREG            COPY DATA AREA POINTER
         SH    R0,=Y(VALUE)       INTRODUCE STANDARD OFFSET
         ST    R0,$$BAS1          SET FIRST BASE REGISTER ADDRESS
         LR    R1,DREG            COPY DATA POINTER
         A     R1,DATASIZE        POINT PAST END OF DATA AREA
         SH    R1,=Y(HASHTBNS*4)  SUBTRACT LENGTH OF MAIN HASH TABLE
         ST    R1,HICINUSE        SAVE LOWEST BYTE IN USE
         SH    R1,=Y(VLINK)       INTRODUCE PROPER OFFSET
         ST    R1,HASHTBAD        STORE ADDRESS OF VARIABLE HASH TABLE
         LA    R0,4*HASHTBNS(,R1) POINT TO END OF HASH TABLE
         ST    R0,HASHTBEN        STORE END OF HASH TABLE ADDRESS
         SH    R1,=Y(2048-VLINK)  ALLOW 2K FOR HIGH CORE EXPANSION
         ST    R1,SUBEXTOP        SAVE END OF CONSTANT CODE
         SH    R1,=H'4'           BACK OFF TO ALLOW FOR BRANCH
         MVC   0(4,R1),B$$ECON    SET BRANCH INSTRUCTION IN PLACE
         ST    R1,SUBEXBOT        STORE START OF CONSTANT EXPR CODE
         MVC   0(4,DREG),BDOIO$   PUT B $$DOIO AT START OF AREA
*
*        INITIALIZE COMPILER WORK AREAS
*
         SDR   ZR,ZR              THIS REG IS ALWAYS ZERO
         ZAP   STMNO,=P'0'        SET STATEMENT NUMBER = ZERO
         ZAP   PAGENO,=P'0'       PAGE NUMBER = 0
         MVI   OUTTITB,C'1'       SET NEW PAGE CTL FOR TITLE
         MVI   OUTITLE,C' '       SET A BLANK
         MVC   OUTITLE+1(256),OUTITLE       BLANK TITLE,SUBTITLE
         MVC   OUTITLE+102(4),=C'PAGE'      SET 'PAGE' CAPTION
         MVI   OUSTITL-1,C'0'     CTL CHAR FOR SUBTITLE
         MVI   BUFR-1,C' '        SET BLANK CONTROL CHAR FOR BUFFER
         MVC   SWITCHES(LSWITCH),SWITCHD    SET CONTROL CARD DEFAULTS
         MVC   AUR$,=X'3E02'      SET AUR INSTRUCTION
         MVI   SCANTB4+C'''',1    SET ' TERMINATION
         MVI   SCANTB4+C'"',1     SET " TERMINATION
         LA    R0,INBUF+72        SET END OF CARD ADDRESS (-IN72)
         ST    R0,STOPLOC         AND SAVE FOR LITERAL PROCESSING
         MVC   INPUTDCB(4),READDCB          SET PTR TO MAIN INPUT FILE
         MVC   CSECTAD(6*4),CSECTADI        SET CSECT ADDRESSES
         ZAP   ERRCOUNT,=P'0'     ZERO COUNT OF COMPILER ERRORS
         EJECT
*
*        READ USER SUPPLIED PATCH CARDS
*
         MVI   LINELEFT+1,255     SET ROOM FOR PATCH CARDS ON TITLE PAG
         BAL   RF,PATCHER         READ USER SUPPLIED PATCH CARDS
         MVI   LINELEFT+1,1       SET FOR NEW PAGE
*
*        GET STARTING COMPILATION TIME
*
         L     R2,=V(SYSTIME)     ADDRESS OF TIMER ROUTINE
         BALR  R1,R2              CALL TIMER ROUTINE
         NOP   0                  NO ERROR RETURN IS POSSIBLE
         ST    R0,TIME            STORE TIME AT START OF COMPILATION
         MVI   STAGE,$COMPILE     SET COMPILE TIME FLAG
*
*        INITIALIZE POINTERS TO VARIOUS WORK AREAS ETC.
*
         LA    LC,DATABGN         POINT TO START OF AVAILABLE AREA
         ST    LC,VBLKNXT(,DREG)  STORE AS ADDR OF 1ST VAR BLK (=INPUT)
         ST    DREG,DATACUR       STORE DREG AS ADDR OF CURRENT 4K BLK
         LA    LC,CBLKEND(,DREG)  POINT TO LAST LOC IN 1ST 4K BLK
         ST    LC,CBLKBOT(,DREG)  STORE AS ADDR OF LAST CONSTANT
         LA    LC,4096-CBLKEND(,LC)         POINT PAST 1ST 4K BLOCK
         ST    LC,CODEADR         STORE STARTING CODE ADDRESS
         ST    LC,LASTNOP         SETUP NOP GENERATION (SEE AURGEN)
*
*        BUILD VARIABLE BLOCKS FOR INPUT, OUTPUT AND PUNCH. THESE ARE
*        BUILT SO THAT WE CAN SETUP THE STANDARD I/O ASSOCIATIONS.
*
         L     R2,=A(VARLOC)      LOAD BASE REGISTER FOR HASH ROUTINE
         USING VARLOC,R2          EXTRA BASE REG TO COVER INITV ENTRIES
         LA    R4,E$INPUT+1-SCHARS          POINT TO NAME 'INPUT'
         LA    R5,5-1             360 LENGTH
         BALR  R1,R2              BUILD BLOCK
         LA    R4,E$OUTPUT+1-SCHARS         POINT TO NAME 'OUTPUT'
         LA    R5,6-1             360 LENGTH
         BALR  R1,R2              BUILD BLOCK
         LA    R4,E$PUNCH+1-SCHARS          POINT TO NAME 'PUNCH'
         LA    R5,5-1             360 LENGTH
         BALR  R1,R2              BUILD BLOCK
         DROP  R2                 DROP INITV BASE REG
         OI    B$INPUT+VFLAGS,VINP+VINA     SET INPUT INPUT ASSOC
         OI    B$OUTPUT+VFLAGS,VOUP+VOUA    SET OUTPUT OUTPUT ASSOC
         OI    B$PUNCH+VFLAGS,VOUP+VOUA     SET PUNCH OUTPUT ASSOC
*
*        INITIALIZE THE SCAN ROUTINE AND START COMPILATION
*
         LA    R1,INBUF           POINT TO START OF BUFFER
         ST    R1,SCANLOC         STORE AS CURRENT SCAN LOCATION
         ST    R1,FLAGLOC         INITIALIZE ERROR FLAG LOCATION
         MVI   RESCAN,X'FF'       RESET RESCAN FLAG
         B     CMPILE             START COMPILATION OF 1ST STATEMENT
.SKIPS1  ANOP
         TITLE 'SPITBOLC -- EXECUTION TIME COMPILER ENTRY'
*
*        CONTROL IS PASSED TO THIS POINT AT EXECUTION TIME IF THE CODE,
*        EVAL OR CONVERT FUNCTIONS REQUIRE EXECUTION TIME COMPILATION
*
*        (R1)                     POINTS TO CODXENT
*        CODXSW                   = CCODE   CODE
*                                 = ECODE   EXPRESSION (EVAL)
*        (A1,A1+1)                STRING TO BE COMPILED
*        (REGS 0-15)              STORED AT CODSVREG, SEE 'COMPILER')
*        (RETURN)                 RETURN POINT   0(RETURN) -- ERROR
*                                                4(RETURN) -- NORMAL
*        (DB2,DB3)                RELOADED FROM $$BAS2 ON EXIT
*
         USING CODXENT,R1         BASE REG SET BY CALLER
CODXENT  LM    CB1,CB4,CBASERGS   SET COMPILER BASE REGS
         DROP  R1                 DROP ENTRY BASE REG
         STE   ZR,GCOLPTR(,FR)    CLEAR GCOL FLD IN NEW CODE BLOCK
         MVI   DTYPE(FR),CBLOK    SET FREE CORE BLOCK TYPE CODE
         ST    FR,CODNLOC(,FR)    STORE STANDARD BACK POINTER
         STE   ZR,CODECCHN(,FR)   CLEAR CONS CHAIN POINTER
         MVI   SCANTB4+C'''',1    SET ' ENTRY IN SCANTB4
         MVI   SCANTB4+C'"',1     SET " ENTRY IN SCANTB4
         OI    STAGE,$COMPILE     SET COMPILE FLAG ($EXECUTE STILL SET)
         MVI   CODEOS,0           RESET END OF STRING FLAG
         AH    A1,CODSVREG+4*A1+SOFFSET     ADD STRING OFFSET
         LA    A1,SCHARS(,A1)     POINT TO STRING TO COMPILE
         ST    A1,SCANLOC         SET SCAN LOCATION AT START OF STRING
         AH    A1,CODSVREG+4*A1+SLENGTH     POINT TO LAST CHAR
         CLI   CODSVREG+4*A1,NCODE          WAS ARGUMENT NULL?
         BNE   *+8                SKIP IF NOT
         MVI   CODEOS,1           IF SO, SET END OF STRING FLAG
         LA    A1,1(,A1)          POINT PAST LAST CHARACTER
         ST    A1,STOPLOC         STORE AS STOP CHARACTER
         LA    LC,CODECODE(,FR)   POINT TO LOC FOR GENERATED CODE
         ST    LC,LASTNOP         STOP UNNECESSARY NOP GENERATION
         STE   ZR,LABSAVE         CLEAR LABEL SAVE LOC FOR & CODE
         MVI   FRETOPT,0          RESET FRETURN OPTIMIZATION CELL
         MVC   AUR$,=X'3E02'      INITIALIZE AUR CONSTANT
         MVI   RESCAN,X'FF'       RESET RESCAN FLAG
         MVI   OPTFLAG,X'00'      CODE IS NEVER OPTIMIZED
         MVI   CONGEN,X'FF'       NO CONSTANT EXPRESSIONS
         MVI   FAILSET,1          SET FOR -FAIL MODE
         MVI   OLDBASE+1,0        CLEAR GARBAGE DB4 SETTING
         CLI   CODXSW,CCODE       TEST FOR CODE CASE
         BE    CMPILE             JUMP IF CODE TO COMPILE 1ST STMNT
         EJECT
*
*        CASE OF EXPRESSION (EVAL OR CONVERT TO 'EXPRESSION')
*
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)
         MVI   GOTOFLG,X'00'      RESET GOTO FLAG
         MVI   AMPFLAG,X'FF'      INHIBIT SPECIAL & CODE
         BAL   RF,STACKSET        SETUP COMPILER WORK STACKS
         LA    R3,NULBLK          POINT TO NULL CONSTANT BLOCK IN CASE
         CLI   CODEOS,0           ALREADY END OF STRING?
         BNE   *+8                SKIP IF SO (NULL SETUP)
         BAL   RF,EXPAN           ELSE SCAN EXPRESSION
         CLI   CODEOS,1           END OF STRING FLAG SHOULD BE SET
         BNE   ERRORE             GIVE ERROR IF BAD ARG (ELSE SET CC)
         LR    R5,R3              ELSE SET TREE POINTER FOR CODEGEN
         L     R3,TEMSTKBS        INITIALIZE POINTER TO TEM#NN STACK
         BAL   R4,CODEGEN         GENERATE CODE (CC = 0 = BY VALUE)
*
*        NOW WE GENERATE THE FOLLOWING TERMINATION CODE
*
*        B     $$EVLR
*        AUR   0,2
*        NOP   OFFSET
*        DC    X'0000'            FLAG END OF CODE BLOCK
*
         MVC   0(4,LC),BLEVLR$    SET B $$EVLR AT END OF CODE
         LA    LC,4(,LC)          BUMP PAST IT
         BAL   RF,AURGENU         GENERATE AUR AND NOP INSTRUCTIONS
         SH    LC,=H'4'           DELETE UNWANTED NOP STMNT-NUMBER
         SR    R0,R0              GET ZERO
         STH   R0,0(,LC)          SET X'0000' TO FLAG END OF CODE
         LA    LC,2(,LC)          BUMP PAST IT
         B     CODXXIT            JUMP TO EXIT
*
*        BASE REGISTER VALUES FOR COMPILATION (LOADED INTO CB1-CB4)
*
*        THESE VALUES MUST BE WITHIN 4K OF SYSSTART
*
CBASERGS DC    A(SPITBOLC,SPITBOLC+4096,SPITBOLC+8192,SPITBOLR)
*
*        INITIAL VALUES FOR CONTROL SECTION ADDRESSES
*
CSECTADI DC    A(SPITBOLC,SPITBOLR,SPITBOLP,SPITBOLX,SPITBOLA,SPITBOLF)
         TITLE 'SPITBOLC -- COMPILATION CONTROL CIRCUIT'
*
*        THIS ROUTINE CONTROLS THE COMPILATION PROCESS FOR A SINGLE
*        STATEMENT, MAKING APPROPRIATE CALLS TO SCAN, EXPAN AND CODGEN
*
*        THE FIELDS RITESIDE,LEFTSIDE,SGOTO,FGOTO CONTAIN POINTERS
*        TO TREE STRUCTURES OF EXPRESSION BLOCKS AS RETURNED BY THE
*        EXPAN ROUTINE AND AS USED BY THE CODEGEN ROUTINE TO GENERATE
*        CODE FOR EXPRESSIONS
*
CMPILE   TM    STAGE,$OVERTIM     CHECK FOR OVERTIME
         BNO   *+12               SKIP IF NOT
         MVI   FATAL,1            ELSE SIGNAL FATAL ERROR
         ERR   14                 ***TIME LIMIT EXCEEDED***
         ST    LC,STMCODE         IF OK, SAVE STARTING CODE LOC FOR STM
         CLI   CODEOS,1           END OF STRING (CODE CASE)?
         BE    SCANLEND           SKIP IF SO (TREAT AS END LABEL)
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)
         MVI   PREDFUNC,0         CLEAR PREDICATE FUNCTION FLAG
         STD   ZR,RITESIDE        ZERO LEFTSIDE AND RITESIDE POINTERS
         STD   ZR,FGOTO           CLEAR SGOTO AND FGOTO POINTERS
         MVI   GOTOFLG,0          SUPPRESS S( AND F(
         MVI   OLDBASE+1,0        FORGET CURRENT DB4 SETTING
         MVI   FAILFLAG,0         RESET FLAG FOR FAILURE POSSIBLE
         MVI   PATFLG,0           RESET FLAG FOR PATTERN MATCH
         MVI   AMPFLAG,0          RESET SPECIAL FLAG FOR & CODE
         BAL   RF,SCANINIT        INITIALIZE SCAN AND PROCESS LABEL
         BAL   RF,AURGEN          GENERATE AUR ETC. AT STATEMENT START
         BAL   RF,SCAN            SCAN FIRST ELEMENT IN STATEMENT
         CLI   SCANFL,TRM         NULL STATEMENT?
         BE    CMPILENN           SKIP IF NULL STATEMENT
         MVI   RESCAN,0           ELSE SET TO RESCAN FIRST ELEMENT
         BAL   RF,STACKSET        ALLOCATE WORK STACKS
         B     CMPILE1            JUMP TO CONTINUE
*
*        COME HERE FOR NULL STATEMENT. FOR COMPATABILITY WITH BTL
*        SNOBOL-4 WE GENERATE AUR SCNT,ZR SO THAT &STCOUNT IS UNCHANGED
*        ALSO THIS IS THE ONE CASE WHERE FRETURN NEED NOT BE SET
*
CMPILENN L     R1,STMCODE         POINT TO START OF STMNT CODE
         MVI   1(R1),16*SCNT+ZR   CHANGE AUR TO AUR SCNT,ZR
         B     CMPILE             LOOP BACK FOR NEXT STATEMENT
         EJECT
*
*        COME HERE FOR AN ERROR DURING COMPILATION OF CODE AT EXECUTE
*        TIME. IT IS IMPORTANT TO FINISH OFF THE CODE BLOCK PROPERLY
*        SO THAT ANY CONSTANTS IT USES ARE RELEASED TO THE FREELIST
*
*        (R1)                     ADJUSTED RETURN LOCATION
*
CODXXITE ST    R1,CODSVREG+4*RETURN         SAVE RETURN POINT
         SR    R0,R0              GET ZERO
         MVC   0(2,LC),AUR$       SET AUR TO TERMINATE BLOCK
         STH   R0,2(,LC)          STORE X'0000' AS END OF BLOCK FLAG
         LA    LC,4(,LC)          BUMP CODE POINTER AND MERGE
*
*        COME HERE TO RETURN TO EXECUTE PACKAGE FOR CODE COMPILED
*        AT EXECUTE TIME (CODE, EVAL, CONVERT)
*
CODXXIT  LA    LC,3(,LC)          PUSH LC PAST FULLWORD BDRY
         N     LC,FULWRDAJ        ADJUST TO FULLWORD
         L     R1,CODSVREG+4*FR   LOAD POINTER TO BLOCK
         LR    R2,R1              COPY BLOCK POINTER
         CLI   CODXSW,CCODE       CODE CASE?
         BE    *+8                SKIP IF SO
         LA    R2,CODECODE(,R2)   ELSE POINT TO CODE FOR EXPR CASE
         ST    R2,CODSVREG+4*A1   STORE RESULT POINTER
         MVC   CODSVREG+4*A1(1),CODXSW      SET TYPE CODE
         ST    LC,CODSVREG+4*FR   SET NEW FREE CORE POINTER
         SR    LC,R1              CALCULATE LENGTH OF BLOCK
         ST    LC,CODNLEN(,R1)    STORE LENGTH OF CODE BLOCK IN CBLOK
         LM    0,15,CODSVREG      RESTORE REGS
         MVI   SCANTB4+C'''',0    CLEAR SCANTB4 ENTRIES
         MVI   SCANTB4+C'"',0     . . . .
         NI    STAGE,X'FF'-$COMPILE         TURN OFF COMPILE SWITCH
         LM    DB2,DB3,$$BAS2     LOAD DB'S IN CASE GET4KBLK CALLED
         LA    RETURN,4(,RETURN)  POINT TO ACTUAL RETURN LOCATION
         L     R1,SPITRAD         ADDRESS OF SPITBOLR CONTROL SECTION
         B     EXECUTE-SPITBOLR(,R1)        JUMP TO EXECUTE SECTION
         EJECT
*
*        GATHER POINTERS TO LEFT AND RIGHT SIDE EXPRESSIONS
*
CMPILE1  MVI   PATFLG,2           SET FLAG FOR PATTERN MATCH POSSIBLE
         LTR   CB1,CB1            SET CC#0 (TERMINATING )> ILLEGAL)
         BAL   RF,EXPAN           SCAN AN EXPRESSION
         NI    PATFLG,1           RESET FLAG FOR PATTERN MATCH POSSIBL
         BZ    *+8                SKIP IF NOT A PATTERN MATCH
         NI    0(R3),X'FF'-OPNCN  ELSE SET PATTERN MATCH NOT CONSTANT
         ST    R3,LEFTSIDE        STORE POINTER IN LEFTSIDE
         CLI   SCANFL,EQL         TEST FOR SCAN TERMINATED BY =
         BNE   CMPILE8            SKIP IF NOT
         LTR   CB1,CB1            SET CC#0 (TERMINATING )> ILLEGAL)
         BAL   RF,EXPAN           SCAN EXPRESSION
         ST    R3,RITESIDE        STORE POINTER
         CLI   PATFLG,0           CHECK FOR PATTERN MATCH
         BE    CMPILE6            SKIP IF NOT
         L     R2,LEFTSIDE        PICK UP LEFT SIDE POINTER
         MVC   1(3,R2),=AL3(PTNDV) CHANGE LEFT SIDE OPTR TO PAT BY NAME
*
*        MERGE HERE FOR PATTERN, NON PATTERN MATCH CASES
*
CMPILE6  CLI   SCANFL,EQL         CHECK FOR SCAN TERMINATED BY =
         BNE   CMPILE8            SKIP IF NOT
         ERR   10                 *** ILLEGAL USE OF = ***
*
*        COME HERE TO CHECK FOR GOTO FIELD
*
CMPILE8  CLI   SCANFL,GTO         CHECK FOR SCAN TERMINATED BY :
         BNE   CMPILG             NO GOTO FIELD IF NOT
         MVI   GOTOFLG,X'FF'      SET FLAG TO ALLOW S( AND F( DETECTION
         BAL   RF,SCAN            SCAN NEXT ELEMENT
         CLI   SCANFL,SGO         SUCCESS GOTO FIELD?
         BE    CMPILE9            SKIP IF SO
         CLI   SCANFL,FGO         FAILURE GOTO?
         BE    CMPILE10           SKIP IF SO
         MVI   RESCAN,0           ELSE RESCAN ELEMENT
         BAL   RF,GOSCAN          SCAN UNCONDITIONAL GOTO
         ST    R3,SGOTO           STORE AS SUCCESS GOTO
         ST    R3,FGOTO           STORE AS FAILURE GOTO
         CLI   FAILSET,1          TEST -NOFAIL OPTION
         BE    CMPILE11           ALL DONE WITH GOTO FIELD IF -FAIL
         EJECT
*
*        HERE WE HAVE PROCESSED AN UNCONDITIONAL GOTO IN -NOFAIL MODE
*        WE SET THE UNCONDF FLAG FOR TWO PURPOSES --
*
*        1)    TO GENERATE PROPER CODE TO SET FRETURN (LR FRETURN,SYS)
*
*        2)    TO SUPPRESS THE SGOTO=FGOTO OPTIMIZATION
*
         OI    FGOTO,UNCONDF      SET SPECIAL FLAG
         B     CMPILE11           ALL DONE WITH GOTO FIELD
*
*        COME HERE FOR A SUCCESS GOTO FOLLOWING THE COLON
*
CMPILE9  BAL   RF,GOSCAN          SCAN SUCCESS GOTO EXPRESSION
         ST    R3,SGOTO           SAVE POINTER
         CLI   SCANFL,FGO         SGOTO FOLLOWED BY AN FGOTO?
         BNE   CMPILE11           ALL DONE WITH GOTO FIELD IF NOT
         BAL   RF,GOSCAN          ELSE SCAN FGOTO EXPRESSION
         ST    R3,FGOTO           SAVE POINTER
         B     CMPILE11           ALL DONE WITH GOTO FIELD
*
*        COME HERE FOR A FAILURE GOTO FOLLOWING THE COLON
*
CMPILE10 BAL   RF,GOSCAN          SCAN FAILURE GOTO EXPRESSION
         ST    R3,FGOTO           SAVE POINTER
         CLI   SCANFL,SGO         FGOTO FOLLOWED BY SGOTO?
         BNE   CMPILE11           ALL DONE WITH GOTO FIELD IF NOT
         BAL   RF,GOSCAN          ELSE SCAN SGOTO EXPRESSION
         ST    R3,SGOTO           SAVE POINTER
*
*        MERGE HERE AFTER DEALING WITH GOTO FIELD
*
CMPILE11 CLI   SCANFL,TRM         END OF STATEMENT?
         BE    CMPILG             JUMP TO GENERATE CODE IF SO
*
*        MERGE HERE FOR ERROR IN GOTO FIELD
*
CMPILE8E ERR   11                 *** ERROR IN GOTO FIELD ***
         EJECT
*
*        SUBROUTINE TO SCAN OUT GOTO EXPRESSION FIELD
*
*        BAL   RF,GOSCAN
*        (R3)                     POINTER TO GOTO EXPRESSION
*                                 NGOTOFLG IN UPPER BYTE IF () CASE
*
GOSCAN   ST    RF,GOSCANSV        SAVE LINKAGE
         MVI   GOTOFLG,0          RESET NORMAL SCAN MODE
         BAL   RF,SCAN            SCAN NEXT ELEMENT
         CLI   SCANFL,LPR         CHECK FOR LEFT PAREN (NORMAL GOTO)
         BE    GOSCANP            SKIP IF NORMAL CASE
         CLI   SCANFL,LBR         CHECK FOR < (DIRECT GOTO)
         BNE   CMPILE8E           ERROR IN GOTO FIELD IF NOT
         BAL   RF,EXPAN           SCAN EXPR (CC=0 ALLOW )> TERMINATION)
         CLI   SCANFL,RBR         CHECK FOR SCAN ENDED BY >
         B     GOSCANX            JUMP TO MERGE POINT WITH CC SET
*
*        HERE FOR LEFT PAREN (NORMAL GOTO)
*
GOSCANP  BAL   RF,EXPAN           SCAN EXPR (CC=0 ALLOW )> TERMINATION)
         A     R3,=A(NGOTOFLG*256*256*256)  SUPPLY FLAG FOR NORMAL GOTO
         CLI   SCANFL,RPR         MUST BE ENDED BY RIGHT PAREN
*
*        BOTH CASES MERGE HERE
*
GOSCANX  BNE   CMPILE8E           ERROR IF NOT CORRECTLY TERMINATED
         MVI   GOTOFLG,X'FF'      SET TO ALLOW F( S( F< S<
         ST    R3,GOSCANSV+4      SAVE EXPRESSION POINTER
         BAL   RF,SCAN            SCAN NEXT ELEMENT FOR CALLER
         L     RF,GOSCANSV        RELOAD LINKAGE
         L     R3,GOSCANSV+4      RESTORE EXPRESSION POINTER
         BR    RF                 RETURN TO CALLER
         EJECT
*
*        COME HERE AFTER SCANNING THROUGH THE STATEMENT -- NOW GENERATE
*        CODE -- FIRST DEAL WITH SETTING FAIL RETURN REGISTER IF NEEDED
*
CMPILG   L     R3,TEMSTKBS        INITIALIZE TEMP STACK S ADDRESS
         L     R5,FGOTO           LOAD POSSIBLE FGOTO POINTER
         LTR   R5,R5              WAS FGOTO GIVEN
         BZ    CMPILG2            SKIP IF NO FAILURE GOTO AT ALL
         TM    FGOTO,UNCONDF      CHECK FOR FGOTO=SGOTO WI -NOFAIL ON
         BNO   CMPILG3            SKIP IF NOT (NORMAL FGOTO SUPPLIED)
*
*        COME HERE IF FAIL IS UNEXPECTED UNDER -NOFAIL OPTION
*        LR    FRETURN,SYS        POINT TO ERROR ROUTINE
*
CMPILG1  CLI   FRETOPT,1          STILL SET FROM LAST STMNT?
         BE    CMPILG9            SKIP IF SO, DO NOT REGENERATE
         MVI   FRETOPT,1          AND SET FOR NEXT STATEMENT
         MVC   0(2,LC),LRFSYS$    AND GENERATE LR  FRETURN,SYS
         LA    LC,2(,LC)          BUMP CODE POINTER
         B     CMPILG9            JUMP TO GEN REST OF CODE
*
*        COME HERE IF NO FGOTO AND NO UNCONDITIONAL GOTO
*
CMPILG2  CE    ZR,SGOTO           WAS AN S GOTO SUPPLIED?
         BNZ   CMPILG2A           SKIP IF SO (FAIL IS EXPECTED)
         CLI   PREDFUNC,0         DID WE HAVE A PREDICATE FUNCTION REF
         BNE   CMPILG2A           SKIP IF SO (FAIL IS EXPECTED)
         CLI   FAILSET,1          ELSE IS UNEXPECTED FAIL ALLOWED?
         BNE   CMPILG1            SKIP IF NOT TO GEN  LR FRETURN,SYS
*
*        COME HERE WITH NO FGOTO WITH -FAIL SET
*        LR    FRETURN,DB1        POINT TO INTERCEPT ROUTINE
*
         CLI   FRETOPT,2          ALREADY SET FROM LAST STMNT?
         BE    CMPILG9            IF SO, SKIP, DO NOT REGENERATE
         MVI   FRETOPT,2          ELSE SET FLAG FOR NEXT STATEMENT
         MVC   0(2,LC),LRFDB1$    GENERATE LR FRETURN,DB1
         LA    LC,2(,LC)          BUMP CODE POINTER
         B     CMPILG9            JUMP TO GEN REST OF CODE
*
*        COME HERE FOR NO FGOTO WITH EXPECTED FAIL
*        BALR  R2,0               GET BASE
*        LA    FRETURN,(NEXT STATEMENT)     (USING BASE REG R2)
*
CMPILG2A MVC   0(4,LC),BAL2LA$    GEN BALR R2,0  LA FRETURN,*-*(R2)
         ST    LC,FGOINAD         SAVE ADDR FOR LATER GEN OF DISPLACEMN
         LA    LC,6(,LC)          BUMP CODE POINTER
         MVI   FAILFLAG,X'FF'     SET FLAG TO FINISH UP AT END OF STMNT
         MVI   FRETOPT,0          FORGET PREVIOUS FRETURN SETTING
         B     CMPILG9            JUMP TO GEN REST OF CODE
         EJECT
*
*        JUMP HERE WHEN A FAILURE GOTO WAS GIVEN
*
CMPILG3  MVI   FRETOPT,0          FORGET PREVIOUS FRETURN SETTING
         TM    0(R5),OPNNM        CHECK FOR SIMPLE FGOTO
         BNO   CMPILG6            SKIP IF COMPLEX FGOTO
         TM    FGOTO,NGOTOFLG     NORMAL GOTO?
         BNO   CMPILG6            IF DIRECT GOTO, TREAT AS COMPLEX
*
*        CASE OF SIMPLE FGOTO
*
*        L     FRETURN,LBL$FGOTO  (DIRECT LOAD OF ADDRESS)
*
         L     R1,0(,R5)          LOAD VARIABLE BLOCK ADDRESS
         LA    R1,VLABL(R1)       BUMP TO LABEL FIELD
         BAL   RF,CALCSAD         CALCULATE S ADDRESS
         STH   R1,2(LC)           GENERATE S ADDRESS
         LH    R1,LFRTN$          PICK UP L FRETURN,
         STH   R1,0(LC)           GENERATE L FRETURN,
         LA    LC,4(LC)           BUMP CODE POINTER
         B     CMPILG9            SKIP TO GENERATE REST OF CODE
*
*        CASE OF COMPLEX FGOTO
*
*        BALR  R2,0               GET BASE REGISTER
*        BAL   FRETURN,*-*(R2)    SKIP FOLLOWING CODE SETTING FRETURN
*        LA    FRETURN,$$FING     FAIL IN GOTO ILLEGAL
*        (CODE BY NAME FOR LABEL)           (CODE BY VALUE IF DIRECT)
*        BAL   RETURN,$$GOTO                ($$DGTO IF DIRECT GOTO)
*
CMPILG6  MVC   0(4,LC),BLRBAL$    BALR R2,0  BAL FRETURN,*-*(R2)
         ST    LC,FGOINAD         SAVE POINTER FOR DISPLACEMENT GEN
         MVC   6(4,LC),LAFING$    GENERATE LA FRETURN,$$FING
         LA    LC,10(LC)          BUMP CODE POINTER
         TM    FGOTO,NGOTOFLG     SET FOR NAME/VALUE ACCORDING TO TYPE
         BAL   R4,CODEGEN         GENERATE CODE FOR FGOTO EXPRESSION
         MVI   OLDBASE+1,0        FORGET CURRENT SETTING OF DB4
         MVC   0(4,LC),BGOTO$     GENERATE BAL  RETURN,$$GOTO
         SPM   R4                 RESTORE CC FROM TEST FOR DIRECT GOTO
         BO    *+10               SKIP IF NORMAL GOTO
         MVC   2(2,LC),DGOTO$+2   FOR DIRECT GOTO, CHANGE TO $$DGTO
         LA    LC,4(,LC)          BUMP PAST BAL
         LR    R2,LC              COPY CURRENT CODE POINTER
         L     R1,FGOINAD         RECALL ORIGINAL CODE POINTER
         LA    R1,2(,R1)          POINT TO BAL INSTRUCTION
         SR    R2,R1              CALCULATE DISPLACEMENT
         STH   R2,2(,R1)          STORE IN BAL INSTRUCTION
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)
*
*        SECTION TO GENERATE CODE FOR BODY OF STATEMENT
*
CMPILG9  L     R1,RITESIDE        CHECK RIGHT HAND SIDE
         LTR   R1,R1              DO WE HAVE ONE?
         BNZ   CMPILG10           SKIP IF YES
         EJECT
*
*        HERE WE HAVE A LEFT SIDE WITH NO RIGHT HAND SIDE
*
*        SIMPLY GENERATE CODE BY VALUE. IF THE CODE ENDS WITH A
*        USELESS LOAD OF THE NULL CONSTANT, DELETE THE LOAD
*
         L     R5,LEFTSIDE        LOAD POINTER TO LEFT SIDE
         BAL   R4,CODEGEN         ELSE CODE BY VALUE (CC=0 FROM ABOVE)
         CLI   PATFLG,0           CHECK FOR PATTERN MATCH
         BE    *+12               SKIP IF NOT
         MVI   OLDBASE+1,0        ELSE DELETE OLD DB4 SETTING
*                                 SINCE PAT MATCH DESTROYS DB4
         B     CMPILT             AND TERMINATE
*
*        HERE CHECK FOR DELETION OF USELESS LOAD OF NULL
*
         LR    R2,LC              COPY CURRENT CODE POINTER
         SH    R2,=H'4'           BACK OFF FOUR BYTES
         CLC   0(4,R2),LA1NUL$    IS LAST INSTRUCTION  L A1,$$NULL ?
         BNE   CMPILT             ALL DONE IF NOT
         LR    LC,R2              IF SO DELETE IT
         B     CMPILT             AND THEN JUMP FOR GOTO
*
*        COME HERE IF A RIGHT HAND SIDE IS GIVEN
*
CMPILG10 CLI   PATFLG,0           WAS THIS A PATTERN MATCH
         BE    CMPILG11           SKIP IF NOT
         L     R5,LEFTSIDE        ELSE LOAD POINTER FOR LEFT SIDE
         CR    R5,R5              SET CC ZERO FOR CODE BY VALUE
         BAL   R4,CODEGEN         GENERATE CODE FOR LEFT HAND SIDE
         L     R5,RITESIDE        LOAD RIGHT SIDE POINTER
         MVI   OLDBASE+1,0        DELETE OLD DB4 SETTING
         STE   ZR,LASTOPN         FORGET CONTENTS OF (A1,A1+1)
*
*        DEAL HERE WITH SPECIAL CASE OF REPLACING RIGHT HAND SIDE NULL
*
         C     R5,=A(NULBLK)      IS RIGHT HAND SIDE NULL?
         BNE   CMPLG10A           SKIP IF NOT
         LR    R1,LC              ELSE GET CODE POINTER
         SH    R1,=H'4'           BACK OFF PAST BAL RETURN,$$PTN2
         MVC   2(2,R1),SPTNL$     REPLACE WITH BAL RETURN,$$PTNL
         B     CMPILT             AND WE ARE ALL DONE
*
*        COME HERE FOR PATMATCH WITH NON-NULL REPLACEMENT
*
CMPLG10A CR    R5,R5              SET CC ZERO FOR CODE BY VALUE
         BAL   R4,CODEGEN         GENERATE CODE FOR RIGHT HAND SIDE
         MVC   0(4,LC),BLPATA$    GENERATE BAL RETURN,$$PATA
         LA    LC,4(LC)           BUMP CODE POINTER
         B     CMPILT             JUMP TO CLEAN UP
         EJECT
*
*        COME HERE FOR ASSIGNMENT STATEMENT
*
*        GENERATE ONE OF THE FOLLOWING ---
*
*        1)    SIMPLEVAR = NULL
*
*              MVI   VAL.VAR,NCODE
*
*        2)    SIMPLEVAR = VALUE
*
*              RIGHT SIDE BY VALUE TO (A1,A1+1)
*              STM   A1,A1+1,VAL.VAR
*
*        3)    &KEYWORD = VALUE
*
*              NAME OF KEYWORD (& OPERAND) BY NAME TO (A1,A1+1)
*              RIGHT SIDE BY VALUE TO (A2,A2+1)
*              BAL   RETURN,$$KPUT
*
*        4)    ALL OTHER CASES (COMPLEX LEFT SIDE)
*
*              LEFT SIDE BY NAME TO (A1,A1+1)
*              RIGHT SIDE BY VALUE TO (A2,A2+1)
*              BAL   RETURN,$$ASSN
*
*              OR
*
*              RIGHT SIDE BY VALUE TO (A1,A1+1)
*              LEFT SIDE BY NAME TO (A2,A2+1)
*              BAL   RETURN,$$RASN
*
*        FOR THE LAST TWO CASES, A DUMMY BINARY OPERATOR BLOCK
*        WITH A POINTER TO THE APPROPRIATE DOPE VECTOR IS CONSTRUCTED
*        AND CODEGEN IS USED TO GENERATE THE CODE -- FOR THE FIRST
*        TWO CASES, THE CODE IS GENERATED BY THIS ROUTINE
         EJECT
*
*        CHECK TO DISTINGUISH CASES OF ASSIGNMENT STATEMENT
*
CMPILG11 LM    R5,R6,RITESIDE     LOAD RITESIDE/LEFTSIDE
         TM    0(R6),X'FF'-OPNNM-READV      SIMPLE LEFT HAND SIDE?
         BNZ   CMPILG13           SKIP IF NOT (CASE 3 OR 4)
*
*        COME HERE FOR CASES 1) AND 2) -- SEE WHICH IT IS
*
         CE    ZR,0(,R5)          IS RIGHT HAND SIDE NULL?
         LH    R0,MVNCD$          LOAD MVI *-*,NCODE IN CASE
         BE    CMPILG12           SKIP IF IT IS (CASE 1)
         CR    R5,R5              ELSE SET CC FOR CODE BY VALUE
         BAL   R4,CODEGEN         GENERATE CODE FOR RIGHT SIDE
         LH    R0,STMA1$          PICK UP STM A1,A1+1,*-*
*
*        CASES 1) AND 2) MERGE HERE FOR ACTUAL GENERATION
*
CMPILG12 L     R1,0(,R6)          LOAD VARIABLE POINTER
         LA    R1,VALUE(,R1)      POINT TO VALUE FIELD
         BAL   RF,CALCSAD         CALCULATE S ADDRESS
         STH   R0,0(,LC)          GENERATE STM A1,A1+1,*-* OR MVI ...
         STH   R1,2(,LC)          GENERATE S ADDRESS
         LA    LC,4(,LC)          BUMP CODE POINTER
         B     CMPILT             SKIP TO PROCESS GOTO
*
*        COME HERE WITH LEFT SIDE COMPLEX
*
CMPILG13 LA    R4,ASSNDV          POINT TO NORMAL ASSIGNMENT DV
         CLC   0(4,R6),=A(OPTRU*256*256*256+KGETDV) KEYWORD REF?
         BNE   CMPILG16           ALL SET IF ANYTHING ELSE
         LA    R4,KPUTDV          ELSE POINT TO KEYWORD ASSIGN DV
         L     R6,4(,R6)          POINT TO & OPERAND AND MERGE
         EJECT
*
*        COME HERE FOR CASES 3) AND 4) (R4) HAS PROPER DV POINTER
*        BUILD THE EQUIVALENT OF AN EXPAN BINARY OPERATOR BLOCK
*
CMPILG16 ST    R4,CMPILBLK        STORE POINTER TO OPERATOR DV
         ST    R6,CMPILBLK+4      STORE POINTER TO LEFT ARG
         ST    R5,CMPILBLK+8      STORE POINTER TO RIGHT ARG
         MVI   CMPILBLK,OPTRB     INDICATE A BINARY OPERATOR BLOCK
         LA    R5,CMPILBLK        POINT TO IT
         CR    R5,R5              SET CC ZERO FOR CODE BY VALUE
         BAL   R4,CODEGEN         GENERATE CODE & MERGE TO PROCESS GOTO
*
*        COME HERE AFTER CODE HAS BEEN GENERATED FOR BODY OF STATEMENT
*        PROCESS SUCCESS GO TO
*
CMPILT   L     R5,SGOTO           CHECK FOR SGOTO
         LTR   R5,R5              WAS THERE ONE?
         BZ    CMPILF             SKIP IF NOT
*
*        FOR SUCCESS GO TO GENERATE (DEPENDING ON CASE)
*
*        L     R1,LBL.VAR         FOR SIMPLE VARIABLE
*        BALR  RETURN,R1
*
*        LA    FRETURN,$$FING     COMPLEX CASE
*        (CODE FOR SGOTO BY NAME TO A1)
*        BAL   RETURN,$$GOTO
*
*        LA    FRETURN,$$FING     DIRECT GOTO
*        (CODE FOR SGOTO BY VALUE TO A1)
*        BAL   RETURN,$$DGTO
*
*        BALR  RETURN,FRETURN     IF RETURN = FRETURN
*
*        THE BALR SETTING RETURN IS SO THAT WE CAN TELL WHERE WE
*        CAME FROM IN THE CASE OF A BAD TRANSFER
*
         C     R5,FGOTO           DOES FGOTO = SGOTO?
         BNE   CMPILT0            SKIP IF NOT
         MVC   0(2,LC),BALREFR$   ELSE GENERATE BALR RETURN,FRETURN
         LA    LC,2(,LC)          BUMP PAST
         B     CMPILF             JUMP TO CLEAN UP
         EJECT
*
*        JUMP HERE IF FGOTO # SGOTO
*
CMPILT0  TM    0(R5),OPNNM        IS SGOTO COMPLEX?
         BNO   CMPILT1            SKIP IF YES
         TM    SGOTO,NGOTOFLG     TEST FOR NORMAL GOTO
         BNO   CMPILT2            SKIP ON CASE OF DIRECT GOTO
         L     R1,0(,R5)          LOAD VARIABLE BLOCK ADDRESS
         LA    R1,VLABL(R1)       BUMP TO LABEL FIELD
         BAL   RF,CALCSAD         GET S ADDRESS
         MVC   0(6,LC),LR1BR1$    GEN   L R1,*-*  BALR RETURN,R1
         STH   R1,2(LC)           GENERATE S ADDRESS
         LA    LC,6(LC)           BUMP CODE POINTER
         B     CMPILF             JUMP TO CLEAN UP
*
*        CASE OF COMPLEX SGOTO
*
CMPILT1  MVC   0(4,LC),LAFING$    GENERATE LA FRETURN,$$FING
         LA    LC,4(LC)           BUMP CODE POINTER
         MVI   FRETOPT,0          FORGET FRETURN SETTING
         CR    CB1,CB2            SET CC NON-ZERO FOR CODE BY NAME
         BAL   R4,CODEGEN         GENERATE CODE FOR SGOTO
         MVC   0(4,LC),BGOTO$     GENERATE BAL  RETURN,$$GOTO
         LA    LC,4(,LC)          BUMP CODE POINTER
         B     CMPILF             JUMP TO CLEAN UP
*
*        HERE FOR DIRECT SGOTO
*
CMPILT2  MVC   0(4,LC),LAFING$    GENERATE LA FRETURN,$$FING
         LA    LC,4(,LC)          BUMP CODE POINTER
         CR    R0,R0              SET CC ZERO FOR CODE BY VALUE
         BAL   R4,CODEGEN         GENERATE CODE BY VALUE
         MVC   0(4,LC),DGOTO$     GENERATE  BAL RETURN,$$DGTO
         LA    LC,4(,LC)          BUMP CODE POINTER AND MERGE
*
*        END OF STATEMENT -- CHECK FOR BALR LA TYPE FGOTO TO CLEAR UP
*
CMPILF   CLI   FAILFLAG,X'FF'     CHECK FOR LA TYPE GOTO TO FINISH UP
         BNE   CMPILE             BACK FOR NEXT STATEMENT IF NOT
         L     R1,FGOINAD         RECALL OLD CODE LOC
         LR    R2,LC              COPY NEW CODE LOC
         SR    R2,R1              CALCULATE DISPLACEMENT FOR LA
         SH    R2,=H'2'           ALLOWING FOR BALR (TWO BYTES)
         STH   R2,4(,R1)          GENERATE DISPLACEMENT
         B     CMPILE             BACK TO COMPILE NEXT STATEMENT
         EJECT
*
*        SUBROUTINE TO ALLOCATE COMPILER WORK STACKS
*
*        THIS ROUTINE ALLOCATES THE THREE WORK STACKS USED BY EXPAN
*        ABOVE THE GENERATED CODE. THE CURRENT CODE IS ALLOWED TO GROW
*        UP TO 2K ON EACH STATEMENT. IN ADDITION, AT COMPILE TIME ( AS
*        OPPOSED TO CODE,EVAL CALLS), 2K IS ALLOWED FOR EXPANSION OF
*        CONSTANT CODE.
*
STACKSET LA    R1,2048+3(,LC)     ALLOW FOR 2K GENERATED CODE
         N     R1,FULWRDAJ        ADJUST TO FULLWORD BOUNDARY
         ST    R1,EXPINIT         STORE AS ADDRESS OF EXPAN BLOCK STACK
         LA    R1,2048(,R1)       ALLOW 2K FOR EXPRESSION BLOCKS
         ST    R1,WRKSTKAD        STORE ADDR OF EXPAN OPERATOR STACK
         LA    R1,512(,R1)        ALLOW 512 BYTES FOR OPERATOR STACK
         ST    R1,WRKSTKAD+4      STORE PTR TO EXPAN POINTER STACK
         LA    R1,512(,R1)        ALLOW 512 BYTES FOR PTR (OPERAND) STK
         ST    R1,ESTACKS         STORE END OF STACK AREA
         TM    STAGE,$EXECUTE     IS THIS A CODE OR EVAL CALL?
         BO    STACKSTX           SKIP IF SO
*
*        HERE WE HAVE A CALL AT STANDARD COMPILE TIME
*
         LA    R1,2048(,R1)       ALLOW 2K FOR CONSTANT EXPRESSIONS
         C     R1,SUBEXBOT        DO WE HAVE ROOM?
         BCR   L,RF               RETURN IF WE HAVE ROOM
         MVI   FATAL,1            ELSE SET FATAL ERROR
         ERR   12                 ******PROGRAM TOO LARGE******
*
*        COME HERE TO CHECK FOR STORAGE OVERFLOW DURING EXECUTE TIME
*
STACKSTX C     R1,CODSVREG+4*PDR  ROOM UNDER STACK?
         BCR   L,RF               RETURN IF SO
*
*        MERGE HERE FROM HIGHCORE WHEN WE RUN OUT OF ROOM AT XEQ TIME
*
CODXCOR  L     R1,=A(GBGCLF-4)    SET FOR RETURN TO GBGCLF
         B     CODXXITE           JUMP TO ERROR EXIT LOCATION
         TITLE 'SPITBOLC -- SCAN CIRCUIT'
*
*        THIS IS THE ONLY ROUTINE WHICH LOOKS AT THE INPUT STATE-
*        MENTS DIRECTLY. IT IS CALLED BY --
*
*        BAL   RF,SCAN
*
*        IN SCANFL, A SYNTAX FLAG IS RETURNED (SEE NEXT PAGE)
*        AND IN SCANAD THE DOPE VECTOR ADDRESS IS RETURNED WHERE
*        APPROPRIATE (VARIABLE,CONSTANT FUNCTION,OPERATOR)
*
*        SCANCHR SAVES THE INITIAL CHARACTER (BEFORE A SCAN BEGINS)
*
*        IF RESCAN IS SET TO ZERO, THEN THE LAST ITEM IS REPEATED ON
*        A CALL TO SCAN (I.E. SCAN RETURNS IMMEDIATELY)
*
*        BEFORE USING SCAN, A CALL TO SCANINIT MUST BE MADE AT THE
*        BEGINNING OF EACH STATEMENT -- THIS ROUTINE INITIALIZES THE
*        SCAN AND PROCESSES A LABEL IF ONE IS PRESENT
*
         EJECT
*
*        SYNTAX PARAMETER DEFINITIONS
*
*        THE FOLLOWING PARAMETERS ARE THOSE WHICH CAN BE RETURNED
*        BY THE SCAN ROUTINE IN SCANFL
*
EQL      EQU   4                  =
GTO      EQU   EQL+4              : GOTO
TRM      EQU   GTO+4              STATEMENT TERMINATOR
LBR      EQU   TRM+4              <
RBR      EQU   LBR+4              >
LPR      EQU   RBR+4              (
RPR      EQU   LPR+4              )
CMA      EQU   RPR+4              ,
OPR      EQU   CMA+4              OPERATOR
FNC      EQU   OPR+4              FUNCTION CALL (LEFT PRN INCLUDED)
VAR      EQU   FNC+4              VARIABLE
CON      EQU   VAR+4              CONSTANT
*
*        THE FOLLOWING ARE DEFINITIONS USED IN THE MAIN SCAN CIRCUIT
*
DLR      EQU   CMA+4              $
PLS      EQU   DLR+4              +
MNS      EQU   PLS+4              -
AST      EQU   MNS+4              *
SLS      EQU   AST+4              /
DOT      EQU   SLS+4              .
QUS      EQU   DOT+4              ?
NOT      EQU   QUS+4              
AMP      EQU   NOT+4              &
ATS      EQU   AMP+4              @
NMS      EQU   ATS+4              #
EXC      EQU   NMS+4              EXCLAMATION POINT
ORP      EQU   EXC+4              |
PCT      EQU   ORP+4              %
NUM      EQU   PCT+4              NUMBER (DIGIT)
QUT      EQU   NUM+4              ' OR "
ILG      EQU   QUT+4              ILLEGAL CHARACTER
*
*        THE FOLLOWING THREE VALUES ARE GROUPED AT THE END SINCE
*        THEY REPRESENT THE LEGAL POSSIBILITIES FOR AN END
*        CARD TRANSFER LABEL (SEE SCANLEND)
*
LTR      EQU   ILG+4              LETTER
*
*        THE FOLLOWING TWO DEFINITIONS CAN BE RETURNED IN SCANFL ONLY
*        IF THE SPECIAL GOTO FLAG GOTOFLG IS SET TO X'FF'
*
FGO      EQU   LTR+4              F (POSSIBLE FGOTO)
SGO      EQU   FGO+4              S (POSSIBLE SGOTO)
         EJECT
*
*        OPERATOR DOPE VECTOR FORMAT
*        ---------------------------
*
*        +-------------+-------------+---------------------------+
*        |   PRIORITY  | FLAGS+YNAME | S ADR OF ROUTINE FOR VALUE|
*        +-------------+-------------+---------------------------+
*        |    ///      |    FLAGS    | S ADR OF ROUTINE FOR NAME |
*        +-------------+-------------+---------------------------+
*
*                                 OR
*
*        +-------------+-------------+---------------------------+
*        |   PRIORITY  |    FLAGS    | S ADR OF ROUTINE FOR VALUE|
*        +-------------+-------------+---------------------------+
*
*                                 OR
*
*        +-------------+-------------+-------------+-------------+
*        |   PRIORITY  |    FLAGS    |   0,1 OR 2  |    CCODE    |
*        +-------------+-------------+-------------+-------------+
*
*        THE TWO WORD FORMAT IS USED IF THE OPERATOR CAN BE CALLED BY
*        NAME OR VALUE (E.G. $) THE ONE WORD FORMAT IS USED IF THE
*        CALL BY NAME IS ILLEGAL (MOST USUAL CASE)
*        THE PRESENCE OF THE FLAG YNAME INDICATES THE TWO WORD FORMAT
*        THE FORMAT USING THE CCODE FIELD IS USED FOR THE OPERATORS
*        GE,LT,LE,NE,EQ,GT (0), LEQ,LNE,LGT,LLT,LLE,LGE (1),
*        IDENT,DIFFER (2) -- FOR ALL THESE OPERATORS, THE CALL IS
*        FOLLOWED BY A SUITABLE BCR INSTRUCTION USING CCODE
*
*        DEFINITIONS OF FLAGS
*
YNAME    EQU   1                  FLAG FOR CALL BY NAME PERMITTED
RASS     EQU   2                  FLAG FOR RIGHT ASSOCIATIVE
LEFNAM   EQU   4                  FLAG FOR LEFT OPERAND BY NAME
RITNAM   EQU   8                  FLAG FOR RIGHT OR ONLY OPERAND BY NAM
COMMUT   EQU   16                 FLAG FOR COMMUTATIVE BINARY OPERATOR
PREDF    EQU   32                 FLAG FOR PREDICATE (EQ,IDENT ...)
BNOP     EQU   64                 FLAG FOR BINARY OPERATOR
SPECL    EQU   128                FLAG FOR SPECIAL CODE REQUIRED
*
*        THERE ARE THREE CASES FOR THE S ADDRESS --
*
*        1)    S ADDRESS OF A ROUTINE IN SPITBOLA (SYS BASE REG)
*
*        2)    S ADDRESS OF DEFINABLE OPERATOR LOCATION IN THE
*              DATA AREA, SEE OPTRTABL (DB1 BASE REG)
*
*        3)    DUMMY VALUE USED TO RECOGNIZE THE DV IN THE SPECIAL
*              OPERATOR TEST SECTION OF CODEGEN. SUCH DUMMY VALUES
*              MUST USE SYS AS THE BASE REGISTER TO AVOID CONFUSION
*        IN THE CODE GENERATOR CIRCUIT.
         EJECT
*
*        MACRO FORMAT FOR GENERATION OF OPERATOR DOPE VECTORS
*        ----------------------------------------------------
*
*        UNARY OPERATOR
*        --------------
*
*LABL    UNOP  (VR,X),(NR,X),FLAGS
*        VR    NAME OF ROUTINE TO RETURN VALUE
*        VN    NAME OF ROUTINE TO RETURN NAME (OMIT IF ILLEGAL)
*        X     IS V OR N DEPENDING ON WHETHER OPERAND IS BY VAL OR NAME
*        (PRIORITY OF 15  ASSUMED -- THIS IS THE HIGHEST PRIORITY)
*
*
*        X MAY BE OMITTED IF IT IS V (VALUE) AND THE CALL SIMPLIFIED TO
*
*LABL    UNOP  VR,NR,FLAGS
*
*        FLAGS IS OPTIONAL AND IF WRITTEN WILL BE ADDED INTO THE
*        FLAG FIELD OF THE VALUE WORD AND THE NAME WORD IF PRESENT
*        THE NR FIELD MAY BE OMITTED IF THE CALL BY NAME IS ILLEGAL
*        HOWEVER, THIS OMISSION MUST BE EXPLICIT IF FLAGS ARE SUPPLIED
*
*        BINARY OPERATOR
*        ---------------
*
*LABL    BINOP PRIORITY,(VR,X,Y),(NR,X,Y),FLAGS
*
*        VR,NR,FLAGS ARE THE SAME AS FOR A UNARY OPERATOR
*        PRIORITY IS THE PRECEDENCE LEVEL -- AN INTEGER FROM 1 - 14
*        X,Y ARE V/N  VALUE/NAME FLAGS FOR LEFT AND RIGHT OPNDS
*        IF BOTH X AND Y ARE V (VALUE), THEY MAY BE OMITTED AND THE
*        CALL WRITTEN AS
*
*LABL    BINOP PRIORITY,VR,NR,FLAGS
         EJECT
*
*        SCAN INITIALIZATION -- HANDLES LABEL AND START OF STATEMENT
*
SCANINIT MVI   SCANFL,0           CLEAR SCAN FLAG IN CASE ERROR
         LH    R1,BSTMNO          LOAD BINARY STATEMENT NUMBER
         LA    R1,1(,R1)          INCREMENT
         STH   R1,BSTMNO          STORE INCREMENTED STATEMENT COUNT
*
*        CHECK FOR COMMENT, CONTROL CARDS (STANDARD MODULES ONLY)
*
         AIF   (&LMOD EQ 1).SCANSS1
SCANINLL CLI   INBUF,C'*'         IS THIS A COMMENT CARD?
         BNE   SCANINCC           SKIP IF NOT TO CHECK FOR CTL CARD
*
*        HERE WE LIST A COMMENT CARD
*
         BAL   R7,LISTER          LIST COMMENT CARD
         BAL   R7,READER          READ NEXT CARD
         B     SCANINLL           LOOP BACK TO CHECK CARD READ
*
*        HERE WE CHECK FOR A CONTROL CARD
*
SCANINCC CLI   INBUF,C'-'         IS THIS A CONTROL CARD?
         BNE   SCANINDD           SKIP IF NOT
         BAL   R7,CONCPROC        ELSE PROCESS CONTROL CARD
         B     SCANINLL           AND LOOP BACK TO CHECK NEXT CARD
*
*        HERE WE FINALLY HAVE A PROGRAM CARD IN THE BUFFER
*        LIST IT WITH STATEMENT NUMBER
*
SCANINDD AP    STMNO,PONE         INCREMENT STATEMENT NUMBER
         LA    R0,INBUF           POINT TO START OF BUFFER
         C     R0,SCANLOC         ARE WE AT START OF CARD?
         BNE   SCANIN2            SKIP IF NOT TO DEAL WITH LABEL
         MVC   BUFR(5),=X'2020202020'       EDIT PATTERN FOR STM NO
         ED    BUFR-1(6),STMNO    EDIT STATEMENT NUMBER
         BAL   R7,LISTER          LIST PROGRAM CARD
         EJECT
.SCANSS1 ANOP
*
*        NOW DEAL WITH LABEL
*
SCANIN2  L     R1,SCANLOC         LOAD SCAN LOCATION
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG
         CLC   0(4,R1),=C'END '   CHECK FOR END LABEL
         BE    SCANLEND           OFF TO PROCESS IT IF ONE
         LR    R3,R1              SAVE START OF POSSIBLE LABEL
         BCTR  R1,0               ADJUST FOR MERGE INTO LOOP
*
*        LOOP TO SCAN OUT LABEL, NOTE THAT BLANKS AND ; ARE NOT ALLOWED
*
SCANIN3  TRT   1(256,R1),SCANTB2  SCAN OUT LABEL
         BNZ   SCANIN3A           SKIP IF WE STOPPED
         LA    R1,256(,R1)        ELSE STEP PAST 256 CHARACTERS
         B     SCANIN3            AND LOOP BACK TO KEEP SCANNING
*
*        HERE IF WE ARE STOPPED BY SOMETHING
*
SCANIN3A C     R1,STOPLOC         ARE WE AT END OF IMAGE OR PAST IT?
         BL    SCANIN3B           SKIP IF NOT (SOMETHING ELSE STOPPED )
         L     R1,STOPLOC         ELSE RESET POINTER TO END OF IMAGE
         B     SCANIN4            LABEL IS SCANNED OUT
*
*        HERE IF WE ARE STOPPED BY SOMETHING OTHER THAN END-OF-CARD
*
SCANIN3B CLI   0(R1),C' '         BLANK?
         BE    SCANIN4            END OF LABEL IF SO
         CLI   0(R1),C';'         STATEMENT SEPARATOR?
         BNE   SCANIN3            IF NOT, KEEP GOING, ELSE MERGE
*
*        COME HERE WITH LABEL SCANNED OUT
*
SCANIN4  CR    R1,R3              IS LABEL NULL? (I.E. NO LABEL)
         BCR   E,RF               IF SO, RETURN TO SCANINIT CALLER
         BAL   R4,SCANHSH         ELSE GET BLOCK LOCATION FOR VARIABLE
         ST    R1,SCANLOC         SAVE SCAN LOCATION
         CLC   VLABL+1(3,R5),=AL3($$NOGO)   IS LABEL ALREADY DEFINED?
         BE    SCANIN5            SKIP IF NOT (ALL OK)
         TM    STAGE,$EXECUTE     ELSE ARE WE IN A CODE FUNCTION CALL?
         BO    SCANIN5            REDEFINITION ALLOWED IF SO
         BAL   RF,AURGEN          ELSE GENERATE AUR AND GIVE ERROR
         ERR   20                 ****** LABEL ALREADY DEFINED ******
         EJECT
*
*        COME HERE IF LABEL IS LEGITIMATE
*
SCANIN5  ST    R5,LABSAVE         SAVE LABEL BLOCK LOC (&LASTNO)
         ST    LC,VLABL(,R5)      STORE LABEL LOCATION
         MVI   FRETOPT,0          FORGET FRETURN SETTING
         BR    RF                 RETURN TO CALLER
*
*        HERE ON END LABEL OR END OF SOURCE STRING (CODE FUNCTION)
*
*        GENERATE THE FOLLOWING TERMINATION CODE
*
*        AUR   SCNT,ZR
*        BAL   RETURN,$$STOP
*        AUR   SCNT,SINC
*        (NOP INSTRUCTIONS)       SEE AURGENU
*        DC    X'0000'            END OF CODE FLAG (FOR IOASSOC)
*
*        NOTE THAT THE AUR INSTRUCTION IS ARRANGED TO COMPENSATE FOR
*        THE FACT THAT BTL SNOBOL4 DOES NOT COUNT THE END STATEMENT
*
SCANLEND LR    R7,LC              SAVE CODE LOCATION
         BAL   RF,AURGEN          GENERATE AUR FOR LAST STMNT
         MVI   1(R7),SCNT*16+ZR   CHANGE TO AUR SCNT,ZR
         MVC   0(4,LC),$STOP$     GENERATE BAL RETURN,$$STOP
         LA    LC,4(,LC)          BUMP CODE POINTER
         LH    R7,BSTMNO          LOAD BINARY STATEMENT NUMBER
         LA    R7,1(,R7)          INCREMENT
         STH   R7,BSTMNO          STORE INCREMENTED COUNT
         MVI   AUR$,X'3E'         STOP PROCDE PRINTING LAST GARBAGE STM
         BAL   RF,AURGENU         GENERATE FINAL AUR FOR CALCSTNO
         SR    R0,R0              GET ZERO
         STH   R0,0(,LC)          STORE X'0000' AT END OF CODE
         LA    LC,2(,LC)          BUMP PAST ZEROS AT END
         TM    STAGE,$EXECUTE     CODE FUNCTION CASE?
         BO    CODXXIT            IF SO, JUMP TO SPECIAL EXIT POINT
*
*        THE FOLLOWING SECTION OF CODE CAN BE ENTERED ONLY IN THE
*        STANDARD MODULES AND IS THEREFORE REMOVED FROM THE LIB MODS
*
         AIF   (&LMOD EQ 1).SCANLL1
         EJECT
*
*        HERE WE DEAL WITH A POSSIBLE TRANSFER LABEL ON THE END CARD
*
         MVC   TRAADR,CODEADR     PROVISIONALLY SET TRA ADDR TO START
         MVI   FATAL,2            SET FLAG IN CASE OF ERROR ON END CARD
         CLI   EOF,0              DID WE HIT AN END OF FILE?
         BE    *+8                SKIP IF NOT
         ERR   19                 *** MISSING END CARD SUPPLIED ***
         SR    R2,R2              CLEAR FOR TRT
         LA    R1,4(,R1)          PUSH PAST END LABEL
         TRT   0(256,R1),SCANTB1  SCAN TO LABEL (TRA ADDRESS)
         BZ    XEQGO              NO TRANSFER ADDRESS IF RUN OUT
         C     R1,STOPLOC         AT END OF CARD?
         BNL   XEQGO              NO TRANSFER ADDRESS IF SO
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG
         CH    R2,=Y(LTR)         ELSE DID WE STOP ON A LETTER?
         BNL   *+8                SKIP IF LETTER (OR F OR S)
         ERR   21                 *** ILLEGAL TRANSFER ADDRESS ***
         LR    R3,R1              SAVE SCAN LOCATION
         TRT   1(256,R1),SCANTB2  SCAN TO END OF LABEL (TRA ADDRESS)
         BAL   R4,SCANHSH         GET BLOCK LOCATION
         CLC   VLABL+1(3,R5),=AL3($$NOGO)   IS LABEL DEFINED
         BNE   *+8                SKIP IF IT IS DEFINED
         ERR   22                 *** UNDEFINED TRANSFER ADDRESS ***
         MVC   TRAADR+1(3),VLABL+1(R5)      MOVE IN TRANSFER ADDRESS
         TRT   0(256,R1),SCANTB1  SCAN TO MAKE SURE THAT WE ARE THROUGH
         CLI   0(R1),X'00'        WE MUST END AT END OF CARD
         BE    XEQGO              ALL OK IF AT END OF CARD
         ERR   21                 *** ILLEGAL TRANSFER ADDRESS ***
.SCANLL1 ANOP
         EJECT
*
*        MAIN ENTRY POINT
*
SCAN     TS    RESCAN             TEST FOR RESCAN, RESETTING FLAG
         BCR   8,RF               ALL DONE IF RESCAN FLAG SET
*
*        REENTER HERE AFTER READING CONTINUATION CARD
*
SCAN0    L     R1,SCANLOC         PICK UP SCAN POINTER
         MVC   SCANCHR,0(R1)      SAVE INITIAL SCAN CHARACTER
         SR    R2,R2              CLEAR FOR TRT INSERTION
*
*        LOOP BACK HERE IF MORE THAN 255 BLANKS SCANNED OUT
*
SCAN1    TRT   0(256,R1),SCANTB1  SCAN TO FIND SOMETHING SIGNIFICANT
         C     R1,STOPLOC         CHECK FOR PAST END OF CARD
         BNL   SCANTRM            JUMP IF AT END OF INPUT IMAGE
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG
         EX    0,SCANBRA(R2)      EXECUTE BRANCH TO CORRECT ROUTINE
*
*        BRANCH TABLE USED TO CONTROL MAIN LOGIC FLOW
*
SCANBRA  B     SCAN256B           256 BLANKS
         B     SCANEQL            =
         B     SCANS              : GOTO
         B     SCANSMC            ;
         B     SCANS              <
         B     SCANS              >
         B     SCANS              (
         B     SCANS              )
         B     SCANS              ,
         B     SCANDLR            $
         B     SCANPLS            +
         B     SCANMNS            -
         B     SCANAST            *
         B     SCANSLS            /
         B     SCANDOT            .
         B     SCANQUS            ?
         B     SCANNOT            
         B     SCANAMP            &
         B     SCANATS            @
         B     SCANNMS            #
         B     SCANEXC            EXCLAMATION POINT
         B     SCANORP            |
         B     SCANPCT            %
         B     SCANNUM            DIGIT (INTEGER)
         B     SCANQUT            ' OR "
         B     SCANILG            ILLEGAL CHARACTER
         B     SCANLTR            LETTER (VARIABLE)
         B     SCANGOTO           F (POSSIBLE FGOTO)
         B     SCANGOTO           S (POSSIBLE SGOTO)
         EJECT
*
*        ENTRY FOR SEMICOLON
*
SCANSMC  CLI   1(R1),C'*'         IS NEXT CHARACTER * (COMMENT)?
         BNE   SCANS              IF NOT, NORMAL SPECIAL CHAR CIRCUIT
         TM    STAGE,$EXECUTE     EXECUTE TIME?
         BNO   SCANTRM            IF COMPILE TIME, ;* IS END OF CARD
*
*        ENTRY FOR SPECIAL CHARACTER
*
SCANS    STC   R2,SCANFL          STORE SYNTAX PARAMETER
         LA    R1,1(R1)           BUMP PAST CHARACTER
         ST    R1,SCANLOC         SAVE SCAN LOCATION
         BR    RF                 RETURN
*
*        ENTRY FOR $ (UNARY OR BINARY)
*
         CNOP  0,4                ENSURE ALLIGNMENT OF BINOP FOR BAL
SCANDLR  BAL   R5,SCANUB          CALL COMMON ROUTINE TO PROCESS UN/BIN
DLR2DV   BINOP 11,($$DLR2,V,N),,SPECL       BINARY $
DLR1DV   UNOP  $$DL1V,$$DL1N
         BINOP 11,$$DLRD          BINARY $, DEFERRED ARG
*
*        ENTRY POINT FOR + (UNARY OR BINARY)
*
SCANPLS  BAL   R5,SCANUB          OFF TO COMMON ROUTINE
ADDDV    BINOP 5,$$ADD2,,SPECL+COMMUT       BINARY +
         BINOP 5,$$ADD2                     BINARY + COMMUTED
         UNOP  $$ADD1
         UNOP  $$INCR                       INCREMENT BY ONE
*
*        ENTRY FOR - (UNARY OR BINARY)
*
SCANMNS  BAL   R5,SCANUB          OFF TO COMMON ROUTINE
SUBDV    BINOP 5,$$SUB2,,SPECL              BINARY -
         UNOP  $$SUB1
         DC    AL4(0)             FILLER (SEE CODE AT CODEBNSA)
         UNOP  $$DECR                       DECREMENT BY ONE
*
*        ENTRY FOR EXCLAMATION POINT (UNARY OR BINARY)
*
SCANEXC  BAL   R5,SCANUB          OFF TO COMMON ROUTINE
         BINOP 10,$$EXP2,,RASS    BINARY EXCLAMATION POINT
         UNOP  $$EXC1             UNARY EXCLAMATION POINT
         EJECT
*
*        ENTRY FOR = SIGN, MUST BE SURROUNDED BY BLANKS
*
SCANEQL  CLI   SCANCHR,C' '       IS PREVIOUS CHARACTER A BLANK?
         BNE   SCANEQLE           ERROR IF NOT
         TM    1(R1),X'FF'-X'40'  NEXT CHAR BLANK OR END OF CARD?
         BZ    SCANS              NORMAL SPECIAL CHAR TREATMENT IF SO
         CLI   1(R1),C';'         ALSO ALLOW SEMICOLON TERMINATOR
         BE    SCANS              NORMAL SPECIAL CHAR TREATMENT IF SO
*
*        HERE FOR = NOT SURROUNDED BY BLANKS, GIVE MISSING OPERATOR MSG
*
SCANEQLE BAL   RF,SCANS           USE SCANS AS SUBR TO STORE SCAN LOC
         ERR   7                  ****** MISSING OPERATOR ******
*
*        ENTRY POINT FOR * (COULD BE * UNARY,BINARY OR ** BINARY)
*
SCANAST  CLI   1(R1),C'*'         CHECK FOR **
         BNE   SCANAST1           SKIP IF NOT
         TM    2(R1),X'FF'-X'40'  TEST FOR BLANK OR CARD END AFTER
         BNZ   SCANAST1           SKIP IF NOT (UNARY)
*
*        HERE FOR BINARY **
*
         LA    R1,2(,R1)          BUMP PAST **
         CNOP  0,4                ALLIGN BAL SO THAT DV IS ALLIGNED
         BAL   R5,SCANUBC         JUMP TO STORE DV ADDR (R5 --> EXPDV)
EXPDV    BINOP 10,$$EXP2,,RASS    ALTERNATE GRAPHIC FOR EXPONENTIATION
*
*        REENTRY FOR NORMAL *
*
         CNOP  0,4                ENSURE ALLIGNMENT
SCANAST1 BAL   R5,SCANUB          OFF TO COMMON ROUTINE
         BINOP 8,$$MLT2,,COMMUT   BINARY *
         BINOP 8,$$MLT2           BINARY * COMMUTED
AST1DV   UNOP  $$AST1,,SPECL      UNARY *
         B     CODENQ4            CODEGEN JUMP FOR UNARY * PROCESSING
*
*        PROCESSING FOR / (UNARY OR BINARY)
*
         CNOP  0,4                ENSURE BAL ALLIGNMENT
SCANSLS  BAL   R5,SCANUB          OFF TO COMMON ROUTINE
         BINOP 7,$$DVD2           BINARY /
         UNOP  $$SLS1             UNARY /
*
*        PROCESSING FOR . (UNARY OR BINARY)
*
SCANDOT  CLI   1(R1),C'0'         IS THIS NUMERIC CASE? (REAL NUMBER)
         BNL   SCANNUM            IF SO, USE STANDARD NUMBER CIRCUIT
         CNOP  0,4                ALLIGN BAL
         BAL   R5,SCANUB          ELSE CALL COMMON OPTR ROUTINE
DOT2DV   BINOP 11,($$DOT2,V,N),,SPECL       BINARY .
DOT1DV   UNOP  (SPITBOLA,N),,SPECL          UNARY . (DUMMY ADDRESS)
         B     CODENQ6            CODEGEN JUMP FOR UNARY .
         BINOP 11,$$DOTD          BINARY . DEFERRED ARG CASE
         EJECT
*
*        PROCESSING FOR ?
*
         CNOP  0,4                ENSURE BAL ALLIGNMENT
SCANQUS  BAL   R5,SCANUB          CALL COMMON ROUTINE
QUS2DV   BINOP 12,$$QUS2          BINARY ?
         UNOP  SPITBOLA+1,,PREDF+SPECL      UNARY ? (DUMMY ADDRESS)
         B     CODENQ1            CODEGEN JUMP FOR UNARY ?
*
*        PROCESSING FOR & (UNARY OR BINARY)
*
*        TO TAKE CARE OF THE &LASTNO CASE, WE GENERATE THE FOLLOWING
*        SPECIAL CODE --
*
*        BALR  RETURN,0           (IN CASE CONTROL FLOWS IN TO STMNT)
*        AUR   0,2                NORMAL STATEMENT COUNT
*        ST    RETURN,$$LAST
*
SCANAMP  CLI   AMPFLAG,0          DID WE GENERATE IT ALREADY?
         BNE   SCANAMP1           SKIP IF SO, NEED IT ONLY ONCE
         CLI   1(R1),C'L'         NEXT CHARACTER AN L?
         BH    SCANAMP1           IF HIGHER, CANNOT BE &LASTNO
         BE    SCANAMP0           SKIP IF AN L (COULD BE &LASTNO)
         CLI   1(R1),C'A'         IS IT FROM A-K?
         BNL   SCANAMP1           SKIP IF SO (CANNOT BE &LASTNO)
*
*        HERE IF THIS COULD BE A DIRECT OR INDIRECT &LASTNO REFERENCE
*
SCANAMP0 MVI   AMPFLAG,1          SET SIGNAL FOR & CODE ALREADY DONE
         L     R2,LABSAVE         LOAD SAVED LABEL BLOCK POINTER
         LTR   R2,R2              WAS THERE A LABEL
         BZ    *+16               SKIP IF NOT
         L     R3,VLABL(,R2)      ELSE LOAD OLD LABEL POINTER
         AH    R3,=H'2'           ADJUST PAST THE BALR WE WILL MAKE
*                                 SAVING LEFT POINTER BYTE
         ST    R3,VLABL(,R2)      STORE ADJUSTED VALUE
         L     LC,STMCODE         DELETE AUR ETC. ALREADY GENERATED
         MVC   0(8,LC),LSTCD$     GENERATE OUR SPECIAL CODE
         MVC   2(2,LC),AUR$       GENERATE THE AUR
         LA    LC,8(,LC)          BUMP CODE POINTER
*
*        COMPLETE NORMAL PROCESSING OF &
*
         CNOP  0,4                MAKE SURE WE ARE ALLIGNED FOR BAL
SCANAMP1 BAL   R5,SCANUB          CALL COMMON ROUTINE
         BINOP 1,$$AMP2           BINARY &
KGETDV   UNOP  ($$KGET,N)         UNARY &
         EJECT
*
*        ENTRY FOR  (UNARY OR BINARY)
*
         CNOP  0,4                ENSURE BAL ALLIGNMENT
SCANNOT  BAL   R5,SCANUB          CALL COMMON ROUTINE
         BINOP 12,$$NOT2,,RASS
NOTDV    UNOP  SPITBOLA+3,,PREDF+SPECL      UNARY  (DUMMY ADDRESS)
         B     CODENQ2            CODEGEN JUMP FOR UNARY 
*
*        ENTRY FOR | (BINARY ONLY)
*
         CNOP  0,4                ENSURE BAL ALLIGNMENT
SCANORP  BAL   R5,SCANUB          CALL COMMON ROUTINE
         BINOP 2,$$ORP2           BINARY |
         UNOP  $$BAR1             UNARY |
*
*        ENTRY FOR # (UNARY OR BINARY)
*
SCANNMS  BAL   R5,SCANUB          CALL COMMON ROUTINE
         BINOP 6,$$PND2           BINARY #
         UNOP  $$PND1             UNARY #
*
*        ENTRY FOR @ (UNARY OR BINARY)
*
         CNOP  0,4                ENSURE BAL ALLIGNMENT
SCANATS  BAL   R5,SCANUB          CALL COMMON ROUTINE
         BINOP 4,$$ATS2           BINARY @
ATS1DV   UNOP  ($$ATSP,N),,SPECL  UNARY @
         B     CODENQ5            CODEGEN JUMP FOR UNARY @
         DC    AL4(0)             FILLER TO GET OFFSET (SEE CODEXTST)
         UNOP  $$ATSD             UNARY @ WITH EXPR ARGUMENT
*
*        ENTRY FOR % (UNARY OR BINARY)
*
         CNOP  0,4                ENSURE BAL ALLIGNMENT
SCANPCT  BAL   R5,SCANUB          CALL COMMON ROUTINE
         BINOP 9,$$PCT2           BINARY %
         UNOP  $$PCT1             UNARY %
         EJECT
*
*        OPERATOR PROCESSING ROUTINE
*
*        CNOP  0,4
*        BAL   R5,SCANUB
*        (DOPE VECTOR FOR BINARY OPERATOR)
*        (COMMUTED BINARY OPERATOR DV IF USED, +,* ONLY)
*        (DOPE VECTOR FOR UNARY OPERATOR)
*
*        THIS ROUTINE DETERMINES WHETHER THE OPERATOR IS UNARY OR
*        BINARY AND RETURNS TO THE CALLER OF SCAN WITH THE ADDRESS
*        OF THE APPROPRIATE OPERATOR DOPE VECTOR STORED IN SCANAD
*
*        NOTE THAT AN OPERATOR IS TREATED AS BINARY ONLY IF IT IS
*        PRECEDED AND FOLLOWED BY BLANKS. OTHERWISE IT IS UNARY.
*        ERROR SITUATIONS (SUCH AS ' A+ B ') ARE CAUGHT IN EXPAN
*
SCANUB   LA    R1,1(,R1)          BUMP PAST OPERATOR
         TM    0(R1),X'FF'-X'40'  TEST FOR BLANK OR END OF CARD AFTER
         BZ    SCANUB1            SKIP IF SO, COULD BE BINARY
*
*        COME HERE IF UNARY
*
SCANUBU  LA    R5,4(,R5)          POINT TO UNARY OP DOPE VECTOR
         TM    1(R5),BNOP         STILL POINTING TO BINARY OP (+,*)
         BO    SCANUBU            BACK TO BUMP AGAIN IF SO
*
*        COME HERE TO STORE DOPE VECTOR ADDRESS & REPORT OPERATOR
*
SCANUBC  ST    R5,SCANAD          STORE OPTR DOPE VECTOR ADDRESS
         MVI   SCANAD,0           MAKE SURE UPPER BYTE IS ZERO
         MVI   SCANFL,OPR         REPORT OPERATOR
         ST    R1,SCANLOC         SAVE SCAN LOCATION
         BR    RF                 AND RETURN
*
*        COME HERE IF IT COULD BE BINARY (FOLLOWED BY BLANK)
*
SCANUB1  CLI   SCANCHR,C' '       DID WE HAVE A PRECEDING BLANK?
         BE    SCANUBC            IF SO, DEFINITELY BINARY
         B     SCANUBU            ELSE UNARY
         EJECT
*
*        SPECIAL ENTRY FOR F,S -- POSSIBLE GOTOS IF FLAG IS SET
*
SCANGOTO CLI   GOTOFLG,X'FF'      TEST FOR GOTO POSSIBLE
         BNE   SCANLTR            SKIP IF NOT FOR NORMAL PROCESSING
         CLI   1(R1),C'('         TEST FOR LEFT PAREN (GOTO)
         BE    SCANS              SIGNAL GOTO IF SO
         CLI   1(R1),C'<'         ELSE CHECK FOR DIRECT GOTO CASE
         BE    SCANS              SIGNAL GOTO IF SO, ELSE MERGE LETTER
*
*        ENTRY POINT FOR LETTER -- VARIABLE
*
SCANLTR  LR    R3,R1              SAVE SCAN LOC (START OF STRING)
*
*        LOOP HERE IF NAME IS LONGER THAN 255 CHARACTERS
*
SCANLTR0 TRT   1(256,R1),SCANTB2  SCAN TO END OF NAME
         BNZ   SCANLTR1           SKIP IF END OF NAME FOUND
         LA    R1,256(,R1)        ELSE PUSH POINTER PAST 256 BYTES
         B     SCANLTR0           AND LOOP BACK
*
*        HERE WHEN WE FIND THE END OF THE NAME
*
SCANLTR1 C     R1,STOPLOC         DID WE OVERSHOOT ON TRT?
         BNL   SCANLTR3           SKIP IF SO
         BAL   R4,SCANHSH         LOCATE VARIABLE BLOCK
         CLI   0(R1),C'('         DO WE HAVE A FOLLOWING (
         BE    SCANFNC            FUNCTION IF SO
*
*        HERE IF A VARIABLE REFERENCE (NOT A FUNCTION CALL)
*
SCANLTR2 ST    R5,SCANAD          STORE VARIABLE BLOCK ADDRESS
         ST    R1,SCANLOC         SAVE SCAN LOCATION
         MVI   SCANFL,VAR         SET SYNTAX REPORT
         BR    RF                 AND RETURN
*
*        HERE IF WE SCAN OFF THE END OF THE INPUT IMAGE
*
SCANLTR3 L     R1,STOPLOC         POINT BACK TO END OF IMAGE
         BAL   R4,SCANHSH         LOCATE VARIABLE BLOCK
         B     SCANLTR2           MERGE BACK (CANNOT BE A FUNCTION)
*
*        HERE FOR A FUNCTION (I.E. VARIABLE NAME FOLLOWED BY A LEFTPRN)
*
SCANFNC  LA    R1,1(,R1)          BUMP SCAN POINTER PAST (
         ST    R5,SCANAD          REPORT DOPE VECTOR ADDRESS FOR BLOCK
         MVI   SCANFL,FNC         REPORT FUNCTION
         ST    R1,SCANLOC         SAVE SCAN LOCATION
         BR    RF                 RETURN
         EJECT
*
*        ENTRY TO DEAL WITH REAL OR INTEGER CONSTANT
*
*
*        IF THIS CONSTANT HAS NOT ALREADY BEEN DEFINED, AN 8-BYTE
*        BLOCK IS BUILT IN THE DATA AREA. A HASH TABLE IS MAINTAINED
*        FOR REAL AND INTEGER CONSTANTS. (DREALS ARE NOT HASHED).
*        THE HASH TABLE HAS 64 FULLWORD ENTRIES. EACH ENTRY IS A PTR
*        TO A CHAIN OF CONSTANTS HASHING INTO THE SAME SLOT. THE
*        CONSTANTS ARE LINKED THROUGH THE FIRST WORD OF THE VALUE
*        FIELD.  ZERO MARKS THE END OF THE CHAIN
*
SCANNUM  LR    R4,R1              SAVE STARTING LOCATION
*
*        SCAN OUT NUMERIC CONSTANT
*
         BCTR  R1,0               BACK OFF R1 TO CALL COMMON ROUTINE
         BAL   R5,SCANDIGS        CALL ROUTINE TO SCAN PAST DIGITS
         CLI   0(R1),C'.'         IS THIS A REAL NUMBER?
         BNE   SCANNUMG           ALL SCANNED OUT IF NOT
         BAL   R5,SCANDIGS        ELSE SCAN DIGITS AFTER DEC POINT
         CLI   0(R1),C'E'         DO WE HAVE "E" EXPONENT
         BE    SCANNUMR           SKIP IF SO
         CLI   0(R1),C'D'         ELSE DO WE HAVE "D" EXPONENT
         BNE   SCANNUMG           ALL DONE IF NOT
*
*        COME HERE AFTER FINDING A D OR E EXPONENT
*
SCANNUMR CLI   1(R1),C'+'         DO WE HAVE A PLUS SIGN
         BE    *+12               SKIP IF SO
         CLI   1(R1),C'-'         OR A MINUS SIGN?
         BNE   *+8                SKIP IF NOT
         LA    R1,1(,R1)          ELSE BUMP ONE FOR THE SIGN
         BAL   R5,SCANDIGS        SCAN PAST DIGITS IN EXPONENT
*
*        COME HERE TO CALL CONVERT ROUTINE
*
SCANNUMG C     R1,STOPLOC         PAST END OF INPUT IMAGE?
         BL    *+8                SKIP IF NOT
         L     R1,STOPLOC         ELSE RESET SCAN PTR TO END OF IMAGE
         ST    R1,SCANLOC         STORE UPDATED SCAN LOCATION
         MVI   SCANFL,CON         INDICATE RETURN TYPE = CONSTANT
         SR    R1,R4              GET REAL LENGTH OF NUMBER STRING
         LR    R5,R1              MOVE TO R5 (A1+1)
         BCTR  R5,0               ADJUST TO 360 LENGTH
         SH    R4,=Y(SCHARS)      INTRODUCE PROPER OFFSET TO ADDRESS
         LA    R2,STGTONUM        LOAD ADDRESS OF CONVERT ROUTINE
         BALR  R1,R2              CALL ROUTINE TO CONVERT TO NUMERIC
         ERR   16                 ILLEGAL NUMERIC ON CONVERT ERROR
         LCR   R2,R4              TEST DATATYPE OF NUMERIC ITEM
         BP    SCANNUM4           SKIP IF DREAL (NO HASH FOR DREAL)
         TM    STAGE,$EXECUTE     EXECUTE TIME (CODE,EVAL)?
         BO    SCANNUM4           SKIP IF SO (DO NOT HASH)
         EJECT
*
*        COME HERE TO HASH THE NUMERIC CONSTANT AND LOOK IT UP
*
*        HASH IS FIRST 6 BITS OF XOR OF 2ND & 4TH BYTES OF SECOND WORD
*
         LR    R2,R5              COPY SECOND WORD (VALUE)
         SRL   R2,16              RIGHT JUSTIFY SECOND BYTE
         XR    R2,R5              GET EXCLUSIVE OR WITH FOURTH BYTE
         N     R2,=X'000000FC'    GET 6 BITS (FULLWORD OFFSET)
         LA    R6,CHASH-CHASHL(R2)          POINT TO SLOT WITH OFFSET
         ST    R4,SCANWRK         STORE FIRST WORD (TYPE CODE)
*
*        LOOP TO SCAN DOWN HASH CHAIN
*
SCANUM3A CE    ZR,CHASHL(,R6)     CHECK FOR END OF HASH CHAIN
         BZ    SCANNUM4           SKIP IF AT END OF CHAIN
         L     R6,CHASHL(,R6)     ELSE POINT TO NEXT BLK ON HASH CHAIN
         C     R5,CVALUE(,R6)     CHECK FOR MATCH ON VALUE
         BNE   SCANUM3A           IF NO MATCH, LOOP BACK
         CLC   CONCODE(1,R6),SCANWRK        CHECK FOR CORRECT TYPE
         BNE   SCANUM3A           LOOP BACK IF NO MATCH
*
*        COME HERE IF WE FIND AN OLD COPY WE CAN USE
*
         ST    R6,SCANAD          STORE ADDRESS OF BLOCK
         BR    RF                 RETURN
*
*        COME HERE TO CREATE NEW CONSTANT (REAL OR INTEGER) BLOCK
*
SCANNUM4 BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK
         STM   R4,R5,VALUE(R1)    STORE CONSTANT
         ST    R1,SCANAD          STORE ADDRESS OF BLOCK FOR SCAN
*
*        HERE WE LINK NEW BLOCK INTO HASH CHAIN UNLESS TYPE = DREAL
*
         LCR   R4,R4              TEST TYPE
         BCR   P,RF               RETURN IF DREAL
         TM    STAGE,$EXECUTE     EXECUTE TIME (CODE,EVAL)?
         BCR   O,RF               SKIP HASH LINKING IF SO
         IC    R0,CONCODE(,R6)    SAVE UPPER BYTE
         ST    R1,CHASHL(,R6)     LINK NEW CONSTANT ONTO HASH CHAIN
         STC   R0,CONCODE(,R6)    RESTORE UPPER BYTE
         BR    RF                 RETURN TO SCAN CALLER
*
*        LITTLE SUBROUTINE TO SCAN PAST DIGITS
*
SCANDIGS TRT   1(256,R1),SCANTB3  SCAN PAST DIGITS
         BCR   NZ,R5              RETURN IF WE FOUND NON-DIGIT
         LA    R1,256(,R1)        ELSE BUMP PAST 256 DIGITS
         B     SCANDIGS           AND LOOP BACK
         EJECT
*
*        ENTRY FOR ' OR "
*
*        AFTER THE ELEMENT IS SCANNED OUT, A STRING IS CONSTRUCTED IN
*        HIGH CORE, AND AN 8-BYTE SPECIFIER POINTING TO THIS STRING
*        IS CONSTRUCTED IN THE DATA AREA
*        IF THE STRING ALREADY EXISTS, THEN A NEW SPECIFIER IS NOT
*        CONSTRUCTED, RATHER THE OLD ADDRESS IS RETURNED--THE LOGIC OF
*        USING A HASH TABLE TO REMEMBER OLD ENTRIES IS VIRTUALLY
*        IDENTICAL TO THAT USED IN PROCESSING INTEGERS
*        EXCEPT THAT THE NXTHASHS FIELD IS USED AS THE LINK FIELD
*
SCANQUT  MVI   SCANFL,CON         INDICATE CONSTANT
         LR    R3,R1              SAVE LOCATION OF INITIAL QUOTE
*
*        LOOP TO SCAN OUT THE LITERAL
*
SCANQT0  TRT   1(256,R1),SCANTB4  SCAN TO ' OR "
         BNZ   SCANQT1            SKIP IF WE GOT STOPPED
         LA    R1,256(,R1)        ELSE BUMP PAST 256 CHARACTERS
         C     R1,STOPLOC         PAST END OF IMAGE?
         BL    SCANQT0            LOOP BACK IF NOT TO KEEP SCANNING
*
*        COME HERE IF WE SCAN OFF THE END OF THE CARD
*
SCANQT00 MVC   SCANLOC,STOPLOC    UPDATE SCAN POINTER TO END OF CARD
         ERR   18                 ******UNMATCHED QUOTE******
*
*        COME HERE IF WE STOP ON A ' OR "
*
SCANQT1  C     R1,STOPLOC         DID WE SCAN OFF THE END OF THE INPUT?
         BNL   SCANQT00           JUMP TO GIVE ERROR IF SO
         CLC   0(1,R3),0(R1)      IS THIS THE QUOTE WE ARE LOOKING FOR?
         BNE   SCANQT0            NO -- PART OF STRING -- KEEP GOING
*
*        HERE WHEN WE HAVE SCANNED TO THE CLOSING QUOTE
*
         LR    R2,R1              GET LOCATION OF FINAL QUOTE
         LA    R1,1(R1)           POINT SCAN POINTER PAST QUOTE
         ST    R1,SCANLOC         SAVE UPDATED SCAN POINTER
         SH    R2,=H'2'           R2 IS LOCATION OF LAST CHAR WI FUDGE
         SR    R2,R3              GET LENGTH - 1
         BNM   SCANQT2            SKIP IF THERE IS A STRING
         STE   ZR,SCANAD          INDICATE NULL CONSTANT BY ZERO PTR
         BR    RF                 RETURN
         EJECT
*
*        REENTRY TO HASH STRING AND LOOK IT UP
*        THE HASHING ALGORITHM IS TO EXCLUSIVE OR THE LENGTH, CHARS 1-4
*        AND CHARS 5-8 AND TAKE THE REMAINDER ON DIVIDING BY 63
*
SCANQT2  TM    STAGE,$EXECUTE     CALL AT EXECUTE TIME?
         BO    SCANQH5            SKIP IF SO
         CH    R2,=H'7'           ELSE TEST FOR LENGTH < 8
         BH    SCANQT3            SKIP IF LONG STRING
         STD   ZR,SCANWRK         ZERO WORK AREA
         EX    R2,SCANQMV         MOVE IN WHAT CHARACTERS WE HAVE
         B     SCANQT4            MERGE
*
*        SKIP HERE IF LENGTH 8 CHARS OR MORE
*
SCANQT3  MVC   SCANWRK(8),1(R3)   FOR LENGTH > 7, MOVE 1ST EIGHT CHARS
*
*        MERGE HERE WITH HASH CHARACTERS MOVED INTO PLACE IN SCANWRK
*
SCANQT4  L     R5,SCANWRK         LOAD FIRST FOUR BYTES
         XR    R5,R2              EXCLUSIVE OR LENGTH
         X     R5,SCANWRK+4       EXCLUSIVE OR BYTES 5-8
         SR    R4,R4              CLEAR HIGH ORDER PART
         D     R4,=F'63'          DIVIDE TO GET HASH
         SLL   R4,2               *4 TO INDEX HASH TABLE
         LA    R4,CHASH-CHASHL(R4)          POINT TO HASH SLOT
         SR    R0,R0              CLEAR R0 FOR IC IN LOOP
*
*        LOOP TO SCAN DOWN HASH CHAIN
*
SCANQH3  CE    ZR,CHASHL(,R4)     IS THIS THE END OF THE CHAIN?
         BZ    SCANQH4            SKIP IF SO
         L     R4,CHASHL(,R4)     ELSE POINT TO NEXT BLOCK ON CHAIN
         CLI   CONCODE(R4),SCODE  IS IT A STRING?
         BNE   SCANQH3            LOOP BACK IF NOT A STRING
         IC    R0,CSLENGTH(,R4)   LOAD 360 LENGTH
         CR    R0,R2              DO LENGTHS MATCH?
         BNE   SCANQH3            LOOP BACK IF DIFFERENT LENGTHS
         L     R7,CSADR(,R4)      LOAD POINTER TO STRING
         EX    R2,SCANQCMP        COMPARE STRINGS
         BNE   SCANQH3            LOOP BACK IF DIFFERENT
*
*        HERE IF WE FOUND AN OLD BLOCK WE CAN USE
*
         ST    R4,SCANAD          SAVE ITS ADDRESS
         BR    RF                 RETURN
*
SCANQCMP CLC   1(*-*,R3),SCHARS(R7)         COMPARE STRINGS FOR MATCH
SCANQMV  MVC   SCANWRK(*-*),1(R3) MOVE CHARACTERS TO WORK AREA
         EJECT
*
*        COME HERE TO CREATE NEW BLOCK FOR STRING CONSTANT
*
SCANQH4  LTR   R7,R4              SAVE LOCATION OF LAST HASH SLOT
*                                 ALSO SET CC=NONZERO FOR HIGHCORE CALL
         LA    R4,1(,R3)          POINT TO STRING
         LA    R5,1(,R2)          ACTUAL LENGTH OF STRING
         LR    R0,R5              COPY LENGTH OF STRING
         A     R0,STRUSED         ADD LENGTH USED SO FAR FOR STRINGS
         ST    R0,STRUSED         STORE INCREMENTED COUNT
         LA    R2,HIGHCORE        POINT TO HIGH CORE ROUTINE
         BALR  R1,R2              MOVE STRING CONSTANT TO HIGH CORE
         SH    R4,=Y(SCHARS)      INTRODUCE PROPER STRING OFFSET
         BCTR  R5,0               ADJUST TO 360 LENGTH
         BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK
         ST    R1,SCANAD          STORE ADDRESS OF NEW CONSTANT BLOCK
*
*        NOW STORE STRING IN CONSTANT BLOCK IN SPECIAL COMPILER FORMAT
*
         ST    R4,CSADR(,R1)      STORE STRING ADDRESS IN NEW BLOCK
         STC   R5,CSLENGTH(,R1)   STORE LENGTH OF STRING
         MVI   CONCODE(R1),SCODE  INDICATE STRING TYPE
*
*        LINK THIS BLOCK INTO THE CONSTANT HASH TABLE
*
         IC    R0,CONCODE(,R7)    SAVE TYPE CODE IN PREVIOUS BLOCK
         ST    R1,CHASHL(,R7)     LINK THIS BLOCK INTO THE CHAIN
         STC   R0,CONCODE(,R7)    RESTORE UPPER BYTE
         BR    RF                 RETURN TO CALLER
*
*        HERE FOR CODE,EVAL CASE, COMPUTE OFFSET IN ARGUMENT STRING
*
*        (R2)                     360 LENGTH OF STRING
*        (R3)                     POINTS TO INITIAL QUOTE
*
SCANQH5  LR    R5,R2              COPY 360 LENGTH
         BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK
         ST    R1,SCANAD          SAVE AS RETURNED SCAN BLOCK PTR
         STH   R5,SLENGTH+VALUE(,R1)        STORE 360 LENGTH OF STRING
         L     R0,CODSVREG+4*A1   LOAD SOURCE STRING BASE POINTER
         ST    R0,VALUE(,R1)      STORE AS FIRST WORD OF CONSTANT
         SH    R3,=Y(SCHARS-1)    POINT SCHARS BEHIND STRING
         SR    R3,R0              COMPUTE PROPER OFFSET IN STRING
         STH   R3,SOFFSET+VALUE(,R1)        STORE OFFSET IN BLOCK
         MVI   CRELFLG,1          TELL GCOL TO COLLECT CONSTANTS
         BR    RF                 RETURN TO CALLER
         EJECT
*
*        COME HERE IF WE SCAN OUT 256 BLANKS (TRT FALLS THROUGH)
*
SCAN256B LA    R1,256(,R1)        PUSH SCAN POINTER
         C     R1,STOPLOC         PAST END OF IMAGE?
         BL    SCAN1              KEEP SCANNING IF NOT
*
*        COME HERE AT END OF INPUT IMAGE
*        RETURN TRM UNLESS THERE ARE CONTINUATION CARDS
*
SCANTRM  MVI   SCANFL,TRM         SET PROVISIONAL REPORT
*
*        FOR END OF IMAGE, TEST FOR COMPILE OR EXECUTE TIME. IN THE
*        LIBRARY MODULES THIS TEST IS OMITTED SINCE IT MUST BE XEQ TIME
*
         AIF   (&LMOD EQ 1).SCANTRS
         TM    STAGE,$EXECUTE     IS THIS CODE OR EVAL CALL?
         BO    SCANTR3            SKIP IF SO
*
*        IF NOT EXECUTE TIME, THEN WE READ THE NEXT CARD TO SEE IF IT
*        IS A CONTINUATION CARD. COMMENT CARDS ARE MERELY LISTED.
*        THIS CODE IS NOT REQUIRED IN THE LIBRARY MODULES
*
SCANTR1  BAL   R7,READER          READ NEXT CARD
         LA    R1,INBUF           POINT TO START OF NEW CARD
         ST    R1,SCANLOC         INITIALIZE SCAN LOCATION
         CLI   0(R1),C'*'         IS THIS A COMMENT CARD?
         BNE   SCANTR2            SKIP IF NOT
         BAL   R7,LISTER          ELSE JUST LIST A COMMENT CARD
         B     SCANTR1            AND BACK TO READ NEXT CARD
*
*        IF NOT A COMMENT CARD, IS IT A CONTINUATION CARD?
*
SCANTR2  CLI   0(R1),C'.'         PERIOD?
         BE    SCANCNTC           SKIP IF SO, CONTINUATION
         CLI   0(R1),C'+'         ALTERNATE CONTINUATION (PLUS)?
         BCR   NE,RF              IF NOT, ALL SET REAL END OF STATEMENT
*
*        HERE FOR CONTINUATION CARD
*
SCANCNTC MVI   0(R1),C' '         BLANK CONTINUATION CHARACTER
         LA    R7,SCAN0           SET EXIT TO SCAN NEXT ELEMENT
         B     LISTER             LIST CONT CARD & BACK TO SCAN ELEMENT
.SCANTRS ANOP
*
*        COME HERE AT END OF STRING FOR EXECUTION TIME CALL
*
SCANTR3  MVI   CODEOS,1           SET CODE END OF STRING FLAG
         BR    RF                 RETURN WITH END OF STRING SET
         EJECT
*
*        ENTRY POINT FOR ILLEGAL CHARACTER DETECTED
*
SCANILG  LA    R1,1(R1)           BUMP POINTER OVER BAD CHARACTER
         CLI   ERRFLG,1           CHECK FOR ERROR IN ERROR
         BE    SCANERR            SKIP IF ERROR IN ERROR
         ERR   24                 *** ILLEGAL CHARACTER ***
*
*        WE COME HERE IF AN ERROR OCCURS INSIDE AN ERROR WHILE
*        SCANNING TO A STATEMENT BOUNDARY (ALSO USED BY CONCPROC)
*
SCANERR  ST    R1,SCANLOC         PUT IN LAST SCAN LOCATION
         MVI   SCANFL,0           CLEAR REPORT CELL
         BR    RF                 RETURN
         EJECT
*
*        INTERNAL SUBROUTINE TO HASH TO LOCATE VARIABLE BLOCK
*        A NEW VARIABLE BLOCK IS CREATED IF NECCESSARY
*        SEE DATA STRUCTURES SECTION FOR DESCRIPTION OF VARIABLE BLOCK
*        AND MAIN HASH TABLE STRUCTURE
*
*        (R1)                     POINTER TO CHARACTER AFTER NAME
*        (R3)                     POINTER TO FIRST CHARACTER OF NAME
*        BAL   R4,SCANHSH
*        (R5)                     DOPE VECTOR POINTER ON RETURN
*
SCANHSH  STM   R1,R4,SCANHSV      SAVE REGS
         LR    R5,R1              COPY PTR TO CHAR AFTER NAME
         SR    R5,R3              GET LENGTH OF NAME
         BCTR  R5,0               ADJUST TO 360 LENGTH
         LR    R4,R3              COPY START OF NAME ADDRESS
         SH    R4,=Y(SCHARS)      INTRODUCE STANDARD OFFSET
         LA    R2,VARLOC          POINT TO HASH ROUTINE
         BALR  R1,R2              CALL MAIN HASH ROUTINE
         LR    R5,R4              MOVE BLOCK PTR TO PROPER REG
         LM    R1,R4,SCANHSV      RELOAD REGS
         BR    R4                 RETURN TO CALLER
         EJECT
*
*        FIND8                    LOCATE CONSTANT BLOCK
*
*        THIS ROUTINE IS CALLED TO LOCATE AN 8-BYTE BLOCK FOR USE
*        AS A CONSTANT (STRING, INTEGER, REAL, DREAL, VCODE)
*
*        BAL   R2,FIND8
*        (R1)                     ADDRESS OF ALLOCATED BLOCK
*        (R0)                     MAY BE CLOBBERED
*        (R2-RF)                  UNCHANGED BY CALL
*
*        AT COMPILE TIME, THE BLOCKS ARE OBTAINED SEQUENTIALLY FROM
*        THE CURRENT 4K BLOCK. HOWEVER, AT EXECUTION TIME, USE OF CODE
*        AND EVAL CAN RESULT IN BLOCKS BEING FREED. SUCH BLOCKS ARE
*        HANDELED AS FOLLOWS --
*
*        SPACE FOR CONSTANTS AT EXECUTION TIME IS ALLOCATED IN
*        MULTIPLES OF 32 BYTES (CONTIGUOUS). THE FIRST WORD IS USED
*        TO CHAIN SUCH 32 BYTE BLOCKS IN USE BY A SECTION OF CODE
*        FROM THE CODECCHN FIELD OF THE CBLOK. THE SECOND WORD GIVES
*        THE ADDRESS OF THE HIGHEST CONSTANT USED IN A PARTICULAR 32
*        BYTE BLOCK. THERE IS ROOM FOR THREE CONSTANTS IN EACH BLOCK.
*        WHEN A CBLOK IS COLLECTED, THE GARBAGE COLLECTOR RETURNS THE
*        32 BYTE BLOCKS TO A FREE LIST CHAINED FROM CONSCHAN IN THE
*        MAIN DATA AREA. THUS WE USE THIS CHAIN FIRST WHEN ATTEMPTING
*        TO OBTAIN A NEW 32 BYTE BLOCK.
*
FIND8    STM   R2,R5,SCANHSV      SAVE ENTRY REGS
         TM    STAGE,$EXECUTE     EXECUTE TIME?
         BO    FIND8EX            SKIP IF SO
*
*        HERE AT COMPILE TIME
*
         BAL   R4,FIND8S          GET A BLOCK FROM THE CURRENT 4K BLK
         DC    H'8'               EIGHT BYTES
         STD   ZR,0(,R1)          CLEAR BLOCK OBTAINED
*
*        MERGE HERE TO EXIT TO CALLER WITH (R1) SET TO POINT TO BLOCK
*
FIND8X   LM    R2,R5,SCANHSV      RESTORE REGS
         SH    R1,=Y(VALUE)       INTRODUCE STANDARD VALUE OFFSET
         BR    R2                 RETURN TO CALLER
*
*        HERE AT EXECUTION TIME
*
FIND8EX  L     R5,CODSVREG+4*FR   LOAD POINTER TO CBLOK
         L     R3,CODECCHN(,R5)   LOAD POINTER TO CURRENT 32 BYTE BLOCK
         LTR   R3,R3              IS THERE ONE?
         BZ    FIND8EX1           IF NOT, SKIP TO GET ONE
         L     R1,4(,R3)          ELSE LOAD ADDR OF LAST CONSTANT
         SH    R1,=H'8'           BACKOFF TO MAKE ROOM FOR NEW ONE
         ST    R1,4(,R3)          STORE NEW LOWEST LOC
         CR    R1,R3              ANY MORE ROOM IN 32 BYTE BLOCK?
         BNE   FIND8X             ALL SET TO EXIT IF SO
         EJECT
*
*        FIND8 -- CONTINUED
*
*        HERE IF NO 32 BYTE BLOCK ALLOCATED YET OR IF LAST ONE USED UP
*
FIND8EX1 L     R1,CONSCHAN        LOAD HEAD OF FREE LIST POINTER
         LTR   R1,R1              ANY ENTRIES ON FREE LIST?
         BNZ   FIND8EX2           SKIP IF SO
*
*        HERE WE MUST GET A 32 BYTE CHUNK FROM THE CURRENT 4K BLOCK
*
         BAL   R4,FIND8S          ALLOCATE BLOCK
         DC    H'32'              32 BYTES LONG
         B     FIND8EX3           MERGE
*
*        HERE IF THERE IS A BLOCK ON THE FREE CHAIN WE CAN USE
*
FIND8EX2 L     R0,0(,R1)          LOAD FORWRAD LINK
         ST    R0,CONSCHAN        DELETE BLOCK FROM CHAIN AND MERGE
*
*        MERGE HERE WITH (R1) POINTING TO NEW 32 BYTE BLOCK
*
FIND8EX3 ST    R3,0(,R1)          STORE FORWARD LINK
         ST    R1,CODECCHN(,R5)   LINK NEW BLOCK INTO CBLOK CHAIN
         STD   ZR,8(,R1)          CLEAR SPACE FOR THREE CONSTANTS
         STD   ZR,16(,R1)         . . . .
         STD   ZR,24(,R1)         . . . .
         LA    R0,24(,R1)         POINT TO LAST OF THREE CONSTANTS
         ST    R0,4(,R1)          STORE AS HIGHEST ONE USED
         LR    R1,R0              GET ADDR OF ONE TO USE THIS TIME
         B     FIND8X             AND EXIT
*
*        SUBROUTINE TO ALLOCATE 8 OR 32 BYTES FROM CURRENT 4K BLOCK
*
*        BAL   R4,FIND8S
*        DC    H'LENGTH'          LENGTH REQUIRED
*        (R1)                     CONTAINS ADDRESS ON RETURN
*
FIND8S   L     R2,DATACUR         LOAD POINTER TO CURRENT BLOCK
         L     R1,CBLKBOT(,R2)    LOAD POINTER TO LOWEST CONSTANT
         SH    R1,0(,R4)          MAKE ROOM FOR NEW SUBBLOCK
         C     R1,VBLKNXT(,R2)    IS THERE ROOM?
         BNL   FIND8S2            SKIP IF THERE IS ROOM
         LA    R2,GET4KBLK        POINT TO ROUTINE TO ALLOCATE 4K BLOCK
         BALR  R1,R2              ALLOCATE A NEW 4K BLOCK
         B     FIND8S             LOOP BACK TO USE NEW BLOCK
*
*        HERE WHEN WE HAVE GOT SPACE IN THE CURRENT 4K BLOCK
*
FIND8S2  ST    R1,CBLKBOT(,R2)    STORE NEW LOWEST CONSTANT BLOCK
         L     R2,CONUSED         LOAD COUNT OF SPACE FOR CONSTANTS
         AH    R2,0(,R4)          INCREMENT FOR THIS BLOCK
         ST    R2,CONUSED         STORE INCREMENTED COUNT
         B     2(,R4)             RETURN PAST PARAMETER
         EJECT
*
*        TABLE OF SUPPLEMENTARY DOPE VECTORS
*
*        THESE DOPE VECTORS ARE REFERENCED ELSEWHERE IN THE COMPILER
*
CNCDV    BINOP 3,$$CNC2,,SPECL              CONCATENATION
PTNDV    BINOP SFPRI,($$PTN2,N,V)           PATTERN MATCH BY NAME
PTVDV    BINOP SFPRI,($$PTV2,V,V)           PATTERN MATCH BY VALUE
O$EQ     BINOP SFPRI,NE,,PREDF+COMMUT       EQ
         BINOP SFPRI,NE,,PREDF+COMMUT       EQ COMMUTED
O$NE     BINOP SFPRI,E,,PREDF+COMMUT        NE
         BINOP SFPRI,E,,PREDF+COMMUT        NE COMMUTED
O$GT     BINOP SFPRI,NH,,PREDF+COMMUT       GT
O$LT     BINOP SFPRI,NL,,PREDF+COMMUT       LT + GT COMMUTED
         BINOP SFPRI,NH,,PREDF+COMMUT       LT COMMUTED
O$LE     BINOP SFPRI,H,,PREDF+COMMUT        LE
O$GE     BINOP SFPRI,L,,PREDF+COMMUT        GE + LE COMMUTED
         BINOP SFPRI,H,,PREDF+COMMUT        GE COMMUTED
O$LEQ    BINOP SFPRI,256+NE,,PREDF+COMMUT   LEQ
         BINOP SFPRI,256+NE,,PREDF+COMMUT   LEQ COMMUTED
O$LNE    BINOP SFPRI,256+E,,PREDF+COMMUT    LNE
         BINOP SFPRI,256+E,,PREDF+COMMUT    LNE COMMUTED
O$LGT    BINOP SFPRI,256+NH,,PREDF+COMMUT   LGT
O$LLT    BINOP SFPRI,256+NL,,PREDF+COMMUT   LLT + LGT COMMUTED
         BINOP SFPRI,256+NH,,PREDF+COMMUT   LLT COMMUTED
O$LLE    BINOP SFPRI,256+H,,PREDF+COMMUT    LLE
O$LGE    BINOP SFPRI,256+L,,PREDF+COMMUT    LGE + LLE COMMUTED
         BINOP SFPRI,256+H,,PREDF+COMMUT    LGE COMMUTED
O$IDENT  BINOP SFPRI,512+NE,,PREDF+SPECL+COMMUT  IDENT
         BINOP SFPRI,512+NE,,PREDF+SPECL+COMMUT  IDENT COMMUTED
         BINOP SFPRI,512+L,,PREDF+SPECL+COMMUT   IDENT WITH NULL
         BINOP SFPRI,512+L,,PREDF+SPECL+COMMUT   IDENT WI NULL COMM
O$DIFFER BINOP SFPRI,512+E,,PREDF+SPECL+COMMUT   DIFFER
         BINOP SFPRI,512+E,,PREDF+SPECL+COMMUT   DIFFER COMMUTED
         BINOP SFPRI,512+NL,,PREDF+SPECL+COMMUT  DIFFER WITH NULL
         BINOP SFPRI,512+NL,,PREDF+SPECL+COMMUT  DIFFER WI NULL COMM
         EJECT
*
*        OPERATOR DOPE VECTORS -- CONTINUED
*
O$ANY    UNOP  $$ANYP             ANY
O$BREAK  UNOP  $$BRKP             BREAK
O$BREAKX UNOP  $$BRKX             BREAKX
O$INTEGE UNOP  $$INTG,,PREDF      INTEGER
O$NOTANY UNOP  $$NTNP             NOTANY
O$SPAN   UNOP  $$SPNP             SPAN
O$POS    UNOP  $$POSP             POS
O$RPOS   UNOP  $$RPSP             RPOS
O$TAB    UNOP  $$TABP             TAB
O$RTAB   UNOP  $$RTBP             RTAB
O$LEN    UNOP  $$LENP             LEN
KPUTDV   BINOP SFPRI,($$KPUT,N,V) KEYWORD ASSIGNMENT
ASSNDV   BINOP SFPRI,($$ASSN,N,V),,COMMUT   ASSIGN WITH I/O CHECK
         BINOP SFPRI,($$RASN,V,N)           I/O CHECK ASSIGN COMMUTED
*
*        THE VALUE SFPRI (PRECEDENCE FOR SYSTEM FUNCTIONS) IS
*        NOT ACTUALLY USED, SINCE THESE DOPE VECTORS ARE NOT USED BY
*        EXPAN, BUT RATHER THEY ARE SUBSTITUTED IN THE CODEGEN ROUTINE.
*
SFPRI    EQU   0                  DUMMY DEFINITION FOR SYSTEM FUNCS
         TITLE 'SPITBOLC -- SCAN TABLES'
*
*        TABLE 1
*        -------
*
*        COMPILE TIME USE -- MAIN SYNTAX SCAN TABLE
*
SCANTB1  TABL  ILG                ILLEGAL CHAR IF NOT OTHERWISE SET
SCANTB1  FOR   'ABCDEFGHI',LTR
SCANTB1  FOR   'JKLMNOPQR',LTR
SCANTB1  FOR   'STUVWXYZ',LTR
SCANTB1  FOR   'abcdefghi',LTR    LOWER CASE
SCANTB1  FOR   'jklmnopqr',LTR    LOWER CASE
SCANTB1  FOR   'stuvwxyz',LTR     LOWER CASE
SCANTB1  FOR   '0123456789',NUM
SCANTB1  FOR   ' ',0
SCANTB1  FOR   '#',NMS
SCANTB1  FOR   '!',EXC            EXCLAMATION MARK
SCANTB1  FOR   '.',DOT
SCANTB1  FOR   '<',LBR,X
SCANTB1  FOR   '(',LPR,X
SCANTB1  FOR   '+',PLS,X
SCANTB1  FOR   '|',ORP,X
SCANTB1  FOR   AM,AMP
SCANTB1  FOR   '$',DLR
SCANTB1  FOR   '*',AST,X
SCANTB1  FOR   ')',RPR,X
SCANTB1  FOR   ';',TRM,X
SCANTB1  FOR   '',NOT,X
SCANTB1  FOR   '-',MNS,X
SCANTB1  FOR   '/',SLS,X
SCANTB1  FOR   ',',CMA
SCANTB1  FOR   '%',PCT,X
SCANTB1  FOR   '>',RBR
SCANTB1  FOR   '?',QUS,X
SCANTB1  FOR   ':',GTO
SCANTB1  FOR   '@',ATS
SCANTB1  FOR   QT,QUT,X
SCANTB1  FOR   '=',EQL,X
SCANTB1  FOR   '"',QUT,X
SCANTB1  FOR   'F',FGO
SCANTB1  FOR   'f',FGO            LOWER CASE F
SCANTB1  FOR   'S',SGO
SCANTB1  FOR   's',SGO            LOWER CASE S
         ORG
         EJECT
*
*        TABLE 2
*        -------
*
*        COMPILE TIME USE -- SCAN TO END OF VARIABLE NAME
*
SCANTB2  TABL  1
SCANTB2  FOR   'ABCDEFGHI',0
SCANTB2  FOR   'JKLMNOPQR',0
SCANTB2  FOR   'STUVWXYZ',0
SCANTB2  FOR   'abcdefghi',0      LOWER CASE
SCANTB2  FOR   'jklmnopqr',0      LOWER CASE
SCANTB2  FOR   'stuvwxyz',0       LOWER CASE
SCANTB2  FOR   '0123456789',0
SCANTB2  FOR   '_',0
SCANTB2  FOR   '.',0
         ORG
*
*        SCAN TABLE 3 IS IN SPITBOLR SINCE IT IS USED AT EXECUTION
*        TIME BY THE NUMERIC CONVERSION ROUTINES
*
*        SCAN TABLE 4 IS IN THE DATA AREA, IT IS CLEARED TO ZEROS
*        FOR USE AT EXECUTION TABLE (ZTBL)
         TITLE 'SPITBOLC -- EXPRESSION ANALYZER'
*
*        DATA STRUCTURES BUILT BY EXPAN
*        ------------------------------
*
*
*        SIMPLE VARIABLE
*        ---------------
*
*        +-------------+-----------------------------------------+
*        |    FLAGS    |       ADDRESS OF BLOCK IN DATA AREA     |
*        +-------------+-----------------------------------------+
*
OPNNM    EQU   1                  FLAG FOR SIMPLE VARIABLE
READV    EQU   128                FLAG FOR READ ASSOCIATED VARIABLE
WRITEV   EQU   64                 FLAG FOR WRITE ASSOCIATED VARIABLE
*
*        CONSTANT
*        --------
*
*        +-------------+-----------------------------------------+
*        |    FLAGS    |       ADDRESS OF BLOCK IN DATA AREA     |
*        +-------------+-----------------------------------------+
*
OPNCN    EQU   2                  FLAG FOR CONSTANT OPERAND
*
*        IN THE ABOVE CASES, THE ADDRESS IS POINTING TO THE BASE OF THE
*        REFERENCE BLOCK -- I.E FOUR BYTES BEFORE THE VALUE
*
*        UNARY OPERATOR
*        --------------
*
*        +-------------+-----------------------------------------+
*        |    FLAGS    |     POINTER TO OPERATOR DOPE VECTOR     |
*        +-------------+-----------------------------------------+
*        |               POINTER TO OPERAND BLOCK                |
*        +-------------------------------------------------------+
*
OPTRU    EQU   4                  FLAG FOR UNARY OPERATOR
STARNAME EQU   128                FLAG FOR * BY NAME (USED IN CODGEN)
*
*        BINARY OPERATOR
*        ---------------
*
*        +-------------+-----------------------------------------+
*        |    FLAGS    |     POINTER TO OPERATOR DOPE VECTOR     |
*        +-------------+-----------------------------------------+
*        |           POINTER TO LEFT OPERAND BLOCK               |
*        +-------------------------------------------------------+
*        |           POINTER TO RIGHT OPERAND BLOCK              |
*        +-------------------------------------------------------+
*
OPTRB    EQU   8                  FLAG FOR BINARY OPERATOR
         EJECT
*
*        ARRAY ELEMENT
*        -------------
*
*        +-------------+-----------------------------------------+
*        |    FLAGS    |     POINTER TO ARRAY OPERAND BLOCK      |
*        +-------------+-----------------------------------------+
*        |                POINTER TO FIRST SUBSCRIPT BLOCK       |
*        +-------------------------------------------------------+
*
ARRAYFLG EQU   16                 FLAG FOR ARRAY ELEMENT
*
*        FUNCTION CALL
*        -------------
*
*        +-------------+-----------------------------------------+
*        |    FLAGS    |      ADDRESS OF FUNCTION BLOCK          |
*        +-------------+-----------------------------------------+
*        |              POINTER TO FIRST ARGUMENT BLOCK          |
*        +-------------------------------------------------------+
*
FUNCT    EQU   32                 FLAG FOR FUNCTION CALL
*
*        FUNCTION ARGUMENT/ ARRAY SUBSCRIPT
*        ----------------------------------
*
*        +-------------------------------------------------------+
*        |      POINTER TO FUNCTION ARG OR SUBSCRIPT BLOCK       |
*        +-------------------------------------------------------+
*        |      POINTER TO NEXT ARG/SUBSCR BLOCK (0 IF LAST)     |
*        +-------------------------------------------------------+
*
*
COMPLEX  EQU   ARRAYFLG+FUNCT+OPTRU+OPTRB   MASK TO TEST COMPLEX OPND
*
*
*        NOTE -- FOR OPERATOR DOPE VECTOR FORMAT -- SEE SCAN ROUTINE
*
*        THE FLAG OPNCN IS ALSO SET FOR CONSTANT SUBEXPRESSIONS WHICH
*        ARE DEFINED TO OCCUR AS FOLLOWS --
*
*        1)    A CONSTANT IS ITSELF A CONSTANT SUBEXPRESSION
*
*        2)    A NON-PREDICATE SPECIAL CHARACTER OPERATOR IS
*              CONSTANT IF ITS OPERANDS ARE CONSTANT
*
*        3)    VARIABLES HAVING A CONSTANT PATTERN VALUE (ARB,BAL,..)
*              ARE CONSTANTS IF THE OPTIMIZE FLAG IS ON
*
*        4)    FUNCTIONS WHICH ARE TREATED AS OPERATORS IF THE
*              OPTIMIZE FLAG IS ON ARE CONSTANT IF THEIR
*              ARGUMENTS ARE ALL CONSTANT
         EJECT
*
*        ENTRY POINT TO EXPAN
*        --------------------
*
*        (CC)                     ZERO IF CALLED DURING SCAN OF A GOTO
*                                 FIELD IN WHICH CASE A ) OR >
*                                 TERMINATES THE SCAN,
*                                 ELSE AN ERROR MESSAGE WILL BE GIVEN
*        BAL   RF,EXPAN
*        (POINTER TO OUTER BLOCK RETURNED IN R3)
*
*        REGISTER USAGE
*        --------------
*
*        (R0,R1,R2,R3)            SCRATCH
*        (R4)                     POINTER TO FREE STORAGE FOR BLOCKS
*        (R5)                     OPERATOR STACK
*        (R6)                     POINTER STACK
*
*        USE OF STACKS
*        -------------
*
*        THE FREE STACK IS USED TO BUILD ACTUAL BLOCKS
*        (R4) IS UPDATED BETWEEN CALLS TO PRESERVE ANY BLOCKS FORMED
*
*        THE OPERATOR STACK CONTAINS OPERATOR DOPE VECTOR POINTERS
*        (WHICH ALWAYS BEGIN WITH A HEX 00)
*        AND STACK LIDS -- WHICH BEGIN WITH A BYTE CONTAINING AN
*        INTEGER FROM 1-4 DEPENDING ON THE USAGE
*
*        1                        STANDARD LID ON END OF STACK
*        2                        NORMAL ( LID
*        3                        LID AFTER < OR , FOLLOWING <
*        4                        LID FOR ( OR , IN FUNCTION CALL
*
*        SIMPLE COMPARISON OF PRECEDENCES IS USED IN BUILDING THIS
*        STACK -- LOW PRECEDENCE OPERATORS DUMP HIGHER PRECEDENCE
*        OPERATORS FROM THE TOP OF THE STACK UP TO A STACK LID
*
*
*        THE POINTER STACK CONTAINS POINTERS TO OPERANDS AND
*        SUBEXPRESSIONS AS THE EXPRESSION IS BUILT UP
         EJECT
*
*        THE EXPRESSION ANALYSIS IS CONTROLED BY A FINITE STATE
*        TRANSITION TABLE WITH THE FOLLOWING STRUCTURE
*
*        ELEMENT       STATE 0,2            STATE 1
*        -------       ---------            -------
*
*        VARIABLE      SETUP VAR BLOCK      GENERATE CONCATENATION
*                      PUT PTR ON PTR STK   RESCAN -- S=>2
*                      S=>1
*
*        CONSTANT      SETUP CON BLOCK      GENERATE CONCATENATION
*                      PUT PTR ON PTR STK   RESCAN -- S=>2
*                      S=>1
*
*        UNOP          PUT OP ON OP STK     GENERATE CONCATENATION
*                      (DUMP OFF OPS)       RESCAN -- S=>2
*                      S=>2
*
*        BINOP         ERROR                PUT OP ON OP STK
*                                           S=>2
*
*        TRM : =       S2=>ERROR            DUMP 1 LEVEL OPTRS
*                      S0=>GENERATE NULL    LID=1  TERMINATE
*                          TREAT LIKE S=1   LID=2-4  ERROR
*
*        (             SET LID=2 ON OP STK  GENERATE CONCATENATION
*                      S=>0                 RESCAN -- STATE=>2
*
*        <             ERROR                GEN ARRAY BLOCK
*                                           PUT ON PTR STACK
*                                           SET LID=3(ARRAY BLK PTR)
*                                           S=>0
*
*        FUNCTION      GEN FUNC BLOCK       GENERATE CONCATENATION
*                      PUT ON PTR STACK     RESCAN -- S=>2
*                      SET LID=5(FUNC BLK)
*                      S=>0
         EJECT
*        ELEMENT       STATE 0,2            STATE 1
*        -------       ---------            -------
*
*        ,             S2=>ERROR            DUMP 1 LEVEL OPERATORS
*                      S0=>GENERATE NULL    LID=0,1  ERROR
*                          TREAT LIKE S=1   LID=3 GEN SUBSCR BLK
*                                             SET PTR IN PREVIOUS BLK
*                                             SET LID=3(SUBSCR BLK)
*                                           LID=4  GEN ARG BLOCK
*                                             SET PTR IN PREVIOUS BLK
*                                             SET LID=4(ARG BLK)
*                                           S=>0 FOR ALL OF ABOVE
*
*        )             S2=>ERROR            DUMP 1 LEVEL OPERATORS
*                      S0=>GENERATE NULL    LID=1  TERMINATE IF CC=0
*                          TREAT LIKE S=1     ELSE ERROR IF CC#0
*                                           LID=2  OK, REMOVE LID S=>1
*                                           LID=3  ERROR
*                                           LID=4  GEN ARG BLOCK
*                                             SET PTR FROM PREVIOUS BLK
*                                             REMOVE LID S=>1
*
*        >             S2=>ERROR            DUMP 1 LEVEL OPERATORS
*                      S0=>GENERATE NULL    LID=1  TERMINATE IF CC=0
*                         TREAT LIKE S=1      ELSE ERROR IF CC#0
*                                           LID=2  ERROR
*                                           LID=3  GEN LAST SUBSCR BLK
*                                             SET PTR FROM PREVIOUS BLK
*                                             REMOVE LID S=>1
*                                           LID=4  ERROR
*
*        IN THE ABOVE TABLE THE NOTATION LID=N(DATA) MEANS THAT THE
*        INDICATED DATA IS STORED IN THE LOW ORDER THREE BYTES OF THE
*        STACK LID, THE UPPER BYTE IS THE LID CODE.
*
*        DUMP 1 LEVEL OPERATORS MEANS THAT OPERATORS ARE DUMPED FROM
*        THE OPERATOR STACK (I.E. POPPED AND APPLIED), UNTIL A
*        STACK LID IS ENCOUNTERED, THE LID IS THEN REMOVED AND EXAMINED
         EJECT
*
*        MAIN ENTRY POINT
*
EXPAN    ST    RF,EXPSAV          SAVE CALL REGISTER
         MVI   EXPNUMBR+1,200     MAX ELEMENTS IN STATEMENT = 200
         MVI   STATE,0            SET INITIAL STATE OF ZERO
         LM    R4,R6,EXPINIT      INITIALIZE STACK POINTERS
         MVI   0(R5),1            SET OUTER STACK LID ON OPERATOR STACK
         LA    R5,4(R5)           COVER IT UP
*
*        LOOP BACK HERE TO ANALYZE SUCCESSIVE ELEMENTS
*
EXPANLP  STM   R4,R6,EXPSAV+4     SAVE CRITICAL REGS
         BAL   RF,SCAN            CALL SCAN ROUTINE
         LM    R4,R6,EXPSAV+4     RESTORE CRITICAL REGS
         LH    R7,EXPNUMBR        LOAD COUNT OF ITEMS
         BCT   R7,*+8             SKIP UNLESS TOO MANY ELEMENTS
         ERR   8                  *** EXPRESSION TOO COMPLEX ***
         STH   R7,EXPNUMBR        STORE AWAY COUNT
         SR    R2,R2              CLEAR R2 FOR IC
         IC    R2,SCANFL          PICK UP SYNTAX FLAG
         B     *+4-EQL(R2)        TAKE CORRECT BRANCH IN TABLE
         B     EXPTERM            EQL       =
         B     EXPTERM            GTO       :
         B     EXPTERM            TRM       STATEMENT TERMINATOR
         B     EXPLBR             LBR       LEFT BRACKET
         B     EXPRBR             RBR       RIGHT BRACKET
         B     EXPLPR             LPR       LEFT PAREN
         B     EXPRPR             RPR       RIGHT PAREN
         B     EXPCMA             CMA       ,
         B     EXPOPTR            OPR       OPERATOR
         B     EXPFUNC            FNC       FUNCTION CALL
         B     EXPVAR             VAR       VARIABLE
*                                 CON       CONSTANT
         EJECT
*
*        PROCESSING FOR CONSTANTS
*
         BAL   R7,EXPCNT          CHECK FOR CONCATENATION
         L     R0,SCANAD          PICK UP ADDRESS
         ST    R0,0(,R4)          STORE ADDRESS IN BLOCK
         MVI   0(R4),OPNCN        SET FLAG FOR CONSTANT
         B     EXPVAR1            MERGE WITH VARIABLE PROCESSING
*
*        PROCESSING FOR VARIABLES
*
EXPVAR   BAL   R7,EXPCNT          CHECK FOR CONCATENATION
         L     R1,SCANAD          LOAD ADDRESS
         ST    R1,0(,R4)          STORE ADDRESS IN BLOCK
         TM    VFLAGS(R1),VINP    IS INPUT ASSOCIATION POSSIBLE?
         BNO   *+8                SKIP IF NOT
         OI    0(R4),READV        SET FLAG IF SO
         TM    VFLAGS(R1),VOUP    IS OUTPUT ASSOCIATION POSSIBLE?
         BNO   *+8                SKIP IF NOT
         OI    0(R4),WRITEV       IF SO, SET FLAG
         OI    0(R4),OPNNM        ADD FLAG FOR VARIABLE
*
*        HERE CHECK FOR VARIABLE CONTAINING POTENTIAL CONSTANT PATTERN
*
         CLI   OPTFLAG,0          ARE WE OPTIMIZING?
         BZ    EXPVAR1            SKIP IF NOT
         CLI   VALUE(R1),PCODE    ELSE DOES VARIABLE CONTAIN A PATTERN?
         BNE   EXPVAR1            SKIP IF NOT
         OI    0(R4),OPNCN        ELSE SET FLAG FOR CONSTANT
*
*        REENTER HERE FOR CONSTANT
*
EXPVAR1  ST    R4,0(R6)           STORE BLOCK ADDRESS ON PTR STACK
         LA    R4,4(R4)           BUMP BLOCK POINTER
         LA    R6,4(R6)           BUMP PTR STACK POINTER
         MVI   STATE,1            MAKE STATE TRANSITION
         B     EXPANLP            AND GO BACK FOR NEXT ELEMENT
*
*        HERE FOR BINARY OPERATOR
*
EXPBNOP  CLI   STATE,1            CHECK STATE
         BE    EXPDUMP            SKIP TO ENTER OP IF STATE OK (S=1)
         ERR   1                  *** MISSING OPERAND ***
*
*        PROCESSING FOR OPERATOR
*
EXPOPTR  L     RE,SCANAD          PICK UP OPERATOR DV ADDRESS
         TM    1(RE),BNOP         TEST FOR BINARY OPERATOR
         BO    EXPBNOP            SKIP IF BINARY
         BAL   R7,EXPCNT          ELSE TEST FOR POSSIBLE CONCATENATION
*                                 MERGE WITH EXPDUMP IF STATE NE 1
         EJECT
*
*        SECTION TO ENTER OPERATOR ON STACK
*
*        (RE)                     POINTER TO DV OF ENTERING OPERATOR
*
EXPDUMP  MVI   STATE,2            SET NEW STATE
*
*        LOOP TO DUMP OPERATORS
*
EXPDUMPL SH    R5,=H'4'           UNCOVER TOP OPTR ON STACK
         CLI   0(R5),0            CHECK FOR STACK LID
         BE    EXPDUMP3           SKIP IF NOT
*
*        COME HERE TO PUT OPERATOR ON OPERATOR STACK
*
EXPDUMP2 ST    RE,4(,R5)          PUT ENTERING OPTR ON STACK
         LA    R5,8(R5)           BUMP STACK POINTER
         B     EXPANLP            BACK FOR NEXT ELEMENT
*
*        COME HERE IF OPERATOR STACK IS NOT EMPTY (NOT AGAINST LID)
*
EXPDUMP3 L     R2,0(R5)           DOPE VECTOR OF STACK OPERATOR
         CLC   0(1,RE),0(R2)      COMPARE PRECEDENCES
         BH    EXPDUMP2           SKIP IF ENTERING OP HIGHER
         BL    EXPDUMP4           FORCE STACK OPTR OFF IF ENTER OP LOWR
         TM    1(R2),RASS         ON EQUAL PRECEDENCE -- CHECK ASSOC
         BNZ   EXPDUMP2           RIGHT ASS => PUT ENTER OP ON STACK
*
*        COME HERE TO DUMP TOP OPERATOR ON OPERATOR STACK
*
EXPDUMP4 BAL   R7,EXPDMPO         DUMP OFF TOP OPERATOR ON STACK
         B     EXPDUMPL           BACK TO TEST NEXT STACK ENTRY
         EJECT
*
*        PROCESSING AT END OF EXPRESSION
*
EXPTERM  BAL   RF,NULCHK          SUPPLY NULL IF IN STATE 0
         ERR   1                  *** MISSING OPERAND (S=2)
*
*        COME HERE FOR NORMAL S=1 CASE (OPERATOR STRIP ALREADY DONE)
*
         CLI   0(R5),1            DO WE END UP AT SUPER LID
         BE    EXPTERM5           SKIP IF SO (ALL OK)
         ERR   2                  *** UNBALANCED () OR <> ***
*
*        MERGE HERE WHEN EXPRESSION IS TERMINATED BY EXTRA RIGHT PAREN
*
EXPTERM5 SH    R6,=H'4'           ENTRY ON PTR STACK IS RESULT
         L     R3,0(R6)           LOAD IT INTO RESULT REGISTER
*
*        COMMON EXIT POINT
*
EXPLEAVE ST    R4,EXPINIT         SAVE UPDATED BLOCK AREA POINTER
         L     RF,EXPSAV          RESTORE LINK REGISTER
         BR    RF                 AND RETURN
         EJECT
*
*        PROCESSING FOR LEFT PARENTHESIS
*
EXPLPR   BAL   R7,EXPCNT          CHECK FOR POSSIBLE CONCATENATION
         MVI   0(R5),2            SET LID=2
         LA    R5,4(R5)           BUMP OPTR STACK POINTER
         MVI   STATE,0            SET NEW STATE
         B     EXPANLP            BACK FOR NEXT ELEMENT
*
*        PROCESSING FOR LEFT BRACKET (ARRAY REFERENCE)
*
EXPLBR   CLI   STATE,1            CHECK STATE
         BE    *+8                SKIP IF OK (STATE=1)
         ERR   3                  *** ILLEGAL USE OF < ***
         SH    R6,=H'4'           PICK UP ARRAY POINTER FROM PTR STACK
         L     R0,0(R6)                     INTO R0
         ST    R4,0(R6)           STORE ARRAY BLOCK POINTER ON PTR STAK
         LA    R6,4(R6)           BUMP PTR STACK POINTER
         ST    R0,0(R4)           STORE ARRAY POINTER IN ARRAY BLOCK
         MVI   0(R4),ARRAYFLG     SET CODE FOR ARRAY BLOCK
         ST    R4,0(R5)           SET ARRAY BLOCK ADR ONTO OPTR STACK
         MVI   0(R5),3            ADD CODE FOR LID=3
         LA    R4,8(R4)           BUMP BLOCK AREA POINTER OVER ARRAY BL
         LA    R5,4(R5)           BUMP OPTR STACK POINTER
         MVI   STATE,0            SET NEW STATE
         B     EXPANLP            BACK FOR NEXT ELEMENT
*
*        PROCESSING FOR FUNCTION CALL
*
EXPFUNC  BAL   R7,EXPCNT          CHECK FOR POSSIBLE CONCATENATION
         ST    R4,0(R6)           SET ADDRESS OF FUNC BLOCK ON PTR STK
         LA    R6,4(R6)           BUMP PTR STACK POINTER
         L     R1,SCANAD          GET FUNCTION VARIABLE BLOCK ADDRESS
         ST    R1,0(,R4)          STORE ADDRESS IN FUNCTION BLOCK
         MVI   0(R4),FUNCT        SET CODE FOR FUNCTION
         STE   ZR,4(R4)           ZERO ARG POINTER IN CASE NO ARGS
         ST    R4,0(R5)           STORE FUNC ADDRESS ON OPTR STACK
         MVI   0(R5),4            SUPPLY CODE FOR TYPE 4 LID (FUNC ARG)
         LA    R5,4(R5)           BUMP PTR OVER LID
         LA    R4,8(R4)           BUMP POINTER OVER FUNCTION BLOCK
         MVI   STATE,0            SET NEW STATE
         B     EXPANLP            BACK FOR NEXT ELEMENT
         EJECT
*
*        PROCESSING FOR COMMA
*
EXPCMA   BAL   RF,NULCHK          CHECK FOR STATE=0, DO STRIP
         ERR   4                  *** ILLEGAL USE OF , *** (S=0)
         CLI   0(R5),2            IF STATE OK, TEST LID
         BNH   *-8                GIVE ERROR IF LID=1 OR 2
         SH    R6,=H'4'           UNCOVER SUBSCRIPT OR ARGUMENT POINTER
         L     R0,0(,R6)          PICK IT UP
         ST    R0,0(,R4)          PUT POINTER IN NEW ARG/SUBSCR BLOCK
         STE   ZR,4(R4)           CLEAR NEXT POINTER (IN CASE LAST)
         L     R1,0(R5)           PICK UP POINTER TO PREVIOUS BLOCK
         ST    R4,4(R1)           LINK TO CURRENT BLOCK
         IC    R0,0(,R5)          SAVE LID CODE
         ST    R4,0(R5)           STORE CURRENT BLOCK POINTER IN LID
         STC   R0,0(,R5)          SET CORRECT LID CODE
         LA    R5,4(R5)           BUMP OPTR STACK POINTER
         LA    R4,8(R4)           BUMP BLOCK POINTER
         MVI   STATE,0            SET NEW STATE
         B     EXPANLP            JUMP TO PROCESS NEXT ITEM
*
*        PROCESSING FOR RIGHT PARENTHESIS
*
EXPRPR   BAL   RF,NULCHK          CHECK FOR S=0, DO STRIP
         ERR   5                  *** ILLEGAL USE OF ) *** (S=2)
         CLI   0(R5),2            CHECK LID CODE
         BNL   EXPRPR1            SKIP IF LID = 2 OR HIGHER
*
*        HERE FOR ) OR > STRIPPING LID WITH CODE=1 (SUPER LID)
*        WE TERMINATE IF THIS IS A GOTO FIELD (CALLING CC = 0)
*        ELSE THIS IS AN EXTRA UNBALANCED ) OR > AND WE GIVE AN ERROR
*
EXPRPRM  TM    EXPSAV,X'30'       TEST CALLING CONDITION CODE
         BZ    EXPTERM5           IF CC=0, THEN TERMINATE ON EXTRA )
         ERR   2                  *** UNBALANCED () OR <> ***
*
*        HERE FOR RIGHT PAREN, LID CODE > 1
*
EXPRPR1  BE    EXPANLP            ALL SET IF STANDARD ( LID REMOVED
         CLI   0(R5),4            FURTHER CHECK ON LID CODE
         BL    EXPRPR+4           GIVE ERROR IF LID=3, ELSE MERGE
*
*        COME HERE FOR ) COMPLETING FUNCTION AND > COMPLETING ARRAY
*
EXPRPR5  SH    R6,=H'4'           GET TOP ENTRY ON PTR STACK (ARG)
         L     R0,0(R6)           PICK IT UP
         ST    R0,0(,R4)          STORE IN NEW ARG BLOCK
         STE   ZR,4(R4)           ZERO OUT LINK POINTER
         L     R1,0(R5)           LID HAS POINTER TO PREVIOUS BLOCK
         ST    R4,4(R1)           LINK TO CURRENT BLOCK
         LA    R4,8(R4)           BUMP PAST NEW ARGUMENT BLOCK
         LA    RF,EXPANLP         SET EXIT ADDRESS FOR NEXT ELEMENT
         CLI   SCANFL,RPR         WAS THAT A FUNCTION?
         BCR   NE,RF              NO, ARRAY, BACK FOR NEXT ITEM
         EJECT
*
*        HERE WE CHECK FOR A CONSTANT FUNCTION CALL
*
         CLI   OPTFLAG,0          FIRST CHECK FOR OPTIMIZATION
         BCR   Z,RF               NOT CONSTANT IF NO OPTIMIZATION
         LR    R1,R6              ELSE COPY OPERAND STACK POINTER
         SH    R1,=H'4'           UNCOVER POINTER TO FUNCTION BLOCK
         L     R2,0(,R1)          LOAD IT
         L     R3,0(,R2)          LOAD POINTER TO FUNCTION NAME BLOCK
         L     R3,VDVPTR(,R3)     LOAD POSSIBLE OPERATOR DV POINTER
         LTR   R3,R3              TEST TO SEE IF THERE IS A DV POINTER
         BCR   Z,RF               IF NOT, EXIT (NOT CONSTANT)
         TM    1(R3),PREDF        IS IT A PREDICATE OPERATOR?
         BO    EXPRPR6            JUMP IF PREDICATE FUNCTION
         L     R3,4(,R2)          LOAD POINTER TO FIRST ARGUMENT BLOCK
         LR    R1,R2              COPY PTR TO ORIGINAL FUNCTION BLK
         OI    0(R1),OPNCN        TURN ON CONSTANT FLAG IN CASE
*
*        HERE IS A LOOP TO CHECK IF THE ARGUMENTS ARE ALL CONSTANT
*
EXPARGLP LTR   R3,R3              TEST FOR ALL ARGUMENTS CHECKED
         BCR   Z,RF               IF SO, RETURN (IT IS CONSTANT)
         LM    R2,R3,0(R3)        ELSE LOAD ARG PTR, POINT TO NEXT ARG
         TM    0(R2),OPNCN        IS THI ARGUMENT CONSTANT?
         BO    EXPARGLP           LOOP BACK TO CHECK NEXT IF SO
         NI    0(R1),X'FF'-OPNCN  ELSE TURN OFF CONSTANT FLAG
         BR    RF                 AND RETURN (NOT CONSTANT)
*
*        HERE FOR PREDICATE FUNCTION (NOT CONSTANT, BUT FLAG OCCURENCE)
*
EXPRPR6  MVI   PREDFUNC,1         SIGNAL PREDICATE FUNCTION OCCURED
         BR    RF                 RETURN TO CALLER (NOT CONSTANT)
*
*        PROCESSING FOR RIGHT BRACKET
*
EXPRBR   BAL   RF,NULCHK          CHECK FOR S=0, STRIP ONE LEVEL
         ERR   6                  *** ILLEGAL USE OF > ***
         CLI   0(R5),3            IF S=1, CHECK FOR TYPE 3 LID
         BE    EXPRPR5            MERGE WITH FUNCTION END CODE IF SO
         CLI   0(R5),1            ELSE TEST FOR LID CODE = 1
         BE    EXPRPRM            MERGE WITH ) PROCESSING IF SO
         B     EXPRBR+4           ELSE GIVE ERROR
         EJECT
*
*        CIRCUIT TO DUMP ONE LEVEL OF OPERATORS (UP TO A STACK LID)
*
*        NOTE THAT (RE) MUST NOT BE USED IN THIS ROUTINE SINCE
*        IT MAY CONTAIN AN OPERATOR DOPE VECTOR ADDRESS
*
EXPSTRIP SH    R5,=H'4'           UNCOVER NEXT ENTRY
         CLI   0(R5),0            IS IT A STACK LID
         BCR   7,RF               ALL DONE IF YES
         BAL   R7,EXPDMPO         ELSE DUMP OPERATOR
         B     EXPSTRIP           AND KEEP GOING
*
*        COME HERE (BAL R7,EXPDMPO) TO DUMP ONE OPERATOR OFF STACK
*
EXPDMPO  L     R2,0(R5)           PICK UP OPERATOR DOPE VECTOR POINTER
         ST    R2,0(R4)           STORE IN FIRST WORD OF OPERATOR BLOCK
         TM    1(R2),BNOP         CHECK FOR BINARY OPERATOR
         BO    EXPDMPO2           SKIP IF BINARY
*
*        HERE TO DUMP A UNARY OPERATOR
*
         SH    R6,=H'4'           GET TOP PTR STACK ENTRY (OPERAND)
         L     R3,0(R6)           PUT IN (R3)
         ST    R3,4(,R4)          STORE OPERAND POINTER
         MVI   0(R4),OPTRU        SET UNARY OPERATOR CODE
         ST    R4,0(R6)           STORE OPTR BLOCK POINTER ON PTR STACK
         LA    R6,4(R6)           BUMP PTR STACK POINTER
         BAL   R3,UNOPCHK         JUMP TO CHECK FOR CONSTANT UNOP
         LA    R4,8(,R4)          BUMP POINTER PAST UNOP BLOCK
         BR    R7                 RETURN TO CALLER
*
*        COME HERE FOR BINARY OPERATOR TO BE DUMPED
*
EXPDMPO2 SH    R6,=H'8'           FOR BINOP UNCOVER TWO ELEMENTS ON PTR
         LM    R2,R3,0(R6)        STACK -- LEFT AND RIGHT ARGUMENTS
         STM   R2,R3,4(R4)        STORE LEFT/RIGHT ARG POINTERS
         MVI   0(R4),OPTRB        SET CODE FOR BINARY OPERATOR
         ST    R4,0(R6)           STORE BINOP BLOCK ADR ON PTR STACK
         LA    R6,4(,R6)          PUSH PTR STACK PTR
         BAL   R3,BINOPCHK        CHECK FOR CONSTANT BINOP
         LA    R4,12(R4)          BUMP POINTER OVER BINOP BLOCK
         BR    R7                 RETURN TO CALLER
         EJECT
*
*        ROUTINE TO CHECK FOR CONSTANT BINOP
*
*        A BINARY OPERATOR IS CONSTANT IN THE FOLLOWING CASES --
*
*        1)    THE OPERATOR IS $ OR . AND THE RIGHT ARGUMENT IS
*              A SIMPLE VARIABLE & THE LEFT ARG IS FLAGGED AS CONSTANT
*
*        2)    ANY OTHER OPERATOR WHERE BOTH THE LEFT AND RIGHT
*              ARGUMENTS ARE FLAGGED AS CONSTANT
*
BINOPCHK L     R1,0(,R4)          LOAD POINTER TO OPERATOR DV
         LH    R0,2(,R1)          LOAD LAST TWO BYTES OF OPTR DV
         L     R1,8(,R4)          LOAD POINTER TO RIGHT ARGUMENT
         CH    R0,DLR2DV+2        BINARY $?
         BE    BINOPCK0           SKIP IF SO
         CH    R0,DOT2DV+2        BINARY . ?
         BNE   BINOPCK1           SKIP IF NEITHER $ NOR .
*
*        HERE FOR SPECIAL $ . CASES
*
BINOPCK0 TM    0(R1),OPNNM        IS RIGHT ARG A SIMPLE VAR?
         BO    UNOPCHK            SKIP TEST OF RIGHT ARG IF SO
         BR    R3                 ELSE RESULT IS NOT CONSTANT
*
*        HERE FOR NORMAL BINOP, TEST RIGHT ARG
*
BINOPCK1 TM    0(R1),OPNCN        IS RIGHT ARGUMENT CONSTANT?
         BCR   NO,R3              RETURN IF NOT (NOT CONSTANT)
         EJECT
*
*        HERE TO CHECK FOR CONSTANT UNARY OPERATOR
*
*        A UNARY OPERATOR IS CONSTANT IF ITS ARGUMENT IS FLAGGED
*        AS CONSTANT (BINOP MERGES TO TEST LEFT ARG)
*        EXCEPT THAT PREDICATE OPERATORS ARE NEVER CONSTANT
*
*        HOWEVER, $ IS NEVER CONSTANT SINCE WE CANNOT TOLERATE THE
*        ALLOCATION OF AN ADDITIONAL 4K BLOCK DURING EVALUATION
*        OF CONSTANT EXPRESSIONS
*
*
*        A SPECIAL CASE ARISES WITH UNEVALUTED EXPRESSIONS (* OPTR)
*        IF THE ARGUMENT IS COMPLEX, THEN THE RESULT IS NEVER CONSTANT
*        SINCE THE EXPR CODE MUST BE GENERATED INLINE. HOWEVER, IF THE
*        ARGUMENT IS A SIMPLE VARIABLE. THEN THIS ROUTINE CONSTRUCTS
*        A SUITABLE VCODE BLOCK AND REPLACES THE UNOP * BLOCK WITH A
*        STANDARD CONSTANT BLOCK POINTING TO THE VCODE CONSTANT.
*
UNOPCHK  LM    R1,R2,0(R4)        LOAD DV PTR, LEFT(ONLY) OPND PTR
         LH    R0,2(,R1)          LOAD LAST 2 BYTES OF OPTR DV
         CH    R0,DLR1DV+2        IS IT UNARY $?
         BCR   E,R3               IF SO, RETURN, NOT CONSTANT
         CH    R0,AST1DV+2        CHECK FOR UNARY * OPERATOR
         BNE   UNOPCHK1           SKIP IF NOT SPECIAL * CASE
         TM    0(R2),OPNNM        SIMPLE VARIABLE AS ARGUMENT?
         BCR   NO,R3              RETURN IF NOT (NOT CONSTANT)
         MVC   1(3,R4),1(R2)      ELSE SAVE PTR TO VARIABLE BLOCK
         BAL   R2,FIND8           LOCATE AN 8 BYTE CONSTANT BLOCK
         MVC   VALUE+1(3,R1),1(R4)          STORE VAR PTR IN BLOCK
         MVI   VALUE(R1),VCODE    SET PROPER TYPE CODE
         ST    R1,0(,R4)          STORE PTR ON TOP OF * UNOP BLOCK
         MVI   0(R4),OPNCN        AND CHANGE TO NORMAL CONSTANT BLOCK
         BR    R3                 AND RETURN TO CALLER
*
*        HERE FOR NORMAL UNOP CHECK
*
UNOPCHK1 TM    1(R1),PREDF        IS IT A PREDICATE OPERATOR?
         BO    UNOPCHK2           SKIP IF PREDICATE OPERATOR
         TM    2(R1),X'70'        CHECK FOR DEFINABLE OPERATOR
         BCR   Z,R3               IF SO, CANNOT BE CONSTANT
         TM    0(R2),OPNCN        ELSE IS LEFT(ONLY) OPERAND CONSTANT?
         BCR   NO,R3              RETURN IF NOT
         OI    0(R4),OPNCN        ELSE WE PASSED TESTS, FLAG CONSTANT
         BR    R3                 RETURN TO CALLER
*
*        HERE FOR PREDICATE OPERATOR (NOT CONSTANT, BUT FLAG OCCURENCE)
*
UNOPCHK2 MVI   PREDFUNC,1         SIGNAL PREDICATE OCCURENCE
         BR    R3                 RETURN TO UNOPCHK CALLER
         EJECT
*
*        TEST FOR POSSIBLE CONCATENATION
*
EXPCNT   CLI   STATE,1            TEST STATE
         BCR   7,R7               NO CONCATENATION NEEDED IF S#1
         MVI   RESCAN,0           ELSE SET FOR RESCAN
         TM    PATFLG,2           TEST FOR PATTERN MATCH POSSIBLE
         BZ    EXPCNT2            SKIP IF NOT
         LR    R1,R5              GET OPTR STACK ADDRESS
*
*        SEARCH DOWN TO LID TO SEE IF THIS IS PATTERN MATCH
*
EXPCNT1  SH    R1,=H'4'           UNCOVER TOP ENTRY
         CLI   0(R1),1            CHECK FOR OUTER LID
         BL    EXPCNT1            KEEP GOING IF NOT AT LID
         BH    EXPCNT2            SKIP IF AT HIGHER TYPE LID
         LA    RE,PTVDV           ELSE SET FOR PATTERN BY VALUE
         MVI   PATFLG,1           RESET POSSIBLE FLAG AND SET OCCURED
         B     EXPCNT3            SKIP AND MERGE
*
*        SKIP HERE IF NOT A PATTERN MATCH
*
EXPCNT2  LA    RE,CNCDV           GET CONCATENATION OPERATOR DV
*
*        MERGE HERE TO MAKE SURE WE HAD THE BLANK FOR CONCATENATION
*
EXPCNT3  CLI   SCANCHR,C' '       WAS THERE A BLANK BEFORE THIS ELEMENT
         BE    EXPDUMP            GO PUT ON STACK IF SO, ALL OK
         ERR   7                  *** MISSING OPERATOR ***
*
*        HERE TO CHECK FOR STATE 0 (USED BY ) > , TRM)
*
*        BAL   RF,NULCHK
*        -->   ERROR RETURN IF STATE=2
*        -->   NORMAL RETURN      STATE SET TO 1
*                                 OPERATOR STRIP COMPLETED
*                                 NULL BLOCK BUILT IF WE WERE IN STATE0
*
NULCHK   CLI   STATE,1            CHECK STATE
         BCR   H,RF               ERROR RETURN IF S=2
         LA    RF,4(,RF)          ELSE FUDGE RETURN POINT FOR EXPSTRIP
         BE    EXPSTRIP           IF S=1, ALL SET, EXIT VIA STRIP ROUTN
*
*        FOR STATE 0, BUILD A NULL OPERAND BLOCK
*
         LA    R0,NULBLK          POINT TO NULL BLOCK
         ST    R0,0(,R6)          STORE PTR TO NULL ON OPERAND STACK
         LA    R6,4(,R6)          BUMP OPERAND STACK POINTER
         MVI   STATE,1            RESET STATE TO 1
         B     EXPSTRIP           EXIT VIA OPERATOR STRIP ROUTINE
         TITLE 'SPITBOLC -- CODE GENERATOR'
*
*        THIS ROUTINE IS CALLED TO GENERATE CODE -- GIVEN A STRUCTURE
*        OF AN EXPRESSION AS CONSTRUCTED BY THE EXPRESSION ANALYSIS
*        ROUTINE EXPAN WHICH CONTAINS DESCRIPTIONS OF THE DATA
*        STRUCTURES INVOLVED.
*
*        CODEGEN IS A RECURSIVE ROUTINE WHICH PROCESSES EXPRESSIONS
*        FROM THE OUTERMOST OPERATOR INWARDS, MAKING RECURSIVE CALLS
*        TO GENERATE CODE FOR THE OPERANDS.
*
*        AT EACH LEVEL OF THE EXPRESSION, EITHER THE VALUE OR THE
*        NAME OF THE ARGUMENT MAY BE REQUIRED -- THUS IN A $ B,
*        THE VALUE OF A AND THE NAME OF B ARE REQUIRED
*        CODEGEN HANDLES THE NECCESSARY TESTS FOR THESE TWO
*        POSSIBILITIES
*
*        A SPECIAL PROCEDURE IS USED TO HANDLE CONSTANT SUBEXPRESSIONS
*        (MARKED WITH THE OPNCN FLAG BY EXPAN). THE FLAG CONGEN, RESET
*        ON ENTRY, IS SET ON ENCOUNTERING A CONSTANT EXPRESSION AND
*        THE CODE MOVED TO THE APPROPRIATE AREA FOLLOWED BY A STORE
*        INTO A BLOCK IN THE DATA AREA. THE CONGEN FLAG STOPS THIS TEST
*        FROM BEING APPLIED RECURSIVELY.
*
*        CALLING SEQUENCE
*        ----------------
*        (R3)                     S ADDRESS OF FIRST AVAILABLE TEMP LOC
*        (R5)                     ADDRESS OF OUTER (TOP) ELEMENT BLOCK
*        CC ZERO                  VALUE IS REQUIRED
*        CC NONZERO               NAME IS REQUIRED
*        BAL   R4,CODEGEN         NOTE CALL IS ON R4 -- NOT RF
*        (R4,R5,R6,R7)            PRESERVED OVER CALL
*
*        REGISTER USAGE
*        --------------
*
*        R0,R1                    SCRATCH
*        R2                       PUSH DOWN POINTER FOR RECURSIVE CALLS
*        R3                       S ADDRESS OF NEXT TEMP LOC
*        R4                       REGISTER FOR INTERNAL CALLS
*        R5                       BLOCK CURRENTLY BEING WORKED ON
*        R6,R7                    SCRATCH
*
*        (R4,R5,R6,R7)            ARE SAVED AT EACH RECURSIVE CALL
*                                 AT 8(R2) ON THE STACK
*
*        THE 8 BYTES AT 0(R2) ARE AVAILABLE AS RECURSIVELY SAVED SCRTCH
*
*        THE FIRST BYTE (AT 0(R2) ) IS USED TO HOLD VARIOUS FLAGS --
*
CODBYVAL EQU   1                  FLAG FOR CODE BY VALUE
CODBYNAM EQU   2                  FLAG FOR CODE BY NAME
ARAYCODE EQU   4                  FLAG FOR ARRAY CASE
FUNCCODE EQU   8                  FLAG FOR FUNCTION CASE
CONSFLAG EQU   16                 FLAG FOR CONSTANT EXPRESSION
OPTRFUNC EQU   32                 CODE FOR OPERATOR TREATED AS FUNCTION
         EJECT
*
*        MAIN ENTRY
*
CODEGEN  L     R2,WRKSTKAD        INITIALIZE PUSH-DOWN TO WORK AREA
         NI    CONGEN,X'FF'-1     CLEAR CONSTANT EXPR FLAG
         SPM   R4                 RESTORE ENTRY CONDITION CODE
*
*        ENTRY POINT FOR INTERNAL CALL
*        (R5)                     BLOCK TO BE PROCESSED
*        CC ZERO                  VALUE REQUIRED
*        CC NONZERO               NAME REQUIRED
*        BAL   R4,CODER
*
CODER    BNZ   CODENAM            SKIP IF BY NAME
*
*        ENTRY POINT FOR ONLY VALUE REQUIRED
*
*        BAL   R4,CODEVAL
*
CODEVAL  TM    0(R5),COMPLEX      IS OPERAND SIMPLE?
         BNZ   CODE1              SKIP IF NOT
*
*        SIMPLE OPERAND BY VALUE, GENERATE ONE OF THE FOLLOWING:
*
*        LM    A1,A1+1,VAL.VAR
*
*        LA    A1,VAR             IF READ ASSOCIATION POSSIBLE
*        BAL   RETURN,$$READ
*
*        L     A1,$$NULL          FOR NULL OPERAND
*
         CE    ZR,0(,R5)          CHECK FOR ZERO ADDR (=NULL)
         BZ    CODEVALN           SKIP IF SO (NULL)
         L     R1,0(,R5)          LOAD OPERAND BLOCK ADDRESS
         CLC   1(3,R5),LASTOPN+1  OPERAND ALREADY LOADED?
         BCR   E,R4               GENERATE NO CODE IF SO, RETURN
         STE   ZR,LASTOPN         ELSE FORGET CONTENTS OF A1,A1+1
         TM    0(R5),OPNCN        IS OPERAND A CONSTANT?
         BNO   *+8                SKIP IF NOT
         ST    R1,LASTOPN         ELSE REMEMBER VALUE IS LOADED
         LH    R0,LA1SR$          LOAD LA A1,*-* IN CASE IT IS READ VAR
         TM    0(R5),READV        TEST FOR READ VARIABLE
         BO    *+12               SKIP IF SO
         LA    R1,VALUE(,R1)      POINT TO VALUE FIELD IF NOT READ ASS
         LH    R0,LMA1$           PICK UP LM A1,A1+1,*-*
         BAL   RF,CALCSAD         GET S ADDRESS
         STH   R0,0(,LC)          GENERATE LM A1,A1+1,*-* OR LA A1,*-*
         STH   R1,2(,LC)          GENERATE S ADDRESS
         LA    LC,4(,LC)          BUMP CODE POINTER
         TM    0(R5),READV        WAS IT READ VAR
         BCR   NO,R4              LEAVE IF NOT
         MVC   0(4,LC),BALRD$     GENERATE BAL RETURN,$$READ
         LA    LC,4(LC)           UPDATE CODE POINTER
         BR    R4                 LEAVE
         EJECT
*
*        HERE FOR REFERENCE TO NULL
*
CODEVALN MVC   0(4,LC),LA1NUL$    GENERATE L A1,$$NULL
         LA    LC,4(,LC)          BUMP POINTER
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1
         BR    R4                 RETURN TO CALLER
*
*        COMPLEX OPERAND BY VALUE
*
*        USED AS AN AUXILIARY ENTRY POINT WHEN CALLER KNOWS BLOCK
*        IS COMPLEX
*
*        BAL   R4,CODE1
*
CODE1    STM   R4,R7,8(R2)        SAVE REGISTERS
         LA    R2,24(R2)          BUMP STACK POINTER
         MVI   0(R2),CODBYVAL     SET CODE BY VALUE FLAG
*
*        NOW TEST FOR START OF A CONSTANT EXPRESSION
*
         CLI   CONGEN,0           ARE WE ALREADY IN A CONSTANT EXPR?
         BNZ   CODE1C             SKIP IF SO (DON'T START A NEW ONE)
         TM    0(R5),OPNCN        IS THIS EXPRESSION CONSTANT?
         BNO   CODE1C             SKIP IF NOT
*
*        HERE WE HAVE THE START OF A CONSTANT SUBEXPRESSION
*
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1
         MVI   0(R2),CONSFLAG     SET FLAG TO CATCH RETURN
         OI    CONGEN,1           SET FLAG TO INHIBIT RECURSIVE TEST
         ST    LC,CONCODAD        SAVE START OF CODE FOR EXPR
         ST    R3,CONSTAK         SAVE CURRENT TEMP STACK POINTER
         L     R3,TEMSTKBS        AND REINITIALIZE POINTER TO BOTTOM
         MVC   SOLDBASE,OLDBASE   SAVE CURRENT OLDBASE VALUE
         MVI   OLDBASE+1,0        AND FORGET CURRENT OLDBASE
*
*        MERGE HERE TO INSPECT TYPE OF EXPRESSION
*
CODE1C   L     R6,0(,R5)          LOAD FIRST WORD OF BLOCK
         TM    0(R5),OPTRU        IS IT UNARY OPERATOR?
         BO    CODEUN             SKIP IF YES
         TM    0(R5),OPTRB        IS IT BINARY OPERATOR?
         BO    CODEBN             SKIP IF YES
         TM    0(R5),FUNCT        IS IT A FUNCTION?
         BO    CODEFN             SKIP IF YES
*
*        ONLY POSSIBILITY LEFT IS ARRAY
*
         EJECT
*
*        ARRAY BY VALUE OR NAME
*
*        CODE TO BE GENERATED
*
*        IF ONLY ONE SUBSCRIPT
*        LM    A1,A1+1,SUBSCRIPTVALUE
*        LM    A2,A2+1,ARRAYVALUE
*        BAL   RETURN,$$AR1V      ($$AR1N IF BY NAME)
*
*        IF MORE THAN ONE SUBSCRIPT AND NO TEMP LOCS IN USE
*        (LOAD SUBSCRIPT VALUES ONTO STACK)
*        LA    R0,NUMSUBSCRIPTS
*        BAL   RETURN,$$ARMV      ($$ARMN IF BY NAME)
*
*        IF MORE THAN ONE SUBSCRIPT AND NTLOC (#0) TEMP LOCS IN USE
*        (LOAD SUBSCRIPT VALUES ONTO STACK)
*        LA    R0,NUMSUBSCRIPTS
*        LA    R1,8*NTLOC
*        SR    PDR,R1
*        BAL   RETURN,$$ARMV      ($$ARMN IF BY NAME)
*
CODEAR   OI    0(R2),ARAYCODE     SET FLAG FOR ARRAY
         LM    R6,R7,0(R5)        LOAD ARRAYVALPTR, SUBSCRIPT PTR
         CE    ZR,4(,R7)          TEST FOR ONLY ONE SUBSCRIPT
         BNZ   CODEFNA            JUMP IF MORE THAN ONE SUBSCRIPT
         TM    0(R6),COMPLEX+READV          TEST FOR ARRAY COMPLEX
         BNZ   CODEAR1            SKIP IF ARRAY COMPLEX
         L     R5,0(R7)           PICK UP SUBSCRIPT BLOCK POINTER
         BAL   R4,CODEVAL         AND GENERATE CODE FOR IT BY VALUE
         LH    R0,LMA2$           PICK UP LM A2,A2+1,*-*
*
*        REENTER HERE FOR CASE OF COMPLEX ARRAY VALUE
*
CODEAR0  L     R1,0(,R6)          LOAD BLOCK ADDRESS
         LA    R1,VALUE(R1)       ADJUST TO POINT TO VALUE
         BAL   RF,CALCSAD         CONVERT TO S ADDRESS
         STH   R0,0(,LC)          GENERATE LM
         STH   R1,2(LC)           GENERATE S ADDRESS
         LA    LC,4(LC)           UPDATE CODE POINTER
         B     CODEAR2A           JUMP TO GENERATE CALL
         EJECT
*
*        ARRAY VALUE IS COMPLEX
*
CODEAR1  LR    R5,R6              POINTER TO ARRAY VALUE BLOCK
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE
         L     R6,0(R7)           PICK UP SUBSCRIPT POINTER
         TM    0(R6),COMPLEX+READV          IS SUBSCRIPT SIMPLE?
         BNZ   CODEAR2            SKIP IF NOT
         MVC   0(4,LC),LRA2A1$    GENERATE LR A2,A1  LR A2+1,A1+1
         LA    LC,4(LC)           UPDATE CODE POINTER
         LH    R0,LMA1$           PICK UP LM A1,A1+1,*-*
         B     CODEAR0            MERGE BACK TO GENERATE S ADDRESS
*
*        ARRAY WITH ONE SUBSCRIPT
*        ARRAY VALUE AND SUBSCRIPT COMPLEX
*        ARRAY VALUE IS IN A1,A1+1
*
CODEAR2  LR    R5,R6              SUBSCRIPT POINTER
         SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION
         LH    R1,STMA1$          PICK UP STM A1,A1+1,
         STH   R1,0(LC)           GENERATE IT
         STH   R3,2(LC)           GENERATE TEMP LOC S ADDRESS
         LA    LC,4(LC)           UPDATE CODE POINTER
         BAL   R4,CODEVAL         GENERATE CODE FOR SUBSCRIPT
         LH    R1,LMA2$           PICK UP LM A2,A2+1,
         STH   R1,0(LC)           GENERATE (RELOAD ARRAYVAL FROM STACK)
         STH   R3,2(LC)           GENERATE STACK S ADDRESS
         LA    LC,4(LC)           UPDATE CODE POINTER
         LA    R3,8(R3)           RELEASE TEMPORARY LOCATION ON STACK
*
*        MERGE HERE TO GENERATE CALL FOR SINGLE SUBSCRIPT CASE
*
CODEAR2A TM    0(R2),CODBYVAL     TEST FOR BY VALUE
         MVC   0(4,LC),BALAV1$    PICK UP  BAL RETURN,$$AR1V
         BO    *+10               SKIP IF BY VALUE (ALL SET)
         MVC   0(4,LC),BALAN1$    ELSE GEN BAL RETURN,$$AR1N IF BY NAME
         LA    LC,4(LC)           UPDATE CODE POINTER
         B     CODEDONE           ALL DONE -- LEAVE
         EJECT
*
*        ARRAY -- MULTIPLE SUBSCRIPT CASE -- REENTRY AFTER LOADING
*        SUBSCRIPTS -- SEE CODEFNA
*
CODEAR3  LR    R5,R6              ARRAY VALUE POINTER
         LR    R6,R0              SUBSCRIPT COUNT (SAVE OVER CALL)
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE FOR ARRAYVAL
         LR    R3,R7              RESTORE OLD TEMP STACK S ADDRESS
         LH    R1,LAR0$           PICK UP LA,R0
         STH   R1,0(LC)           GENERATE IT
         STH   R6,2(LC)           GENERATE SUBSCR COUNT -- LA R0,NSUBS
         LA    LC,4(LC)           BUMP CODE POINTER PAST THE LA R0
         LCR   R0,R7              NEGATIVE OF ORIGINAL TEMP LOC S ADDR
         A     R0,TEMSTKBS        MINUS S ADDRESS FOR NO TEMPS IN USE
         BZ    CODEAR4            SKIP IF CASE OF NO TEMPS IN USE
         MVC   0(6,LC),ARM$       ELSE GENERATE THE MODEL CODE
         STH   R0,2(LC)           PLUG IN 8*NTLOC
         LA    LC,6(LC)           UPDATE CODE POINTER AND MERGE
*
*        SKIP HERE IF NO TEMPORARY LOCATIONS WERE IN USE
*
CODEAR4  TM    0(R2),CODBYVAL     TEST FOR BY VALUE
         MVC   0(4,LC),BALAV$     GENERATE BAL RETURN,$$ARMV
         BO    *+10               SKIP IF BY VALUE (ALL SET)
         MVC   0(4,LC),BALAN$     ELSE GEN BAL RETURN,$$ARMN IF BY NAME
         LA    LC,4(LC)           UPDATE CODE POINTER
         B     CODEDONE           AND RETURN
         EJECT
*
*        FUNCTION CALL
*
*
*        IF NO TEMPS IN USE BEFORE CALL
*        (LOAD ARGUMENTS ONTO TEMPORARY STACK)
*        LA    R0,NUMARGS
*        L     DB4,FUNCTIONADDRESS
*        BAL   RETURN,FCODE(,DB4)
*       (B     $$FRVN             IF CALL BY NAME)
*
*        IF NTLOC (#0) TEMPS IN USE BEFORE CALL
*        (LOAD ARGUMENTS ONTO TEMPORARY STACK)
*        LA    R0,NUMARGS
*        L     DB4,FUNCTIONADDRESS
*        LA    R1,8*NTLOC
*        SR    PDR,R1
*        BAL   RETURN,FCODE(,DB4)
*       (B     $$FRVN             IF CALL BY NAME)
*
CODEFN   BAL   RF,CODEFCHK        CHECK FOR OPERATOR (SYSTEM FUNC)
*
*        MERGE HERE FOR FUNCTION BY NAME
*
CODEFNN  L     R6,0(,R5)          LOAD PTR TO VAR BLK FOR FUNCTION
         OI    0(R2),FUNCCODE     SET FLAG FOR FUNCTION
*
*        MULTIPLE SUBSCRIPT ARRAY PROCESSING MERGES HERE
*        THE FOLLOWING SECTION IS USED TO LOAD PARAMS OR SUBSCRIPTS
*        ONTO THE STACK
*
CODEFNA  STH   R3,2(,R2)          SAVE CURRENT TEMP LOC POINTER
         LR    R7,R5              ADJUST PTR TO PICK UP FIRST ARGUMENT
*
*        LOOP TO PROCESS ONE ARGUMENT AT A TIME
*
CODEFNL  L     R7,4(R7)           MOVE TO NEXT ARGUMENT/SUBSCRIPT BLOCK
         LTR   R7,R7              ARE THERE ANY MORE?
         BZ    CODEFN2            SKIP IF NO MORE
         L     R5,0(R7)           PICK UP POINTER TO THIS ARG/SUB
         BAL   R1,CODTMPST        GENERATE STORE ON STACK
         B     CODEFNL            LOOP BACK FOR NEXT ARG/SUB
         EJECT
*
*        COME HERE WHEN ALL ARG/SUBS PROCESSED (PUT ON TEPORARY STACK)
*
CODEFN2  LH    R7,2(,R2)          RETRIEVE ORIGINAL TEMP LOC S ADDRESS
         N     R7,=X'0000FFFF'    STRIP POSSIBLE GARBAGE SIGN BITS
         LR    R0,R7              COPY IT
         SR    R0,R3              NUMBER OF BYTES USED ON TEMP STACK
         SRL   R0,3               DIVIDED BY 8 = NUMBER OF ARGS/SUBS
         TM    0(R2),FUNCCODE     TEST FOR FUNCTION CASE
         BNO   CODEAR3            SKIP IF NOT TO COMPLETE ARRAY PROC
         LR    R3,R7              RESTORE OLD TEMP LOC S ADDRESS
         LH    R1,LAR0$           PICK UP LA R0,
         STH   R1,0(LC)           GENERATE LA 0,
         STH   R0,2(LC)                         NUMARGS
         LA    LC,4(,LC)          BUMP CODE POINTER
         TM    0(R2),OPTRFUNC     OPERATOR TREATED AS FUNCTION?
         LH    R1,2(,R6)          LOAD POSS. FUNC ADDR FROM OPTR DV
         BO    CODEFN3            SKIP IF WE HAVE THE FUNC ADDRESS
         LA    R1,VFUNC(,R6)      ELSE POINT TO FUNC FLD OF VAR BLK
         MVI   OLDBASE+1,0        FORCE LOAD OF DB4 FOR FUNC IF NECC
         BAL   RF,CALCSAD         GET S ADDRESS
*
*        NOW GENERATE THE L DB4,FUNC -- (R1) HAS THE S ADDR OF FUNC ADR
*
CODEFN3  LH    R0,LDB4$           PICK UP L  DB4,
         STH   R0,0(,LC)          GENERATE L  DB4,
         STH   R1,2(,LC)          COMPLETE GENERATION OF L  DB4,FUNCADR
         MVI   OLDBASE+1,0        FORGET DB4, WE JUST CLOBBERED IT
         LA    LC,4(,LC)          BUMP CODE POINTER
         LCR   R0,R7              - ORIGINAL TEMP LOC S ADDRESS
         A     R0,TEMSTKBS        + BASE (NO TEMPS) S ADDRESS
         BZ    CODEFN4            SKIP IF ZERO (NO TEMPS IN USE)
         MVC   0(14,LC),FUNCM$    MOVE IN MODEL CODE FOR TEMPS IN USE
         STH   R0,2(LC)           PLUG IN 8*NTLOC
         LA    LC,10(,LC)         BUMP PAST ALL BUT B $$FRVN
         B     CODEFN5            MERGE WITH NO TEMPS IN USE CASE
*
*        FINISH OFF IF NO TEMPS WERE IN USE
*
CODEFN4  MVC   0(8,LC),BALFR2$    GENERATE BAL RETURN,FCODE(R2) B $$FRV
         LA    LC,4(LC)           UPDATE CODE POINTER
*
*        TEMPS/NO TEMPS CASES MERGE TO GENERATE NAME CALL IF NEEDED
*
CODEFN5  TM    0(R2),CODBYNAM     CHECK FOR CODE BY NAME
         BNO   CODEDONE           ALL DONE IF BY VALUE, DELETE B $$FRVN
         LA    LC,4(LC)           ELSE BUMP LC TO KEEP B $$FRVN IF NAME
         B     CODEDONE           AND RETURN
         EJECT
*
*        COME HERE TO TEST FOR A FUNCTION CALL WHICH REFERENCES A
*        STANDARD SYSTEM FUNCTION FOR WHICH WE CAN COMPILE OPERATOR
*        TYPE CODE IF WE ARE IN OPTIMIZING MODE. RETURNS
*        ON (RF) IF ALL THE NECCESSARY CONDITIONS ARE NOT MET.
*
CODEFCHK CLI   OPTFLAG,0          ARE WE OPTIMIZING?
         BCR   Z,RF               RETURN IF NOT
         LM    R6,R7,0(R5)        LOAD FUNCTION PTR, FIRST ARG PTR
         L     R6,VDVPTR(,R6)     LOAD POSSIBLE OPERATOR DV PTR
         LTR   R6,R6              IS THERE ONE?
         BCR   Z,RF               RETURN IF NOT
         TM    1(R6),BNOP         ELSE TEST UNARY/BINARY
         BO    CODEFNB            SKIP IF BINARY OPERATOR
*
*        COME HERE IF OPERATOR IS UNARY
*
         CE    ZR,4(,R7)          IS THERE A SECOND ARGUMENT?
         BCR   NZ,RF              IF MORE THAN ONE ARG, USE NORMAL
         L     R5,0(,R7)          ELSE LOAD POINTER TO OPERAND
         B     CODEUNF            AND MERGE WITH UNOP PROCESSING
*
*        HERE IF OPERATOR IS BINARY
*
CODEFNB  L     R1,0(,R7)          SAVE POINTER TO FIRST ARG (LEFT OPND)
         L     R7,4(,R7)          POINT TO SECOND ARGUMENT BLOCK
         LTR   R7,R7              IS THERE A SECOND ARGUMENT?
         BZ    CODEFNNN           SKIP IF NOT
         CE    ZR,4(,R7)          ELSE IS THERE A THIRD ARGUMENT?
         BCR   NZ,RF              IF > 2 ARGS, USE STANDARD CIRCUIT
         LR    R5,R1              ELSE RECALL POINTER TO LEFT OPND
         L     R7,0(,R7)          LOAD PTR FO 2ND ARG (RIGHT OPERAND)
         B     CODEBN1            MERGE WITH BINOP PROCESSING
*
*        HERE FOR BINOP WITH ONLY ONE ARGUMENT
*
CODEFNNN LR    R5,R1              RECALL POINTER TO LEFT OPERAND
         LA    R7,NULBLK          SET NULL AS RIGHT OPERAND
         B     CODEBN1            MERGE WITH BINOP PROCESSING
*
*        SUBROUTINE TO STORE VALUE ON TEMPORARY STACK, CALLED ON (R1)
*
CODTMPST ST    R1,4(,R2)          SAVE LINKAGE
         CE    ZR,0(,R5)          IS ARGUMENT NULL?
         LH    R1,MVNCD$          GET MVI *-*,NCODE IN CASE
         BE    *+12               SKIP IF ARGUMENT NULL (MVI *-*,NCODE)
         BAL   R4,CODEVAL         ELSE GENERATE CODE FOR ARGUMENT
         LH    R1,STMA1$          AND LOAD STM A1,A1+1,*-*
         STH   R1,0(,LC)          GENERATE MVI OR STM
         SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION
         STH   R3,2(,LC)          GENERATE TEMP STACK S ADDRESS
         LA    LC,4(,LC)          BUMP CODE POINTER
         L     R1,4(,R2)          LOAD RETURN LINKAGE
         BR    R1                 RETURN TO CALLER
         EJECT
*
*        ENTRY FOR CALL TO CODE BY NAME
*
CODENAM  TM    0(R5),OPNNM        IS OPERAND A SIMPLE VARIABLE?
         BNO   CODEN1             SKIP IF NOT
*
*        SIMPLE OPERAND BY NAME
*        LA    A1,ADDRESS
*        SR    A1+1,A1+1
*
         L     R1,0(,R5)          LOAD ADDRESS OF BLOCK
         BAL   RF,CALCSAD         CALCULATE S ADDRESS
         MVC   0(6,LC),LA1SR$     GENERATE LA A1,*-* SR A1+1,A1+1
         STH   R1,2(,LC)          GENERATE S ADDRESS
         LA    LC,6(,LC)          BUMP CODE POINTER
         BR    R4                 RETURN
*
*        COMPLEX OPERAND BY NAME (NOTE: CAN NEVER BE A CONSTANT EXPR)
*
CODEN1   STM   R4,R7,8(R2)        SAVE REGISTERS
         LA    R2,24(R2)          BUMP CALL STACK POINTER
         MVI   0(R2),CODBYNAM     SET CODE BY NAME FLAG
         TM    0(R5),OPTRU        TEST FOR UNARY OPERATOR
         BO    CODENUN            SKIP IF YES
         TM    0(R5),OPTRB        TEST FOR BINARY OPERATOR
         BO    CODENBN            SKIP IF YES
         TM    0(R5),ARRAYFLG     TEST FOR ARRAY
         BO    CODEAR             SKIP IF ARRAY
         TM    0(R5),FUNCT        TEST FOR FUNCTION
         BO    CODEFNN            SKIP IF FUNCTION
*
*        COME HERE FOR VALUE WHERE NAME IS REQUIRED
*        GENERATE CALL TO CLOBBER HIM AT XEQ TIME
*
CODENMER MVC   0(4,LC),BNMVL$     GENERATE BAL  RETURN,$$NMVL
         LA    LC,4(,LC)          BUMP PAST IT
         B     CODEDONE           ALL FINISHED
         EJECT
*
*        UNARY OPERATOR BY NAME
*
CODENUN  L     R6,0(R5)           POINTER TO OPERATOR DOPE VECTOR
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?
         BZ    CODEUN             SKIP IF SO
         TM    1(R6),YNAME        CALL BY NAME ALLOWED?
         BZ    CODENMER           NO CLOBBER HIM
         LA    R6,4(R6)           ELSE POINT TO NAME ENTRY & MERGE
*
*        UNARY OPERATOR BY VALUE ENTRY (UNOP BY NAME MERGES)
*        (R6) POINTS TO OPERATOR DOPE VECTOR
*
*        LM    A1,A1+1,OPERAND
*        BAL   RETURN,OPERATORROUTINE
*
CODEUN   LR    R7,R5              SAVE POINTER TO UNOP BLOCK
         L     R5,4(,R5)          LOAD OPERAND POINTER
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?
         BZ    CODENUNU           SKIP TO SPECIAL CIRCUIT IF SO
*
*        MERGE HERE FOR FUNCTION TREATED AS UNARY OPERATOR
*
*        (R6)                     POINTER TO OPERATOR DV
*        (R5)                     POINTER TO BLOCK FOR OPERAND
*
CODEUNF  TM    1(R6),SPECL        TEST FOR SPECIAL PROCESSING
         BO    4(,R6)             EXECUTE JUMP IF SPECIAL PROCESSING
*
*        COME HERE FOR NORMAL UNOP PROCESSING (ALSO FOR $$INCR,$$DECR)
*
CODESRT  TM    1(R6),RITNAM       SET CC FOR NAME OR VALUE REQUIRED
         BAL   R4,CODER           GENERATE CODE FOR OPERAND
*
*        MERGE HERE ALSO FROM BINARY OPERATOR PROCESSING
*
CODEOP   LH    R1,BALRTN$         LOAD BAL RETURN,
         STH   R1,0(,LC)          GENERATE IT
         CLI   2(R6),2            CHECK FOR SPECIAL COMPARE OP EG,GT...
         BH    CODEOP1            SKIP IF NOT
*
*        COME HERE FOR SPECIAL PREDICATE OPERATORS EQ,NE,IDENT ETC.
*
         MVC   2(4,LC),CMPSAD$    GENERATE ,$$CMPR BCR 0,0
         CLI   2(R6),1            CHECK 3 DIFFERENT CASES
         BL    CODEOP0            SKIP IF NE,EQ,GE,LE,GT,LT
         MVC   2(2,LC),IDNT$      ELSE CHANGE S ADDRESS TO $$IDNT
         BH    CODEOP0            SKIP IF IDENT,DIFFER
         MVC   2(2,LC),LCMP$      ELSE CHANGE S ADDRESS TO $$LCMP
         EJECT
*
*        COME HERE TO GENERATE BCR AFTER $$CMPR,$$LCMP OR $$IDNT CALL
*
CODEOP0  IC    R1,3(R6)           PICK UP CONDITION CODE
         SLL   R1,4               POSITION
         LA    R1,FRETURN(R1)     ADD IN FRETURN REG
         STC   R1,5(LC)           GENERATE CODE,FRETURN
         LA    LC,6(LC)           UPDATE CODE POINTER
         B     CODEOP2            MERGE
*
*        JUMP HERE FOR CASES OTHER THAN GT,NE,IDENT,LEQ ETC.
*
CODEOP1  LH    R1,2(R6)           OPERATOR ROUTINE S ADDRESS
         STH   R1,2(LC)           GENERATE IT
         LA    LC,4(LC)           UPDATE CODE POINTER
*
*        TEST FOR PREDICATE OPERATOR
*        IF SO -- GENERATE L A1,NULL
*
CODEOP2  TM    1(R6),PREDF        IS THIS A PREDICATE FUNCTION?
         BZ    CODEDONE           SKIP IF NOT
*
*        MERGE HERE FROM ? 
*
CODEOP3  MVC   0(4,LC),LA1NUL$    GENERATE L  A1,=NULL
         LA    LC,4(,LC)          BUMP CODE POINTER, MERGE TO RETURN
         B     CODEDONE           ALL DONE
*
*        SPECIAL ROUTINE FOR UNARY OPERATOR TREATED AS FUNCTION
*
CODENUNU STH   R3,2(,R2)          SAVE TEMP STACK POINTER
         OI    0(R2),OPTRFUNC+FUNCCODE      SET PROPER FLAGS
         BAL   R1,CODTMPST        GENERATE CODE TO STORE ARG ON STACK
         B     CODEFN2            MERGE WITH FUNCTION PROCESSING
         EJECT
*
*        COMMON RETURN POINT
*
CODEDONE STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1
         TM    0(R2),CONSFLAG     CHECK FOR END OF CONSTANT EXPR
         BNO   CODEDON1           SKIP IF NOT
*
*        HERE IF THIS IS THE COMPLETION OF CODE FOR A CONSTANT EXPR
*
*        GENERATE THE FOLLOWING TERMINATION CODE
*
*        (L    DB4,$$BASXX)       ALWAYS GENERATED IF ON DB4
*        STM   A1,A1+1,***        STORE RESULT IN 8 BYTE BLOCK
*        AUR   0,2                FOR GARBAGE COLLECTOR AND CODE LISTER
*
         LR    R5,R2              SAVE CODEGEN CALL STACK POINTER
         BAL   R2,FIND8           LOCATE AN 8 BYTE BLOCK
         LA    R1,VALUE(,R1)      BUMP TO POINT TO VALUE FIELD
         LR    R4,R1              SAVE POINTER TO BLOCK
         MVI   OLDBASE+1,0        MAKE SURE OF DB4 LOAD IF REQUIRED
         BAL   RF,CALCSAD         CALCULATE S ADDRESS
         STH   R1,2(,LC)          STORE S ADDRESS
         MVC   0(2,LC),STMA1$     SET STM A1,A1+1,
         MVC   4(2,LC),=X'3E02'   SET AUR 0,2 (SCNT,SINC)
         LA    R6,6(,LC)          POINT TO END OF EXPR CODE
*
*        NOW MOVE THE CODE UP TO THE CONSTANT CODE AREA
*
         L     LC,CONCODAD        POINT BACK TO START OF EXPR CODE
         LR    R2,LC              COPY CODE POINTER
         SR    R6,R2              ACTUAL LENGTH OF CODE
         L     R7,SUBEXBOT        CURRENT LOWEST BYTE IN USE
         SR    R7,R6              COMPUTE NEW VALUE
         ST    R7,SUBEXBOT        STORE UPDATED LOWEST BYTE IN USE
         LR    R0,R7              COPY CODE ADDRESS
         S     R0,SUBEXTOP        MAKE PTR RELATIVE FOR PRCODE
         ST    R0,VALUE-VALUE(,R4)          STORE PTR FOR PRCODE
         ST    LC,VALUE-VALUE+4(,R4)        SET PTR TO LM IN CASE ERROR
         MVI   VALUE-VALUE(R4),KCODE        SET PROPER TYPE CODE
         BCTR  R6,0               ADJUST TO 360 LENGTH
         LA    R0,256             GET CRANK CONSTANT
         EJECT
*
*        LOOP TO MOVE UP CONSTANT CODE IN 256 BYTE CHUNKS
*
CODEDONL CR    R6,R0              CHECK LENGTH REMAINING
         BL    CODEDONG           SKIP IF 256 BYTES LEFT OR LESS
         MVC   0(256,R7),0(R2)    ELSE MOVE 256 BYTES
         AR    R7,R0              PUSH POINTERS
         AR    R2,R0              . . . .
         SR    R6,R0              DECREMENT LENGTH REMAINING
         B     CODEDONL           LOOP BACK FOR NEXT CHUNK
*
*        HERE TO MOVE LAST CHUNK
*
CODEDONG EX    R6,CODEDONM        MOVE LAST SECTION
         LR    R1,R4              COPY POINTER TO TEMPORARY CELL
         MVC   OLDBASE,SOLDBASE   RESTORE OLDBASE FROM BEFORE EXPR
         L     R3,CONSTAK         RESTORE SAVED TEMP STACK POINTER
         LR    R2,R5              RESTORE CODGEN CALL STACK POINTER
         NI    CONGEN,X'FF'-1     TURN OFF CONGEN FLAG
         BAL   RF,CALCSAD         GET S ADDRESS OF TEMPORARY CELL
*                                 NOTE: MUST REGENERATE POSSIBLE DB4 L
         STH   R1,2(,LC)          STORE IN CODE
         MVC   0(2,LC),LMA1$      GENERATE LM A1,A1+1,
         LA    LC,4(,LC)          PUSH CODE POINTER
*
*        HERE TO POP STACK AND RETURN TO CALLER
*
CODEDON1 SH    R2,=H'24'          POP CALL STACK
         LM    R4,R7,8(R2)        RESTORE REGISTERS
         BR    R4                 AND RETURN
*
CODEDONM MVC   0(*-*,R7),0(R2)    MOVE LAST CHUNK OF CODE UP
         EJECT
*
*        UNARY OPERATORS REQUIRING SPECIAL PROCESSING
*
*
*
*        FOR ?, WE MERELY EVALUATE THE ARGUMENT BY VALUE AND THEN
*        GENERATE THE L A1,NULL AS USUAL FOR PREDICATE OPERATORS
*
CODENQ1  BAL   R4,CODEVAL         GENERATE CODE BY VALUE FOR ARGUMENT
         B     CODEOP3            MERGE TO GENERATE LOAD OF NULL
*
*        FOR NOT, THE CODE IS AS FOLLOWS --
*
*        ST    FRETURN,TEM#N      SAVE CURRENT FRETURN
*        MVI   TEM#N,ECODE        MAKE SURE IT GETS RELOCATED
*        BALR  R2,0               ESTABLISH BASE REGISTER
*        LA    FRETURN,L#NNN      POINT SO THAT FAILURE JUMPS TO END
*        (CODE FOR ARGUMENT BY VALUE)
*        L     FRETURN,TEM#N      ON SUCCESS, RELOAD FRETURN
*        BALR  RETURN,FRETURN     AND FAIL
*L#NNN   L     FRETURN,TEM#N      ON SUCCESS, JUST RELOAD FRETURN
*
CODENQ2  SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION
         MVC   0(6,LC),STFR$      GET ST FRETURN,*-* MVI *-*,ECODE
         STH   R3,2(LC)           STORE TEMP S ADDRESS IN ST
         STH   R3,6(,LC)          STORE TEMP S ADDRESS IN MVI
         LA    LC,8(,LC)          BUMP CODE POINTER
         MVC   0(4,LC),BAL2LA$    GEN BALR R2,0 LA FRETURN,*-*(R2)
         LA    R7,2(LC)           SAVE ADDRESS OF LA
         LA    LC,6(LC)           BUMP CODE POINTER
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE FOR ARGUMENT
         MVI   OLDBASE+1,0        FORGET CURRENT DB4 SETTING
         MVC   0(8,LC),LFRBR$     L FRETURN,*-* BR FRETURN L FRETURN,
         STH   R3,2(LC)           STORE TEMP SADDRESS
         STH   R3,8(LC)           WHERE NEEDED
         LA    R1,6(LC)           ADDRESS FOR LA PREVIOUSLY GENERATED
         LA    LC,10(LC)          BUMP CODE POINTER
         SR    R1,R7              CALCULATE DISPLACEMENT
         STH   R1,2(R7)           STORE DISPLACEMENT
         LA    R3,8(R3)           RELEASE TEMPORARY LOCATION
         B     CODEOP3            JUMP TO GENERATE L A1,NULL
         EJECT
*
*        FOR UNEVALUATED EXPRESSIONS WITH COMPLEX ARGUMENTS, WE
*        GENERATE THE FOLLOWING SPECIAL CODE --
*
*        BALR  R2,0
*        B     L#XXX              (USING INDEX R2 AS BASE)
*        (CODE FOR EXPR)          (TEM STACK RESET TO BASE)
*        B     $$EVLR
*L#XXX   BAL   RETURN,$$AST1
*
*        NOTE THAT THE CASE OF SIMPLE VARIABLES AS ARGUMENTS HAS
*        ALREADY BEEN DEALT WITH BY THE EXPRESSION ANALYZER (UNOPCHK)
*
*        IN SOME SITUATIONS, THE CODE FOR THE EXPRESSION MUST BE
*        GENERATED BY NAME. IN THIS EVENT, THE SPECIAL STARNAME FLAG
*        HAS BEEN SET IN THE UNOP BLOCK BY OUR CALLER.
*
*        THERE MAY BE SOME CONCERN THAT THE CODE IN THE GARBAGE
*        COLLECTOR WHICH SCANS TO FIND THE NEXT TEMPORARY REFERENCE
*        WILL BE UPSET BY TEMPORARILY RESETTING THE TEMPORARY STACK
*        POINTER. THIS IS NOT THE CASE, SINCE EXCEPT IN THE SIMPLEST
*        CASES, WHERE NO SUCH SCAN WILL OCCUR, THE ABOVE CODE WILL
*        ALWAYS BE PRECEEDED BY A STM WHICH SAVES THE PREVIOUS VALUE
*        OF (A1,A1+1) IN A TEMPORARY AND STOPS THE GCOL SCAN.
*
CODENQ4  STH   R3,2(,R2)          SAVE CURRENT TEMP STACK POINTER
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1
         L     R3,TEMSTKBS        RESET TEMP STACK POINTER TO BASE
         ST    LC,4(,R2)          SAVE CODE PTR (PTR TO BALR)
         TM    0(R7),STARNAME     SET CC FOR NAME/VALUE (R7 IS BLK PTR)
         LH    R7,OLDBASE         REMEMBER CURRENT DB4 SETTING
         MVI   OLDBASE+1,0        AND THEN FORGET IT
         MVC   0(4,LC),BLRB$      GENERATE BALR R2,0 B *-*(R2)
         LA    LC,6(,LC)          BUMP PAST IT AND DISPLACEMENT
         BAL   R4,CODER           GENERATE CODE FOR EXPRESSION
         MVC   0(4,LC),BLEVLR$    GENERATE B $$EVLR
         LA    LC,4(,LC)          BUMP PAST IT
         STH   R7,OLDBASE         RECALL PREVIOUS DB4 VALUE
         LH    R3,2(,R2)          RESTORE TEMP STACK S ADDRESS
         N     R3,=X'0000FFFF'    STRIP GARBAGE SIGN BITS
         L     R4,4(,R2)          POINT TO BALR AT START
         LR    R0,LC              COPY CURRENT CODE PTR (L#NNN)
         SR    R0,R4              CALCULATE DISPLACEMENT
         SH    R0,=H'2'           ADJUST FOR 2 BYTE BALR
         STH   R0,4(,R4)          GENERATE DISPLACEMENT
         B     CODEOP             MERGE BACK TO GENERATE BAL $$EXP1
         EJECT
*
*        FOR THE @ OPERATOR, WE MUST MAKE A TEST FOR THE SPECIAL CASE
*        OF AN EXPRESSION ARGUMENT. SEE BINARY $ . FOR FURTHER DETAILS
*
CODENQ5  LR    R1,R5              COPY OPERAND POINTER
         BAL   R4,CODEXTST        PERFORM SPECIAL TEST FOR EXPR CASE
         B     CODESRT            RETURN TO STANDARD UNOP CIRCUIT
*
*        SPECIAL PROCESSING FOR UNARY .
*
*        WE FIRST GENERATE CODE BY NAME FOR THE ARGUMENT. IF THE
*        ARGUMENT IS COMPLEX, THEN THE RESULT IS IN CORRECT FORM
*        WITH NO ADDITIONAL CODE. FOR SIMPLE VARIABLES, WE ADD:
*
*        O     A1,$$MCOD          ADD NAME CODE
*
CODENQ6  BAL   R4,CODENAM         GENERATE CODE BY NAME FOR ARG
         TM    0(R5),OPNNM        IS OPERAND A SIMPLE VARIABLE?
         BNO   CODEDONE           ALL SET IF NOT
         MVC   0(4,LC),OMCOD$     ELSE GENERATE O A1,$$MCOD
         LA    LC,4(,LC)          BUMP CODE POINTER
         B     CODEDONE           AND EXIT
         EJECT
*
*        BINARY OPERATOR BY NAME
*
CODENBN  L     R6,0(R5)           OPERATOR DOPE VECTOR POINTER
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?
         BZ    CODEBN             SKIP IF SO
         TM    1(R6),YNAME        TEST FOR CALL BY NAME ALLOWED
         BZ    CODENMER           CLOBBER HIM IF NOT
         LA    R6,4(R6)           ELSE POINT TO NAME ENTRY & MERGE
*
*        BINARY OPERATOR BY VALUE (BINOP BY NAME MERGES)
*        (R6)                     OPERATOR DOPE VECTOR POINTER
*
*        LM    A1,A1+1            LEFT ARGUMENT
*        LM    A2,A2+1            RIGHT ARGUMENT
*        BAL   RETURN,OPERATOR-ROUTINE
*
CODEBN   L     R7,8(R5)           RIGHT ARGUMENT POINTER
         L     R5,4(R5)           LEFT ARGUMENT POINTER
         TM    2(R6),X'70'        OPTR TREATED AS FUNC (DB1 BASE REG)?
         BZ    CODENBNU           SKIP TO SPECIAL ROUTINE IF SO
*
*        MERGE HERE FOR SYSTEM FUNCTION TREATED AS BINARY OP
*
*        (R6)                     POINTER TO OPERATOR DV
*        (R5)                     POINTER TO LEFT OPERAND
*        (R7)                     POINTER TO RIGHT OPERAND
*
CODEBN1  TM    1(R6),SPECL        TEST FOR SPECIAL PROCESSING
         BO    CODEBNS            SKIP IF SPECIAL PROCESSING
*
*        NORMAL BINARY OPERATOR PROCESSING
*
CODEBNC  TM    0(R7),COMPLEX+READV          TEST FOR RIGHT ARG COMPLEX
         BZ    CODEBNC1           SKIP IF DEFINITELY SIMPLE
         TM    1(R6),RITNAM       IS RIGHT ARG BY NAME?
         BO    CODEBN5            IF SO, CANNOT BE CONSTANT (SIMPLE)
         CLI   CONGEN,0           ARE WE IN MIDDLE OF CONSTANT EXPR?
         BNZ   CODEBN5            IF SO, DEFINITELY COMPLEX
         TM    0(R7),OPNCN        ELSE IS RIGHT ARGUMENT CONSTANT?
         BNO   CODEBN5            COMPLEX IF NOT, ELSE TREAT AS SIMPLE
         EJECT
*
*        COME HERE IF RIGHT ARGUMENT IS SIMPLE
*
*        IN THIS SITUATION, GENERATION OF CODE FOR THE RIGHT ARGUMENT
*        CAN BE DONE LEAVING THE RESULT DIRECTLY IN A2,A2+1 WITHOUT
*        DISTURBING A1,A1+1 SO WE CAN GENERATE CODE FOR THE LEFT ARG
*        FIRST AND THEN LOAD THE RIGHT ARGUMENT WITHOUT NEEDING
*        A TEMPORARY STORE OF THE LEFT ARGUMENT
*
*        NOTE: COMMUTATIVE OPERATORS REENTER HERE AFTER SWITCHING ARGS
*
CODEBNC1 TM    1(R6),LEFNAM       SET CC FOR LEFT ARG BY NAME OR VALUE
         BAL   R4,CODER           GENERATE CODE FOR LEFT ARG
         TM    1(R6),RITNAM       TEST FOR RIGHT ARG BY NAME OR VALUE
         BO    CODEBN3            SKIP IF RIGHT ARG BY NAME
*
*        SIMPLE RIGHT ARGUMENT BY VALUE
*
CODEBN1A LR    R5,R7              COPY POINTER TO RIGHT ARGUMENT
         STE   ZR,LASTOPN         FORGET CONTENTS OF A1,A1+1
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE
         LR    R1,LC              COPY CODE POINTER
         SH    R1,=H'4'           POINT TO LM A1,A1+1,XX OR L A1,$$NULL
         CLI   1(R1),16*A1+A1+1   IS IT LM A1,A1+1, CASE?
         MVI   1(R1),16*A2+A2+1   REPLACE BY LM A2,A2+1, IN CASE
         BE    CODEOP             DONE EXCEPT FOR BAL IF IT WAS
         MVI   1(R1),16*A2        ELSE CHG L A1,$$NULL TO L A2,$$NULL
         B     CODEOP             AND JUMP BACK TO GENERATE BAL
*
*        SIMPLE RIGHT ARGUMENT BY NAME
*
CODEBN3  TM    0(R7),OPNNM        MAKE SURE IT IS A NAME
         BNO   CODENMER           ERROR OF VALUE BY NAME IF NOT
         L     R1,0(,R7)          ELSE LOAD BLOCK ADDRESS
         BAL   RF,CALCSAD         CALCULATE S ADDRESS
         MVC   0(6,LC),LA2SR$     LA A2,*-*  SR A2+1,A2+1
         STH   R1,2(,LC)          GENERATE S ADDRESS
         LA    LC,6(,LC)          BUMP CODE POINTER
         B     CODEOP             MERGE BACK TO GENERATE BAL
*
*        COME HERE FOR A COMMUTATIVE OP (LEFT SIMPLE, RIGHT COMPLEX)
*
CODEBN1B LA    R6,4(,R6)          POINT TO DV FOR COMMUTED OP
         B     CODEBNC1           AND MERGE BACK
         EJECT
*
*        BINARY OPERATOR PROCESSING -- RIGHT ARG IS COMPLEX
*
CODEBN5  TM    0(R5),COMPLEX+READV          TEST FOR LEFT ARG COMPLEX
         BZ    CODEBN6            SKIP IF DEFINITELY SIMPLE
         TM    1(R6),LEFNAM       LEFT ARGUMENT BY NAME?
         BO    CODEBN10           IF SO, CANNOT BE CONSTANT (SIMPLE)
         CLI   CONGEN,0           ARE WE IN A CONSTANT EXPRESSION?
         BNZ   CODEBN10           DEFINITELY COMPLEX IF SO
         TM    0(R5),OPNCN        ELSE TEST FOR CONSTANT EXPR
         BNO   CODEBN10           COMPLEX IF NOT, ELSE TREAT AS SIMPLE
*
*        BINARY OPERATOR -- LEFT ARG SIMPLE -- RIGHT ARG COMPLEX
*
CODEBN6  LR    R1,R5              SWITCH ARGS AROUND
         LR    R5,R7              RIGHT ARG TO (R5)
         LR    R7,R1              LEFT ARG TO (R7)
         TM    1(R6),COMMUT       IS THIS OPERATOR COMMUTATIVE?
         BO    CODEBN1B           SKIP IF SO WITH ARGS SWITCHED
         TM    1(R6),RITNAM       SET CC FOR RIGHT ARG BY NAME/VALUE
         BAL   R4,CODER           GENERATE CODE FOR RIGHT ARGUMENT
         MVC   0(4,LC),LRA2A1$    GENERATE LR A2,A1  LR A2+1,A1+1
         LA    LC,4(LC)           BUMP CODE POINTER
         TM    1(R6),LEFNAM       TEST FOR LEFT ARG BY NAME/VALUE
         LR    R5,R7              LOAD LEFT ARG
         BAL   R4,CODER           GENERATE CODE FOR LEFT ARG
         B     CODEOP             GENERATE OPERATOR CALL
         EJECT
*
*        BINARY OPERATOR -- BOTH ARGUMENTS COMPLEX
*
CODEBN10 TM    1(R6),LEFNAM       SET CC FOR LEFT ARG BY NAME/VALUE
         BAL   R4,CODER           GENERATE CODE FOR LEFT ARG
*
*        MERGE HERE FROM SPECIAL CONCATENATION CIRCUIT
*
CODEBN11 SH    R3,=H'8'           RESERVE A TEMPORARY LOCATION
         LH    R1,STMA1$          PICK UP STM A1,A1+1, FOR TEMP STORE
         STH   R1,0(LC)           GENERATE STM A1,A1+1,
         STH   R3,2(LC)           GENERATE TEMP LOC S ADDRESS
         LA    LC,4(LC)           UPDATE CODE POINTER
         LR    R5,R7              LOAD RIGHT ARG
         TM    1(R6),RITNAM       SET CC FOR RIGHT ARG BY NAME/VALUE
         BAL   R4,CODER           GENERATE CODE FOR RIGHT ARG
*
*        NOW WE GENERATE TWO POSSIBLE SEQUENCES AS FOLLOWS:
*
*        FOR NON-COMMUTATIVE OPERATORS:
*
*        LR    A2,A1              MOVE SECOND ARG TO SECOND ACCUM
*        LR    A2+1,A1+1          .
*        LM    A1,A1+1,TEM#NN     RELOAD FIRST ARG
*
*        FOR COMMUTATIVE OPERATORS:
*
*        LM    A2,A2+1,TEM#NN     LOAD FIRST ARG TO SECOND ACCUM
*
*        FOLLOWED BY A CALL TO THE APPROPRIATE ROUTINE (CODEOP)
*
         TM    1(R6),COMMUT       IS OPERATOR COMMUTATIVE?
         BNO   CODEBN12           SKIP IF NOT
*
*        HERE FOR A COMMUTATIVE OPERATOR
*
         LA    R6,4(,R6)          POINT TO DV FOR COMMUTED OPERATOR
         LH    R1,LMA2SM$         SET TO GENERATE LM A2,A2+1
         B     CODEBN13           JUMP TO MERGE
*
*        HERE FOR NON-COMMUTATIVE OPERATOR
*
CODEBN12 MVC   0(4,LC),LRA2A1$    GENERATE LR A2,A1 LR A2+1,A1+1
         LA    LC,4(,LC)          BUMP CODE POINTER
         LH    R1,LMA1$           SET TO GENERATE LM A1,A1+1
*
*        THE TWO CASES MERGE HERE
*
CODEBN13 STH   R1,0(,LC)          GENERATE LM INSTRUCTION
         STH   R3,2(,LC)          STORE S ADDRESS OF TEMPORARY LOC
         LA    LC,4(,LC)          BUMP CODE POINTER
         LA    R3,8(,R3)          RELEASE TEMPORARY LOCATION
         B     CODEOP             JUMP TO GENERATE BAL TO SYSTEM ROUTNE
         EJECT
*
*        BINARY OPERATORS REQUIRING SPECIAL PROCESSING
*
CODEBNS  LH    R1,2(,R6)          GET LAST BYTES OF DOPE VEC FOR TEST
         CH    R1,CNCDV+2         IS THIS CASE OF CONCATENATION?
         BE    CODEBNSC           SKIP IF SO
         CH    R1,ADDDV+2         IS THIS CASE OF +
         BE    CODEBNSA           SKIP IF SO
         CH    R1,SUBDV+2         IS THIS CASE OF - ?
         BE    CODEBNSA           SKIP IF SO
         CLI   2(R6),2            CHECK FOR IDENT,DIFR
         BE    CODEBNSI           SKIP FOR THIS SPECIAL CASE
*
*        THE REMAINING POSSIBILITIES ARE $ . WHICH SHARE COMMON CODE
*
*        THE ONLY SPECIAL CASE IS WHEN THE RIGHT ARGUMENT IS AN
*        UNEVALUATED EXPRESSION -- OTHERWISE NORMAL PROCESSING OCCURS
*
*        IN THE CASE OF AN UNEVALUTED EXPRESSION. THE OPERATOR DOPE
*        VECTOR POINTER IS ADJUSTED TO POINT TO THE SPECIAL CASE DV
*        AND THE STARNAME FLAG IS SET FOR COMPLEX EXPRESSION ARGUMENTS
*
         LR    R1,R7              COPY RIGHT ARGUMENT POINTER
         BAL   R4,CODEXTST        CALL ROUTINE TO PERFORM TEST
         B     CODEBNC            MERGE WITH NORMAL PROCESSING
*
*        COMMON ROUTINE SHARED BY $ . AND @ TO DEAL WITH EXPR ARGS
*
*        (R6)                     OPERATOR DV POINTER
*        (R1)                     ARGUMENT POINTER
*        BAL   R4,CODEXTST
*
CODEXTST CLC   1(3,R1),=AL3(AST1DV)         IS OPERAND UNARY * ?
         BE    CODEXTS1           SKIP IF SO
         CLI   0(R1),OPNCN        ELSE IS ARGUMENT A CONSTANT?
         BCR   NE,R4              RETURN IF NOT (NOT EXPR ARGUMENT)
         L     RE,0(,R1)          ELSE LOAD POINTER TO CONSTANT
         CLI   VALUE(RE),VCODE    IS ARGUMENT A SIMPLE EXPR?
         BCR   NE,R4              RETURN IF NOT
         LA    R6,12(,R6)         ELSE ADJUST OPERATOR DV POINTER
         BR    R4                 AND RETURN
*
*        HERE IF ARGUMENT IS A COMPLEX EXPRESSION
*
CODEXTS1 OI    0(R1),STARNAME     SET SPECIAL FLAG FOR EXPR BY NAME
         LA    R6,12(,R6)         ADJUST OPERATOR DV POINTER
         BR    R4                 RETURN TO CALLER
         EJECT
*
*        CONCATENATION SPECIAL PROCESSING
*
*        THE ONLY SPECIAL CASE IS WHEN THE LEFT ARGUMENT IS A
*        PREDICATE EXPRESSION (SUCH AS EQ(..) ) WHICH MUST BE NULL,
*        IN THIS CASE, WE CAN SKIP THE CONCATENATION ALLTOGETHER
*
CODEBNSC CLI   OPTFLAG,0          ARE WE OPTIMIZING?
         BZ    CODEBNC            SKIP IF NOT (NORMAL PROCESSING)
         TM    0(R5),COMPLEX      ELSE IS LEFT ARGUMENT COMPLEX?
         BZ    CODEBNC            NORMAL PROCESSING IF LEFT ARG SIMPLE
*
*        NOW WE GENERATE CODE FOR THE LEFT ARGUMENT AND SEE IF THE
*        LAST ITEM GENERATED IS  L A1,$$NULL. IF SO, THEN WE
*        CAN OPTIMIZE, ELSE WE MERGE BACK INTO THE STANDARD CIRCUIT
*
         BAL   R4,CODE1           CODE FOR LEFT ARG (COMPLEX BY VALUE)
         LR    R1,LC              COPY CODE POINTER
         SH    R1,=H'4'           BACK OFF FOUR BYTES
         CLC   0(4,R1),LA1NUL$    WAS LAST INSTRUCTION L A1,$$NULL
         BNE   CODBNSC1           SKIP IF NOT
*
*        HERE IS THE CASE WE CAN OPTIMIZE
*
         LR    LC,R1              DELETE THE USELESS LOAD OF NULL
         LR    R5,R7              GET POINTER TO RIGHT ARGUMENT
         BAL   R4,CODEVAL         FETCH BY VALUE (THIS IS RESULT)
         B     CODEDONE           ALL DONE
*
*        HERE IF WE CANNOT OPTIMIZE, NOTE THAT WE ALREADY
*        GENERATED CODE FOR THE LEFT HAND SIDE
*
CODBNSC1 TM    0(R7),COMPLEX+READV          CHECK RIGHT ARGUMENT
         BZ    CODEBN1A           TAKE MERGE IF SIMPLE RIGHT ARG
         B     CODEBN11           ELSE MERGE FOR BOTH ARGS COMPLEX
         EJECT
*
*        SPECIAL PROCESSING FOR ADD AND SUBTRACT (+ AND -)
*
*
*        IF THE RIGHT ARGUMENT IS THE INTEGER ONE, SPECIAL CALLS TO
*        $$INCR AND $$DECR ARE GENERATED INSTEAD OF NORMAL CODE
*
CODEBNSA CLI   0(R7),OPNCN        IS RIGHT ARGUMENT A CONSTANT?
         BNE   CODEBNC            NORMAL PROCESSING IF NOT
         L     R1,0(,R7)          ELSE LOAD POINTER
         CLI   VALUE(R1),0        CHECK FOR INTEGER CONSTANT
         BNE   CODEBNC            NOT SPECIAL CASE IF NOT INTEGER
         L     R1,VALUE+4(,R1)    LOAD VALUE OF INTEGER CONSTANT
         BCT   R1,CODEBNC         NORMAL PROCESSING UNLESS IT IS A 1
         LA    R6,12(,R6)         POINT TO $$INCR OR $$DECR DOPE VECTOR
         B     CODESRT            AND MERGE WITH UNOP PROCESSING
*
*        SPECIAL PROCESSING FOR IDENT,DIFFER
*
*        IF THE RIGHT ARGUMENT IS NULL, THEN WE GENERATE ---
*
*        (CODE FOR LEFT ARG BY VALUE TO A1,A1+1)
*        C     A1,$$NULL
*        BALR  RETURN,0           SET RETURN FOR TRACE, &LASTNO
*        BCR   NL,FRETURN         FOR DIFFER (LT FOR IDENT)
*
CODEBNSI C     R7,=A(NULBLK)      IS RIGHT ARGUMENT NULL?
         BNE   CODEBNC            NORMAL PROCESSING IF NOT
         BAL   R4,CODEVAL         GENERATE CODE BY VALUE
         MVC   0(8,LC),CNULL$     GENERATE OUR SPECIAL CODE
         LA    LC,2(,LC)          ADJUST FOR EXTRA RR INSTRUCTION
         LA    R6,8(,R6)          POINT TO DOPE VECTOR WITH MODIFIED CC
         B     CODEOP0            MERGE TO COMPLETE THE BCR
*
*        HERE FOR BINARY OPERATOR TREATED AS FUNCTION
*
CODENBNU STH   R3,2(,R2)          SAVE TEMP STACK POINTER
         OI    0(R2),OPTRFUNC+FUNCCODE      SET PROPER FLAGS
         BAL   R1,CODTMPST        GEN CODE TO STORE LEFT ARG ON STACK
         LR    R5,R7              COPY PTR TO RIGHT OPERAND
         BAL   R1,CODTMPST        GEN CODE TO STORE RIGHT ARG ON STACK
         B     CODEFN2            MERGE WITH FUNCTION CIRCUIT
         EJECT
*
*        CALCSAD -- UTILITY ROUTINE TO CALCULATE S ADDRESSES
*
*        (R1)                     ACTUAL ADDRESS
*        BAL   RF,CALCSAD
*        (R1)                     RESULTING S ADDRESS
*
*        NOTE: THIS ROUTINE MODIFIES R1, ALL OTHER REGS ARE UNAFFECTED
*
*        IF THE ADDRESS IS IN ONE OF THE FIRST THREE 4K BLOCKS, THEN
*        A REFERENCE TO DB1,DB2 OR DB3 IS GENERATED.
*
*        FOR THE REMAINING BLOCKS, A REFERENCE USING DB4 IS GENERATED
*        CALCSAD MAKES SURE THE CORRECT VALUE IS LOADED INTO DB4,
*        THE NECESSARY LOADS ARE GENERATED FROM THE BASE TABLE.
*        THE LOCATION OLDBASE KEEPS TRACK OF THE CURRENT SETTING OF
*        DB4 TO AVOID REDUNDANT LOADS. OLDBASE GETS CLEARED WHENEVER
*        THE VALUE IN DB4 IS DESTROYED (E.G. A FUNCTION CALL).
*
CALCSAD  STM   R2,R4,CALSDSV      SAVE WORK REGS
         LA    R4,4095            MAXIMUM LEGAL DISPLACEMENT
         LA    R1,0(,R1)          STRIP UPPER BYTE OF ADDRESS
*
*        CHECK FOR REFERENCE TO FIRST BLOCK (DB1)
*
         LR    R3,R1              COPY ADDRESS
         SR    R3,DB1             CALCULATE DISPLACEMENT IN 1ST BLOCK
         CLR   R3,R4              LEGAL DISPLACEMENT?
         BH    CALCSAD2           SKIP IF NOT
         A     R3,=A(DB1*X'1000') ELSE SUPPLY DB1 AS BASE REG
         B     CALCSEX            JUMP TO EXIT
*
*        CHECK FOR REFERENCE TO SECOND BLOCK (DB2)
*
CALCSAD2 LR    R3,R1              COPY ADDRESS
         S     R3,$$BAS2          CALCULATE DISPLACEMENT IN 2ND BLOCK
         CLR   R3,R4              LEGAL DISPLACEMENT?
         BH    CALCSAD3           SKIP IF NOT
         A     R3,=A(DB2*X'1000') ELSE SUPPLY DB2 AS BASE REG
         B     CALCSEX            JUMP TO EXIT
*
*        CHECK FOR REFERENCE TO THIRD BLOCK (DB3)
*
CALCSAD3 LR    R3,R1              COPY ADDRESS
         S     R3,$$BAS3          CALCULATE DISPLACEMENT IN 3RD BLOCK
         LA    R3,0(,R3)          STRIP UPPER X'FF' BYTE
         CLR   R3,R4              LEGAL DISPLACEMENT?
         BH    CALCSAD4           SKIP IF NOT
         A     R3,=A(DB3*X'1000') ELSE SUPPLY DB3 AS BASE REG
*
*        COMMON EXIT POINT
*
CALCSEX  LR    R1,R3              PUT RESULT (S ADDRESS) IN PROPER REG
         LM    R2,R4,CALSDSV      RESTORE WORK REGS
         BR    RF                 RETURN TO CALLER
         EJECT
*
*        CALCSAD (CONTINUED)
*
*        HERE IF WE HAVE A DB4 REFERENCE
*
CALCSAD4 SR    R2,R2              INITIALIZE TO TEST $$BAS4
*
*        LOOP TO FIND CORRECT BASE REGISTER
*
CALCSADL LR    R3,R1              COPY ADDRESS
         S     R3,$$BAS4(R2)      CALCULATE DISPLACEMENT FOR NEXT BASE
         CLR   R3,R4              LEGAL DISPLACEMENT?
         LA    R2,4(,R2)          BUMP POINTER ANYWAY (HENCE FUDGE)
         BH    CALCSADL           LOOP BACK IF ILLEGAL DISPLACEMENT
*
*        HERE WHEN WE HAVE FOUND THE ENTRY
*
         A     R3,=A(DB4*X'1000') SUPPLY DB4 AS BASE REG
         CH    R2,OLDBASE         IS DB4 SET RIGHT?
         BE    CALCSEX            ALL DONE IF SO
*
*        HERE WE MUST GENERATE CODE TO LOAD DB4 WITH A NEW VALUE
*
         STH   R2,OLDBASE         REMEMBER NEW VALUE
         MVC   0(2,LC),LDB4$      GENERATE L DB4,
         AH    R2,BASES$          CALCULATE S ADDR FOR BASE TABLE REF
         STH   R2,2(,LC)          STORE IN CODE AS LOAD OPERAND
         LA    LC,4(,LC)          BUMP CODE POINTER
         B     CALCSEX            ALL DONE
         EJECT
*
*        UTILITY ROUTINE TO GENERATE CODE AT START OF STATEMENT
*
*        THE NORMAL CALL -- BAL RF AURGEN GENERATES THE FOLLOWING --
*
*        AUR   0,2
*        (BR   0)
*        (NOP  OFFSET)
*        (NOP  STMNO)
*
*        THE STRANGE BR INSTRUCTION IS GENERATED IF THE HOST MACHINE
*        HAS IMPRECISE INTERRUPTS. IT ENSURES THAT THE AUR OVERFLOW
*        FOR &STLIMIT, OVERTIME ETC. IS RECOGNIZED CORRECTLY.
*
*        THE NOP INSTRUCTIONS ARE NOT GENERATED FOR EVERY STATEMENT.
*        THE LOCATION LASTNOP CONTAINS THE ADDRESS OF THE LAST POINT
*        AT WHICH THESE NOPS WERE GENERATED. THEY ARE REGENERATED IF
*        THE CURRENT LOCATION IS MORE THAN NOPBYTES PAST THE PREVIOUS
*        LOCATION (LASTNOP).
*
*        THE FIRST OF THE TWO NOPS (NOP OFFSET) IS PRESENT ONLY FOR
*        THE CASE OF CODE COMPILED AT EXECUTION TIME (CODE,EVAL). THE
*        SECOND HALFWORD IS AN OFFSET BACK TO THE START OF THE CODE
*        BLOCK (IN HALFWORDS) FOR USE BY THE GARBAGE COLLECTOR.
*        ALL SIXTEEN BITS MAY BE USED ALLOWING UP TO 128K BYTES OFFSET
*
*        THE SECOND NOP HAS THE CURRENT STATEMENT NUMBER IN THE SECOND
*        HALFWORD AND IS USED BY THE CALCSTNO ROUTINE TO TELL WHAT
*        STATEMENT AN ERROR OCCURS IN ETC.
*
*        NOTE THAT IN THE CASE OF AN EXPRESSION, THE SECOND NOP IS
*        NOT REQUIRED, AND IS DELETED (SEE CODXENT)
*
*        THE SECOND ENTRY POINT -- BAL RF,AURGENU -- IS USED WHEN THE
*        NOP INSTRUCTIONS MUST BE GENERATED REGARDLESS OF THE VALUE
*        IN LASTNOP. THIS IS USED AT THE END OF A SEQUENCE OF CODE.
*
*        THE FOLLOWING EQUATE DEFINES THE PERIODICITY CONSTANT,
*        LOWER VALUES SPEED GARBAGE COLLECTION AND CALCSTNO, BUT
*        GENERATE ADDITIONAL CODE
*
NOPBYTES EQU   200                200 BYTES BETWEEN NOPS
         EJECT
*
*        AURGEN -- CONTINUED
*
*        ENTRY POINT FOR AURGENU CALL (GENERATE NOPS UNCONDITIONALLY)
*
AURGENU  STE   ZR,LASTNOP         CLEAR LASTNOP TO ENSURE NOP'S
*
*        NORMAL AURGEN ENTRY POINT
*
AURGEN   LH    R0,AUR$            LOAD AUR 0,2
         STH   R0,0(,LC)          GENERATE IT
         LA    LC,2(,LC)          PUSH PAST IT
*
*        NOW TEST FOR GENERATION OF BR FOR IMPRECISE INTERRUPTS
*
         TM    INTFLAG+3,1        TEST INTERRUPT TYPE FLAG
         BNO   AURGEN0            SKIP IF PRECISE
         LH    R0,BR0$            ELSE LOAD SPECIAL BR INSTRUCTION
         STH   R0,0(,LC)          GENERATE IT
         LA    LC,2(,LC)          AND BUMP PAST IT
*
*        TEST FOR GENERATION OF NOPS REQUIRED
*
AURGEN0  LR    R0,LC              COPY CURRENT CODE LOCATION
         SH    R0,=Y(NOPBYTES)    BACK OFF BY CONSTANT
         C     R0,LASTNOP         SHOULD WE GENERATE NOP'S
         BCR   NH,RF              RETURN IF NOT NEEDED YET
*
*        HERE WE SHOULD GENERATE A NEW SET OF NOP'S
*
         ST    LC,LASTNOP         REMEMBER NEWEST LOCATION
         MVC   0(6,LC),NOP$       GENERATE TWO POSSIBLE NOP'S
         TM    STAGE,$EXECUTE     EXECUTE TIME (CODE EVAL)?
         BNO   AURGEN1            SKIP IF NOT CODE,EVAL CASE
*
*        HERE WE GENERATE THE NOP OFFSET FOR CODE,EVAL
*
         LR    R0,LC              COPY CURRENT LOCATION
         S     R0,CODSVREG+4*FR   SUBTRACT STARTING LOC = OFFSET
         SRL   R0,1               CONVERT BYTE OFFSET TO HALFWORDS
         STH   R0,2(,LC)          STORE OFFSET IN NOP
         LA    LC,4(,LC)          BUMP PAST NOP
*
*        HERE WE GENERATE THE NOP WITH THE STATEMENT NUMBER
*
AURGEN1  MVC   2(2,LC),BSTMNO     SET STATEMENT NUMBER
         LA    LC,4(,LC)          BUMP CODE PTR PAST NOP
         BR    RF                 RETURN TO CALLER
         EJECT
*
*        TABLE OF GENERATED INSTRUCTIONS
*
*
*        DO NOT ALTER THE ORDER IN WHICH THESE INSTRUCTIONS APPEAR
*        SINCE, IN MANY CASES, THERE ARE GROUPS TOGETHER, USED IN
*        MORE THAN ONE WAY
*
BRTN$    BR    RETURN
STMA1$   STM   A1,A1+1,*-*
         ORG   *-2
LAR0$    LA    R0,*-*
         ORG   *-2
FUNCM$   LA    R1,*-*
         SR    PDR,R1
BALFR2$  BAL   RETURN,FCODE(,DB4)
         B     $$FRVN
BALRTN$  BAL   RETURN,*-*
         ORG   *-2
BLEVLR$  B     $$EVLR
LMA2$    EQU   *
LMA2SM$  LM    A2,A2+1,*-*
         AR    A1,A1+1
         STM   A2,A2+1,VALUE(A1)
LRA2A1$  LR    A2,A1
         LR    A2+1,A1+1
LR2$     L     R2,*-*
         ORG   *-2
MVNCD$   MVI   *-*,NCODE
         ORG   *-2
ARM$     LA    R1,*-*
         SR    PDR,R1
LRFSYS$  LR    FRETURN,SYS
BR0$     BR    0
OMCOD$   O     A1,$$MCOD
         EJECT
LA1NUL$  L     A1,$$NULL
LR1BR$   L     R1,VLABL(,A1)
         BALR  RETURN,R1
LR1BR1$  L     R1,*-*
         BALR  RETURN,R1
BAL2LA$  BALR  R2,0
         LA    FRETURN,*-*(R2)
         ORG   *-2
LDB4$    L     DB4,*-*
         ORG   *-2
LMA1$    LM    A1,A1+1,*-*
         ORG   *-2
BLRBAL$  BALR  R2,0
         BAL   FRETURN,*-*(R2)
         ORG   *-2
BLRB$    BALR  R2,0
         B     *-*(R2)
         ORG   *-2
LFRBR$   L     FRETURN,*-*
BRFRTN$  BALR  RETURN,FRETURN
LFRTN$   L     FRETURN,*-*
         ORG   *-2
STFR$    ST    FRETURN,*-*
         MVI   *-*,ECODE
         ORG   *-2
$STOP$   BAL   RETURN,$$STOP
LA1SR$   LA    A1,*-*
         SR    A1+1,A1+1
LA2SR$   LA    A2,*-*
         SR    A2+1,A2+1
AR2SA1$  AR    A1,A1+1
         STM   A2,A2+1,VALUE(A1)
LRFDB1$  LR    FRETURN,DB1
         BAL   RETURN,$$SERR
BALREFR$ BALR  RETURN,FRETURN
NOP$     NOP   0
         NOP   0
         ORG   *-2
         EJECT
CNULL$   C     A1,$$NULL
         BALR  RETURN,0
         BCR   *-*,FRETURN
LSTCD$   BALR  RETURN,0
         DS    H                  SPACE FOR AUR
         ST    RETURN,$$LAST
BGOTO$   BAL   RETURN,$$GOTO
DGOTO$   BAL   RETURN,$$DGTO
BNMVL$   BAL   RETURN,$$NMVL
BALAV$   BAL   RETURN,$$ARMV
BALAN$   BAL   RETURN,$$ARMN
BALAV1$  BAL   RETURN,$$AR1V
BALAN1$  BAL   RETURN,$$AR1N
SDOTB$   BAL   RETURN,$$DOTD
SDLRB$   BAL   RETURN,$$DLRD
BALRD$   BAL   RETURN,$$READ
CMPSAD$  DC    S($$CMPR)
         BCR   *-*,FRETURN
LCMP$    DC    S($$LCMP)
IDNT$    DC    S($$IDNT)
SPTNL$   DC    S($$PTNL)
BLPATA$  BAL   RETURN,$$PATA
LAFING$  LA    FRETURN,$$FING
BDOIO$   B     $$DOIO
BASES$   DC    S($$BAS4-4)        S ADDR OF FIRST BASE FOR CALCSAD
         TITLE 'SPITBOLC -- CODE LISTING ROUTINE'
*
*        THIS ROUTINE IS USED TO LIST GENERATED CODE -- THE CODE
*        IS ELABORATELY LISTED IN SYMBOLIC SOURCE FORM AND IN HEX
*        THIS ROUTINE IS INCLUDED ONLY IN THE STANDARD MODULES
*
         AIF   (&LMOD EQ 1).SKIPS6
*        STATEMENTS TO BE LISTED START WITH X'3D' (INSTEAD OF X'3E')
*
*        USAGE OF REGISTERS
*
*        (R4)  REG FOR CALL TO PRINT ONE STATEMENT OF CODE
*        (R5)  ABSOLUTE CODE LOCATION
*        (R6)  BUFFER POINTER
*        (R7)  USED FOR INTERNAL AND EXTERNAL CALLS
*        (RE)  PARAMETER REGISTER FOR INTERNAL CALLS
*
*        LABEL PROCESSING --
*
*        THE SETTING OF THE FAILURE RETURN REGISTER FOR STATEMENTS
*        AND FOR THE NOT OPERATOR IS REPRESENTED BY THE USE OF LABELS
*        OF THE FORM L#NNNN, WHERE NNNN IS AN INTEGER
*
*        THE LADR STACK IS USED TO HOLD LABEL LOCATIONS AND LABEL
*        NUMBERS -- USING THE OBSERVATION THAT ALL SUCH
*        REFERENCE-LABEL PAIRS ARE NESTED
*
         DROP  CB1                FIRST BASE NOT AVAILABLE
PRCODE   MVI   LINELEFT+1,1       SET FOR NEW PAGE
         STE   ZR,CEXPCNT         CLEAR COUNT OF CONSTANT EXPRS
         ZAP   LCNT,=P'0'         ZERO COUNT OF LABELS
         MVI   DUBLFLG,0          CODE LISTING IS ALWAYS SINGLE SPACED
         SP    STMNO,STMNO        ZERO STATEMENT COUNT
         MVC   BUFR,BUFR-1        CLEAR BUFFER
         MVC   BUFR(L'TTLCOD),TTLCOD        MOVE IN TITLE LINE
         BAL   R7,LISTER          LIST TITLE LINE
         MVC   BUFR,BUFR-1        CLEAR BUFFER
         BAL   R7,LISTER          PRINT A BLANK LINE
         L     R5,CODEADR         INITIALIZE ABSOLUTE CODE LOC
         L     R3,WRKSTKAD        INITIALIZE STACK OF LABELS TO GENERAT
         ST    R3,LADR            STORE IN ADDRESS CELL
         STE   ZR,0(R3)           ZERO OUT TOP CELL (NO LABELS YET)
         B     PRCODECC+4         JUMP TO FIND FIRST STATEMENT
*
*        THIS IS THE LOOP THROUGH STATEMENTS
*
PRCODEC  CR    R5,LC              ARE WE ALL DONE?
         BCR   NL,RF              RETURN IF WE ARE
         AP    STMNO,PONE         ELSE INCREMENT STATEMENT NUMBER
         CLI   0(R5),X'3D'        SHOULD WE LIST CODE FOR THIS STMNT?
         BE    PRCODECY           SKIP IF YES
         EJECT
*
*        HERE WE LOOP TO NEXT STATEMENT IF CODE IS NOT TO BE LISTED
*
PRCODECC LA    R5,2(,R5)          BUMP CODE POINTER
         CLI   0(R5),X'3E'        NORMAL START OF STATEMENT?
         BE    PRCODEC            JUMP TO PROCESS IT IF SO
         CLI   0(R5),X'3D'        NEXT STATEMENT (LIST FLAG SET)?
         BNE   PRCODECC           LOOP BACK TO SEARCH IF NOT
         B     PRCODEC            ELSE BACK TO PROCESS NEXT STATEMENT
*
*        HERE WE HAVE A STATEMENT WHICH IS TO BE LISTED
*
PRCODECY MVI   0(R5),X'3E'        RESET STANDARD AUR OPCODE
         STE   ZR,VEXOFS          CLEAR EXPR LIST CNTR AND TOTAL
         MVC   BUFR,BUFR-1        CLEAR PRINT BUFFER
         MVC   BUFR+21(28),STMNTTL          MOVE IN STATEMENT NUM...
         ED    BUFR+43(6),STMNO   EDIT STATEMENT NUMBER
         BAL   R7,LISTER          LIST STATEMENT HEADER
         MVC   BUFR,BUFR-1        CLEAR BUFFER TO BLANKS
*
*        THE FOLLOWING SECTION DOES A SERIAL SEARCH THROUGH THE
*        DATA AREA TO LOCATE A POSSIBLE LABEL FOR THIS STATEMENT
*
         LA    R1,4*HASHTBNS-4    POINT TO LAST HASH SLOT
         ST    R5,PRLOCSV         SAVE START OF STATEMENT CODE ADDRESS
*
*        LOOP THROUGH HASH SLOTS
*
PRCODLL1 LR    R2,R1              COPY CURRENT HASH SLOT OFFSET
         A     R2,HASHTBAD        POINT TO SLOT IN HASH TABLE
*
*        LOOP THROUGH VARIABLE BLOCKS ON ONE HASH CHAIN
*
PRCODLL  L     R2,VLINK(,R2)      POINT TO NEXT BLOCK ON CHAIN
         N     R2,=X'00FFFFFF'    END OF CHAIN?
         BZ    PRCODLLE           JUMP TO END OF LOOP IF END OF CHAIN
         CLC   VLABL+1(3,R2),PRLOCSV+1      DOES LABEL MATCH THIS LOC?
         BNE   PRCODLL            LOOP BACK IF NOT
*
*        HERE WE HAVE FOUND A LABEL TO BE PRINTED
*
         LA    RE,VNAME(,R2)      POINT TO NAME OF BLOCK
         LA    R6,BUFR+21         SET FOR START OF LABEL
         BAL   R7,PRCODST         PRINT STRING NAME
         LA    R0,BUFR+29         POINT TO NORMAL OPCODE POSITION
         CR    R6,R0              ARE WE BEYOND IT?
         BNL   *+6                SKIP IF SO
         LR    R6,R0              ELSE MOVE POINTER OVER TO OPCODE
         MVC   0(8,R6),EQU#       MAKE  EQU *
         BAL   R7,LISTER          LIST   LABEL  EQU  *
         B     PRCODLLP           JUMP TO PRINT CODE FOR STATEMENT
         EJECT
*
*        HERE TO MOVE TO NEXT HASH SLOT
*
PRCODLLE SH    R1,=H'4'           POINT TO NEXT HASH SLOT
         BNM   PRCODLL1           LOOP BACK IF MORE SLOTS TO GO
*
*        COME HERE AFTER DEALING WITH LABEL TO LIST THE CODE
*
PRCODLLP BAL   R4,PRCODEL         CALL ROUTINE TO LIST CODE FOR STMNT
         ST    R5,PRLOCSV         SAVE CURRENT CODE LOCATION
*
*        HERE WE LIST CODE FOR CONSTANT EXPRESSIONS REFERENCED IN THIS
*        STATEMENT. THE LIST IN THE 'VEXSTAK' CONTAINS TWO WORD ENTRIES
*        THE FIRST WORD POINTS TO THE CODE FOR THE EXPRESSION.
*        THE SECOND WORD CONTAINS THE NUMBER OF THE EXPRESSION
*
*        AFTER THE CALL TO PRCODEL, VEXOFS IS THE FINAL OFFSET IN THIS
*        LIST. VEXPTR IS USED AS A CONTROLLING COUNTER FOR THE LOOP
*
PRCODLLX LH    R1,VEXPTR          LOAD CURRENT POINTER (STARTS AT 0)
         CH    R1,VEXOFS          ALL DONE YET?
         L     R5,PRLOCSV         RELOAD CODE POINTER IN CASE YES
         BE    PRCODEC            LOOP BACK IF ALL ENTRIES PROCESSED
         LA    R0,8(,R1)          ELSE UPDATE POINTER
         STH   R0,VEXPTR          STORE INCREMENTED POINTER
         L     R5,0(LC,R1)        LOAD POINTER TO CODE
         SR    R7,R7              SET TYPE CODE = INTEGER FOR PRCODNM
         L     RE,4(LC,R1)        LOAD ID NUMBER OF CONSTANT FOR MSG
         STH   RE,VEXNUM          SAVE NUMBER OF CURRENT ITEM
         MVC   BUFR,BUFR-1        CLEAR PRINT BUFFER
         MVI   BUFR+21,C'*'       ADD * FOR COMMENT
         MVC   BUFR+27(L'CONHED),CONHED     SET 'CODE TO COMPUTE CONS.'
         LA    R6,BUFR+27+L'CONHED          POINT PAST MESSAGE, MERGE
*
*        HERE TO ADD PROPER IDENTIFICATION NUMBER
*
PRCODLLM BAL   R3,PRCODNM         PRINT INTEGER ID NUMBER
         BAL   R7,LISTER          LIST HEADER LINE
         BAL   R4,PRCODEL         LIST CODE FOR EXPRESSION
         B     PRCODLLX           LOOP BACK FOR NEXT EXPR
         EJECT
*
*        SUBROUTINE TO PRINT ONE SECTION OF CODE UP TO AN AUR
*
*        BAL   R4,PRCODEL
*        (R5)                     POINTER TO CURRENT CODE LOCATION
*
*        USED TO PRINT CODE FOR A STATEMENT OR A CONSTANT EXPRESSION
*
*        THIS IS ALSO THE LOOP FOR SUCCESSIVE INSTRUCTIONS
*
PRCODEL  MVC   BUFR,BUFR-1        CLEAR BUFFER
         ST    R5,PRWRK           SAVE CODE LOCATION
         UNPK  BUFR(6+1),PRWRK+1(3+1)       UNPACK TO PRINT IN HEX
         MVI   BUFR+6,C' '        BLANK EXTRA GARBAGE CHARACTER
         TR    BUFR(6),HEXPRT     TRANSLATE TO PRINTABLE HEX DIGITS
         UNPK  BUFR+9(4+1),0(2+1,R5)        UNPACK FIRST TWO BYTES
         MVI   BUFR+13,C' '       BLANK OUT EXTRA CHARACTER
         TR    BUFR+9(4),HEXPRT   TRANSLATE TO HEX DIGITS
         SR    RE,RE              CLEAR FOR IC
         IC    RE,1(,R5)          LOAD SECOND BYTE
         SRL   RE,4               ISOLATE REGISTER FOR LATER USE
         LA    R6,BUFR+36         INITIALIZE POINTER TO START OF VAR FL
         L     R3,LADR            GET ADDRESS OF CURRENT LABEL
         C     R5,0(R3)           SHOULD WE PRINT A LABEL AT THIS LOC?
         BNE   PRCOD1             SKIP IF NOT
         MVC   BUFR+21(6),PREDIT  ELSE GET PATTERN TO PRINT LABEL
         ED    BUFR+22(5),4(R3)   EDIT LABEL INTO THE FORM L0NNNN
         MVI   BUFR+22,C'.'       SET 2ND CHARACTER AS .
         SH    R3,=H'8'           REMOVE TOP ENTRY ON LABEL STACK
         ST    R3,LADR            STORE NEW LABEL STACK ADDRESS
*
*        JUMP HERE WHEN THERE IS NO LABEL TO PRINT
*
PRCOD1   TM    0(R5),X'C0'        TEST FOR 4 BYTE OPERATION
         BZ    PRCODRR            SKIP IF NOT
         UNPK  BUFR+14(4+1),2(2+1,R5)       UNPACK SECOND 2 BYTE GROUP
         MVI   BUFR+18,C' '       BLANK OUT EXTRA CHARACTER
         TR    BUFR+14(4),HEXPRT  TRANSLATE TO HEX DIGITS
         EJECT
*
*        WE NOW HAVE TO GENERATE THE SYMBOLIC LINE FOR A FOUR BYTE
*        INSTRUCTION -- THE POSSIBILITIES ARE LM,STM,BAL,L,LA,ST,MVI,B,
*        O,C. WE RELY ON KNOWLEDGE OF WHAT SPITBOL GENERATES,
*        IF AN INSTRUCTION IS INCOMPREHENSIBLE, NO SYMBOLIC IS LISTED
*
PRCODRX  CLC   0(2,R5),NOP$       IS THIS A NOP? (STATEMENT NUMBER)
         BE    PRCODNOP           SKIP IF SO (SPECIAL CASE)
         LA    R3,PRCRXTB         ELSE INITIALIZE OPCODE TABLE POINTER
         LA    R2,10              SET FOR 10 ENTRIES TO SEARCH
*
*        LOOP THROUGH POSSIBILITIES FOR FOUR BYTE INSTRUCS
*
PRCODRXC CLC   0(1,R3),0(R5)      IS THIS THE ONE?
         BE    PRCODX1            SKIP IF YES
         LA    R3,4(R3)           ELSE BUMP POINTER TO NEXT ENTRY
         BCT   R2,PRCODRXC        AND JUMP BACK IF MORE TO GO
*
*        EXIT POINT FOR 4 BYTE INSTRUCTION PROCESSING
*
PRCODXL  LA    R5,4(,R5)          BUMP ABSOLUTE CODE LOC
         B     PRCODRD            MERGE WITH RR END OR PROCESSING
*
*        4-BYTE INSTRUCTION TABLE
*
PRCRXTB  DC    X'98'
         DC    CL3'LM'
         DC    X'90'
         DC    CL3'STM'
         DC    X'45'
         DC    CL3'BAL'
         DC    X'58'
         DC    CL3'L'
         DC    X'41'
         DC    CL3'LA'
         DC    X'50'
         DC    CL3'ST'
         DC    X'92'
         DC    CL3'MVI'
         DC    X'47'
         DC    CL3'B'
         DC    X'59'
         DC    CL3'C'
         DC    X'56'
         DC    CL3'O'
         EJECT
*
*        COME HERE WHEN OP CODE IS LOCATED
*
PRCODX1  MVC   BUFR+30(3),1(R3)   MOVE IN MNEMONIC
         CLI   0(R5),X'92'        CHECK FOR CASE OF MVI
         BE    PRCODX4            SKIP REG PRINT IF MVI
         CLI   0(R5),X'47'        IS IT A B?
         BE    PRCODX3            SKIP REG PRINT IF BRANCH
         BAL   R7,PRCODERG        PRINT REGISTER
         MVI   0(R6),C','         MOVE IN A COMMA
         LA    R6,1(R6)           BUMP POINTER PAST ,
         TM    0(R5),X'80'        IS THIS A LM OR STM?
         BZ    PRCODX3            SKIP IF NOT
         MVC   BUFR+39(2),BUFR+36 COPY REG NAME (A1 OR A2)
         MVC   BUFR+41(3),PONE#   APPEND +1,
         LA    R6,BUFR+44         SET NEW POINTER LOCATION
*
*        SKIP HERE IF NOT LM OR STM
*
PRCODX3  TM    1(R5),R2           CHECK FOR INDEX REGISTER R2
         BNO   PRCODX4            SKIP IF NOT
         TM    1(R5),X'0F'-R2     FURTHER CHECK FOR R2 XR
         BNZ   PRCODX4            SKIP IF NOT R2
*
*        THIS IS THE CASE OF THE LA FRETURN,... OR THE BAL FRETURN,...
*        (USING BASE REGISTER R2) AT THE BEGINNING OF A STATEMENT
*        THE SYMBOLIC LISTING FOR THIS USES LABELS OF THE FORM L.NNNN
*        THE LADR STACK HOLDS THE LABEL ADDRESSES TO BE PRINTED
*
         LR    R0,R5              COPY CURRENT CODE LOC
         AH    R0,2(R5)           ADD DISPLACEMENT TO GET LABEL ADDRESS
         AP    LCNT,PONE          BUMP LABEL COUNT
         L     R3,LADR            GET LABEL STACK ADDRESS
         LA    R3,8(R3)           MAKE ROOM FOR NEW ENTRY
         ST    R3,LADR            STORE NEW LABEL STACK POINTER
         ST    R0,0(R3)           STORE LABEL ADDRESS
         MVC   4(3,R3),LCNT       STORE LABEL NUMBER
         MVC   0(6,R6),PREDIT     MOVE IN PATTERN
         ED    1(5,R6),LCNT       ADD L/NNNN TO CURRENT LINE
         MVI   1(R6),C'.'         CHANGE 2ND CHAR TO .
         B     PRCODXL            LEAVE
*
*        CONTINUATION OF 4-BYTE INSTRUCTION SYMBOLIC FIELD PROCESSING
*
PRCODX4  MVC   PRWRK(1),2(R5)     PICK UP BASE REGISTER
         NI    PRWRK,X'F0'        ISOLATE BASE REGISTER
         CLI   PRWRK,16*SYS       CHECK FOR REF TO SYS REG
         BNE   PRCODX5            SKIP IF NOT SYS REF
         EJECT
*
*        THIS SECTION IS USED TO PRINT THE NAME OF A SPECIAL FIELD
*        IT IS USED FOR REFERENCES TO SYSTEM ROUTINES ON THE SYS
*        BASE REGISTER. OR REFERENCE TO SPECIAL FIELD IN THE USER AREA
*        SUCH AS $$LAST AND THE LOCATIONS OF ADDRESSES FOR OPERATORS
*        TREATED AS FUNCTIONS (E.G. $$QUS2 -- BINARY ?)
*
PRCODX4J LA    R2,SYSUBNMS        INITIALIZE TABLE POINTER
         LA    R3,(ENDSSBNM-SYSUBNMS)/6     SET NUMBER OF ENTRIES IN TB
         MVC   0(2,R6),$$BAS#     SET $$ IN PLACE
*
*        LOOP TO SEARCH THROUGH NAMES
*
PRCODX4L CLC   2(2,R5),0(R2)      IS THIS THE ONE?
         BE    PRCODX4E           SKIP IF YES
         LA    R2,6(R2)           ELSE STEP TO NEXT TABLE LOCATION
         BCT   R3,PRCODX4L        BACK FOR NEXT ENTRY
*
*        IF WE FALL THROUGH, WE END UP USING THE LAST DUMMY ENTRY ????
*        WHICH INDICATES THAT SOMETHING FUNNY HAS BEEN FOUND
*
*
*        COME HERE WHEN NORMAL ENTRY IS FOUND
*
PRCODX4E MVC   2(4,R6),2(R2)      MOVE IN ROUTINE NAME
         B     PRCODXL            ALL DONE WITH THIS LINE
*
*        TABLE OF SYSTEM FUNCTION NAMES AND LOCATIONS
*
SYSUBNMS EQU   *
         NAME  CNC2,DLR2,DL1N,DL1V,DOT2,DVD2,EXP2,FING,IDNT
         NAME  ADD1,ADD2,ANYP,ARMN,ARMV,AR1N,AR1V,AST1,ATSP,BRKP,CMPR
         NAME  MLT2,NTNP,ORP2,PATA,POSP,PTN2,PTV2,READ
         NAME  EXC1,PCT1,SLS1,PND1,BAR1,NOT2,QUS2,PCT2,PND2,ATS2,AMP2
         NAME  RPSP,RTBP,SPNP,SUB1,SUB2,TABP,STOP,SERR,FRVN
         NAME  LENP,DLRD,DOTD,EVLR,INTG,ASSN,RASN,BRKX
         NAME  KGET,KPUT,INCR,DECR,PTNL,LCMP
         NAME  NULL,LAST,GOTO,NMVL,DGTO,ATSD,MCOD
ENDSSBNM EQU   *
         DC    C'??????'          DUMMY ENTRY FOR USE IF NOT FOUND
         EJECT
*
*        CHECK FOR AND DEAL WITH CASE OF DATA REFERENCE
*
PRCODX5  LM    R1,R2,$$BAS2       LOAD $$BAS2,3 VALUES TO (R2,R3)
         CLI   PRWRK,16*DB2       DB2 REFERENCE?
         BE    PRCODX5C           SKIP IF SO WITH R1 SET TO BASE
         LR    R1,R2              ELSE SET $$BAS3 IN PLACE
         CLI   PRWRK,16*DB3       TEST FOR DB3 REFERENCE
         BE    PRCODX5C           SKIP IF SO WITH BASE SET IN (R1)
         CLI   PRWRK,16*DB1       CHECK FOR DB1 REFERENCE
         BE    PRCODX5A           SKIP IF DB1 REFERENCE
         CLI   PRWRK,16*DB4       CHECK FOR DB4 REFERENCE
         BNE   PRCODX9            JUMP IF NOT DB1-DB4 REFERENCE
*
*        REFERENCE TO DB4 COMES HERE
*
         L     R1,CODBASE         LOAD PREVIOUSLY SET DB4 VALUE IN CASE
         CLC   0(4,R5),BALFR2$    SPECIAL BAL RETURN,FCODE(,DB4) CASE?
         BNE   PRCODX5C           IF NOT, SKIP WITH R1 SET TO BASE
         MVC   0(11,R6),FCODE#    IF SO, SET 'FCODE(,DB4)'
         LA    R6,11(,R6)         BUMP PAST IT
         B     PRCODXL            ALL DONE WITH THIS INSTRUCTION
*
*        HERE FOR A DB1 REFERENCE
*
PRCODX5A LR    R1,DREG            COPY $$BAS1 ADDRESS
         CLC   2(2,R5),S$$BAS32   CHECK FOR $$BASXX REFERENCE
         BH    PRCODX5B           SKIP IF NOT
         LH    RE,2(,R5)          LOAD S ADDRESS
         SH    RE,S$$BAS1M        SUBTRACT TO GET OFFSET INTO TABLE
         L     R0,$$BAS1-4(RE)    LOAD ENTRY FROM BASE TABLE
         ST    R0,CODBASE         SAVE FOR LATER REFERENCES
         SRL   RE,2               DIVIDE BY 4 TO GET BASE NUMBER
         SR    R7,R7              SET INTEGER CODE FOR PRCODNM
         MVC   0(5,R6),$$BAS#     SET '$$BAS'
         LA    R6,5(,R6)          BUMP PAST IT
         BAL   R3,PRCODNM         PRINT BASE NUMBER
         B     PRCODXL            DONE WITH INSTRUCTION
*
*        HERE FOR DB1 REFERENCE NOT $$BAS TABLE REFERENCE
*
PRCODX5B CLC   2(2,R5),S$$USER    SPECIAL REFERENCE? ($$LAST OR OPTR)
         BH    PRCODX5C           SKIP IF NOT WITH R1=$$BAS1 VALUE
         B     PRCODX4J           IF SPECIAL FIELD, MERGE TO PRINT NAME
*
*        S CONSTANTS FOR ABOVE CHECKS, SINCE NO S LITERALS (UGH)
*
S$$BAS32 DC    S($$BAS32)         LAST REF FOR $$BASXX REFERENCE
S$$BAS1M DC    S($$BAS1-4)        BASE S ADDRESS FOR BASE REG TABLE
S$$USER  DC    S(DATABGN-VALUE-1) END OF SPECIAL VALUES IN DATA AREA
         EJECT
*
*        HERE FOR REF TO VARIABLE OR CONSTANT, (R1) = BASE VALUE
*
PRCODX5C LH    R0,2(,R5)          LOAD S ADDRESS
         N     R0,=X'00000FFF'    ISOLATE DISPLACEMENT
         AR    R1,R0              ADD DISPLACEMENT TO BASE
         CLI   0(R5),X'41'        IS THIS A LA (ACTUAL BLOCK REF)
         LA    RE,VNAME(,R1)      POINT TO NAME POINTER IN CASE
         BE    PRCODX6            SKIP IF IT IS AN LA
         MVI   0(R6),C'='         SET = IN CASE THIS IS A LITERAL
         TM    0(R5),X'80'        ELSE IS IT LM OR STM?
         BZ    PRCODX7            SKIP IF NOT
         CLI   VALUE-VALUE(R1),NCODE        IS OPERAND NULL?
         BE    PRCODX5M           SKIP IF SO (MUST BE VARIABLE BLOCK)
         CLI   VALUE-VALUE(R1),PCODE        IS OPERAND A PATTERN?
         BE    PRCODX5M           SKIP IF SO (MUST BE VARIABLE)
*
*        HERE FOR LITERAL, TEST FOR NUMERIC
*
         L     R7,VALUE-VALUE(,R1)          LOAD FIRST WORD OF VALUE
         LTR   R7,R7              TEST TYPES
         BP    PRCODX5F           SKIP IF NON-NUMERIC
         LA    R6,1(,R6)          ELSE BUMP PAST EQUALS SIGN
         L     RE,VALUE-VALUE+4(,R1)        LOAD 2ND WORD OF CONSTANT
         BAL   R3,PRCODNM         PRINT VALUE OF LITERAL
         B     PRCODXL            ALL DONE
*
*        NEXT POSSIBILITY IS A STRING LITERAL
*
PRCODX5F CLI   VALUE-VALUE(R1),SCODE        IS IT A STRING?
         BNE   PRCODX5G           SKIP IF NOT
         MVI   1(R6),C''''        SET ' MARK
         LA    R6,2(R6)           BUMP POINTER PAST ='
         LR    RE,R1              POINT TO VALUE
         BAL   R7,PRCODST         AND PRINT STRING
         MVI   0(R6),C''''        ADD A TERMINAL '
         B     PRCODXL            LEAVE
*
*        NEXT POSSIBILITY IS A SIMPLE VARIABLE AS AN EXPRESSION
*
PRCODX5G CLI   VALUE-VALUE(R1),VCODE        IS IT *(VARIABLE) ?
         BNE   PRCODX5H           SKIP IF NOT
         LA    RE,VNAME(,R7)      POINT TO NAME
         MVI   1(R6),C'*'         MOVE A * INTO PLACE
         LA    R6,2(,R6)          BUMP PAST =*
         BAL   R7,PRCODST         PRINT THE NAME
         B     PRCODXL            AND LEAVE
         EJECT
*
*        LAST POSSIBILITY IS REFERENCE TO A CONSTANT EXPRESSION
*
PRCODX5H CLI   VALUE-VALUE(R1),KCODE        TEST FOR CONSTANT EXPR
         BNE   PRCODXL            IF NOT, MUST BE GARBAGE, LEAVE
         MVC   0(5,R6),CONS##     SET 'CONS#'
         LA    R6,5(,R6)          POINT PAST IT
         L     R1,VALUE-VALUE(,R1)          LOAD RELATIVE CODE PTR
         A     R1,SUBEXTOP        MAKE CODE PTR ABSOLUTE
         LH    RE,VEXNUM          LOAD EXPR NUMBER IN CASE STM INSTRUC
         CLI   0(R5),X'98'        IS THIS AN LM INSTRUCTION?
         BNE   PRCODX5K           SKIP IF NOT (STM, RE SET OK)
         L     RE,CEXPCNT         ELSE LOAD COUNTER OF EXPR'S
         LA    RE,1(,RE)          INCREMENT COUNTER
         ST    RE,CEXPCNT         STORE INCREMENTED COUNTER
         LH    R3,VEXOFS          LOAD CURRENT OFFSET INTO VEXSTAK
         LA    R0,8(,R3)          INCREMENT OFFSET
         STH   R0,VEXOFS          STORE INCREMENTED POINTER
         ST    R1,0(LC,R3)        STORE POINTER TO CODE
         ST    RE,4(LC,R3)        SAVE IDENTIFICATION NUJBER
*
*        MERGE HERE TO PRINT EXPRESSION NUMBER (NUMBER IS IN (RE) )
*
PRCODX5K SR    R7,R7              SET TYPE CODE = 0 = ICODE = INTEGER
         BAL   R3,PRCODNM         PRINT NUMBER
         B     PRCODXL            DONE WITH THIS INSTRUCTION
*
*        COME HERE ON DATA REFERENCE BY VALUE IN VARIABLE BLOCK
*        FOR THIS WE GENERATE A REF TO VAL.VARIABLENAME
*
PRCODX5M MVC   0(4,R6),VAL#       MOVE IN VAL.
         LA    RE,VNAME-VALUE(,R1)          POINT TO NAME
         EJECT
*
*        FNC. AND LBL. CASES MERGE HERE
*
PRCODX5N LA    R6,4(R6)           BUM POINTER PAST VAR. (OR FNC. LBL.)
*
*        LA CASE MERGES HERE
*
PRCODX6  BAL   R7,PRCODST         PRINT VARIABLE NAME
         B     PRCODX11           AND JUMP TO TEST FOR POSSIBLE MVI
*
*        IF A REF TO THE DATA AREA IS NOT A LA,LM OR STM IT MUST BE
*        L     R1,LBL.VARNAME     FOR A GOTO
*  OR    L     DB4,FNC.VARNAME    FOR A FUNCTION CALL
*  OR    L     FRETURN,LBL.VARNAME
*
PRCODX7  CLI   0(R5),X'58'        DO WE HAVE A LOAD?
         BNE   PRCODXL            LEAVE IF NOT (???)
         SH    R1,=H'32'          REDUCE R1 TO GET + DISP IN FOLLOWING
         CLI   1(R5),16*FRETURN   TEST FOR L FRETURN, CASE
         BE    PRCODX8            SKIP ON THIS CASE TO GENERATE LBL.
         CLI   1(R5),16*R1        TEST FOR L  R1,  CASE
         BE    PRCODX8            JUMP ON THIS CASE OF LBL.
         LA    RE,32+VNAME-VFUNC(,R1)       ELSE IS FUNC, POINT TO NAME
         MVC   0(4,R6),FNC#       PUT IN FNC.
         B     PRCODX5N           AND MERGE
*
*        COME HERE FOR REFERENCE TO LABEL FIELD
*
PRCODX8  LA    RE,32+VNAME-VLABL(,R1)       POINT TO NAME FOR LABEL
         MVC   0(4,R6),LBL#       PUT IN LBL.
         B     PRCODX5N           AND MERGE
*
*        THIS SECTION CHECKS FOR AND DEALS WITH REFERENCES TO PDR
*        (TEMPORARY STACK LOCATION REFERENCES WITH THE EXCEPTION OF
*        THE LA USED IN ARRAY AND FUNCTION CALLS)
*        THE FIELD PRINTED IS TEM.NN WHERE NN IS THE NUMBER OF THE
*        TEMPORARY
*
PRCODX9  CLI   PRWRK,16*PDR       IS BASE REG PDR?
         BNE   PRCODX12           SKIP IF NOT
         CLI   0(R5),X'41'        IS THIS THE LA CASE
         BE    PRCODX12           SKIP TO DEFAULT CASE IF YES
         LH    R1,2(R5)           PICK UP TEM STACK S ADDRESS
         N     R1,=A(X'FFFF')     AND OUT EXTENDED SIGN BIT
         S     R1,TEMSTKBS        SUBTRACT BASE ADDRESS
         LCR   RE,R1              GET RIGHT SIGN
         SRA   RE,3               DIVIDE TO GET TEMP NUMBER
         MVC   0(4,R6),TEM#       MOVE IN TEM#
         LA    R6,4(R6)           BUMP POINTER PAST TEM.
         SR    R7,R7              INDICATE INTEGER TYPE
         BAL   R3,PRCODNM         PRINT TEMP NUM
         B     PRCODX11           ALL       DONE
         EJECT
*
*        IF WE GET HERE, USE THE DEFAULT DISPLACEMENT(,BASE) FORMAT
*
PRCODX12 LH    RE,2(,R5)          GET BASE-DISPLACEMENT
         N     RE,=X'00000FFF'    MASK OUT BASE
         SR    R7,R7              INDICATE INTEGER TYPE
         BAL   R3,PRCODNM         PRINT DISPLACEMENT
         SR    RE,RE              CLEAR FOR IC
         IC    RE,2(,R5)          PICK UP BASE REG
         SRA   RE,4               ISOLATE BASE REG
         BZ    PRCODXL            ALL DONE IF ZERO BASE REG
         MVC   0(2,R6),LPC#       MOVE IN (,
         LA    R6,2(R6)           BUMP POINTER PAST (,
         BAL   R7,PRCODERG        PRINT REGISTER NAME
         MVI   0(R6),C')'         ADD TERMINAL )
         LA    R6,1(R6)           BUMP PAST )
*
*        COME HERE WHEN WE ARE DONE PRINTING OPERAND FIELD
*
PRCODX11 CLI   0(R5),X'92'        TEST FOR MVI CASE
         BNE   PRCODXL            ALL DONE WITH THIS LINE IF NOT
*
*        FOR MVI, ADD IMMEDIATE OPERAND AFTER COMMA
*
         MVI   0(R6),C','         ADD A COMMA
         LA    R6,1(,R6)          BUMP PAST THE COMMA
         LA    R3,PRCODXL         SET EXIT ADDRESS
         MVC   0(5,R6),NCODE#     SET 'NCODE'
         LR    RE,R6              SAVE BUFFER POINTER
         LA    R6,5(,R6)          BUMP BUFFER POINTER
         CLI   1(R5),NCODE        IS IT REFERENCE TO NCODE?
         BCR   E,R3               ALL SET IF SO
         MVI   0(RE),C'E'         ELSE CHANGE TO 'ECODE'
         CLI   1(R5),ECODE        DO WE HAVE A REF TO ECODE?
         BCR   E,R3               ALL SET IF SO
         LR    R6,RE              ELSE RESET BUFFER POINTER
         SR    RE,RE              CLEAR FOR IC
         IC    RE,1(,R5)          LOAD MVI OPERAND
         SR    R7,R7              SET INTEGER TYPE
         MVC   1(4,R6),5(R6)      BLANK OUT GARBAGE ('CODE')
         B     PRCODNM            EXIT VIA ROUTINE TO PRINT INTEGER
*
*        SECTION TO PRINT SYMBOLIC FIELD OF RR TYPE INSTRUCTIONS
*        THE POSSIBILITIES ARE LR,SR,BALR,BCR,AR
*
PRCODRR  CLI   0(R5),X'18'        IS IT LR?
         BNE   PRCODR1            SKIP IF NOT
         MVC   BUFR+30(2),LR#     MOVE IN LR
         B     PRCODR2            AND MERGE
         EJECT
*
*        HERE TEST FOR CASE OF SR
*
PRCODR1  CLI   0(R5),X'1B'        IS IT SR?
         BNE   PRCODR3            SKIP IF NOT
         MVC   BUFR+30(2),SR#     ELSE MOVE IN SR
*
*        AR,SR,LR MERGE HERE -- IN THESE CASES, PRINT REG NAMES
*
PRCODR2  BAL   R7,PRCODERG        PRINT REG NAME
*
*        BCR,BALR MERGE HERE TO PRINT SECOND REG NAME
*
PRCODR2A MVI   0(R6),C','         MOVE IN COMMA
         LA    R6,1(R6)           BUMP POINTER OVER ,
*
*        BR MERGES HERE TO PRINT REGISTER NAME
*
PRCODR2B IC    RE,1(,R5)          PICK UP SECOND REG
         N     RE,=X'0000000F'    ISOLATE SECOND REG
         BAL   R7,PRCODERG        PRINT SECOND REG NAME
         B     PRCODRL            ALL DONE
*
*        TEST FOR AND DEAL WITH BALR -- THIS IS A SPECIAL CASE SINCE
*        WE WANT TO PRINT BALR R2,0 NOT BALR R2,R0
*
PRCODR3  CLI   0(R5),X'05'        IS THIS BALR?
         BNE   PRCODR4            SKIP IF NOT
         MVC   BUFR+30(4),BALR#   IF IT IS, MOVE IN OPCODE
         BAL   R7,PRCODERG        PRINT FIRST REG
         TM    1(R5),X'0F'        TEST SECOND REG
         BNZ   PRCODR2A           CARRY ON IF NON-ZERO
         MVC   0(2,R6),CMZ#       ELSE MOVE IN ,0
         B     PRCODRL            AND LEAVE
*
*        HERE IS THE SPECIAL PROCESSING FOR BCR
*        IF THE BRANCH IS UNCONDITIONAL, WE PRINT BR REGNAME
*        OTHERWISE, WE PRINT BCR MM,REGNAME WHERE MM IS A CODE
*
PRCODR4  CLI   0(R5),X'07'        IS THIS A BCR?
         BNE   PRCODR6            SKIP IF NOT
         TM    1(R5),X'F0'        IS THE BRANCH UNCONDITIONAL (CC=15)
         BO    PRCODR5            SKIP IF YES
         MVC   BUFR+30(3),BCR#    ELSE SET BCR AS MNEMONIC
         N     RE,=X'000000FE'    CLEAR LOW ORDER BIT OF MASK
         LA    RE,CCTBL-2(RE)     POINT TO CORRECT BRANCH MNEMONIC
         MVC   BUFR+36(2),0(RE)   MOVE IT IN
         LA    R6,2(R6)           BUMP POINTER PAST IT
         B     PRCODR2A           MERGE TO PRINT SECOND REG NAME
         EJECT
*
*        COME HERE FOR BR (UNCONDITIONAL BRANCH)
*
PRCODR5  MVC   BUFR+30(2),BR#     SET BR MNEMONIC
         B     PRCODR2B           JUMP TO PRINT REGNAME
*
*        COME HERE TO CHECK FOR AUR, SUR
*
PRCODR6  TM    0(R5),X'3E'        IS IT AUR (3E) OR SUR (3F)?
         BNO   PRCODR7            SKIP IF NOT
         MVC   BUFR+30(15),AUR#   ELSE PUT AUR  SCNT,SINC IN BUFFER
         CLI   1(R5),SCNT*4+ZR    IS OPERAND SCNT,ZR?
         BNE   *+10               SKIP IF NOT
         MVC   BUFR+30+11(4),ZR#  ELSE REPLACE 2ND SCNT BY ZR
         B     PRCODRL            ALL DONE
*
*        COME HERE TO CHECK FOR AR
*
PRCODR7  CLI   0(R5),X'1A'        CHECK FOR AR
         BNE   PRCODRL            SKIP IF NOT (???)
         MVC   BUFR+30(2),AR#     MOVE IN AR MNEMONIC
         B     PRCODR2            JUMP TO PRINT REGNAMES
*
*        HERE FOR SPECIAL CASE OF STATEMENT NUMBER (NOP INSTRUCTION)
*
PRCODNOP MVC   BUFR+30(3),NOP#    SET NOP AS MNEMONIC
         LH    RE,2(,R5)          LOAD STATEMENT NUMBER
         SR    R7,R7              SET INTEGER TYPE
         BAL   R3,PRCODNM         PRINT STATEMENT NUMBER
         B     PRCODXL            EXIT (FOUR BYTE INSTRUCTION)
*
*        EXIT POINT FOR RR TYPE INSTRUCTION PROCESSING
*
PRCODRL  LA    R5,2(,R5)          BUMP CODE POINTER
*
*        COMMON EXIT ROUTINE AT END OF LINE
*
PRCODRD  BAL   R7,LISTER          LIST LINE
         CLI   0(R5),X'3E'        CHECK FOR END OF CODE TO PRINT
         BCR   E,R4               RETURN TO PRCODEL CALLER IF SO
         CLI   0(R5),X'3D'        ELSE CHECK FOR MODIFIED END
         BCR   E,R4               RETURN TO PRCODEL CALLER IF SO
         B     PRCODEL            ELSE LOOP BACK
         EJECT
*
*        SUBROUTINE TO PRINT REGISTER NAME
*
*        (RE)                     REGISTER NUMBER
*        BAL   R7,PRCODERG
*
PRCODERG SLL   RE,3               REG NUMBER * 8
         LA    R3,PRCRGNAM(RE)    POINT TO CORRECT TABLE LOCATION
         MVC   0(7,R6),1(R3)      MOVE CHARACTERS
         IC    RE,0(,R3)          PICK UP NUMBER OF CHARACTERS
         AR    R6,RE              BUMP BUFFER POINTER
         BR    R7                 LEAVE
*
*        TABLE OF REGISTER NAMES
*
PRCRGNAM DC    AL1(2)
         DC    CL7'R0'
         DC    AL1(2)
         DC    CL7'R1'
         DC    AL1(2)
         DC    CL7'R2'
         DC    AL1(2)
         DC    CL7'FR'
         DC    AL1(2)
         DC    CL7'A1'
         DC    AL1(4)
         DC    CL7'A1+1'
         DC    AL1(2)
         DC    CL7'A2'
         DC    AL1(4)
         DC    CL7'A2+1'
         DC    AL1(3)
         DC    CL7'DB1'
         DC    AL1(3)
         DC    CL7'DB2'
         DC    AL1(3)
         DC    CL7'DB3'
         DC    AL1(3)
         DC    CL7'DB4'
         DC    AL1(7)
         DC    CL7'FRETURN'
         DC    AL1(6)
         DC    CL7'RETURN'
         DC    AL1(3)
         DC    CL7'SYS'
         DC    AL1(3)
         DC    CL7'PDR'
         EJECT
*
*        SUBROUTINE TO PRINT A STRING
*
*        USED TO PRINT LITERAL STRINGS AND VARIABLE NAMES
*
*        (RE)  POINTS TO STRING SPECIFIER
*        BAL   R7,PRCODST
*
PRCODST  LH    R3,SLENGTH(,RE)    LOAD LENGTH FIELD
         L     RE,0(,RE)          LOAD STRING POINTER
         EX    R3,PRCODST2        MOVE IN CHARS OF STRING
         LA    R6,1(R6,R3)        BUMP POINTER
         BR    R7                 RETURN
*
PRCODST2 MVC   0(*-*,R6),SCHARS(RE)         MOVE LESS THAN 20 CHARS
         EJECT
*
*        SUBROUTINE TO PRINT A NUMERIC VALUE AT (R6) CURSOR LOCATION
*        (R6) IS UPDATED -- LEADING BLANKS/ZEROS ARE SUPPRESSED
*
*        (R7,RE)                  NUMERIC CONSTANT TO BE PRINTED
*        BAL   R3,PRCODNM
*
PRCODNM  STM   R4,R5,PRWRK        SAVE REGISTERS
         LR    R4,R7              COPY ARGUMENT TO PROPER REG
         LR    R5,RE              ...
         LA    R2,NUMTOSTG        POINT TO CONVERSION ROUTINE
         L     R0,PRCODNMC        PICK UP CONVERSION PARAMETERS
         BALR  R1,R2              CALL CONVERT ROUTINE
         EX    R5,PRCODNMM        MOVE CHARACTERS INTO PLACE
         LA    R6,1(R5,R6)        UPDATE POINTER
         LM    R4,R5,PRWRK        RESTORE REGS
         BR    R3                 RETURN TO CALLER
*
PRCODNMM MVC   0(*-*,R6),SCHARS(R4)         MOVE CHARACTERS INTO PLACE
         CNOP  0,4                ALLIGN CONVERSION PARAMETERS
PRCODNMC DC    AL1(0,14,0,7)      FORMAT=0, DIGS = 7(REAL), 14(DREAL)
         EJECT
*
*        CONSTANTS FOR PRCODE
*
CCTBL    DC    C'GTLTNEEQGELE'    BRANCH CODE MNEMONICS
PREDIT   DC    C'L'               EDIT PATTERN FOR LABELS
         DC    X'2120202020'      REST OF PATTERN
HEXPRT   EQU   *-X'F0'            HEX TRANSLATION TABLE WITH ADR FUDGE
         DC    C'0123456789ABCDEF'          ACTUAL ENTRIES USED IN HEXT
TTLCOD   DC    C'  LOC    CODE        SYMBOLIC'
STMNTTL  DC    C'*     STATEMENT NUMBER '
STPAT    DC    X'2020202020'
         CNOP  0,4                ALLIGN FOLLOWING CONSTANT
DB4KON   DC    Y(0)               FIRST TWO BYTES ARE ZERO
         DC    S($$BAS4-16)       CONSTANT TO CALC BASE NUMBER
EQU#     DC    C' EQU   *'         EQU *
PONE#    DC    C'+1,'             +1,
$$BAS#   DC    C'$$BAS'           $$BAS
FCODE#   DC    C'FCODE(,DB4)'     FCODE(,DB4)
VAL#     DC    C'VAL.'            VAL.
FNC#     DC    C'FNC.'            FNC.
LBL#     DC    C'LBL.'            LBL.
TEM#     DC    C'TEM#'            TEM#
LPC#     DC    C'(,'              (,
NCODE#   DC    C'NCODE'           NCODE
LR#      DC    C'LR'              LR
SR#      DC    C'SR'              SR
BALR#    DC    C'BALR'            BALR
CMZ#     DC    C',0'              ,0
BCR#     DC    C'BCR'             BCR
BR#      DC    C'BR'              BR
AUR#     DC    C'AUR   SCNT,SINC' AUR   SCNT,SINC
AR#      DC    C'AR'              AR
CONS##   DC    C'CONS#'           CONS#
ZR#      DC    C'ZR  '            ZR
NOP#     DC    C'NOP'             NOP
CONHED   DC    C'CODE TO COMPUTE CONS#'     CODE TO COMPUTE CONS#
.SKIPS6  ANOP
         TITLE 'SPITBOLC -- COMPILE TIME READER ROUTINE'
*
*        NOTE: THIS ROUTINE AND THE THREE FOLLOWING IT ARE OMITTED
*        FROM THE LIBRARY ROUTINES (READER,LISTER,CONCPROC,ERROR)
*
*        CALLED BY BAL R7,READER
*
*        READS 80-BYTE CARD INTO INBUF
*
*        THROUGH THE USE OF (POSSIBLY NESTED) -COPY CARDS, SEVERAL
*        INPUT FILES MAY BE ACTIVE AT THE SAME TIME. THIS IS HANDELED
*        BY USING THE INPUTDCB STACK. THE BOTTOM (LOWEST) ENTRY IN THIS
*        STACK IS THE MAIN INPUT FILE POINTER (SYSIN). HIGHER ENTRIES
*        ARE MADE FOR -COPY CARDS. THE LOCATION RDDCBOFS HOLDS AN
*        OFFSET TO THE TOP ELEMENT WHICH CONTAINS THE CURRENT FILE PTR.
*
         AIF   (&LMOD EQ 1).SKIPS7
         USING SPITBOLC,CB1       GET FIRST BASE REG BACK
READER   STM   R4,R5,IOHOLD       SAVE I/O PARAM REGS
         MVI   INBUF,C' '         SET A BLANK
         MVC   INBUF+1(80-1),INBUF          CLEAR INPUT BUFFER
         LH    R5,RDDCBOFS        LOAD OFFSET INTO INPUT FILE STACK
*
*        MERGE BACK HERE FOR END OF FILE ON -COPY INPUT
*
READERL  L     R0,INPUTDCB(R5)    LOAD APPROPRIATE FILE POINTER
         L     R2,=V(SYSMAXL)     POINT TO ROUTINE
         BALR  R1,R2              GET INPUT RECORD LENGTH
         CH    R0,=H'80'          MUST NOT EXCEED 80 CHARS LONG
         BH    READIOER           TREAT AS I/O ERROR IF LONGER
         L     R0,INPUTDCB(R5)    ELSE RELOAD FILE POINTER
         LA    R4,INBUF           POINT TO INPUT BUFFER
         L     R2,=V(SYSREAD)     POINT TO READ ROUTINE
         BALR  R1,R2              CALL SYSTEM INPUT ROUTINE
         B     READIOER           JUMP IF INPUT ERROR
         LTR   R0,R0              CHECK RECORD LENGTH READ
         BM    READEOF            SKIP ON END OF FILE
*
*        MERGE BACK HERE AFTER SUPPLYING END CARD ON EOF
*
READER1  LM    R4,R5,IOHOLD       RESTORE REGS USED FOR I/O PARAMS
         MVC   BUFR,BUFR-1        BLANK OUTPUT BUFFER
         MVC   BUFR+6(80),INBUF   MOVE CARD TO OUTPUT BUFFER
         CLI   IN72,0             TEST FOR 72 COLUMN MODE
         BCR   E,R7               RETURN IF NOT
*
*        HERE DEAL WITH -IN72 OPTION (72 COLUMN READ)
*
         MVI   SERIAL-1,C'.'      SET VISUAL DIVIDER
         MVI   BUFR+6+72,C' '     BLANK OUT GARBAGE CHARACTER
         MVC   SERIAL,INBUF+72    MOVE SERIALIZATION TO OUTPUT
         MVI   INBUF+72,X'00'     SET SCAN TERMINATE CHAR IN COL 73
         CLI   SEQFLG,0           TEST FOR -SEQ OPTION
         BCR   E,R7               LEAVE IF NO SEQUENCE CHECK
         EJECT
*
*        HERE WE DO THE SEQUENCE CHECK
*
         CLC   SERIAL,SERIAL+8    CHECK FOR ALL BLANKS
         BCR   E,R7               NO CHECK IF ALL BLANK
         CLC   SERIAL,LASTSEQ     ELSE DO SEQUENCE CHECK
         BH    *+16               SKIP IF HIGHER (OK)
         MVC   BUFR+90(14),=C'***SEQUENCE***'     ELSE SET MESSAGE
         OC    SUPRXEQ,NOXEQE     STOP XEQ IF -NOERRORS OPTION SET
         MVC   LASTSEQ,SERIAL     SAVE THIS VALUE FOR NEXT TEST
         BR    R7                 LEAVE
*
*        COME HERE ON END OF FILE
*
*        THERE ARE TWO POSSIBLE CASES --
*
*        1)    END OF PRIMARY INPUT FILE. IN THIS CASE THE END CARD
*              IS MISSING AND WE SUPPLY ONE WITH AN ERROR MESSAGE.
*
*        2)    AN END OF FILE FROM A -COPY INPUT. IN THIS CASE, WE POP
*              THE POINTER TO THE INPUT FILE STACK AND CONTINUE
*              READING FROM THE PREVIOUS INPUT FILE.
*
READEOF  SH    R5,=H'4'           POP OFFSET INTO FILE PTR STACK
         STH   R5,RDDCBOFS        STORE POPPED POINTER
         BNM   READERL            LOOP BACK IF NOT PRIMARY INPUT FILE
         MVI   EOF,1              ELSE SET SPECIAL END OF FILE FLAG
         MVC   INBUF(3),=C'END'   SUPPLY MISSING END CARD
         B     READER1            MERGE WITH NORMAL READ CIRCUIT
*
*        HERE ON PERMANENT INPUT-OUTPUT ERROR
*
READIOER MVI   FATAL,1            SET FATAL ERROR FLAG
         ERR   17                 I/O ERROR MESSAGE
         TITLE 'SPITBOLC -- COMPILE TIME LISTER ROUTINE'
*
*        CALLED BY
*
*        BAL   R7,LISTER
*
*        PRINTS THE LINE STORED IN BUFR (WITH CONTROL CHARACTER AT
*                                                   BUFR - 1)
*        SKIPS OVER CREASES
*        TO SET FOR A NEW PAGE -- EXECUTE
*
*        MVI   LINELEFT+1,1
*
LISTER   CLI   BUFR+90,C'*'       CHECK FOR SEQUENCE ERROR MSG
         BE    LISTERU            ALWAYS PRINT IF SEQUENCE ERROR
         CLI   LISTSW,0           ELSE CHECK -LIST MODE FLAG
         BCR   8,R7               SKIP OUT IF NO LIST
*
*        BAL   R7,LISTERU         FOR UNCONDITIONAL LISTING
*
LISTERU  STM   R4,R7,IOHOLD       SAVE I/O PARAM REGS
         LH    R1,LINELEFT        PICK UP COUNT OF LINES LEFT ON PAGE
         CLI   DUBLFLG,0          -DOUBLE OPTION SET?
         BZ    *+6                SKIP IF NOT
         BCTR  R1,0               IF IT IS, DECREMENT LINE COUNT 1 EXTR
         SH    R1,=H'1'           DECREMENT FOR LINE TO BE PRINTED
         BP    LISTER1            SKIP IF ROOM LEFT ON THIS PAGE
         AP    PAGENO,PONE        NEW PAGE -- BUMP PAGE COUNT
         MVC   OUTPAGE,=X'202020' MOVE PATTERN ONTO TITLE LINE
         ED    OUTPAGE-1(4),PAGENO          EDIT PAGE NUMBER
         LA    R4,OUTTITB         POINT TO TITLE LINE
         LA    R5,111             SET LINE LENGTH = 111
         BAL   R3,WLINE           CALL WRITE A LINE ROUTINE
         MVI   BUFR-1,C'0'        SET CARRIAGE CONTROL FOR BLANK LINE
         L     R1,PGDEPTH         RESET LINE COUNTER
*
*        OUTPUT SUB-TITLE IF ONE HAS BEEN GIVEN
*
         CLC   OUSTITL,OUSTITL-1  DO WE HAVE A SUB-TITLE?
         BE    LISTER1            SKIP IF NOT (ALL ZEROS)
         LA    R4,OUSTITL-1       POINT TO SUB-TITLE WITH CTL CHAR
         LA    R5,L'OUSTITL+1     SET LENGTH INCLUDING CTL CHAR
         BAL   R3,WLINE           OUTPUT THE SUB-TITLE
         L     R1,PGDEPTH         RESET LINE COUNTER
         SH    R1,=H'2'           ADJUST BY TWO FOR SUBTITLE
         EJECT
*
*        JUMP HERE WHEN WE DO NOT NEED NEW PAGE
*
LISTER1  STH   R1,LINELEFT        RE-STORE LINE COUNT
         CLI   DUBLFLG,1          TEST FOR -DOUBLE SET
         BNE   *+8                SKIP IF NOT
         OI    BUFR-1,C'0'        SET FOR DOUBLE SPACE UNLESS NEW PAGE
         LA    R4,BUFR-1          POINT TO OUTPUT BUFFER WITH CTL CHAR
         LA    R5,133             SET LENGTH
         BAL   R3,WLINE           OUTPUT THE LINE
         MVI   BUFR-1,C' '        RESTORE BLANK CONTROL CHARACTER
         LM    R4,R7,IOHOLD       RELOAD I/O PARAM REGS
         BR    R7                 RETURN TO CALLER
*
*        LITTLE SUBROUTINE TO PRINT A LINE AT COMPILE TIME
*
*        (R4,R5)                  PARAMS SET FOR SYSWRITE (ADDR/LENGTH)
*        BAL   R3,WLINE
*        -->   NORMAL RETURN
*
WLINE    L     R0,PRINTDCB        POINT TO SYSPRINT DCB
         SR    R7,R7              INDICATE UNFORMATTED
         L     R2,=V(SYSWRITE)    POINT TO OUTPUT ROUTINE
         BALR  R1,R2              CALL SYSTEM OUTPUT ROUTINE
         NOP   0                  ERROR NOT POSSIBLE ON SYSPRINT
         LTR   R0,R0              CHECK FOR LINE LIMIT EXCEEDED
         BCR   NZ,R3              RETURN IF NOT EXCEEDED
         MVI   FATAL,1            ELSE SIGNAL FATAL ERROR
         ERR   15                 GIVE ***PAGE LIMIT EXCEEDED*** MSG
         TITLE 'SPITBOLC -- CONTROL CARD INTERPRETATION ROUTINE'
*        THIS ROUTINE IS CALLED WITH
*
*        BAL   R7,CONCPROC
*
*        IT PROCESSES THE CONTROL CARD AND TRANSFERS TO READER WHICH
*        READS IN THE NEXT CARD AND RETURNS CONTROL TO THE CALLER
*
CONCPROC LA    R1,INBUF+1         POINT TO START OF CONTROL CARD
         ST    R1,FLAGLOC         SAVE LOCATION FOR POSSIBLE ERROR FLAG
*
*        REENTER HERE FOR CASE OF MULTIPLE ITEMS
*
CONCPRCR LA    R2,CONCDICT        POINT TO CONTROL CARD DICTIONARY
         ST    R7,CONCSAV         SAVE LINKAGE
         ST    RF,CONCSAV+4       SAVE (RF)
         LA    R0,(CONCDICN-CONCDICT)/6     LOAD NUMBER OF ENTRIES
*
*        LOOP THROUGH ENTRIES IN DICTIONARY
*
CONCPRLP CLC   0(4,R1),0(R2)      IS THIS THE ONE?
         BNE   CONCPRE            SKIP IF NOT
         LH    R2,4(,R2)          LOAD ROUTINE ADDRESS
*
*        COME HERE TO BRANCH TO PROPER ROUTINE
*
CONCPRGO LA    R0,1               GET A CONSTANT ONE FOR FLAG SETS
         LA    R2,CONCPROC(R2)    POINT TO ROUTINE
         BALR  R2,R2              OFF TO ROUTINE SETTING RETURN
*
*        CONTROL CARD TYPES PERMITTING OTHER ITEMS TO FOLLOW COME HERE
*
         CLI   0(R1),C' '         IS THERE A BLANK?
         BE    CONCDONE           JUMP TO READ IF SO (ALL DONE)
         CLI   0(R1),C','         ELSE IS THERE A COMMA?
         LA    R1,1(,R1)          BUMP POINTER
         BCR   NE,R2              LOOP BACK IF NOT AT COMMA
         B     CONCPRCR           ELSE JUMP BACK TO SCAN NEXT ENTRY
*
*        SKIP HERE ON NO MATCH TO GO TO NEXT ENTRY
*
CONCPRE  LA    R2,6(,R2)          POINT TO NEXT ENTRY
         BCT   R0,CONCPRLP        SKIP BACK IF MORE TO GO
         BAL   R7,LISTERU         ALWAYS LIST GARBAGE CONTROL CARD
         L     R7,CONCSAV         RESTORE LINKAGE
         B     READER             AND THEN IGNORE IT
         EJECT
*
*        -NOLIST,-UNLIST
*
CONCNOLI EQU   *                  -NOLIST ENTRY
CONCUNLI SR    R0,R0              SET TO TURN OFF FLAG & MERGE
*
*        -LIST
*
CONCLIST STC   R0,LISTSW          STORE LIST SWITCH
         BR    R2                 RETURN FOR NEXT ENTRY
*
*        -CODE
*
CONCCODE MVI   CODESW,1           SET CODE SWITCH
         MVI   AUR$,X'3D'         SET SPECIAL AUR TO GET CODE LIST
         BR    R2                 RETURN TO SCAN NEXT ITEM
*
*        -NOCODE
*
CONCNOCO MVI   AUR$,X'3E'         SET CODE LIST OFF
         BR    R2                 RETURN TO SCAN NEXT ITEM
*
*        -TITLE
*
CONCTITL MVC   OUTITLE,BUFR+13    ACQUIRE SUPPLIED TITLE
         MVC   OUSTITL,OUSTITL-1  CLEAR SUB-TITLE
         B     CONCEJEC           MERGE WITH EJECT
*
*        -STITL
*
CONCSTIT MVC   OUSTITL,BUFR+13    ACQUIRE SUB-TITLE, MERGE EJECT
*
*        -EJECT
*
CONCEJEC MVI   LINELEFT+1,1       SET FOR NEW PAGE
         B     CONCDONE           ALL DONE, JUMP TO END
*
*        -SINGLE
*
CONCSING SR    R0,R0              SET TO TURN OFF FLAG & MERGE
*
*        -DOUBLE
*
CONCDOUB STC   R0,DUBLFLG         STORE VALUE OF -DOUBLE FLAG
         BR    R2                 RETURN FOR NEXT ITEM
         EJECT
*
*        -NOFAIL
*
CONCNOFA SR    R0,R0              SET TO TURN OFF & MERGE
*
*        -FAIL
*
CONCFAIL STC   R0,FAILSET         STORE FAIL VALUE
         BR    R2                 RETURN FOR NEXT ITEM
*
*        -IN80
*
CONCIN80 SR    R0,R0              SET TO TURN OFF -IN72 SW & MERGE
         LA    RF,INBUF+80        SET LOCATION OF STOP CHARACTER
         MVI   INBUF+80,X'00'     SET STOP CHARACTER IN PLACE
         B     CONCINMR           JUMP TO MERGE POINT
*
*        -IN72
*
CONCIN72 LA    RF,INBUF+72        POINT TO STOP CHARACTER, MERGE
*
*        -IN72, -IN80 MERGE HERE
*
CONCINMR STC   R0,IN72            SET MODE FLAG
         ST    RF,STOPLOC         REMEMBER LOCATION OF STOP CHARACTER
         BR    R2                 RETURN FOR NEXT ITEM
*
*        -NOSEQ
*
CONCNOSE SR    R0,R0              SET TO TURN SWITCH OFF & MERGE
*
*        -SEQUENCE
*
CONCSEQU STC   R0,SEQFLG          STORE VALUE OF SEQ FLAG
         STD   ZR,LASTSEQ         CLEAR LAST SEQ TO 8X'00'
         BR    R2                 RETURN FOR NEXT ITEM
*
*        -NOOPTIMIZE
*
CONCNOOP SR    R0,R0              SET TO CLEAR OPTIMIZE FLAG, MERGE
*
*        -OPTIMIZE
*
CONCOPTI STC   R0,OPTFLAG         SET PROPER VALUE IN OPTIMIZE FLAG
         BR    R2                 RETURN FOR NEXT ITEM
         EJECT
*
*        -EXECUTE
*
CONCEXEC SR    R0,R0              SET TO ALLOW EXECUTION
*
*        -NOEXECUTE
*
CONCNOEX STC   R0,BYPASXEQ        SET FLAG PROPERLY
         BR    R2                 ALL DONE, LOOP BACK
*
*        -ERRORS
*
CONCERRO SR    R0,R0              SET TO TURN OF ERROR FLAG, MERGE
*
*        -NOERRORS
*
CONCNOER STC   R0,NOXEQE          SET VALUE OF -NOERRORS SWITCH
         BR    R2                 ALL DONE
*
*        -NOPRINT
*
CONCNOPR SR    R0,R0              SET TO TURN OFF PRINT SWITCH
*
*        -PRINT
*
CONCPRIN STC   R0,PRINFLG         SET PRINT SWITCH PROPERLY
         BR    R2                 ALL DONE
*
*        -SPACE
*
CONCSPAC NI    INBUF+7,X'0F'      MASK OUT ZONES ON COUNT
         CLC   LINELEFT+1(1),INBUF+7        ARE THERE ENOUGH LINES?
         BNH   CONCEJEC           TREAT AS -EJECT IF NOT
         SR    RF,RF              ELSE CLEAR RF FOR FOLLOWING IC
         IC    RF,INBUF+7         PICK UP COUNT
         MVC   BUFR,BUFR-1        CLEAR BUFFER
*
*        LOOP TO SPACE ONE LINE AT A TIME
*
CONCSLP  BAL   R7,LISTER          LIST A BLANK LINE
         BCTR  RF,0               DECREASE COUNT
         LTR   RF,RF              TEST IT
         BP    CONCSLP            BACK FOR ANOTHER LINE IF MORE TO GO
         B     CONCDONE           ALL DONE WITH SPACE CARD
         EJECT
*
*        -COPY
*
CONCCOPY STM   R4,R5,IOHOLD       SAVE REGS
         TRT   INBUF+5(80),SCANTB1          SCAN TO START OF FILENAME
         LR    R4,R1              COPY START OF FILE NAME ADDRESS
         LR    R5,R4              COPY POINTER
*
*        LOOP TO SCAN TO END OF FILE NAME
*
         BALR  R2,0               SET START OF LOOP ADDRESS
         CLI   1(R5),C' '         TERMINATING BLANK?
         LA    R5,1(,R5)          BUMP POINTER
         BCR   NE,R2              LOOP BACK IF BLANK NOT FOUND
*
*        HERE WITH FILE NAME SCANNED OUT
*
         SR    R5,R4              GET LENGTH OF FILENAME
         L     R2,=V(SYSDCB)      POINT TO SYSTEM ROUTINE
         BALR  R1,R2              CALL SYSTEM ROUTINE TO GET FILE PTR
         B     CONCOPER           ERROR IF FILE CANNOT BE OPENED
*
*        HERE WE HAVE THE FILE POINTER IN (R0)
*
         LH    R5,RDDCBOFS        LOAD CURRENT FILE PTR OFFSET
         LA    R5,4(,R5)          PUSH POINTER
         CH    R5,=Y(MAXCOPY*4)   CHECK FOR NESTED TOO DEEP
         BNH   CONCCOP3           SKIP IF OK
*
*        HERE ON ANY KIND OF ERROR
*
CONCOPER BAL   R7,LISTERU         UNCONDITIONALLY LIST CONTROL CARD
         ERR   13                 AND SIGNAL ERROR (BAD -COPY CARD)
*
*        HERE TO STORE FILE POINTER AND EXIT
*
CONCCOP3 STH   R5,RDDCBOFS        STORE NEW FILE PTR OFFSET
         ST    R0,INPUTDCB(R5)    STORE FILE POINTER IN STACK
         LM    R4,R5,IOHOLD       RELOAD REGS AND MERGE TO EXIT
*
*        MERGE HERE AFTER PROCESSING CONTROL CARD
*
CONCDONE CLI   PRINFLG,0          SHOULD WE PRINT CONTROL CRD?
         BE    *+8                SKIP IF NOT
         BAL   R7,LISTER          ELSE LIST CONTROL CARD
         L     R7,CONCSAV         RELOAD REGISTERS
         L     RF,CONCSAV+4       . . . .
         B     READER             AND JUMP TO READ NEXT CARD
         EJECT
*
*        CONTROL CARD DICTIONARY
*
CONCDICT EQU   *
         CONC  LIST               -LIST
         CONC  UNLI               -UNLIST
         CONC  STIT               -STITL
         CONC  TITL               -TITLE
         CONC  EJEC               -EJECT
         CONC  CODE               -CODE
         CONC  ERRO               -ERRORS
         CONC  NOER               -NOERRORS
         CONC  SPAC               -SPACE
         CONC  SING               -SINGLE
         CONC  DOUB               -DOUBLE
         CONC  NOCO               -NOCODE
         CONC  NOLI               -NOLIST
         CONC  PRIN               -PRINT
         CONC  NOPR               -NOPRINT
         CONC  FAIL               -FAIL
         CONC  NOFA               -NOFAIL
         CONC  SEQU               -SEQUENCE
         CONC  NOSE               -NOSEQUENCE
         CONC  IN72               -IN72
         CONC  IN80               -IN80
         CONC  OPTI               -OPTIMIZE
         CONC  NOOP               -NOOPTIMIZE
         CONC  EXEC               -EXECUTE
         CONC  NOEX               -NOEXECUTE
         CONC  COPY               -COPY
CONCDICN EQU   *                  END OF DICTIONARY
         TITLE 'SPITBOLC -- COMPILE TIME ERROR MESSAGE ROUTINE'
*
*        CALLED BY THE MACRO
*
*        ERR   NN                 TO GENERATE ERROR MESSAGE NN
*
*        FATAL IS A FLAG WHICH HAS THREE SETTINGS  --
*
*              0                  NORMAL ERROR
*              1                  FATAL ERROR
*              2                  ERROR IN END CARD
*
ERROR    CLI   LISTSW,0           CHECK LIST SWITCH
         BNE   *+8                SKIP IF SWITCH IS ON
         BAL   R7,LISTERU         ELSE UNCONDITIONAL LIST OF BUFR
         OC    SUPRXEQ,NOXEQE     SET FLAG IF -NOERRORS OPTION SET
         MVI   0(LC),C' '         SETUP BUFFER JUST BEYOND CODE
         MVC   1(86,LC),0(LC)     CLEAR TO BLANKS
         L     R2,FLAGLOC         LOAD LOCATION FOR ERROR FLAG
         LA    R0,INBUF-1         POINT TO START OF BUFFER WITH FUDGE
         SR    R2,R0              COMPUTE CURRENT OFFSET IN BUFFER
         AR    R2,LC              POINT TO LOCATION IN OUR OUTPUT BUFR
         MVI   6(R2),C'|'         SET ERROR FLAG
         LH    R0,LINELEFT        COUNT OF LINES LEFT ON PAGE
         SH    R0,=H'3'           MINUS 3 FOR FLAG, MESSAGE, BLANK
         STH   R0,LINELEFT        STORE DECREMENTED VALUE
         LR    R4,LC              POINT TO BUFFER
         LA    R5,86              SET LENGTH
         BAL   R3,WLINE           PRINT ERROR FLAG
         MVI   1(LC),C'*'         SET A *
         MVC   2(70,LC),1(LC)     PROPAGATE STARS
         SR    R2,R2              CLEAR FOR IC
         IC    R2,0(,RE)          GET LENGTH OF ERROR MESSAGE
         EX    R2,ERRMOV          MOVE IN ERROR MESSAGE
         LA    R5,6+6+1+1(,R2)    LENGTH OF MSG AND ******
         BAL   R3,WLINE           PRINT ERROR MESSAGE
         LA    R5,1               SET TO PRINT ONE CHARACTER
         BAL   R3,WLINE           PRINT A BLANK LINE UNDER MSG
         MVC   0(6,LC),LRFDB1$    GEN LR FRETURN,DB1 BAL RETURN,$$SERR
         LA    LC,6(,LC)          BUMP CODE POINTER
         AP    ERRCOUNT,=P'1'     INCREMENT ERROR COUNT
         CLI   FATAL,1            TEST CASES
         BH    XEQGO              START EXECUTION IF END CARD ERROR
         BE    ENDJOB             END OF JOB IF FATAL ERROR
         MVI   ERRFLG,1           ELSE SET FLAG FOR ERROR IN ERROR
         EJECT
*
*        COME HERE TO SCAN TO END OF STATEMENT
*
ERROR1   CLI   SCANFL,TRM         ARE WE AT END OF STATEMENT?
         BE    *+12               SKIP IF SO
         BAL   RF,SCAN            ELSE SCAN NEXT ELEMENT
         B     ERROR1             BACK TO SEE IF IT IS END OF STATEMENT
         MVI   ERRFLG,0           RESET ERROR IGNORE FLAG
         B     CMPILE             GO COMPILE NEXT STATEMENT
*
ERRMOV   MVC   6+1(*-*,LC),1(RE)  MOVE ERROR MESSAGE INTO BUFFER
*
*        COME HERE TO TERMINATE JOB ON A FATAL ERROR
*
ENDJOB   LA    R0,12              SET RETURN CODE TO INDICATE ERROR
         L     R2,=V(SYSEOJ)      LOAD ADDRESS OF EOJ ROUTINE
         BR    R2                 RETURN TO SYSTEM INTERFACE
*
*        ERROR MESSAGES
*
1        ERRM  'MISSING OPERAND'
2        ERRM  'UNBALANCED () OR <>'
3        ERRM  'ILLEGAL USE OF < '
4        ERRM  'ILLEGAL USE OF , '
5        ERRM  'ILLEGAL USE OF ) '
6        ERRM  'ILLEGAL USE OF > '
7        ERRM  'MISSING OPERATOR'
8        ERRM  'EXPRESSION IS TOO COMPLEX FOR THE COMPILER'
10       ERRM  'ILLEGAL USE OF = '
11       ERRM  'ERROR IN GO TO FIELD'
12       ERRM  'PROGRAM TOO LONG FOR AVAILABLE STORAGE'
13       ERRM  'INVALID -COPY CARD'
14       ERRM  'TIME LIMIT EXCEEDED'
15       ERRM  'PAGE LIMIT EXCEEDED'
16       ERRM  'ERROR IN NUMERIC ITEM'
17       ERRM  'NON-RECOVERABLE INPUT ERROR'
18       ERRM  'UNMATCHED QUOTE'
19       ERRM  'MISSING END CARD SUPPLIED'
20       ERRM  'LABEL HAS BEEN PREVIOUSLY DEFINED'
21       ERRM  'ILLEGAL TRANSFER ADDRESS'
22       ERRM  'UNDEFINED TRANSFER ADDRESS'
24       ERRM  'ILLEGAL CHARACTER'
         TITLE 'SPITBOLC -- RUN TIME PATCH ROUTINE'
*
*        THIS ROUTINE IS CALLED TO READ PATCH CARDS AT RUN TIME
*        THE FORMAT OF THESE CARDS IS SIMILAR TO THAT USED IN DOS ---
*
*REP  AAAAAA NNNDDDD,DDDD,DDDD,DDDD   . . .
*
*        AAAAAA IS THE ASSEMBLY ADDRESS OF THE START OF THE PATCH
*        NNN IS THE ESD NUMBER (IGNORED BY THE PATCHER ROUTINE)
*        DDDD,DDDD ARE 4 HEX DIGIT GROUPS OF DATA
*
*
*
*        MAIN ENTRY POINT
*
PATCHER  BAL   R7,READER          READ A CARD
         CLC   INBUF(4),=C'-REP'  IS IT REALLY A REP CARD?
         BCR   NE,RF              RETURN IF NOT A REP CARD
         BAL   R7,LISTERU         LIST PATCH CARD
         TR    INBUF+6(6),HEXTABL TRANSLATE HEX DIGITS OF ADDRESS
         PACK  PAKWRK+1(3+1),INBUF+6(6+1)  PACK PATCH ADDRESS
         L     R2,PAKWRK          LOAD ADDRESS
         AR    R2,CB1             GET ACTUAL CORE ADDRESS
         LA    R3,INBUF+13+3      INITIALIZE POINTER TO PATCH DATA
*
*        THIS LOOP ENTERS ONE TWO BYTE (4 HEX DIGIT) PATCH
*
PATCHLP  TR    0(4,3),HEXTABL     TRANSLATE HEX DIGITS
         PACK  PAKWRK+2(2+1),0(4+1,R3)      PACK UP DIGITS
         MVC   0(2,R2),PAKWRK+2   MOVE DATA TO NEW LOCATION
         CLI   4(R3),C' '         DO WE HAVE A BLANK NEXT?
         BE    PATCHER            IF YES -- ALL DONE -- GET NEXT CARD
         LA    R3,5(R3)           IF MORE, BUMP INPUT POINTER
         LA    R2,2(R2)           BUMP CORE POINTER
         B     PATCHLP            AND GO BACK FOR NEXT PATCH
*
*        WORK AREAS AND CONSTANTS FOR PATCHER
*
HEXTABL  EQU   *-C'A'             TRANSLATE TABLE TO CONVERT HEX
         DC    YL1(10,11,12,13,14,15)       TRANSLATE A,B,C,D,E,F
PAKWRK   DC    F'0'               WORK AREA FOR PATCHER
         ORG   HEXTABL+C'0'       REST OF HEXTABL
         DC    YL1(0,1,2,3,4,5,6,7,8,9)     TRANSLATE DIGITS
.SKIPS7  ANOP
         TITLE 'SPITBOLC -- OBJECT MODULE RESTART ROUTINE'
*
*        THIS IS THE JOB INITIALIZATION ROUTINE FOR USE IN THE CASE
*        OF A RESTART FROM A GENERATED OBJECT MODULE. IT IS LOCATED IN
*        THE COMPILER SECTION TO SAVE SPACE IN THE TWO PHASE VERSION.
*        THE OBJECT MODULE DOES NOT INCLUDE ANY RLD INFORMATION. THUS
*        THE NECESSARY RELOCATION MUST BE PERFORMED IN THIS ROUTINE.
*        THIS ROUTINE SHOULD BE ALTERED TO TOLERATE BATCHING
*
*        THIS ROUTINE IS INCLUDED ONLY IN THE LIBRARY MODULES.
*
         AIF   (&LMOD EQ 0).SKIPLLL
         DROP  CB1,CB2,CB3,CB4    KILL COMPILER BASE REGS
         ENTRY SYSSTART           ENTRY POINT FROM INTERFACE
SYSSTART BALR  FRETURN,0          ESTABLISH A BASE REGISTER
         USING *,FRETURN          TELL ASSEMBLER
         SDR   ZR,ZR              SET STANDARD ZERO REGISTER
         LR    FR,DB1             SET ADDRESS OF START OF DYNAMIC CORE
         L     DB1,SPITLADN       LOAD ADDR OF START OF OLD DATA AREA
         L     SYS,SPITLAD        OLD DATA AREA STARTING ADDRESS
         A     SYS,DATASIZE       OLD END OF DATA AREA ADDR (RELOCAD)
         LA    A1,RELOCAD         ADDR OF ROUTINE TO RELOC BY DATA AREA
         MVC   SYSCONS(LSYS),SYSCONS-SPITBOLD(FR) MOVE INTERFACE STUFF
         L     R2,=V(SYSSETP)     LOAD INTERFACE ROUTINE ADDRESS
         BALR  R1,R2              GIVE INTERFACE NEW DATA AREA ADDRESS
         NOP   0                  IMPOSSIBLE TO HAVE ERROR RETURN
         ST    FR,DYNAMB          START OF NEW DYNAMIC MEMORY
         LR    PDR,FR             COPY STARTING ADDRESS
         A     PDR,DATASIZE       PUSH TO END OF NEW AREA
         ST    PDR,HICINUSE       ALSO HIGHEST LOCATION IN USE
         SH    PDR,=Y(STACKTOP)   STANDARD STACK OFFSET
*
*        NOW RELOCATE $$BASXX BASE TABLE ENTRIES
*
         SR    A2,A2              OFFSET INTO BASE TABLE
         LR    R1,DB1             FIRST POINTER
         SH    R1,=Y(VALUE)       INTRODUCE STANDARD OFFSET
         ST    R1,$$BAS1          STORE RELOCATED VALUE
         BAL   A2+1,RLOAD2        MERGE INTO LOOP, SETTING LOOP ADDR
*
*        LOOP THROUGH ENTRIES IN BASE TABLE
*
RLOAD1   LA    R1,$$BAS1(A2)      POINT TO NEXT ENTRY
         BALR  RETURN,A1          CALL RELOCAD ROUTINE TO RELOCATE
         BCR   Z,R2               ALL DONE IF NON-RELOC, GOTO RLOAD3
*
*        MERGE AT THIS POINT WHEN DEALING WITH $$BAS1
*
RLOAD2   LA    A1+1,VALUE(,R1)    POINT TO BLOCK ITSELF
         LA    R1,CBLKBOT(,A1+1)  POINT TO CBLKBOT FIELD
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)
         LA    R1,VBLKNXT(,A1+1)  POINT TO VBLKNXT FIELD
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)
         LA    A2,4(,A2)          INCREMENT BASE TABLE OFFSET
         BALR  R2,A2+1            BACK TO RLOAD1, SETTING END ADDRESS
         EJECT
*
*        HERE AFTER PROCESSING BASE TABLE, NOW RELOCATE MISC POINTERS
*
RLOAD3   LA    A2,NDRELOC*4-4     OFFSET TO LAST POINTER
*
*        RELOCATE VARIOUS POINTERS TO DATA AREA
*
         BALR  R2,0               SET START OF LOOP ADDRESS
RLOAD4   LA    R1,FDRELOC(A2)     POINT TO ENTRY
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)
         SH    A2,=H'4'           STEP BACK TO NEXT ENTRY
         BCR   NM,R2              LOOP BACK (RLOAD4) IF MORE TO GO
*
*        NOW DEAL WITH SCANMODE AND ANYTPTR
*
         L     R0,QPATSBAD        LOAD ADDRESS OF QPATSUBS
         ST    R0,SCANMODE        STORE AS VALUE OF SCANMODE
         LA    R1,ANYTPTR         POINT TO CURRENT ANY TABLE PTR
         BALR  RETURN,A1          RELOCATE IT (RELOCAD)
*
*        NOW START THE LOOP THROUGH THE VARIABLE HASH TABLE
*
         L     A2,HASHTBAD        POINT TO HASH TABLE
*
*        LOOP THROUGH SLOTS IN HASH TABLE
*
RLOADHL  LA    R1,VLINK(,A2)      POINT TO VAR BLOCK POINTER
*
*        LOOP THROUGH VARIABLE BLOCKS ON ONE HASH CHAIN
*
RLOAD5   BALR  RETURN,A1          RELOCATE AND LOAD VAR BLOCK POINTER
         BZ    RLOAD10            SKIP IF END OF CHAIN
         LR    A2+1,R1            POINT TO VARIABLE BLOCK
         LA    R1,VNAME(,A2+1)    POINT TO NAME FIELD
         BALR  RETURN,A1          TRY TO RELOCATE IT
         BNZ   RLOAD7             SKIP IF PTR WAS INTO DATA AREA
*
*        HERE WE HAVE A NAME POINTER INTO THE INITV TBL IN SPITBOLR
*
         S     R1,SPITRAD         MAKE POINTER RELATIVE
         A     R1,SPITRADN        ADD NEW BASE ADDRESS TO MAKE ABSOLUTE
         ST    R1,VNAME(,A2+1)    STORE RELOCATED NAME POINTER
         AH    R1,VNAME+SLENGTH(,A2+1)      STEP PAST NAME IN INITV TBL
         LR    A1+1,R1            COPY INITV ENTRY POINTER
         TM    SCHARS+1(A1+1),INITK         KEYWORD PRESENT?
         BNO   *+8                SKIP IF NOT
         LA    R1,1(,R1)          IF SO, STEP PAST IT
         TM    SCHARS+1(A1+1),INITP         STANDARD PATTERN?
         BNO   RLOAD6             SKIP IF NOT
         EJECT
*
*        HERE WE MUST RELOCATE A STANDARD PATTERN POINTER
*
         L     R0,VALUE(,A2+1)    LOAD OLD PATTERN POINTER
         S     R0,SPITXAD         MAKE POINTER RELATIVE
         A     R0,SPITXADN        ADD NEW STARTING ADDRESS
         ST    R0,VALUE(,A2+1)    STORE RELOCATED POINTER
         LA    R1,2(,R1)          STEP PAST PATTERN OFFSET IN INITV TBL
*
*        NOW TEST FOR STANDARD FUNCTION POINTER
*
RLOAD6   TM    SCHARS+1(A1+1),INITF         IS THERE A STANDARD FUNC?
         BNO   RLOAD7             SKIP IF NOT
         MVC   VFUNC+1(3,A2+1),SCHARS+1+1(R1)         IF SO, SET IT
         B     RLOAD8             SKIP
*
*        HERE IF NO STANDARD FUNCTION POINTER
*
RLOAD7   MVC   VFUNC+1(3,A2+1),NOFNAD       SET STANDARD NO FUNCTION AD
*
*        NOW WE DEAL WITH THE LABEL POINTER
*
RLOAD8   LA    R1,VLABL(,A2+1)    POINT TO LABEL POINTER
         BALR  RETURN,A1          TRY TO RELOCATE AS DATA AREA PTR
         BNZ   RLOAD9             SKIP IF IT WAS DATA AREA PTR
         S     R1,SPITXAD         ELSE IT WAS STANDARD, MAKE IT REL
         A     R1,SPITXADN        ADD NEW BASE POINTER
         ST    R1,VLABL(,A2+1)    STORE RELOCATED VALUE
*
*        HERE AFTER COMPLETELY RELOCATING VAR BLOCK EXCEPT FOR VLINK
*
RLOAD9   LA    R1,VLINK(,A2+1)    POINT TO HASH FORWARD LINK PTR
         B     RLOAD5             LOOP BACK
*
*        HERE AFTER DEALING WITH ALL VARIABLE BLOCKS ON ONE HASH CHAIN
*
RLOAD10  LA    A2,4(,A2)          POINT TO NEXT SLOT
         C     A2,HASHTBEN        MORE SLOTS TO GO?
         BL    RLOADHL            LOOP BACK IF MORE TO GO
*
*        NOW WE MUST DEAL WITH CONSTANT BLOCKS AND PATTERN STRUCTURES
*
         SR    DB4,DB4            INITIALIZE BASE TABLE OFFSET
         LH    A2,=H'-8'          BXH INCREMENT
*
*        START LOOP THROUGH 4K BLOCKS (BASE TABLE ENTRIES)
*
RLOAD11  L     A2+1,$$BAS1(DB4)   LOAD NEXT BASE TABLE POINTER
         LA    A2+1,VALUE(,A2+1)  POINT TO ACTUAL BLOCK
         LA    DB2,CBLKEND(,A2+1) POINT TO END OF BLOCK
         L     A2+1,CBLKBOT(,A2+1)          POINT TO LOWEST CONSTANT
         AR    A2+1,A2            BACK OFF BY 8 FOR BXH
         EJECT
*
*        LOOP THROUGH CONSTANTS IN ONE 4K BLOCK
*
RLOAD12  TM    0(DB2),RELOCBIT+EXPRBIT      RELOCATABLE OR VCODE?
         BZ    RLOAD17            SKIP TO END OF LOOP IF NOT
         LR    R1,DB2             ELSE COPY POINTER
         BALR  RETURN,A1          RELOCATE IT AND LOAD
         CLI   0(DB2),PCODE       DOES IT POINT TO A PATTERN STRUCTURE?
         BNE   RLOAD17            SKIP TO END OF LOOP IF NOT
*
*        HERE WE MUST RELOCATE ALL POINTERS IN A PATTERN STRUCTURE
*
         LA    A1+1,0(,R1)        COPY PATTERN PTR, CLEAR UPPER BYTE
         L     DB3,SPITPADN       NEW SPITBOLP ADDRESS
         S     DB3,SPITPAD        MINUS OLD = SPITBOLP RELOC FACTOR
         LM    R0,R1,PNOTHEN(A1+1)          LOAD PNOTHEN, PNOOR PTRS
         AR    R0,DB3             RELOCATE THEM
         AR    R1,DB3             . . . .
         STM   R0,R1,PNOTHEN(A1+1)          STORE RELOCATED POINTERS
         LA    R2,PATS(,A1+1)     POINT TO FIRST PATTERN NODE
         AH    A1+1,PTLENG(,A1+1) POINT TO END OF PATTERN NODES
*
*        LOOP THROUGH NODES IN PATTERN STRUCTURE
*
RLOAD13  L     R0,CODELOC(,R2)    LOAD PATTERN CODE POINTER
         AR    R0,DB3             RELOCATE AS SPITBOLP POINTER
         ST    R0,CODELOC(,R2)    STORE RELOCATED POINTER
         TM    PFLAGS(R2),PSPANFLG          POINTER TO MASTER SPAN TBL?
         BNO   RLOAD13A           SKIP IF NOT
*
*        HERE FOR SPECIAL CASE OF PTR TO MASTER SPAN TABLE
*
         L     R0,PARAM1(,R2)     LOAD POINTER
         S     R0,SPITRAD         MAKE RELATIVE
         A     R0,SPITRADN        COMPUTE RELOCATED VALUE
         ST    R0,PARAM1(,R2)     STORE RELOCATED VALUE
         B     RLOAD15            JUMP TO SKIP PAST NODE
*
*        HERE IF NOT SPECIAL CASE OF MASTER SPAN TABLE POINTER
*
RLOAD13A TM    PFLAGS(R2),PRELOC2 TEST FOR RELOCATABLE PARAMS
         BZ    RLOAD15            SKIP IF NEITHER RELOCATABLE
         BM    RLOAD14            SKIP IF PARAM1 RELOCATABLE
*
*        COME HERE IF PARAM2 IS RELOCATABLE
*
         LA    R1,PARAM2(,R2)     POINT TO SECOND PARAMETER
         BALR  RETURN,A1          RELOCATE IT
         B     RLOAD15            JUMP TO SKIP PAST NODE
*
*        HERE IF PARAM1 IS RELOCATABLE
*
RLOAD14  LA    R1,PARAM1(,R2)     POINT TO FIRST PARAMETER
         BALR  RETURN,A1          RELOCATE IT
         EJECT
*
*        HERE TO BUMP PAST FULLY RELOCATED NODE
*
RLOAD15  TM    PFLAGS(R2),PARM1+PARM2       TEST NUMBER OF PARAMETERS
         LA    R2,LPRM0-PATS(,R2) BUMP PAST STANDARD STUFF ANYWAY
         BZ    RLOAD16            SKIP IF NO PARAMETERS
         BM    *+8                SKIP IF ONLY ONE PARAMETER
         LA    R2,4(,R2)          SKIP PAST PARAM2
         LA    R2,4(,R2)          SKIP PAST PARAM1
*
*        HERE WE ARE POINTING TO THE NEXT NODE
*
RLOAD16  CR    R2,A1+1            MORE NODES TO GO?
         BL    RLOAD13            LOOP BACK IF SO
*
*        HERE WE MOVE TO THE NEXT CONSTANT IN THIS 4K BLOCK
*
RLOAD17  BXH   DB2,A2,RLOAD12     LOOP BACK IF MORE TO GO IN THIS BLOCK
*
*        HERE WE LOOP TO THE NEXT 4K BLOCK
*
         LA    DB4,4(,DB4)        INCREMENT BASE TABLE OFFSET
         CH    DB4,CURBASE        ANY MORE TO GO?
         BNH   RLOAD11            SKIP BACK IF NOT
*
*        REINITIALIZE UNDEFINED OPERATOR TABLE
*
         L     R0,=A(XER09002-FCODE)        POINT TO FIRST ERROR LOC
         SR    R1,R1              SET OFFSET TO FIRST ENTRY
         LA    R2,NOPTRS          SET NUMBER OF ENTRIES TO REINITIALIZE
         BALR  DB4,0              GET ADDRESS OF LOOP IN REG
         ST    R0,OPTRTABL(R1)    STORE AN ENTRY
         SH    R0,=H'2'           BACK OFF TO NEXT ERROR LOC
         LA    R1,4(,R1)          BUMP TABLE POINTER
         BCTR  R2,DB4             LOOP BACK TILL ALL SET
*
*        AT THIS POINT ALL RELOCATION IS COMPLETE
*
         ZAP   GCOLCNT,=P'0'      RESET GARBAGE COLLECTION COUNT
         MVC   CSECTAD(32),CSECTADN         SET NEW CSECT ADDRESSES
         L     SYS,SPITAAD        LOAD STANDARD SYSTEM AREA BASE REG
         L     RETURN,RLOADTRA    LOAD ADDRESS OF XEQ MERGE POINT
         LR    FRETURN,RETURN     SET UP BASE REGISTER FOR XEQGOGO
         L     R1,SPITRAD         ADDRESS OF SPITBOLR
         USING SPITBOLR,R1        TELL ASSEMBLER
         B     EXECUTE            JUMP TO EXECUTE SECTION
         DROP  R1                 DROP TEMPORARY BASE REG
         EJECT
*
*        CONSTANTS FOR RELOAD ROUTINE
*
NOFNAD   DC    AL3($$NOFN-FCODE)  UNDEFINED FUNCTION TRANSFER ADDRESS
QPATSBAD DC    A(QPATSUBS)        DEFAULT SETTING FOR SCANMODE
*
*        NEW CSECT ADDRESSES
*
         EXTRN SPITBOLL,SPITBOLH  OLD DATA REGIONS (OBJECT MODULE)
CSECTADN DS    0F                 START OF NEW CSECT ADDRESSES
SPITCADN DC    A(SPITBOLC)        COMPILER
SPITRADN DC    A(SPITBOLR)        ROOT PHASE
SPITPADN DC    A(SPITBOLP)        PATTERN MATCH ROUTINES
SPITXADN DC    A(SPITBOLX)        NON-ADDRESSABLE EXECUTION ROUTINES
SPITAADN DC    A(SPITBOLA)        ADDRESSABLE EXECUTION ROUTINES, DATA
SPITFADN DC    A(SPITBOLF)        STANDARD FUNCTION DEFINITIONS
SPITLADN DC    A(SPITBOLL)        LOW CORE OF OLD DATA AREA
SPITHADN DC    A(SPITBOLH)        HIGH CORE OF OLD DATA AREA
*
RLOADTRA DC    A(XEQGOGO)         ADDRESS OF EXECUTION MERGE POINT
         EJECT
*
*        THE ORIGINAL DATA AREA WAS SEPARATED INTO TWO PARTS BY THE
*        OBJECT MODULE GENERATOR (SPITBOLL AND SPITBOLH). THIS ROUTINE
*        DETERMINES WHICH SECTION WAS REFERENCED AND PERFORMS
*        RELOCATION --
*
*        (R1)                     POINTS TO FIELD TO BE RELOCATED
*        (A1)                     POINTS TO RELOCAD ROUTINE
*        BALR  RETURN,A1
*        (CC)                     NON-ZERO IF RELOCATION SUCCESSFUL
*                                 ZERO IF NOT A DATA AREA POINTER
*        (R1)                     RELOCATED POINTER
*                                 UNCHANGED POINTER IF CC=ZERO
*
*        THE RELOCATED POINTER IS ALSO STORED BACK INTO THE FIELD
*
RELOCAD  L     A1,0(,R1)          LOAD POINTER TO BE RELOCATED
         LA    R0,0(,A1)          STRIP UPPER BYTE
         C     R0,SPITLAD         BELOW OLD AREA?
         BL    RELOCADX           EXIT IF SO (NOT IN DATA AREA)
         CR    R0,SYS             ABOVE OLD DYNAMIC AREA?
         BH    RELOCADX           SKIP IF SO (NOT IN DATA AREA
*
*        HERE WE HAVE A POINTER WHICH MUST BE RELOCATED
*
         C     R0,SPITHAD         LOW CORE OR HIGH CORE SECTION?
         BNL   RELOCADH           SKIP IF HIGH CORE SECTION
*
*        HERE WE HAVE A POINTER TO THE LOW CORE SECTION TO RELOCATE
*
         S     A1,SPITLAD         SUBTRACT OLD BASE
         A     A1,SPITLADN        ADD NEW BASE
         B     RELOCADR           SKIP TO RETURN
*
*        HERE WE HAVE A POINTER TO THE HIGH CORE SECTION TO RELOCATE
*
RELOCADH S     A1,SPITHAD         SUBTRACT OLD BASE
         A     A1,SPITHADN        ADD NEW BASE
*
*        MERGE HERE AFTER RELOCATING POINTER
*
RELOCADR ST    A1,0(,R1)          STORE RELOCATED POINTER
         LR    R1,A1              COPY TO RESULT REG
         LA    A1,RELOCAD         RESET CALL REGISTER
         BR    RETURN             RETURN TO CALLER (CC = NON-ZERO)
*
*        HERE IF POINTER IS NOT TO DATA AREA
*
RELOCADX CR    R0,R0              SET CC = ZERO
         LR    R1,A1              COPY NON-RELOCATED POINTER
         LA    A1,RELOCAD         RESTORE CALL REGISTER
         BR    RETURN             RETURN TO CALLER (CC = ZERO)
         DROP  FRETURN            THROUGH WITH THIS BASE REG
.SKIPLLL ANOP
         TITLE 'SPITBOLC -- CONSTANTS'
*
*        MISCELLANEOUS CONSTANTS
*
         DS    0F                 ALLIGN
FULWRDAJ DC    X'FFFFFFFC'        ALLIGN TO FULLWORD
TEMSTKBS DC    Y(0)               BASE FOR TEMPORARY LOCATIONS
         DC    S(TEM#1+8(PDR))    . . . .
NULBLK   DC    A(OPNCN*256*256*256)         NULL OPND BLOCK FOR EXPAN
B$$ECON  B     $$ECON             BRANCH TO END CONSTANT EXPR CODE
PONE     DC    P'1'               DECIMAL ONE
*
*        STANDARD COMPILE TIME SETTINGS OF CONTROL CARD SWITCHES
*
SWITCHD  EQU   *                  START OF DEFAULTS
         DC    AL1(0)             -NOCODE
         DC    AL1(0)             -SINGLE
         DC    AL1(1)             -FAIL
         DC    AL1(1)             -IN72
         DC    AL1(1)             -LIST
         DC    AL1(0)             -ERRORS
         DC    AL1(1)             -OPTIMIZE
         DC    AL1(0)             -NOPRINT
         DC    AL1(0)             -NOSEQUENCE
*
PATCHC   DC    10A(0)             SPITBOLC PATCH AREA
*
*        LITERALS
*
         LTORG ,                  PLACE LITERALS HERE
         TITLE 'SPITBOLC -- ROUTINE TO LINK TO EXECUTION'
         AIF   (&LMOD EQ 1).SKIPSS2
*
*        COME HERE AT END OF COMPILATION, PRINT STATISTICS
*
XEQGO    BALR  CB1,0              ENSURE ADDRESSABILITY
         USING *,CB1              TELL ASSEMBLER ABOUT NEW BASE VALUE
         ST    LC,ENDCODAD        SAVE END OF GENERATED CODE
         MVI   LINELEFT+1,1       SET FOR NEW PAGE
         MVC   OUSTITL,OUSTITL-1  CLEAR SUBTITLE
         MVI   DUBLFLG,1          DOUBLE SPACE THIS OUTPUT
         L     R2,=V(SYSTIME)     LOAD ADDRESS OF TIMER ROUTINE
         BALR  R1,R2              CALL TIMER ROUTINE
         NOP   0                  NO ERROR RETURN POSSIBLE
         S     R0,TIME            SUBTRACT START TIME
         MVC   BUFR,BUFR-1        CLEAR OUTPUT BUFFER
         CVD   R0,SCANWRK         CONVERT COMPILATION TIME TO DECIMAL
         MVC   BUFR(33),CTIMEN    MOVE IN COMP TIME MSG + EDIT PATTERN
         ED    BUFR+16(9),SCANWRK+4         EDIT COMPILATION TIME
         BAL   R7,LISTERU         LIST COMPILATION TIME
         LR    R0,LC              COPY CURRENT CODE POINTER
         S     R0,CODEADR         SUBTRACT STARTING ADDRESS
*
*        NOW PREPARE TO PRINT STATISTICS ON SPACE USAGE
*
         LA    LC,3(,LC)          PUSH LC LAST FULLWORD
         N     LC,FULWRDAJ        ADJUST TO FULLWORD BOUNDARY
         ST    R0,0(,LC)          STORE LENGTH OF CODE
         MVC   4(12,LC),STRUSED   SET STRUSED, VARUSED, CONUSED
         A     R0,STRUSED         COMPUTE TOTAL USED
         A     R0,VARUSED         . . . .
         A     R0,CONUSED         . . . .
         ST    R0,16(,LC)         STORE TOTAL
         L     R0,HICINUSE        GET END OF CORE AFTER SUBEX GONE
         SR    R0,LC              COMPUTE MEMORY AVAILABLE
         SH    R0,=Y(STACKTOP)    ADJUST FOR PDR OFFSET FACTOR
         ST    R0,20(,LC)         STORE AVAILABLE MEMORY
         MVC   BUFR(34),BUFR-1    BLANK BUFFER
         MVC   BUFR(L'MEMMSG),MEMMSG        SET MEMORY USAGE MESSAGE
         BAL   R7,LISTERU         LIST LINE
         LA    A1+1,6             SET SIX LINES TO PRINT
         LR    A1,LC              SET POINTER TO 1ST QUANTITY TO PRINT
         LA    A2,MEMMSGS         POINT TO MESSAGES
         MVC   BUFR(40),BUFR-1    CLEAR BUFFER
         EJECT
*
*        LOOP TO PRINT VARIOUS QUANTITIES
*
XEQGOML  MVC   BUFR(10),0(A2)     MOVE PROPER CAPTION
         LA    A2,10(,A2)         BUMP POINTER
         MVC   BUFR+18(7),MSGMEME EDIT PATTERN FOR SPACE USED
         L     R0,0(,A1)          LOAD QUANTITY TO CONVERT
         LA    A1,4(,A1)          POINT TO NEXT QUANTITY
         CVD   R0,SCANWRK         CONVERT TO DECIMAL
         ED    BUFR+17(8),SCANWRK+4         EDIT PARAMETER VALUE
         BAL   R7,LISTERU         LIST LINE
         BCT   A1+1,XEQGOML       LOOP BACK TILL ALL PRINTED
*
*        NOW PRINT COMMENT ERRORS ENCOUNTERED
*
         MVC   BUFR(40),BUFR-1    CLEAR BUFFER
         MVC   BUFR(L'XEQGONOE),XEQGONOE    SET NO ERRORS MSG IN CASE
         CP    ERRCOUNT,=P'0'     ANY COMPILATION ERRORS?
         BZ    XEQGOPRE           SKIP IF NO ERRORS
         MVC   BUFR(25),XEQGONER  ELSE SET MSG & EDIT PATTERN FOR ERRS
         ED    BUFR+19(6),ERRCOUNT          EDIT COUNT OF ERRORS
*
*        MERGE HERE TO PRINT 'NO ERRORS' OR 'NUMBER OF ERRORS...'
*
XEQGOPRE BAL   R7,LISTERU         LIST LINE
         B     XEQGOZR            JUMP TO NEXT SECTION
*
*        CONSTANTS FOR STATISTICS PRINTOUT
*
CTIMEN   DC    C'COMPILATION TIME '
         DC    X'202021204B202020'
         DC    C' SECONDS'
*
MEMMSG   DC    C'MEMORY USAGE (DECIMAL BYTES)'
*
MEMMSGS  DC    CL10'CODE:'        CAPTIONS FOR SPACE USAGE
         DC    CL10'STRINGS:'
         DC    CL10'VARIABLES:'
         DC    CL10'CONSTANTS:'
         DC    CL10'TOTAL:'
         DC    CL10'AVAILABLE:'
*
MSGMEME  DC    X'20202020202120'  EDIT PATTERN FOR SPACE USED
*
XEQGONOE DC    C'SUCCESSFUL COMPILATION'
*
XEQGONER DC    C'COMPILATION ERRORS  '
         DC    X'2020202020'
         EJECT
*
*        HERE WE SCAN DOWN THE CONSTANT HASH TABLE CHAINS RESETTING
*        THE CONSTANTS TO THEIR STANDARD EXECUTION TIME FORMAT
*
XEQGOZR  LA    R1,63*4            SET OFFSET TO LAST HASH SLOT
         SR    R0,R0              CLEAR FOR IC
*
*        LOOP THROUGH HASH SLOTS
*
XEQGOL1  L     R2,CHASH(R1)       LOAD POINTER TO FIRST ITEM ON CHAIN
*
*        LOOP THROUGH ITEMS ON ONE HASH CHAIN
*
XEQGOL2  LA    R3,0(,R2)          COPY POINTER AND STRIP UPPER BYTE
         LTR   R3,R3              END OF CHAIN?
         BZ    XEQGOC             SKIP IF END OF CHAIN
         L     R2,CHASHL(,R3)     LOAD POINTER TO NEXT BLOCK ON CHAIN
         XC    VALUE+1(3,R3),VALUE+1(R3)    CLEAR CHASHL FIELD
         CLI   VALUE(R3),SCODE    IS THIS A STRING CONSTANT?
         BNE   XEQGOL2            DONE IF REAL OR INTEGER
         MVC   VALUE+1(3,R3),CSADR+1(R3)    ELSE MOVE STRING POINTER
         IC    R0,CSLENGTH(,R3)   LOAD 360 LENGTH OF STRING
         ST    R0,VALUE+4(,R3)    STORE LENGTH, SET SOFFSET = 0
         B     XEQGOL2            LOOP BACK
*
*        HERE TO MOVE TO NEXT HASH SLOT
*
XEQGOC   SH    R1,=H'4'           BACK OFF TO NEXT HASH SLOT
         BNM   XEQGOL1            LOOP BACK IF MORE SLOTS TO GO
         EJECT
*
*        NOW WE CHECK FOR LISTING OF GENERATE CODE
*
         CLI   CODESW,0           CODE LISTING REQUIRED?
         BE    *+8                SKIP IF NOT
         BAL   RF,PRCODE          ELSE LIST GENERATE CODE
*
*        SAVE LIMITS OF DYNAMIC STORAGE
*
         LA    LC,3(LC)           PUSH UP LC TO PREPARE FOR FULLWRDADJ
         N     LC,FULWRDAJ        PUT ON FULLWORD
         ST    LC,DYNAMB          SAVE LOWER BOUND OF DYNAMIC STORAGE
         L     R2,=V(SYSTIME)     GET TIMER ROUTINE ADDRESS
         BALR  R1,R2              CALL ROUTINE
         NOP   0                  NO ERROR RETURN POSSIBLE
         ST    R0,TIME            SAVE TIME
         L     PDR,SUBEXBOT       START OF CONSTANT CODE ADDR
         LR    R5,PDR             SAVE IN R5 (A1+1) FOR LATER
         N     PDR,=X'FFFFFFF8'   ADJUST TO DOUBLW WORD BOUNDARY
         SH    PDR,=Y(STACKTOP)   CALCULATE INITIAL VALUE OF PDR
         L     FR,DYNAMB          GET LOWER LIMIT OF DYNAMIC STORAGE
         SER   SINC,SINC          INDICATE CONSTANT EXPR EVALUATION
         SER   SCNT,SCNT          CLEAR STATEMENT COUNT REGISTER
         XI    STAGE,$EXECUTE+$COMPILE      INDICATE EXECUTE TIME
*
*        LOAD EXECUTION BASE REGISTER
*
         L     SYS,=A(SPITBOLA)   SET EXECUTE BASE REG
         ST    PDR,PDRLOC         SAVE INITIAL PDR LOCATION FOR FAILURE
*
*        INITIALIZE UNDEFINED OPERATORS TO UNDEFINED
*
         L     R0,=A(XER09002-FCODE)        POINT TO 1ST ERROR MESSAGE
         SR    R1,R1              SET OFFSET TO FIRST ENTRY
         LA    R2,NOPTRS          SET NUMBER OF ENTRIES TO INITIALIZE
         BALR  DB4,0              SET LOOP ADDRESS REGISTER
         ST    R0,OPTRTABL(R1)    STORE AN ENTRY
         SH    R0,=H'2'           BACK OFF TO PREVIOUS MESSAGE
         LA    R1,4(,R1)          BUMP POINTER
         BCTR  R2,DB4             LOOP BACK IF MORE TO GO
         EJECT
*
*        MISCELLANEOUS HOUSE KEEPING
*
         XC    ZTBL,ZTBL          CLEAR TABLE OF ZEROS
         MVI   BREAKTBL+CTCHARS,X'FF'       SET NONZERO IN BREAK TABLE
         XC    BREAKTBL+CTCHARS+1(255),BREAKTBL+CTCHARS+1  ZERO REST
         MVC   XEQVALS(LXEQVALS),XEQINIT    INITIALIZE XEQ WORK AREAS
         MVC   V$MAXLN(8),=F'5000,50000'    SET &MAXLNGTH, &STLIMIT
         MVI   V$INPUT+3,1        SET &INPUT = 1
         MVI   V$OUTPUT+3,1       SET &OUTPUT = 1
         LCR   R0,PDR             GET A NEGATIVE FLAG FOR STACK END
         ST    R0,FBLOKLOC(,PDR)  AND PLACE IT ON THE STACK
         STE   ZR,PNAME(,PDR)     SET PNAME FLD NOT IN USE (FOR GCOL)
         LM    DB2,DB3,$$BAS2     INITIALIZE PTRS TO 2ND, 3RD 4K BLOCKS
*
*        HERE WE GO
*
         MVI   CRELFLG,1          TELL GCOL TO PROCESS CONSTANTS
         CLI   SUPRXEQ,0          CAN WE EXECUTE?
         LR    RETURN,A1+1        COPY JUMP ADDRESS
         BE    EXECUTE            IF WE CAN EXEUTE, DO IT
         MVI   BYPASXEQ,1         ELSE SUPPRESS EXECUTION
         B     EXECUTE            AND JUMP TO LET XEQ GIVE MESSAGE
         DROP  CB1,CB2,CB3,CB4    DROP COMPILER BASE REGS
*
*        LITERALS AND PATCH SPACE FOR XEQGO
*
         DC    5A(0)
         LTORG ,
.SKIPSS2 ANOP
         TITLE 'SPITBOLR -- START OF CONTROL SECTION'
*
*        THE SPITBOLR CONTROL SECTION CONTAINS ROUTINES, CONSTANTS AND
*        WORK AREAS USED BY THE COMPILER AND EXECUTE PACKAGE
*
*        IN THE TWO PHASE VERSION, THIS IS THE ROOT PHASE
*
         BEGIN R                  START OF SPITBOLR, SPITBLLR CSECT
         USING SPITBOLA,SYS       SYSTEM BASE REG FOR TOUEINS
         TITLE 'SPITBOLR -- STRING TO NUMERIC CONVERSION ROUTINE'
*
*        THIS ROUTINE IS USED BOTH AT COMPILE AND EXECUTE TIME TO
*        CONVERT A STRING TO A NUMERIC VALUE-- THE RESULT OF THE
*        CONVERSION IS IN THE STANDARD 8-BYTE FORMAT AND IS DETERMINED
*        AS FOLLOWS --
*
*        THE RESULT IS AN INTEGER           IF THE STRING IS A SIGNED
*                                           OR UNSIGNED INTEGER IN THE
*                                           RANGE -2**31-1 < N < 2**31
*
*        THE RESULT IS A REAL               IF THE STRING IS A FLOATING
*                                           POINT NUMBER WITH 8 OR
*                                           FEWER SIGNIFICANT DIGITS
*
*        THE RESULT IS A DREAL              IF THE STRING IS A FLOATING
*                                           POINT NUMBER WITH MORE THAN
*                                           8 SIGNIFICANT DIGITS OR AN
*                                           EXPONENT WITH A 'D'
*
*
*        CALLING SEQUENCE --
*
*        (R2)                     ADDRESS OF STGTONUM ROUTINE
*        (A1)                     STARTING ADDRESS (MINUS SCHARS)
*        (A1+1)                   360 LENGTH
*        BALR  R1,R2
*        => ERROR RETURN IF UNCONVERTIBLE
*        => NORMAL RETURN
*        (A1,A1+1)                NUMERIC RESULT
*
*        ALL OTHER REGISTERS ARE SAVED AND RESTORED EXCEPT (R0)
*
         EJECT
*
*        ENTRY POINT
*
         USING STGTONUM,R2        BASE REGISTER SET BY CALLER
STGTONUM STM   R6,R10,STNSV       SAVE WORK REGS
         ST    R1,STNRTN          SAVE RETURN POINT
         LR    R6,R2              SWITCH BASE REGISTERS
         DROP  R2                 TELL ASSEMBLER
         USING STGTONUM,R6        ...
         CH    A1+1,=H'15'        MORE THAN 15 DIGITS?
         BNL   STN7               IF SO, SKIP TO TRY AS REAL
         CLI   SCHARS(A1),C'0'    IS FIRST CHARACTER A DIGIT?
         BL    STN2               SKIP IF NOT (MAY BE A SIGN)
*
*        COME HERE TO TRY FOR INTEGER WITH NO LEADING SIGN
*
STN0     EX    A1+1,STNT1         CHECK FOR ALL DIGITS
         BNZ   STN7               SKIP TO TRY AS REAL IF NOT ALL DIGITS
         EX    A1+1,STNP1         PACK UP DIGITS IF OK
*
*        COME HERE TO CONVERT INTEGER TO BINARY
*
STN1     CVB   A1+1,STNWRK        CONVERT TO BINARY
*
*        THIS IS AN INTERRUPT LOCATION (INTEGER DIVIDE ON TOO LARGE)
*        ON INTERRUPT, AN EXIT TO STNE (CONVERSION ERROR) IS TAKEN
*
STN1A    NOPR  1                  ENSURE PRECISE INTERRUPT
         SR    A1,A1              IF OK, INDICATE INTEGER RESULT
         L     R6,STNSV           RESTORE R6
         L     R1,STNRTN          RELOAD RETURN POINT
         B     4(,R1)             GIVE SUCCESSFUL RETURN
*
STNT1    TRT   SCHARS(*-*,A1),SCANTB3       TEST FOR DIGITS (NO SIGN)
STNP1    PACK  STNWRK,SCHARS(*-*,A1)        PACK (NO SIGN)
*
*        COME HERE IF FIRST CHARACTER IS NOT A DIGIT
*
STN2     SH    A1+1,=H'1'         DECREMENT LENGTH FOR POSSIBLE SIGN
         BM    STNE               ONE CHARACTER NOT A DIGIT IS AN ERROR
         EX    A1+1,STNT2         TEST FOR ALL DIGITS AFTER SIGN
         BNZ   STN6               SKIP IF NOT ALL DIGITS
         EX    A1+1,STNP2         ELSE PACK UP DIGITS
         CLI   SCHARS(A1),C'-'    DID WE HAVE A MINUS SIGN?
         BNE   STN5               SKIP IF NOT
         NI    STNWRK+7,X'FD'     CHANGE PACKED SIGN TO MINUS
         B     STN1               AND JUMP BACK TO CONVERT TO BINARY
*
STNT2    TRT   SCHARS+1(*-*,A1),SCANTB3     TEST FOR DIGITS WITH SIGN
STNP2    PACK  STNWRK,SCHARS+1(*-*,A1)      PACK DIGITS WITH SIGN
         EJECT
*
*        COME HERE FOR LEADING "SIGN" NOT A MINUS SIGN
*
STN5     CLI   SCHARS(A1),C'+'    IS IT PLUS SIGN?
         BE    STN1               SKIP BACK IF SO TO CONVERT TO BINARY
*
*        COME HERE IF NOT INTEGER WITH SIGN AFTER ALL
*
STN6     LA    A1+1,1(,A1+1)      ADJUST LENGTH BACK FOR SIGN FUDGE
*
*        COME HERE IF NOT INTEGER -- CHECK FOR POSSIBLE BLANKS
*
STN7     LA    A1+1,1(,A1+1)      ADJUST TO GET REAL LENGTH
         CLI   SCHARS(A1),C' '    TEST FOR LEADING BLANK
         BE    STNBL              SKIP IF LEADING BLANKS
         LA    R2,SCHARS-1(A1,A1+1)         POINT TO LAST CHARACTER
         CLI   0(R2),C' '         DO WE HAVE A TRAILING BLANK?
         BE    STNBLD             SKIP IF TRAILING BLANK(S)
*
*        COME HERE TO TRY FOR REAL WITH POSSIBLE SIGN
*
         CLI   SCHARS(A1),C'-'    DO WE HAVE AN INITIAL MINUS?
         BNE   STN7A              SKIP IF NOT
         MVI   STNFLG,STNM        ELSE SET FLAG FOR NEGATIVE
         LA    A1,1(,A1)          PUSH CHARACTER POINTER
         BCT   A1+1,STN9          AND SKIP, DECREMENTING LENGTH
*
*        COME HERE IF NOT A MINUS SIGN TO START
*
STN7A    CLI   SCHARS(A1),C'+'    DO WE HAVE A PLUS SIGN?
         BNE   STN8               SKIP IF NOT
         LA    A1,1(,A1)          ELSE BUMP PAST PLUS SIGN
         BCTR  A1+1,0             DECREMENT LENGTH
*
*        COME HERE FOR POSITIVE REAL
*
STN8     MVI   STNFLG,0           SET POSITIVE
*
*        COME HERE WITH SIGN FLAG SET ALL READY TO GO
*
STN9     LA    R9,1               GET CONSTANT OF ONE FOR GENERAL USE
         SR    R0,R0              CLEAR R0,R1 FOR DIGIT COLLECTION
         SR    R1,R1              ... DIGS ARE COLLECTED AS PACKED DEC
         SR    R2,R2              SET SCALE = 0
         LR    R7,R9              (R7)=1 BEFORE DEC PT. 0 AFTER DEC PT.
         EJECT
*
*        LOOP TO COLLECT DIGITS
*
STN10    CLI   SCHARS(A1),C'0'    IS THIS A DIGIT?
         BL    STN13A             SKIP IF IT IS NOT A DIGIT
*
*        COME HERE FOR A DIGIT
*
         CL    R0,=X'0FFFFFFF'    CHECK FOR 16 DIGITS COLLECTED ALREADY
         BH    STN12              SKIP IF SO (IGNORE DIGIT)
         SLDL  R0,4               MAKE ROOM FOR NEW DIGIT
         IC    R10,SCHARS(A1)     LOAD CHARACTER
         N     R10,=X'0000000F'   REMOVE ZONE BITS
         OR    R1,R10             STICK IN NEW DIGIT
         BCTR  R2,0               ADJUST SCALE (WITH NEXT INSTRUCTION)
*
*        COME HERE WHEN DIGIT IS SKIPPED (SCALING IS REVERSED)
*
STN12    AR    R2,R7              COMPLETE ADJUSTMENT OF SCALE
*
*        JUMP HERE AFTER DEC POINT
*
STN13    AR    A1,R9              PUSH CHARACTER POINTER
         BCT   A1+1,STN10         LOOP BACK IF MORE CHARACTERS
*
*        FALL THROUGH HERE IF STRING EXHAUSTED (NO EXPONENT)
*
         BCT   R7,STN14           SKIP IF WE HAD DEC POINT, ELSE ERROR
*
*        COME HERE FOR ALL CONVERSION ERRORS
*
STNE     LM    R6,R10,STNSV       RESTORE REGS
         L     R1,STNRTN          RELOAD RETURN POINT
         BR    R1                 GIVE ERROR RETURN
*
*        COME HERE IF NOT A DIGIT
*
STN13A   BCT   R7,STN14           DECREMENT R7, SKIP IF ALREADY HAD A .
         CLI   SCHARS(A1),C'.'    ELSE IS THIS A DEC POINT?
         BE    STN13              SKIP BACK IF SO, ELSE FALL OUT
         EJECT
*
*        HERE AFTER LOOP (EITHER NO CHRS LEFT OR STOPPED BY NON-DIGIT)
*        CONVERT COLLECTED DIGITS TO BINARY INTEGER IN A1,A1+1
*
STN14    STM   A1,A1+1,STNSV2     SAVE SCAN REGISTERS
         SR    A1,A1              CLEAR HIGH ORDER OF RESULT
         LR    R10,R0             SA0E HIGH ORDER DIGITS COLLECTED
         BAL   R7,STNCVB          CONVERT LOW ORDER TO BINARY INTO A1+1
         LTR   R1,R10             RECALL (AND TEST) HIGH ORDER DIGITS
         BZ    STN16              SKIP IF NONE (REAL CASE)
         OI    STNFLG,STND        ELSE SET FOR DREAL RESULT
         LR    R10,A1+1           SAVE CONVERTED LOW ORDER
         BAL   R7,STNCVB          CONVERT HIGH ORDER DIGS TO BINARY
         M     A1,=F'100000000'   MULTIPLY BY 10**8 FOR LOW ORDER DIGS
         ALR   A1+1,R10           ADD IN LOW ORDER
         BC    12,*+6             SKIP IF NO CARRY
         AR    A1,R9              ELSE ADD 1 (CARRY) TO HI ORDER RESULT
*
*        COME HERE TO CONVERT INTEGER IN A1,A1+1 TO FLOATING POINT
*
STN16    STM   A1,A1+1,STNWRK     STORE INTEGER
         LM    A1,A1+1,STNSV2     RESTORE SCAN REGS
         MVI   STNWRK,X'4E'       SUPPLY EXPONENT
         LD    FA,STNWRK          LOAD UNNORMALIZED FLOATING POINT
         ADR   FA,ZR              NORMALIZE
         TM    STNFLG,STNM        TEST SIGN FLAG
         BNO   STN20              SKIP IF NOT MINUS
         LCDR  FA,FA              ELSE SET FLOATING POINT NUM NEGATIVE
*
*        COME HERE TO TEST FOR EXPONENT
*
STN20    LTR   A1+1,A1+1          DO WE HAVE ANY CHARS LEFT?
         BZ    STN30              SKIP IF NOT TO SCALING SECTION
         CLI   SCHARS(A1),C'E'    DO WE HAVE AN E?
         BE    STN21              SKIP IF SO
         CLI   SCHARS(A1),C'D'    DO WE HAVE A D?
         BNE   STNE               ANYTHING ELSE IS AN ERROR
         OI    STNFLG,STND        ELSE SET FLAG FOR DREAL RESULT
*
*        COME HERE WHEN WE ACTUALLY HAVE AN EXPONENT
*
STN21    SR    A1+1,R9            DECREMENT COUNT FOR D OR E
         CLI   SCHARS+1(A1),C'+'  DO WE HAVE A PLUS SIGN?
         BE    STN22              SKIP IF SO
         CLI   SCHARS+1(A1),C'-'  ELSE DO WE HAVE A MINUS SIGN?
         BNE   STN23              SKIP IF NOT
         OI    STNFLG,STNEM       SET FOR EXPONENT MINUS
         EJECT
*
*        COME HERE AFTER FINDING AN EXPONENT SIGN
*
STN22    AR    A1,R9              PUSH CHARACTER POINTER FOR SIGN
         SR    A1+1,R9            DECREMENT COUNT FOR SIGN
*
*        COME HERE TO CONVERT EXPONENT
*
STN23    SR    A1+1,R9            DECREMENT TO GET 360 LENGTH OF EXPON
         CLR   A1+1,R9            MUST BE ZERO OR ONE
         BH    STNE               ERROR IF NEGATIVE OR HIGHER THAN 1
         EX    A1+1,STNT2         CHECK FOR DIGITS
         BNZ   STNE               ERROR IF NOT
         EX    A1+1,STNP2         ELSE PACK DIGITS
         CVB   R9,STNWRK          CONVERT EXPONENT TO BINARY
         TM    STNFLG,STNEM       WAS EXPONENT NEGATIVE?
         BNO   *+6                SKIP IF NOT
         LCR   R9,R9              ELSE COMPLEMENT IT
         AR    R2,R9              ADD EXPONENT TO SCALE
*
*        COME HERE TO SCALE THE FLOATING POINT NUMBER BY MULTIPLYING
*        BY 10**N WHERE N IS THE SCALE
*
STN30    LA    R1,SCALER          POINT TO SCALING SUBROUTINE
         LR    R6,R2              GET VALUE OF SCALE
         DROP  R6                 DROP OUR BASE REGISTER
         BALR  R7,R1              MULTIPLY REAL BY 10**SCALE
         USING *,R7               OUR NEW BASE REGISTER
*
*        COME HERE WHEN WE ARE ALL READY WITH FLOATING POINT NUMBER
*
STN33    SDR   ZR,ZR              CLEAR ZR BACK TO ZERO
         STD   FA,STNWRK          STORE RESULTING FPT NUMBER
         TM    STNFLG,STND        TEST FOR DREAL TO BE RETURNED
         BO    STN40              SKIP IF SO
         EJECT
*
*        COME HERE IF REAL IS TO BE RETURNED
*
         XC    STNWRK+1(3),STNWRK+1         CLEAR UPPER 3 BYTES OF FRAC
         AD    FA,STNWRK          ADD LOW ORDER TO ROUND CORRECTLY
         STE   FA,STNWRK          STORE SHORT FORM ROUNDED RESULT
         L     A1+1,STNWRK        LOAD INTO RESULT REGISTER
         L     A1,=X'80000000'    SUPPLY REAL TYPE CODE
         LM    R6,R10,STNSV       RESTORE REGS
         L     R1,STNRTN          RELOAD RETURN POINT
         B     4(,R1)             RETURN TO CALLER
*
*        COME HERE IF DREAL IS TO BE RETURNED
*
STN40    XC    STNWRK+1(6),STNWRK+1         CLEAR ALL BUT LOW ORDER BYT
         AD    FA,STNWRK          ADD TO ROUND
         STD   FA,STNWRK          STORE ROUNDED RESULT
         LM    A1,A1+1,STNWRK     LOAD INTO RESULT REGS
         SRDL  A1,8               POSITION FOR DREAL
         AL    A1,=X'C0000000'    SUPPLY WCODE FOR DREAL
         LM    R6,R10,STNSV       RESTORE REGS
         L     R1,STNRTN          RELOAD RETURN POINT
         B     4(,R1)             RETURN TO CALLER
         DROP  R7                 DROP OUR NEW BASE REG
*
*        SCALING INSTRUCTIONS
*
STNS     DDR   FA,ZR              SCALE DOWN IF S < 0
         MDR   FA,ZR              SCALE UP IF S > 0
*
*        SUBROUTINE TO CONVERT TO BINARY
*
*        (R1)                     PACKED DECIMAL DIGITS
*        BAL   R7,STNCVB
*        (A1+1)                   BINARY RESULT
*
         USING STGTONUM,R6        STANDARD STGTONUM BASE REGISTER
STNCVB   SR    R0,R0              CLEAR HIGH ORDER
         SLDL  R0,4               MAKE ROOM FOR PACKED DEC SIGN
         STM   R0,R1,STNWRK       STORE PACKED NUMBER
         OI    STNWRK+7,X'0C'     SUPPLY PACKED PLUS SIGN
         CVB   A1+1,STNWRK        CONVERT TO BINARY
*
*        THIS IS AN INTERRUPT LOCATION (DATA -- CODES > X'F9')
*        ON INTERRUPT -- AN EXIT TO STNE (CONVERSION ERROR) IS TAKEN
*
STNCVBE  NOPR  1                  ENSURE PRECISE INTERRUPT
         BR    R7                 IF NO ERROR ON CONVERT -- RETURN
         EJECT
*
*        SECTION TO REMOVE LEADING BLANKS
*
STNBL    LA    A1,1(,A1)          CRANK PAST LEADING BLANK
         BCT   A1+1,STNBL2        SKIP DECREMENTING CHARS LEFT
         B     STNE               ELSE ALL BLANKS, SIGNAL CONVERT ERROR
*
*        COME HERE TO TEST FOR ANOTHER LEADING BLANK
*
STNBL2   CLI   SCHARS(A1),C' '    DO WE HAVE ANOTHER LEADING BLANK
         BE    STNBL              IF SO, LOOP BACK TO DELETE IT
*
*        COME HERE TO DELETE TRAILING BLANKS
*
STNBLDL  LA    R2,SCHARS-1(A1,A1+1)         POINT TO LAST CHARACTER
         CLI   0(R2),C' '         TEST FOR TRAILING BLANK
         BE    STNBLD             SKIP IF ANOTHER TRAILING BLANK
         BCT   A1+1,STN0          ELSE REENTER WITH COUNT PROPERLY SET
         B     STN0               JUMP EVEN IF ONLY ONE CHARACTER LEFT
*
*        COME HERE AFTER DETECTING THE INITIAL TRAILING BLANK
*
STNBLD   BCT   A1+1,STNBLDL       DECR CHAR COUNT (ALWAYS BRANCHES)
         DROP  R6                 DROP ORIGNAL BASE REGISTER
         TITLE 'SPITBOLR -- NUMERIC TO STRING ROUTINE'
*
*        (A1,A1+1) (R4,R5)        NUMERIC ITEM (INTEGER,REAL OR DREAL)
*        (R0)                     FORMAT -- SEE BELOW
*        L     R2,=A(NUMTOSTG)
*        BALR  R1,R2
*        (A1,A1+1)                STRING ADDR(-SCHARS) 360 LENGTH
*        (CONDITION CODE)         SET TO ZERO IF TABLE LOOKUP USED
*                                 (I.E. NO NEED TO COPY RESULT)
*
*        THE FOUR BYTE FORMAT DESCRIPTION CONSISTS OF THE FOLLOWING
*
*        DC    AL1(DREAL FORMAT, DREAL NDIGS, REAL FORMAT, REAL NDIGS)
*
*        NDIGS IS THE NUMBER OF DIGITS (DSECRIBED FURTHER BELOW)
*
*        FORMAT IS A NUMBER FROM 0 TO 5 AS FOLLOWS --
*
*        0)    FIXED IF POSSIBLE, ELSE FLOATING -- TRAILING ZEROS
*              SUPPRESSED -- NDIGS = NUMBER OF SIGNIFICANT DIGITS
*
*        1)    SAME AS 0 BUT WITHOUT SUPPRESSION OF TRAILING ZEROS
*
*        2)    FLOATING FORMAT (FORTRAN E ) NDIGS = NUM DEC PLACES
*              TRAILING ZEROS (IN FRACTION) SUPPRESSED
*
*        3)    LIKE 2 BUT WITH NO SUPPRESSION OF TRAILING ZEROS
*
*        4)    FIXED FORMAT (FORTRAN F) NDIGS = NUM DEC PLACES -- USES
*              FLOATING FORMAT IF MORE THAN 8 (REAL) OR 16(DREAL)
*              SIGNIFICANT DIGITS WOULD BE DISPLAYED -- TRAILING ZEROS
*              ARE SUPPRESSED
*
*        5)    LIKE 4 BUT WITH NO SUPPRESSION OF TRAILING ZEROS
*
         EJECT
*
*        ENTRY POINT
*
         USING *,R2               BASE REGISTER SET BY CALLER
NUMTOSTG LCR   A1,A1              TEST TYPE OF ARGUMENT
         BO    NTSR               SKIP IF REAL
         BP    NTSD               SKIP IF DREAL
*
*        COME HERE IF INTEGER
*
         CL    A1+1,=F'100'       IS IT IN RANGE 0 <= N < 100 ?
         BL    NTSI1              SKIP IF SO (SPECIAL ROUTINE)
*
*        CONVERT INTEGER GREATER THAN 100 OR NEGATIVE
*
         CVD   A1+1,NTSWRK        CONVERT TO DECIMAL
         MVC   NTSRSL(11),=X'2020202020202020202020'  SET EDIT PATTERN
         LR    R0,R1              SAVE RETURN POINT
         EDMK  NTSRSL(11),NTSWRK+2          GET STRING MARKING 1ST DIG
         LA    A1,0(,R1)          SAVE 1ST DIGIT LOC (STRIP UPPER BYTE)
         LR    R1,R0              RESTORE RETURN ADDRESS
         BNM   *+10               SKIP IF NON-NEGATIVE
         BCTR  A1,0               IF NEGATIVE, BACK OFF POINTER
         MVI   0(A1),C'-'         AND SUPPLY A MINUS SIGN
         LA    A1+1,NTSRSL+10     POINT TO LAST CHARACTER
         SR    A1+1,A1            CALCULATE 360 LENGTH OF RESULT
         SH    A1,=Y(SCHARS)      ADJUST FOR SCHARS OFFSET
         BR    R1                 RETURN TO CALLER
*
*        COME HERE FOR INTEGER IN RANGE 0 <= N < 100
*
NTSI1    CH    A1+1,=H'10'        IS IT LESS THAN 10 ?
         BL    NTSI2              SKIP IF SO
*
*        COME HERE TO CONVERT INTEGER IN THE RANGE 10 <= N < 100
*
         AR    A1+1,A1+1          DOUBLE TO FORM INDEX
         LA    A1,NTSD2-2*10-SCHARS(A1+1)   POINT TO PROPER TABLE LOC
         LA    A1+1,1             SET 360 LENGTH = 1
         CR    R0,R0              SET CC = ZERO FOR NO MOVE NEEDED
         BR    R1                 RETURN TO CALLER
*
*        COME HERE TO CONVERT INTEGER IN RANGE 0 <= N < 10
*
NTSI2    LA    A1,NTSD1-SCHARS(A1+1)        POINT TO PROPER TABLE LOC
         SR    A1+1,A1+1          SET 360 LENGTH = 0
         BR    R1                 RETURN TO CALLER
         EJECT
*
*        COME HERE FOR DREAL
*
NTSD     SRL   R0,16              POSITION TO GET DREAL FORMAT PARAMS
         LCR   A1,A1              RESTORE A1
         SLDL  A1,8               POSITION DREAL
         STM   A1,A1+1,NTSWRK     STORE LONG FORM REAL IN WORK AREA
         LD    ZR,TENTO16         LOAD 10**16 FOR DREAL
         B     NTSRM              JUMP TO MERGE
*
*        COME HERE FOR REAL
*
NTSR     ST    A1+1,NTSWRK        STORE REAL IN WORK AREA
         STE   ZR,NTSWRK+4        CLEAR LOW ORDER BYTES OF LONG REAL
         LD    ZR,TENTO8          LOAD 10**8 FOR REAL
*
*        MERGE HERE FOR REAL (ZR=10**8) AND DREAL (ZR=10**16)
*
NTSRM    LD    FA,NTSWRK          LOAD LONG FORM REAL
         LPER  FA,FA              FORCE POSITIVE
         STH   R0,NTSFRM          SAVE FORMAT PARAMETERS
         STM   R6,R10,NTSSAV      SAVE REGISTERS
         SR    R9,R9              CLEAR FOR IC
         IC    R9,NTSDGS          LOAD NUMBER OF DIGITS
         LR    R10,R9             COPY NUMBER OF DIGITS
         SLL   R10,3              * 8 TO FORM POWERS OF TEN TABLE INDEX
         CLI   NTSFRM,4           IS THIS FORMAT TYPE 4 OR 5 ?
         BL    NTS2               SKIP IF NOT
*
*        COME HERE FOR FORMAT CASES 4,5 (FIXED)
*
*        FOR THESE FORMATS, WE MULTIPLY BY 10**NDIGS -- IF THE RESULT
*        EXCEEDS 10**8(REAL) OR 10**16(DREAL) AFTER ROUNDING, WE SKIP
*        TO USE FLOATING FORMAT -- OTHERWISE, WE BRANCH TO THE STRING
*        CREATION ROUTINE WITH NPLACES=NDIGS, EXPONENT=0
*
         MD    FA,POWTEN(R10)     MULTIPLY BY 10**NDIGS
         AD    FA,=D'0.5'         ROUND
         CDR   FA,ZR              IS IT TOO BIG?
         BNL   NTS1               SKIP IF TOO LARGE FOR FIXED FORMAT
*
*        COME HERE FOR OK FIXED FORMAT OR ZERO IN ANY FORMAT
*
NTS0     LR    R6,R9              SET NPLACES = NDIGS
         SR    R7,R7              SET EXPONENT = 0
         B     NTSN               JUMP TO MAKE OUR STRING
         EJECT
*
*        COME HERE WHEN NUMBER IS TOO LARGE FOR FIXED FORMAT
*
NTS1     LD    FA,NTSWRK          RELOAD NUMBER AND MERGE FLOATING FMT
*
*        COME HERE FOR FORMAT CASES 0,1,2,3
*
*        FOR THESE CASES WE FIND Q SUCH THAT
*
*        10**(NDIGS-1) <= N*10**Q < 10**NDIGS
*
*        Q IS COMPUTED APPROXIMATELY AS NDIGS-E(LOG16/LOG10)
*        WHERE E IS THE HEXADECIMAL EXPONENT
*
NTS2     LTER  FA,FA              FIRST TEST FOR ZERO CASE
         BZ    NTS0               ALWAYS FIXED FORMAT FOR ZERO CASE
         IC    R0,NTSWRK          LOAD EXPONENT
         N     R0,=X'0000007F'    REMOVE CHARACTERISTIC SIGN
         SH    R0,=H'64'          REMOVE EXPONENT BIAS
         MH    R0,=H'1233'        E * LOG16/LOG10 * 2**10
         SRA   R0,10              DIVIDED BY 2**10 = E(LOG16/LOG10)
         SR    R0,R9              E(LOG16/LOG10)-NDIGS
         LCR   R6,R0              NDIGS-E(LOG16/LOG10)
         ST    R1,NTSRTN          SAVE RETURN POINT
         LA    R1,SCALER          POINT TO SCALING ROUTINE
         BALR  R7,R1              USE IT TO MULTIPLY FA * 10**Q
         L     R1,NTSRTN          RELOAD RETURN POINT
*
*        THIS APPROXIMATION MAY BE ONE OFF -- CHECK FOR THIS
*
         LCR   R6,R0              RESTORE ESTIMATE OF Q
         CD    FA,POWTEN-8(R10)   COMPARE WITH 10**(NDIGS-1)
         BNL   *+12               SKIP IF OK THAT WAY
         MD    FA,TENTO1          ELSE MULTIPLY BY 10
         AH    R6,=H'1'           AND ADJUST SCALE ACCORDINGLY
         AD    FA,=D'0.5'         ADD 0.5 TO ROUND
         CD    FA,POWTEN(R10)     CHECK AGAINST 10**NDIGS
         BL    *+10               SKIP IF OK (LESS THAN 10**NDIGS)
         DD    FA,TENTO1          ELSE DIVIDE BY 10
         BCTR  R6,0               AND ADJUST Q ACCORDINGLY
         CLI   NTSFRM,1           TEST FOR FLOATING FORMATS 2,3
         BH    NTSS2              SKIP IF SO
         EJECT
*
*        COME HERE FOR FORMATS 0,1 (FLOATING/FIXED)
*
*        IF 0<=Q<=NDIGS, THEN USE FIXED FORMAT -- PLACES=Q,EXPONENT=0
*        OTHERWISE, WE TREAT AS FLOATING FORMAT
*
         SR    R7,R7              CLEAR EXPONENT IN CASE WE ARE OK
         CLR   R6,R9              ARE WE IN RANGE 0 <= Q <= NDIGS
         BNH   NTSN               JUMP TO MAKE STRING IF SO (PLACES=Q)
*
*        COME HERE FOR FLOATING -- PLACES=NDIGS, EXPONENT=NDIGS-Q
*
NTSS2    LR    R7,R9              COPY NDIGS
         SR    R7,R6              SET EXPONENT=NDIGS-Q
         LR    R6,R9              SET PLACES=NDIGS
*
*        COME HERE TO DO ACTUAL CONVERSION --
*
*        (FA)                     REAL -- SCALED TO INTEGER AND ROUNDED
*        (R7)                     EXPONENT TO BE PRINTED
*        (R6)                     NUMBER OF DECIMAL PLACES
*
NTSN     AW    FA,=X'4E00000000000000'      RIGHT JUSTIFY BINARY POINT
         L     R0,NTSWRK          SAVE SIGN OF REAL
         STD   FA,NTSWRK          STORE "INTEGERIZED" REAL
         MVI   NTSWRK,0           CLEAR EXPONENT
         LM    A1,A1+1,NTSWRK     LOAD DOUBLE LENGTH INTEGER
         D     A1,=F'1000000000'  SEPARATE HIGH AND LOW ORDER PARTS
         CVD   A1,NTSWRK2         CONVERT LOW ORDER TO DECIMAL
         CVD   A1+1,NTSWRK        CONVERT HIGH ORDER TO DECIMAL
         IC    R0,NTSWRK2+3       SAVE 1ST TWO DIGS OF LO ORDER
         MVO   NTSWRK2-1(5),NTSWRK+3(5)     PUT HI ORDER NEXT TO LO ORD
         STC   R0,NTSWRK2+3       RESTORE SAVED DIGITS
         MVI   NTSRSL,X'20'       SET EDIT CHARACTER
         MVC   NTSRSL+1(18),NTSRSL          PROPAGATE TO GET PATTERN
         LNR   R6,R6              NEGATIVE OF NUM DEC PLACES
         LA    R6,NTSRSL+16(R6)   POINT TWO BEFORE DEC PT POS
         MVC   0(3,R6),=X'21204B' SET SIGNIFICANCE START AND DEC POINT
         LR    R5,R1              SAVE RETURN LOCATION
         LA    R1,1(,R6)          INITIALIZE IN CASE SIGNIFICANCE FORCD
         OI    NTSWRK2+7,X'0D'    SET NEG SIGN TO ENSURE DEC POINT
         EDMK  NTSRSL+1(18),NTSWRK2-1       DO GREAT BIG EDIT AND MARK
         LA    A1,0(,R1)          SAVE LOC OF FIRST SIGIFICANT DIGIT
         LR    R1,R5              RESTORE RETURN LOCATION
         LTR   R0,R0              TEST SIGN OF ORIGINAL REAL
         BNM   *+10               SKIP IF POSITIVE
         BCTR  A1,0               ELSE BACK OFF ONE CHARACTER
         MVI   0(A1),C'-'         AND SUPPLY A MINUS SIGN
         LA    A1+1,NTSRSL+18     POINT TO LAST CHARACTER
         TM    NTSFRM,1           TEST FOR TRAILING ZERO SUPPRESSION
         BO    NTSN4              SKIP IF NONE WANTED
         EJECT
*
*        LOOP TO REMOVE TRAILING ZEROS
*
         BALR  R10,0              SET START OF LOOP ADDRESS FOR SPEED
NTSN3    CLI   0(A1+1),C'0'       IS LAST CHARACTER A ZERO?
         BNE   NTSN4              SKIP IF NOT
         BCTR  A1+1,R10           ELSE DELETE IT AND LOOP BACK
*
*        COME HERE TO DEAL WITH EXPONENT
*
NTSN4    LTR   R7,R7              IS EXPONENT NON-ZERO?
         BNZ   NTSN5              SKIP IF SO
         CLI   NTSFRM,3           ELSE IS THIS FORMAT TYPE 3?
         BNO   NTSN6              IN ANY OTHER FORMAT, SKIP 0 EXPONENT
*
*        COME HERE IF AN EXPONENT IS TO BE PRINTED
*
NTSN5    MVC   1(4,A1+1),=X'C5212121'       SET "E" AND EDIT PATTERN
         CD    ZR,TENTO9          TEST REAL/DREAL CASES
         BNH   *+8                SKIP IF REAL
         MVI   1(A1+1),C'D'       ELSE REPLACE "E" BY "D"
         CVD   R7,NTSWRK          CONVERT EXPONENT TO DECIMAL
         ED    1(4,R5),NTSWRK+6   EDIT EXPONENT INTO PLACE
         MVI   2(A1+1),C'+'       SET A PLUS SIGN TENTATIVELY
         BNM   *+8                SKIP IF IT WAS PLUS (OR ZERO)
         MVI   2(A1+1),C'-'       ELSE SET A MINUS SIGN FOR EXPONENT
         LA    A1+1,4(,A1+1)      BUMP PAST PRINTED EXPONENT
*
*        EXIT POINT
*
NTSN6    SR    A1+1,A1            GET 360 LENGTH OF STRING
         LM    R6,R10,NTSSAV      RESTORE REGS
         SDR   ZR,ZR              RESTORE OUR ZERO REGISTER
         SH    A1,=Y(SCHARS)      PUT IN OFFSET (ALSO CC = NONZERO)
         BR    R1                 RETURN TO CALLER
         DROP  R2                 DROP BASE REGISTER FOR NUMTOSTG
         TITLE 'SPITBOLR -- CONVERSION ROUTINES -- COMMON AREA'
*
*        SCALING ROUTINE USED BY NUMTOSTG AND STGTONUM
*
*        (FA)                     REAL TO BE SCALED
*        (R6)                     POWER OF TEN
*        (R1)                     BASE REG SET BY CALLER
*        BALR  R7,R1
*        (FA)                     (FA)*10**(R6)
*
         USING SCALER,R1          BASE REG SET BY CALLER
SCALER   SLA   R6,3               ARGUMENT * 8 AND TEST IT
         BCR   Z,R7               IMMEDIATE RETURN IF ZERO
         BM    SCALED             JUMP ON CASE OF ARGUMENT NEGATIVE
*
*        HERE FOR POSITIVE EXPONENT -- LOOP TO SCALE BY 10**16
*
SCALEUL  CH    R6,=Y(8*16)        MORE THAN 16 STEPS TO GO?
         BNH   SCALEU1            SKIP IF NOT
         MD    FA,TENTO16         ELSE MULTIPLY BY 10**16
         SH    R6,=Y(8*16)        DECREMENT COUNT LEFT
         B     SCALEUL            AND LOOP BACK
*
*        COME HERE TO SCALE UP BY 10**16 OR LESS
*
SCALEU1  MD    FA,POWTEN(R6)      MULTIPLY BY CORRECT POWER OF TEN
         BR    R7                 RETURN TO CALLER
*
*        COME HERE WHEN ARGUMENT IS NEGATIVE TO SCALE DOWN
*
SCALED   LPR   R6,R6              MAKE SCALE POSITIVE
*
*        LOOP TO SCALE DOWN IN STEPS OF 10**16
*
SCALEDL  CH    R6,=Y(8*16)        MORE THAN 16 STEPS TO GO?
         BNH   SCALED1            SKIP IF NOT
         DD    FA,TENTO16         ELSE DIVIDE BY 10**16
         SH    R6,=Y(8*16)        DECREMENT COUNT LEFT
         B     SCALEDL            LOOP BACK
*
*        COME HERE TO SCALE DOWN BY 10**16 OR LESS
*
SCALED1  DD    FA,POWTEN(R6)      DIVIDE BY PROPER POWER OF TEN
         BR    R7                 RETURN TO CALLER
         DROP  R1                 DROP SCALER BASE REGISTER
         EJECT
*
*        POWERS OF TEN TABLE
*
         DS    0D                 ALLIGN ON DOUBLE WORD BOUNDARY
POWTEN   EQU   *+8                ZERO ENTRY IS 1 (10**0)
         DC    D'0.1,1,10,100,1E3,1E4,1E5,1E6,1E7,1E8'
         DC    D'1E9,1E10,1E11,1E12,1E13,1E14,1E15,1E16'
TENTO1   EQU   POWTEN+1*8         10**1 = 10
TENTO8   EQU   POWTEN+8*8         10**8 = 100000000
TENTO9   EQU   POWTEN+9*8         10**9 = 1000000000
TENTO16  EQU   POWTEN+16*8        10**16 = 10000000000000000
*
*        CHARACTER TABLES FOR SMALL INTEGERS (ACTUAL DEFINITIONS ARE
*        TO BE FOUND OVERLAYING THE FIRST PART OF SCANTB3)
*
*NTSD2   DC    C'101112131415161718192021222324'
*        DC    C'252627282930313233343536373839'
*        DC    C'404142434445464748495051525354'
*        DC    C'555657585960616263646566676869'
*        DC    C'707172737475767778798081828384'
*        DC    C'858687888990919293949596979899'
*
*NTSD1   DC    C'0123456789'
         TITLE 'SPITBOLR -- SCAN TABLES'
*
*        TABLE 3
*        -------
*
*        COMPILE TIME USE -- SCAN OUT INTEGER (TESTING FOR "REAL" CHRS)
*
*        EXECUTE TIME USE -- (1)  CHECK FOR VALID INTEGER IN STGTONUM
*                            (2)  PROVIDE MASTER SPAN TABLE
*
*        THE MASTER SPAN TABLE IS USED TO PROVIDE ALL REQUIRED
*        SPAN TABLES FOR ONE CHARACTER CASES. IT ACTUALLY REQUIRES
*        255 BYTES OF NON-ZERO BYTES FOLLOWED BY A ZERO BYTE
*        FOLLOWED BY 255 NON-ZERO BYTES. THE REQUIREMENT FOR 255
*        NONZERO BYTES AT THE START IS MET BY PLACING THE &ALPHABET
*        TABLE AT THIS LOCATION (WHOSE LAST 255 BYTES ARE NON-ZERO).
*        THE ENDING 255 NONZERO BYTES ARE THEN LARGELY SUPPLIED BY
*        OVERLAP WITH SCANTB3. NOTE THAT THE CORRECT SPAN TABLE
*        FOR THE CHARACTER X LIES AT THE ADDRESS SPANTABL-X.
*
*        TABLE FOR &ALPHABET (ALSO USED BY REPLACE)
*
ALPHBET  DS    0D                 ALLIGN FOR FAST COPY IN REPLACE
         DC    X'000102030405060708090A0B0C0D0E0F'
         DC    X'101112131415161718191A1B1C1D1E1F'
         DC    X'202122232425262728292A2B2C2D2E2F'
         DC    X'303132333435363738393A3B3C3D3E3F'
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
*
*        REFERENCE POINT FOR MASTER SPAN TABLE
*
SPANTBL  EQU   *-CTCHARS          PROVIDE STANDARD OFFSET
         DC    X'00'              OUR ONE BYTE OF ZEROS
         DC    C'XXXXXXXXXXXXXXX' 15 NON-ZERO BYTES (+240 FROM SCANTB3)
         EJECT
*
*        SCANTB3 STARTS HERE (SEE PREVIOUS PAGE)
*
SCANTB3  TABL  1                  INITIALIZE TABLE TO TERMINATORS
SCANTB3  FOR   '0123456789',0     SCAN PAST INTEGERS
         ORG
*
*        THE FOLLOWING CHARACTER TABLES USED IN THE NUMTOSTG ROUTINE
*        OVERLAY UNUSED SECTIONS OF SCANTB3
*
         ORG   SCANTB3            POSITION TO START OF TABLE
NTSD1    DC    C'0123456789'
NTSD2    DC    C'101112131415161718192021222324'
         DC    C'252627282930313233343536373839'
         DC    C'404142434445464748495051525354'
         DC    C'555657585960616263646566676869'
         DC    C'707172737475767778798081828384'
         DC    C'858687888990919293949596979899'
*
         ORG   ,                  REPOSITION TO END OF TABLE
*
*        NOTE -- SCAN TABLES 1,2 ARE IN SPITBOLC FOLLOWING SCAN
         TITLE 'SPITBOLR -- INTERRUPT HANDLING ROUTINE'
*
*        THIS ROUTINE HANDLES PROGRAM INTERRUPTS -- SUITABLE LINKAGE
*        MUST BE ESTABLISHED IN THE SYSTEM INTERFACE -- WHEN A PROGRAM
*        INTERRUPT OCCURS, THE SYSTEM INTERFACE SHOULD PASS CONTROL AS
*        FOLLOWS --
*
*        (8=DREG)                 POINTS TO DATA AREA
*                                 SYSPSW, SYSREGS STORED AT INTERRUPT
*        (15)                     POINTS TO SYSINTR
         BR    15
*
         ENTRY SYSINTR            ENTRY POINT FROM SYSTEM INTERFACE
         USING SYSINTR,15         BASE REG SET BY INTERFACE
SYSINTR  DS    0H                 START OF INTERRUPT ROUTINE
*
*        FIRST CHECK FOR OVERFLOW OF STATEMENT COUNT IN FR 0
*
*        NOTE THAT IF STATEMENT COUNT OVERFLOW OCCURS ON TRANSFER TO
*        ANY SYSTEM LABEL (LIKE END) OR A TRACED LABEL (INCLUDING
*        FALLING THROUGH TO THAT LABEL) THE STATEMENT NUMBER GIVEN WITH
*        ERROR MESSAGE WILL BE THAT OF LAST STATEMENT EXECUTED
*
         CLI   SYSPSW+3,INTEXOV   PRECISE EXPONENT OVERFLOW INTRUP?
         BE    SPINTR1            SKIP IF SO (MAY BE AUR)
         CLC   SYSPSW+2(2),=AL2(IINEXOV)    IMPRECISE EXP OVERFLOW?
         BNE   SPINTR2            SKIP IF NOT (CANNOT BE AUR CASE)
*
*        HERE WE HAVE A POSSIBLE AUR INTERRUPT
*
SPINTR1  L     12,SYSPSW+4        LOAD INTERRUPT ADDRESS
         BCTR  12,0               BACK OFF TWO BYTES
         BCTR  12,0               .
         CLI   0(12),X'3E'        WAS IT AN AUR?
         BNE   SPINTR2            SKIP IF NOT AN AUR
         MVC   SYSREGS+5(3),=AL3(STMOVER)   SET EXIT ADDRESS IF AUR
         B     SPINTR6            AND MERGE TO EXIT
         EJECT
*
*        HERE WE INITIATE THE SEARCH FOR A VALID INTERRUPT IN THE TABLE
*
SPINTR2  LA    10,SPINTBL         POINT TO INTERRUPT TABLE
         LA    11,(SPINTBLE-SPINTBL)/9      LOAD NUMBER OF ENTRIES
*
*        LOOP CHECKING ENTRIES IN TABLE
*
SPINTR3  CLC   SYSPSW+5(3),3(10)  DOES INTERRUPT ADDRESS MATCH?
         BNE   SPINTR4            SKIP IF NOT, NO MATCH
         CLC   SYSPSW+3(1),0(10)  CORRECT PRECISE INTERRUPT CODE?
         BE    SPINTR5            SKIP IF SO (MATCH)
         CLC   SYSPSW+2(2),1(10)  ELSE CHECK FOR IMPRECISE CODE
         BE    SPINTR5            SKIP IF MATCH
*
*        HERE IF NO MATCH, MOVE TO NEXT TABLE ENTRY
*
SPINTR4  LA    10,9(,10)          POINT TO NEXT ENTRY
         BCT   11,SPINTR3         LOOP BACK IF MORE TO GO
         L     2,=V(SYSABEND)     IF NO MORE, LOAD BOMB ADDRESS
         BALR  1,2                AND BOMB
*
*        HERE IF WE HAVE A MATCH IN THE TABLE
*
SPINTR5  MVC   SYSREGS+5(3),6(10) SET EXIT ADDRESS (FOR REG 1)
*
*        MERGE HERE FROM AUR CASE
*
SPINTR6  LM    0,15,SYSREGS       RELOAD REGISTERS (RETURN TO REG 1)
         BR    1                  JUMP TO EXIT ADDRESS FOR INTERRUPT
*
         DROP  15                 DROP SYSINTR BASE REGISTER
         EJECT
*
*        INTERRUPT TABLE -- THIS TABLE CONTAINS AN ENTRY FOR EACH
*        LEGITIMATE PROGRAM INTERRUPT POSSIBLE
*
*        THE FORMAT OF EACH NINE BYTE ENTRY IS AS FOLLOWS:
*
*        BYTE 0                   PRECISE INTERRUPT CODE
*        BYTES 1-2                IMPRECISE INTERRUPT CODE
*        BYTES 3-5                INTERRUPT ADDRESS
*        BYTES 6-8                EXIT ADDRESS AFTER INTERRUPT
*
*        THESE ENTRIES ARE GENERATED WITH THE INTRUP MACRO:
*
*        INTRUP    PSWADDRESS,TYPE,EXITADDRESS
*
*        TYPE IS ONE OF THE FOLLOWING:
*
*        DATA                     DATA EXCEPTION
*        IDVD                     INTEGER DIVIDE EXCEPTION
*        EXOV                     EXPONENT OVERFLOW EXCEPTION
*        FDVD                     FLOATING POINT DIVIDE EXCEPTION
*
*        DEFINITION OF INTERRUPT CODES:
*
INTDATA  EQU   X'07'              DATA PRECISE CODE
INTIDVD  EQU   X'09'              IDVD PRECISE CODE
INTEXOV  EQU   X'0C'              EXOV PRECISE CODE
INTFDVD  EQU   X'0F'              FDVD PRECISE CODE
IINDATA  EQU   X'1000'            DATA IMPRECISE CODE
IINIDVD  EQU   X'0800'            IDVD IMPRECISE CODE
IINEXOV  EQU   X'0200'            EXOV IMPRECISE CODE
IINFDVD  EQU   X'0040'            FDVD IMPRECISE CODE
*
SPINTBL  EQU   *                  START OF INTERRUPT TABLE
         INTRUP    STN1A,IDVD,STNE          INTEGER TOO LARGE STGTONUM
         INTRUP    STNCVBE,DATA,STNE        CODES > X'F9' STGTONUM
         INTRUP    DREALIL,EXOV,DREALO      DREAL OVERFLOW
         INTRUP    DREALIL,FDVD,DREALDZ     DREAL DIVISION BY ZERO
         INTRUP    REALIL,EXOV,REALO        REAL OVERFLOW
         INTRUP    REALIL,FDVD,REALDZ       REAL DIVISION BY ZERO
         INTRUP    EXPWRE,EXOV,EXPWRO       REAL OR DREAL ** OVERFLOW
         INTRUP    DVDII,IDVD,DVDIZ         INTEGER DIVISION BY ZERO
SPINTBLE EQU   *                  END OF INTERRUPT TABLE
         TITLE 'SPITBOLR -- TIMER OVERFLOW ROUTINE'
*
*        THIS ROUTINE IS ENTERED FROM THE SYSTEM INTERFACE ON
*        DETECTION OF TIME LIMIT OVERFLOW. THE FOLLOWING
*        IS THE CALLING SEQUENCE --
*
*        (8=DREG)                 POINTS TO DATA AREA
*        (15)                     POINTS TO SYSOVTM
*        BALR  14,15
*        -->   RETURN HERE AFTER SETTING FLAGS ETC.
*
*        SYSOVTIM PROCEEDS AS FOLLOWS --
*
*        THE OVERTIME FLAG IS SET IN THE STAGE BYTE
*
*        AFTER SAVING THE VALUE IN THE STATEMENT COUNT REGISTER
*        A VALUE IS SET TO CAUSE APPARENT OVERFLOW OF THE STATEMENT
*        COUNT AT THE START OF THE NEXT STATEMENT. THE STATEMENT
*        OVERFLOW ROUTINE EXAMINES THE OVERTIME FLAG IN STAGE
*        TO DETERMINE WHAT REALLY HAPPENED. NOTE THAT THIS
*        MANIPULATION OF SCNT HAS NO EFFECT AT COMPILE TIME
*
         ENTRY SYSOVTM            ENTRY POINT FROM INTERFACE
         USING SYSOVTM,15         BASE REG SET BY INTERFACE
SYSOVTM  OI    STAGE,$OVERTIM     SET OVERTIME FLAG
         STE   SCNT,SCNTTSAV      SAVE CURRENT STATEMENT COUNT
         LE    SCNT,=X'7FFFFFFF'  LOAD MAX VALUE TO GET OVERFLOW
         BR    14                 RETURN TO SYSTEM INTERFACE
         DROP  15                 DROP BASE REG
         TITLE 'SPITBOLR -- PHASE LOAD ROUTINES'
*
*        THESE ROUTINES PROVIDE THE NECCESSARY CALLS TO THE SYSTEM
*        PHASE LOADING ROUTINE WHEN OPERATING IN THE TWO PHASE VERSION
*
*        HERE TO LOAD COMPILER AND ENTER IT AT EXECUTION TIME
*
*        (R1)                     POINTS TO THIS ROUTINE
*
COMPILER LR    DB2,R1             SET NEW BASE REGISTER
         USING COMPILER,DB2       TELL ASSEMBLER
         STM   0,15,CODSVREG      SAVE REGS FOR COMPILER
         CLC   SPITCAD,SPITPAD    ONE OR TWO PHASE VERSION?
         BNE   COMPILEE           SKIP IF ONE PHASE
*
*        HERE WE MUST LOAD IN THE COMPILER PHASE
*
         L     R2,=V(SYSPHASE)    LOAD ADDRESS OF SYSTEM LOAD ROUTINE
         L     R0,COMVCON         LOAD VCON FOR COMPILER
         LA    R4,COMNAME         POINT TO NAME
         BALR  R1,R2              LOAD PHASE INTO MEMORY
         NOP   0                  NO ERROR RETURN ALLOWED
         L     R4,CODSVREG+R4*4   RESTORE OLD VALUE IN R4 FOR COMPILE
*
*        NOW BRANCH INTO THE COMPILER
*
COMPILEE L     R1,=A(CODXENT)     LOAD ADDRESS OF BRANCH POINT
         BR    R1                 OFF TO IT
         DROP  DB2                DROP BASE REG
         EJECT
*
*        HERE TO LOAD EXECUTE PHASE
*
*        (RETURN)                 TRANSFER LOCATION IN EXECUTE PACKAGE
*
EXECUTE  CLC   SPITCAD,SPITPAD    ONE PHASE VERSION?
         BCR   NE,RETURN          IMMEDIATE JUMP TO EXECUTE IF SO
         BALR  R1,0               GET A TEMPORARY BASE REG
         USING *,R1               TELL ASSEMBLER
         L     R2,=V(SYSPHASE)    POINT TO SYSTEM PHASE LOAD ROUTINE
         L     R0,XEQVCON         LOAD VCON FOR EXECUTE PHASE
         ST    R4,CODSVREG+R4*4   SAVE R4 VALUE OVER INTERFACE CALL
         LA    R4,XEQNAME         POINT TO NAME OF EXECUTE PHASE
         BALR  R1,R2              CALL PHASE LOAD ROUTINE
         NOP   0                  NO ERROR RETURN ALLOWED
         L     R4,CODSVREG+R4*4   RESTORE POSSIBLE CODE POINTER TO R4
         BR    RETURN             JUMP TO EXECUTE
         DROP  R1                 DROP TEMP BASE REG
*
*        PARAMETERS FOR SYSPHASE (DEPEND ON SETTING OF &LMOD)
*
         AIF   (&LMOD EQ 0).PHASE1
COMVCON  DC    V(SPITBLLC)        VCON FOR COMPILER
COMNAME  DC    CL8'SPITBLLC'      NAME
XEQVCON  DC    V(SPITBLLP)        EXECUTE VCON
XEQNAME  DC    CL8'SPITBLLP'      EXECUTE NAME
.PHASE1  ANOP
         AIF   (&LMOD EQ 1).PHASE2
COMVCON  DC    V(SPITBOLC)        VCON FOR COMPILER
COMNAME  DC    CL8'SPITBOLC'      NAME
XEQVCON  DC    V(SPITBOLP)        EXECUTE VCON
XEQNAME  DC    CL8'SPITBOLP'      EXECUTE NAME
.PHASE2  ANOP
         TITLE 'SPITBOLR -- VARIABLE HASH LOCATE ROUTINE'
*
*        THIS ROUTINE IS USED AT COMPILE AND EXECUTE TIME TO BUILD
*        AND LOCATE VARIABLE BLOCKS (SEE INITIAL SECTION FOR FORMATS)
*
*        CALLING SEQUENCE
*
*        LOCATE VARIABLE BLOCK BY NAME (COMPILE AND EXECUTE USAGE)
*
*        (A1,A1+1) (R4,R5)        SPECIFIER FOR STRING NAME
*        L     R2,=A(VARLOC)
*        BALR  R1,R2
*        -->   NORMAL RETURN (A1) HAS ADDRESS OF VARIABLE BLOCK
*
*        THESE CALLS DO NOT DISTURB ANY REGISTERS EXCEPT R0,R1,R2
*        AND A1,A1+1 (R4,R5).
*
*        THE HASHING ALGORITHM USED IS AS FOLLOWS --
*
*        NAMES SHORTER THAN 8 CHARACTERS ARE RIGHT FILLED WITH
*        HEXADECIMAL ZEROS. THEN THE FIRST FOUR BYTES ARE EXCLUSIVE
*        OR'ED INTO THE SECOND FOUR BYTES AND THE RESULT IS EXCLUSIVE
*        OR'ED WITH THE 360 LENGTH OF THE ORIGINAL NAME. THE HASH
*        FUNCTION IS THE 127 RESIDUE OF THIS QUANTITY
         EJECT
*
*        ENTRY POINT
*
         USING VARLOC,R2          BASE REGISTER SET BY CALLER
VARLOC   STM   A1,A2+1,VARLOCSV   STORE ARGUMENT, SAVE A2,A2+1
         STM   R1,R2,VARLOCLK     SAVE LINKAGE, ADDRESS
         AH    A1,VARLOCSV+SOFFSET          ADD OFFSET TO POINT TO NAME
         LH    A1+1,VARLOCSV+SLENGTH        LOAD 360 LENGTH OF NAME
         CH    A1+1,=H'7'         CHECK FOR LENGTH LESS THAN 8 CHARS
         BL    VARLOC1            SKIP IF LESS THAN 8 CHARS
*
*        HERE FOR NAMES LONGER THAN 7 CHARACTERS
*
         MVC   VARLOCHS,SCHARS(A1)          MOVE FIRST 8 CHARS OF NAME
         B     VARLOC2            JUMP TO MERGE
*
*        HERE FOR NAMES LESS THAN 8 CHARS LONG
*
VARLOC1  STD   ZR,VARLOCHS        CLEAR AREA TO X'00'
         EX    A1+1,VARLOCM       MOVE CHARS WE HAVE (LEFT JUST)
*
*        MERGE HERE TO COMPUTE HASH
*
VARLOC2  LM    A2,A2+1,VARLOCHS   LOAD 8 BYTES OF NAME
         XR    A2+1,A2            EXCLUSIVE OR FIRST 4, NEXT 4 BYTES
         XR    A2+1,A1+1          EXCLUSIVE OR LENGTH
         SR    A2,A2              CLEAR FOR DIVIDE
         D     A2,=F'127'         DIVIDE (REMAINDER TO A2)
         SLL   A2,2               *4 TO INDEX HASH TABLE
         A     A2,HASHTBAD        POINT TO HASH SLOT (-VLINK OFFSET)
         ST    A2,VARLOCSL        SAVE POINTER TO HASH SLOT
*
*        SET PROPER CONDITIONS FOR SHORT/LONG STRINGS
*
         LA    A2+1,VARLOCS       ASSUME SHORT STRING
         CLI   VARLOCSV+SLENGTH,0 IS IT A SHORT STRING?
         BZ    VARLOC3            SKIP IF SO
         LA    A2+1,VARLOCL       ELSE SET FOR LONG STRING CASE
         LA    R0,256             SET CRANK FOR LONG STRING LOOP
*
*        LOOP TO SEARCH EXISTING BLOCKS ON HASH CHAIN
*
VARLOC3  L     A2,VLINK(,A2)      POINT TO NEXT BLOCK ON CHAIN
         N     A2,=X'00FFFFFF'    IS THIS THE END OF CHAIN?
         BZ    VARLOC8            SKIP IF THIS IS THE END OF THE CHAIN
         CH    A1+1,VNAME+SLENGTH(,A2)      ELSE DO LENGTHS MATCH?
         BNE   VARLOC3            LOOP BACK FOR NEXT BLOCK IF NOT
         L     R1,VNAME(,A2)      ELSE LOAD NAME BASE POINTER
         AH    R1,VNAME+SOFFSET(,A2)        ADD OFFSET TO POINT TO NAME
         BR    A2+1               JUMP TO PROPER (SHORT/LONG) SECTION
         EJECT
*
*        HERE WE HAVE THE LOOP TO COMPARE LONG NAMES
*
VARLOCL  CLC   SCHARS(256,R1),SCHARS(A1)    COMPARE 256 BYTE CHUNK
         BNE   VARLOC5            SKIP IF NO MATCH
         AR    R1,R0              ELSE PUSH STRING POINTERS
         AR    A1,R0              . . . .
         SR    A1+1,R0            DECREMENT LENGTH
         CR    A1+1,R0            CHECK LENGTH REMAINING
         BNL   VARLOCL            LOOP BACK IF MORE THAN 256 CHRS LEFT
         EX    A1+1,VARLOCC       ELSE COMPARE REMAINING CHARACTERS
*
*        MERGE HERE WITH CORRECT CONDITION CODE FOR LONG STRING COMPARE
*
VARLOC5  LM    A1,A1+1,VARLOCHS   RELOAD STRING NAME ADDR/LENGTH
         BNE   VARLOC3            LOOP BACK FOR NEXT BLOCK IF NO MATCH
         B     VARLOC6            ELSE JUMP ON A MATCH
*
*        HERE TO COMPARE SHORT STRINGS
*
VARLOCS  EX    A1+1,VARLOCC       COMPARE NAMES
         BNE   VARLOC3            LOOP BACK FOR NEXT BLOCK IF NO MATCH
*
*        COME HERE IF WE LOCATE A MATCHING VARIABLE BLOCK
*
VARLOC6  LR    A1,A2              COPY VARIABLE BLOCK ADDRESS
         B     VARLOCX            JUMP TO EXIT
         EJECT
*
*        HERE IF BLOCK WAS NOT LOCATED
*
VARLOC8  L     A2,DATACUR         LOAD POINTER TO CURRENT 4K BLOCK
         L     R1,VBLKNXT(,A2)    LOAD PTR TO SPACE FOR NEXT VAR BLK
         LA    R0,VARSIZ(,R1)     BUMP PAST NEW BLOCK
         C     R0,CBLKBOT(,A2)    IS THERE ROOM?
         BNH   VARLOC20           SKIP IF THERE IS ROOM
*
*        HERE WE HAVE INSUFFICIENT ROOM IN THE CURRENT 4K BLOCK
*
         TM    STAGE,$CLEARFG     TEST FOR CALL FROM CLEAR
         BNO   *+10               SKIP IF NOT
         SR    A1,A1              ELSE SET RESULT = 0 = BLOCK NOT FOUND
         B     VARLOCX            JUMP TO EXIT
         LA    R2,GET4KBLK        POINT TO ROUTINE TO GET 4K BLOCK
         BALR  R1,R2              ALLOCATE A NEW 4K BLOCK
         L     R2,VARLOCLK+4      RELOAD BASE REG SETTING
         B     VARLOC8            LOOP BACK TO USE NEW BLOCK
*
*        HERE WHEN WE HAVE FOUND ROOM FOR THE VARIABLE BLOCK
*
VARLOC20 ST    R0,VBLKNXT(,A2)    STORE UPDATED VAR BLK POINTER
         MVC   0(VARSIZ,R1),MODVAR          MOVE IN MODEL BLOCK
         SH    R1,=Y(VALUE)       BACK OFF TO GET VALUE OFFSET
         L     A2,VARLOCSL        RECALL REMEMBERED HASH SLOT LOCATION
         MVC   VLINK+1(3,R1),VLINK+1(A2)    LINK BLOCK TO HEAD OF CHAIN
         ST    R1,VLINK(,A2)      STORE NEW HEAD OF CHAIN POINTER
         CH    A1+1,=Y(MAXSSTL)   COULD THIS BE A STANDARD VARIABLE?
         BH    VARLOC30           SKIP IF NOT TO EXIT
         CLI   SCHARS(A1),X'FF'   DOES IT BEGIN WITH X'FF'
         BE    VARLOC30           IF SO, CANNOT BE STANDARD VAR
*
*        HERE WE SEE IF THERE IS A STANDARD VARIABLE WITH THIS NAME
*
         LA    A2,0(A1+1,A1+1)    GET 2 * 360 LENGTH
         LH    A2,INITHDR(A2)     LOAD PTR TO LIST FOR THIS LENGTH
         A     A2,VARLOCB         MAKE PTR ABSOLUTE, SUPPLY SCODE
         SR    R0,R0              CLEAR FOR IC
*
*        LOOP TO CHECK FOR MATCH
*
VARLOC22 EX    A1+1,VARLOCCS      CHECK FOR MATCH WITH THIS ENTRY
         BL    VARLOC30           IF HIGH, NOT THERE, SINCE IN ORDER
         BE    VARLOC24           SKIP IF WE FIND A MATCH
         IC    R0,SCHARS-1(,A2)   ELSE LOAD LENGTH OF ENTRY
         AR    A2,R0              POINT TO NEXT ENTRY
         B     VARLOC22           LOOP BACK TO CHECK NEXT ENTRY
         EJECT
*
*        HERE WHEN WE FIND A MATCH WITH A STANDARD VARIABLE
*
VARLOC24 ST    A1+1,VNAME+4(,R1)  STORE LENGTH OF NAME, OFFSET = 0
         ST    A2,VNAME(,R1)      STORE NAME POINTER AND SCODE
         LA    A2,SCHARS+1(A2,A1+1)         PUSH POINTER PAST NAME
         LR    A2+1,A2            COPY POINTER
*
*        TEST FOR KEYWORD
*
         TM    0(A2),INITK        TEST FOR KEYWORD
         BNO   VARLOC25           SKIP IF NO KEYWORD ASSOCIATION
         MVC   VKEY(1,R1),1(A2+1) IF SO, MOVE INTO PLACE
         LA    A2+1,1(,A2+1)      BUMP PAST KEYWORD NUMBER
*
*        TEST FOR PATTERN VALUE
*
VARLOC25 TM    0(A2),INITP        TEST FOR PATTERN VALUE
         BNO   VARLOC26           SKIP IF NOT PATTERN (AVOID THE MVI)
         CNOP  0,4                ALLIGN VARLOCG2 PARAMETER WORD
         BAL   A1+1,VARLOCG2      SET PATTERN VALUE IF SO
         DC    AL1(VALUE+1)       LOCATION OF VALUE
         DC    AL3(SPITBOLX)      PATTERN OFFSET
         MVI   VALUE(R1),PCODE    SUPPLY PATTERN CODE
*
*        TEST FOR FUNCTION VALUE
*
VARLOC26 TM    0(A2),INITF        TEST FOR FUNCTION DEFINED
         BNO   VARLOC27           SKIP IF NOT
         MVC   VFUNC+1(3,R1),1(A2+1)        ELSE SET FUNCTION ADDR
         LA    A2+1,3(,A2+1)      BUMP PAST FUNCTION ADDRESS
*
*        TEST FOR OPERATOR DV POINTER
*
         CNOP  0,4                ALLIGN VARLOCG2 PARAMETERS
VARLOC27 TM    0(A2),INITO        TEST FOR OPERATOR DV POINTER
         BAL   A1+1,VARLOCG2      SET OPERATOR DV ADDRESS IF SO
         DC    AL1(VDVPTR+1)      ADDRESS FOR OPERATOR DV PTR
         DC    AL3(SPITBOLC)      DOPE VECTOR OFFSET
*
*        TEST FOR LABEL
*
         TM    0(A2),INITL        TEST FOR LABEL ASSOCIATION
         BAL   A1+1,VARLOCG2      SET LABEL ADDRESS IF SO
         DC    AL1(VLABL+1)       ADDRESS FOR LABEL
         DC    AL3(SPITBOLX)      OFFSET FOR LABEL
         EJECT
*
*        HERE WITH ALL SPECIAL FIELDS FOR STANDARD VARIABLE FILLED IN
*
         LR    A1,R1              PUT RESULT IN PROPER REGISTER
         TM    STAGE,$EXECUTE     EXECUTE TIME?
         BO    VARLOCX            IF SO, JUMP TO RETURN TO CALLER
         L     R1,VARUSED         ELSE LOAD SPACE USED FOR VARIABLES
         LA    R1,32(,R1)         BUMP FOR SPACE USED BY THIS BLOCK
         ST    R1,VARUSED         STORE INCREMENTED VALUE
         B     VARLOCX            AND THEN JUMP TO EXIT
*
*        LITTLE SUBROUTINE TO LOAD OFFSET FOR STANDARD VAR FIELD
*
VARLOCG2 BNO   4(,A1+1)           RETURN IF THIS ATTRIBUTE NOT PRESENT
         MVC   VARLOCHS(2),1(A2+1)          GET OFFSET
         LA    A2+1,2(,A2+1)      BUMP PAST OFFSET
         LH    A1,VARLOCHS        LOAD OFFSET
         A     A1,0(,A1+1)        ADD BASE ADDRESS
         ST    A1,VARLOCHS        STORE ABSOLUTE ADDRESS
         SRL   A1,24              POSITION OFFSET IN VARIABLE BLOCK
         AR    A1,R1              POINT TO LOCATION FOR MOVE
         MVC   0(3,A1),VARLOCHS+1 MOVE ADDRESS INTO PLACE
         B     4(,A1+1)           RETURN PAST PARAMETERS
*
*        HERE IF THIS IS NOT A STANDARD VARIABLE
*
VARLOC30 TM    STAGE,$EXECUTE     EXECUTE TIME?
         BNO   VARLOC35           SKIP IF NOT (PURE COMPILE TIME)
         TM    STAGE,$COMPILE     CASE OF CODE,EVAL?
         BNO   VARLOC34           SKIP IF NOT
*
*        HERE FOR VARIABLE BLOCK BUILT DURING CODE, EVAL
*
         L     R0,VARLOCSV        LOAD ARGUMENT STRING POINTER
         S     R0,CODSVREG+4*A1   GET OFFSET FROM BASE
         STH   R0,VARLOCSV+SOFFSET          SET PROPER OFFSET
         MVC   VARLOCSV(4),CODSVREG+4*A1    SET PROPER BASE POINTER
*
*        MERGE HERE FOR NORMAL COMPILE TIME, OR CODE,EVAL CASE
*
*
*        HERE FOR NEW BLOCK BUILT AT EXECUTE TIME
*
VARLOC34 MVC   VNAME(8,R1),VARLOCSV         SET PROPER NAME INTO PLACE
         LR    A1,R1              PUT RESULT IN PROPER REGISTER
         B     VARLOCX            JUMP TO RETURN TO CALLER
         EJECT
*
*        HERE FOR NEW BLOCK BUILT AT COMPILE TIME
*
VARLOC35 LA    A1,SCHARS(,A1)     POINT TO ACTUAL STRING
         LA    A1+1,1(,A1+1)      GET ACTUAL LENGTH
         LTR   A2,R1              SAVE BLOCK PTR, SET CC NON-ZERO
         LM    R0,R1,STRUSED      LOAD STRUSED, VARUSED
         AR    R0,A1+1            INCREMENT STRING SPACE
         LA    R1,32(,R1)         INCREMENT VARIABLE SPACE USED
         STM   R0,R1,STRUSED      STORE INCREMENTED COUNTS
         LA    R2,HIGHCORE        POINT TO HIGHCORE ROUTINE
         DROP  R2                 DROP VARLOC BASE REGISTER
         BALR  R1,R2              MOVE STRING TO HIGH CORE
         LA    R0,SCHARS          GET STANDARD OFFSET
         SR    A1,R0              ADJUST HIGH CORE STRING POINTER
         BCTR  A1+1,0             ADJUST TO 360 LENGTH
         STM   A1,A1+1,VNAME(A2)  STORE ADDRESS, LENGTH OF NAME
         MVI   VNAME(A2),SCODE    SET STRING CODE
         LR    A1,A2              SET RESULT IN PROPER REGISTER
*
*        COMMON EXIT POINT
*
VARLOCX  LM    A2,A2+1,VARLOCSV+8 RELOAD CLOBBERED REGS
         LM    R1,R2,VARLOCLK     RELOAD LINKAGE, ADDRESS
         BR    R1                 RETURN TO CALLER
         EJECT
*
*        EXECUTE TARGET INSTRUCTIONS
*
VARLOCM  MVC   VARLOCHS(*-*),SCHARS(A1)     MOVE CHARS OF NAME FOR HASH
VARLOCC  CLC   SCHARS(*-*,R1),SCHARS(A1)    COMPARE FOR HASH SEARCH
VARLOCCS CLC   SCHARS(*-*,A1),SCHARS(A2)    COMPARE FOR STANDARD VAR SR
*
*        CONSTANT TO ADJUST BASE POINTER TO STANDARD VARIABLE TABLE
*
         DS    0F                 ALLIGN
VARLOCB  DC    AL1(SCODE)         CODE FOR STRING
         DC    AL3(SPITBOLR)      BASE ADDRESS
*
*        MODEL VARIABLE BLOCK
*
MODVAR   DC    AL1(NCODE)         CODE FOR NULL VALUE
         DC    7AL1(0)            REMAINING 7 BYTES OF VALUE
         DC    AL1(0)             VFLAGS = 0, NO FLAGS SET
         DC    AL3(0)             VLINK = 0
         DC    AL1(0)             VKEY = 0
         DC    AL3($$NOFN-FCODE)  UNDEFINED FUNCTION CODE
         DC    AL1(1)             VPHASE = 1
         DC    AL3($$NOGO)        VLABL = UNDEFINED LABEL TRANSFER
         DC    AL4(0)             VIOPTR = 0
*
*        TABL OF HEADERS TO BLOCKS OF ENTRIES BY NAME LENGTH
*
INITHDR  DC    Y(INITVR1-SCHARS+1-SPITBOLR) NAMES OF LENGTH 1
         DC    Y(INITVR2-SCHARS+1-SPITBOLR) NAMES OF LENGTH 2
         DC    Y(INITVR3-SCHARS+1-SPITBOLR) NAMES OF LENGTH 3
         DC    Y(INITVR4-SCHARS+1-SPITBOLR) NAMES OF LENGTH 4
         DC    Y(INITVR5-SCHARS+1-SPITBOLR) NAMES OF LENGTH 5
         DC    Y(INITVR6-SCHARS+1-SPITBOLR) NAMES OF LENGTH 6
         DC    Y(INITVR7-SCHARS+1-SPITBOLR) NAMES OF LENGTH 7
         DC    Y(INITVR8-SCHARS+1-SPITBOLR) NAMES OF LENGTH 8
         DC    Y(INITVR9-SCHARS+1-SPITBOLR) NAMES OF LENGTH 9
*
MAXSSTL  EQU   9-1                360 LENGTH OF LONGEST STANDARD VAR
         TITLE 'SPITBOLR -- ROUTINE TO ALLOCATE NEW 4K VARIABLE BLOCK'
*
*        GET4KBLK
*
*        THIS ROUTINE ALLOCATES A FRESH 4K BLOCK IN HIGH CORE FOR
*        VARIABLES AND STORES ITS ADDRESS IN THE BASE REGISTER TABLE
*
*        CALLING SEQUENCE
*
*        LA    R2,GET4KBLK
*        BALR  R1,R2
*        =>    NORMAL RETURN
*
*        NO REGISTERS ARE AFFECTED EXCEPT R0,R1,R2
*
         USING GET4KBLK,R2        BASE REG SET BY CALLER
GET4KBLK ST    R1,GET4KLK         SAVE LINKAGE
         STM   R4,R5,GET4KSV      SAVE REGS FOR HIGHCORE PARAMETERS
         LA    R5,4096-1          GET SIZE - 1
         LA    R5,1(,R5)          GET 4096 = SIZE OF BLOCK
         LA    R2,HIGHCORE        POINT TO HIGH CORE ROUTINE
         DROP  R2                 KILL CLOBBERED BASE REG
         NI    HICINUSE+3,X'F8'   SET FOR DOUBLE WORD ALLIGNMENT
         CR    R0,R0              SET CC = 0 TO INHIBIT MOVE
         BALR  R1,R2              ALLOCATE 4K IN HIGH CORE
         USING *,R1               SET NEW BASE REGISTER
         LH    R5,CURBASE         LOAD OFFSET TO CURRENT BASE
         LA    R5,4(,R5)          PUSH TO NEXT ENTRY
         CH    R5,=H'128'         TOO MANY BLOCKS ALREADY?
         BL    *+8                SKIP IF OK
         XERR  06,002             ELSE ISSUE ERROR MESSAGE
         STH   R5,CURBASE         STORE NEW OFFSET
         ST    R4,DATACUR         STORE AS ADDRESS OF CURRENT BLOCK
         LA    R0,CBLKEND(,R4)    POINT TO LAST 8 BYTE BLOCK
         ST    R0,CBLKBOT(,R4)    STORE IN FIELD AT END OF BLOCK
         ST    R4,VBLKNXT(,R4)    STORE START AS NEXT VAR BLK ADDR
         SH    R4,=Y(VALUE)       INTRODUCE STANDARD OFFSET
         ST    R4,$$BAS1(R5)      STORE NEW POINTER IN BASE TABLE
         MVI   $$BAS3,X'FF'       MAKE SURE OF X'FF' BYTE IN 3RD ENTRY
         LM    R4,R5,GET4KSV      RELOAD SAVED REGS
         L     R1,GET4KLK         RELOAD LINKAGE
         BR    R1                 RETURN TO CALLER
         DROP  R1                 DROP BASE REG SET ABOVE
         TITLE 'SPITBOLR -- HIGHCORE -- ALLOCATE SPACE AT TOP OF CORE'
*
*        ROUTINE TO ALLOCATE SPACE AT TOP OF CORE
*        NOTE THAT FOR ANY GARBAGE COLLECTION CALL THE FOLLOWING
*        REGISTERS MUST HAVE THEIR PROPER EXECUTION TIME VALUES
*        FR,DB1,SYS,PDR  ALSO A1 FOR GBGCL1 CALL
*
*        CONDITIONS ON ENTRY
*
*        STAGE                    $COMPILE SET IF COMPILE TIME CALL
*                                 $EXECUTE ON IF EXECUTION TIME CALL
*                                 $GBGCLF SET IF COLLECT = GBGCLF
*
*        CONDITION CODE           ZERO      NOTHING TO MOVE
*                                 NONZERO   MOVE BLOCK FROM (R4)
*
*        (R4)                     BLOCK ADDRESS
*        (R5)                     BLOCK LENGTH
*        (R2)                     ADDRESS OF HIGHCORE
*        BALR  R1,R2              STANDARD CALL
*        (R4)                     NEW BLOCK ADDRESS
*        (R1)                     MAY HAVE UPPER BYTE STRIPPED
*                                 ALL REGS EXCEPT R0 RESTORED OR RELOC
*
         USING SPITBOLA,SYS       BASE REGISTER AVAILABLE AT XEQ TIME
         USING HIGHCORE,R2        TELL ASSEMBLER OF BASE REGISTER
HIGHCORE STM   R4,R6,HICORESV     SAVE SCRATCH REGISTERS
         L     R6,HICINUSE        LOAD OLD HI CORE IN USE ADDRESS
         SR    R6,R5              MINUS LENGTH TO MOVE IN= 'TO' ADDR
         ST    R6,HICINUSE        STORE ADDRESS OF ALLOCATED BLOCK
         TM    STAGE,$EXECUTE     CHECK FOR COMPILE TIME CALL
         BNO   HICOREC            OFF TO SPECIAL CODE IF COMPILE TIME
         TM    STAGE,$COMPILE     CASE OF CODE,EVAL?
         BNO   HICORE0            SKIP IF NOT
         ST    PDR,HICORPDR       ELSE SAVE PDR VALUE
         L     PDR,CODSVREG+4*PDR LOAD XEQ PDR VALUE
*
*        COME HERE TO TEST FOR COLLECT NEEDED
*
HICORE0  LA    R5,7(,R5)          PUSH OVER DOUBLE WORD BOUND
         N     R5,=X'FFFFFFF8'    AND PUT ON DOUBLE WORD BOUND
         LR    R0,R5              COPY LENGTH
         A     R0,CODSVREG+4*FR   GET ENDING ADDRESS FOR TEST
         CR    R0,PDR             WOULD WE OVER LAP?
         BL    HICORE1            SKIP IF NOT
         TM    STAGE,$COMPILE     CASE OF CODE,EVAL?
         USING SPITBOLC,CB1,CB2,CB3         BASE REG FOR FOLLOWING JUMP
         BO    CODXCOR            JUMP FOR CODE,EVAL OUT OF CORE IF SO
         DROP  CB1,CB2,CB3        DROP BASE REGS FOR COMPILER
         TM    STAGE,$GBGCLF      DO WE NEED A FUNCTION COLLECT?
         BO    HICGBGF            IF SET, OFF TO DO GBGCLF
         BAL   RETURN,GBGCL1      COLLECT SAVING A1 OVER CALL
         B     HICORE0            AND GO BACK FOR ANOTHER TEST
         EJECT
*
*        COME HERE WHEN THERE IS SUFFICIENT CORE FOR EXPANSION
*
HICORE1  L     R4,PDRLOC          LOAD PDR CURRENT LOC TO RELOCATE
         SR    R4,R5              GET RELOCATED ADDRESS
         ST    R4,PDRLOC          AND STORE IT BACK
         NI    STAGE,X'FF'-$GBGCLF          TURN OFF SPCL GBG FLAG
*
*        LOOP TO RELOCATE PDRPTR ENTRIES ON STCK
*
HICORE2  LA    R6,0(R4,R5)        GET CURRENT STACK ADDRESS
         L     R4,PDRBPTR(,R6)    GET BACKPOINTER AT THIS LEVEL
         SR    R4,R5              RELOCATE IT
         ST    R4,PDRBPTR(,R6)    RE STORE IT
         CE    ZR,FBLOKLOC(,R6)   TEST USAGE OF STACK ABOVE US
         BL    HICORE2            LOOP BACK IF NEXT LEVEL = FUNCTION
         BH    HICORE3            IF FBLOCLOC NEGATIVE, END OF STK
*
*        COME HERE FOR AN UNEVALUATED EXPRESSION CALL ABOVE US
*
         TM    EVLINK(R6),X'30'   TEST TO SEE WHO CALLED UNEVAL EXP
         BNZ   HICORE2            IF CC NE 0 EVAL FUNCTION ABOVE
*
*        COME HERE FOR PATTERN MATCHING ON LEVEL ABOVE
*
         L     R0,PATSPACE+PSAVPS1(,R6)     GET PS1 TO RELOCATE
         SR    R0,R5              RELOCATE IT
         ST    R0,PATSPACE+PSAVPS1(,R6)     STORE RELOCATED PS1
         L     R0,PATSPACE+PSAVPS2(,R6)     LOAD PS2 TO RELOCATE IT
         SR    R0,R5              RELOCATE IT
         ST    R0,PATSPACE+PSAVPS2(,R6)     STORE NEW PS2 VALUE
         LA    R0,0(R4,R5)        GET OLD PDR ABOVE US
         C     R0,PATSPACE+PSAVPB(,R6)      TEST FOR ENDPAT ABOVE US
         BNE   HICORE2            IF NOT IN ENDPAT, DONE WITH THIS LEVL
*
*        COME HERE WHEN PATTERN MATCH ABOVE IS DONE EXCEPT FOR DOTS
*
         ST    R4,PATSPACE+PSAVPB(,R6)      STORE RELOCATED PDR FOR END
         L     R0,PATSPACE+PSAVMINR(,R6)    VALUE IN MINR MUST BE RELOC
         SR    R0,R5              RELOCATE IT
         ST    R0,PATSPACE+PSAVMINR(,R6)    STORE NEW VALUE
         L     R0,PATSPACE+PSAVCP(,R6)      AND CP MUST BE RELOCATED
         SR    R0,R5              RELOCATE IT
         ST    R0,PATSPACE+PSAVCP(,R6)      STORE NEW CP VALUE
         B     HICORE2            BACK TO TAKE CRE OF STD STUFF
*
*        COME HERE WHEN ENTIRE STACK HAS BEEN RELOCATED
*
HICORE3  LR    R4,PDR             LOAD MOVE 'FROM' ADDRESS
         SR    PDR,R5             RELOCATE PDR
         LA    R5,STACKTOP-1(,R6) GET END OF STACK-1 FOR LENGTH CALC
         SR    R5,R4              MINUS BOTTOM ADDR = 360 LENGTH
         LR    R6,PDR             LOAD MOVE 'TO' ADDRESS
         EJECT
*
*        COME HERE TO MOVE A BLOCK IN CORE
*        (R4)                     'FROM' ADDRESS
*        (R6)                     'TO' ADDRESS
*        (R5)                     360 LENGTH FOR MOVE
*
*        CONDITIONS ON ENTRY
*
HICOREM  LA    R0,256             GET STANDARD MOVE CONSTANT
         CR    R5,R0              ARE WE SMALL ENOUGH FOR ONE MOVE?
         BL    HICOREMS           OFF TO MOVE SMALL PIECE IF <=256
*
*        LOOP TO MOVE 256 CHARACTERS AT A TIME
*
HICOREML MVC   0(256,R6),0(R4)    MOVE A LARGE PIECE
         AR    R6,R0              PUSH 'TO' POINTER
         AR    R4,R0              PUSH 'FROM' POINTER
         SR    R5,R0              DECREMENT LENGTH LEFT
         CR    R5,R0              SMALL ENOUGH FOR ONE MOVE?
         BNL   HICOREML           LOOP BACK IF NOT
*
*        COME HERE TO MOVE LAST PIECE
*
HICOREMS EX    R5,HICOREMV        DO VARIABLE LENGTH MOVE
         LM    R4,R5,HICORESV     RESTORE 'FROM' INFO & LENGTH
         L     R6,HICINUSE        LOAD NEW BLOCK ADDRESS
*
*        COME HERE WITH 'TO', 'FROM' & LENGTH PTRS SET UP FOR MOVEIN
*
HICOREC1 SPM   R1                 RESET ENTRY CONDITION CODE
         BZ    HICOREX            IF ZERO, NOTHING TO MOVE
         LA    R1,0(,R1)          CLEAR OUT CC TO FORCE EXIT NEXT CALL
         BCT   R5,HICOREM         GET 360 LENGTH AND OFF TO MOVE
         B     HICOREM            JUMP EVEN IF BCT FALLS THROUGH
*
HICOREMV MVC   0(*-*,R6),0(R4)    VARIABLE LENGTH MVC
         EJECT
*
*        COME HERE TO EXIT FROM HICORE ROUTINE
*
HICOREX  LR    R4,R6              COPY ADDRESS OF NEW BLOCK
         L     R6,HICORESV+8      RESTORE REGISTER 6
         TM    STAGE,$COMPILE+$EXECUTE      CODE,EVAL CASE?
         BCR   NO,R1              IMMEDIATE EXIT IF NOT
         ST    PDR,CODSVREG+4*PDR STORE NEW XEQ PDR VALUE
         ST    PDR,CODSVREG+4*PDR ELSE STORE NEW XEQ PDR VALUE
         L     PDR,HICORPDR       RELOAD CALLING VALUE
         BR    R1                 AND RETURN
*
*        COME HERE TO DO GBGCLF CALL FOR COLLECT
*
HICGBGF  NI    STAGE,X'FF'-$GBGCLF          TURN OFF SPECIAL FLAG
         B     GBGCLF             AND CALL COLLECT
*
*        COME HERE TO ALLOCATE CORE DURING COMPILE
*
HICOREC  C     R6,SUBEXTOP        WILL WE BE ABOVE SUBEXPRESSIONS?
         BH    HICOREC1           OFF TO TEST CASES IF SO
*
*        COME HERE IF WE MUST MOVE DOWN SUBEXPRESSIONS
*
         LA    R6,2*1024+1(,R5)   MOVE DOWN 2K, PUT ON HALFWORD
         N     R6,=X'FFFFFFFE'    PUT ON HALFWORD
         L     R0,ESTACKS         END OF COMPILER WORK STACKS
         AH    R0,=Y(2048)        ADD 2K SAFETY MARGIN
         L     R4,SUBEXBOT        GET ADDR OF START OF SUBEXPRESSIONS
         CR    R0,R4              WILL THERE BE CONFLICT?
         BNL   CMPLNORM           ISSUE ERROR IF OUT OF ROOM
         L     R5,SUBEXTOP        GET END OF EXPRESSION ADDRESS
         SR    R5,R6              GET RELOCATED TOP
         ST    R5,SUBEXTOP        AND RESTORE
         LCR   R6,R6              GET NEGATIVE MOVE AMOUNT
         LA    R6,0(R6,R4)        GET 'TO' ADDRESS
         ST    R6,SUBEXBOT        STORE UPDATED STARTING POINTER
         SR    R5,R6              GET REAL LENGTH OF BLOCK
         BCT   R5,HICOREM         GET 360 LENGTH AND OFF TO MOVE
*
*        COME HERE IF NO ROOM LEFT AT COMPILE TIME
*
CMPLNORM MVI   FATAL,1            SET FLAG FOR FATAL ERROR
         ERR   12                 AND ISSUE PROGRAM TOO LONG MESSAGE
         DROP  R2                 GET RID OF BASE REGISTER
         TITLE 'SPITBOLR -- CONSTANTS'
*
*        HEADER FOR INITIAL PAGE PRINTED BY INTERFACE
*
         ENTRY SYSHEAD            MAKE LOCATION KNOWN TO INTERFACE
SYSHEAD  EQU   *                  START OF HEADER LINES
         HEDR  '1S P I T B O L  360 -- VERSION 2.3'          (34)  V2.3
         DC    AL1(64)                                             V2.3
         DC    C'0COPYRIGHT (C) 1971, 2001 ROBERT B K DEWAR' (42)  V2.3
         DC    C' AND KENNETH E BELCHER'                     (22)  V2.3
         DC    AL1(63)                                             V2.3
         DC    C'0LICENSED UNDER THE GPL, '                  (25)  V2.3
         DC    C'SEE HTTP://WWW.SNOBOL4.COM FOR DETAILS'     (38)  V2.3
         DC    X'00'              END OF HEADERS                   V2.3
         ORG   SYSHEAD+X'A9'      RE-ORG FOR TFS 2.2.1 - 2.2.6     V2.3
*
*        BATCHING FLAG (WE ONLY PERMIT BATCHING IN STANDARD MODULES)
*
         ENTRY SYSBATCH
SYSBATCH DC    AL1(1-&LMOD)
*
*        VALUES OF STANDARD EXECUTION WORK AREAS NEEDING INITIALIZING
*
XEQINIT  DS    0F                 DEFINE START OF VALUES + ALLIGN
         BALR  DB3,DB1            IOASSCOD
         DC    H'0'               . . . .
         DC    X'00000000'        ANCHMODE (&ANCHOR = 0)
         DC    A(QPATSUBS)        SCANMODE (&FULLSCAN = 0)
         DC    A(0)               ANYTPTR = 0 (NO TABLE YET)
         TM    CTCHARS(R2),0      ANYMASK = 0
         LA    DB2,*-*            LTRCLA,GBGLA
         DC    PL3'-1'            GCOLCNT = 0 (-1 FOR CALL IN ECON)
         DC    X'00'              CLLCTFL = 0
         DS    0F                 ALLIGN
         DC    X'7FFF3CAF'        STSTART = OVERFLOW - 50000
         XERR  00,000             ERR MSG (PARAMS GET FILLED IN)
*
*        THE FOLLOWING CONSTANTS GIVE THE ADDRESSES OF THE COMPILER
*        AND EXECUTE PACGAGE. IF THEY ARE THE SAME, THEN WE MUST BE
*        IN A TWO PHASE VERSION. ELSE WE ARE IN THE SINGLE PHASE VERSN
*
CMPADR   DC    AL3(SPITBOLC)      ADDRESS OF COMPILER
XEQADR   DC    AL3(SPITBOLP)      ADDRESS OF EXECUTE PACKAGE
         EJECT
*
*        LITERALS
*
         LTORG ,                  LITERALS FOR SPITBOLR
*
*        PATCH SPACE
*
PATCHR   DC    10A(0)             INITIALIZE TO ZEROS
         TITLE 'SPITBOLR -- VARLOCF -- STANDARD VARIABLE TABLES'
*
*        THESE TABLES DESCRIBE VARIABLE BLOCKS HAVING ANY OF THE
*        FOLLOWING SPECIAL PROPERTIES --
*
*        K     KEYWORD ASSOCIATION
*        P     STANDARD PATTERN VALUE
*        F     STANDARD FUNCTION DEFINITION
*        O     OPERATOR DOPE VECTOR POINTER
*        L     STANDARD LABEL ASSOCIATION
*
*        EACH ENTRY HAS THE FOLLOWING FORMAT --
*
*        BYTE 1                   LENGTH OF ENTRY IN BYTES
*
*        FOLLOWING BYTES          FULL VARIABLE NAME IN EBCDIC
*
*        BYTE AFTER NAME          FLAGS
INITK    EQU   1                  ON => KEYWORD ASSOCIATION
INITP    EQU   2                  ON => STANDARD PATTERN VALUE
INITF    EQU   4                  ON => SYSTEM FUNCTION DEFINITION
INITO    EQU   8                  ON => OPERATOR DV POINTER
INITL    EQU   16                 ON => STANDARD LABEL ASSOCIATION
*
*        THE FOLLOWING FIELDS ARE PRESENT ONLY IF THE CORRESPONDING
*        FLAG BIT IS SET IN THE FLAG BYTE
*
*        ONE BYTE                 KEYWORD NUMBER
*
*        TWO BYTES                OFFSET TO PATTERN VALUE IN SPITBOLX
*
*        THREE BYTES              ADDRESS OF FUNCTION
*
*        TWO BYTES                OFFSET TO OPERATOR DV IN SPITBOLC
*
*        TWO BYTES                OFFSET TO STANDARD LABEL IN SPITBOLX
*
*        NOTE THERE IS NO PROVISION FOR STANDARD INPUT/OUTPUT
*        ASSOCIATIONS (INPUT,OUTPUT,PUNCH). THESE BLOCKS MUST BE PRE-
*        CONSTRUCTUED AND THE CORRECT POINTERS AND FLAGS PREINITIALIZED
*
*        ALL ENTRIES FOR NAMES OF A GIVEN LENGTH ARE TOGETHER IN
*        ALPHABETICAL ORDER ENDED BY A DUMMY ENTRY STARTING WITH X'FF'
         EJECT
*
*        FORMAT OF MACRO CALL
*
*        INITV                    NAME,TYPE
*
*        NAME IS THE NAME OF THE VARIABLE FOR WHICH AN ENTRY IS
*        TO BE CREATED (THE NAME OF THE ENTRY IS E$NAME)
*
*        TYPE IS A SERIES OF LETTERS INDICATING WHICH ATTRIBUTES ARE
*        PRESENT. FOR EXAMPLE KF MEANS A KEYWORD AND FUNCTION
*
INITVR1  EQU   *                  START OF TABLE FOR ONE CHAR NAMES
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
*
INITVR2  EQU   *                  START OF TABLE FOR TWO CHAR NAMES
         INITV                    EQ,OF
         INITV                    GE,OF
         INITV                    GT,OF
         INITV                    LE,OF
         INITV                    LT,OF
         INITV                    NE,OF
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
*
INITVR3  EQU   *                  START OF TABLE FOR THREE CHAR NAMES
         INITV                    ANY,OF
         INITV                    ARB,PK
         INITV                    ARG,F
         INITV                    BAL,KP
         INITV                    END,L
         INITV                    LEN,OF
         INITV                    LEQ,OF
         INITV                    LGE,OF
         INITV                    LGT,OF
         INITV                    LLE,OF
         INITV                    LLT,OF
         INITV                    LNE,OF
         INITV                    POS,OF
         INITV                    REM,PK
         INITV                    TAB,OF
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
         EJECT
*
INITVR4  EQU   *                  START OF TABLE FOR FOUR CHAR NAMES
         INITV                    CODE,KF
         INITV                    COPY,F
         INITV                    DATA,F
         INITV                    DATE,F
         INITV                    DUMP,FK
         INITV                    DUPL,F
         INITV                    EVAL,F
         INITV                    FAIL,PK
         INITV                    ITEM,F
         INITV                    LOAD,F
         INITV                    LPAD,F
         INITV                    RPAD,F
         INITV                    RPOS,OF
         INITV                    RTAB,OF
         INITV                    SIZE,F
         INITV                    SPAN,OF
         INITV                    STNO,K
         INITV                    TIME,F
         INITV                    TRIM,KF
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
*
INITVR5  EQU   *                  START OF TABLE FOR FIVE CHAR NAMES
         INITV                    ABEND,K
         INITV                    ABORT,KLP
         INITV                    APPLY,F
         INITV                    ARBNO,F
         INITV                    ARRAY,F
         INITV                    BREAK,OF
         INITV                    CLEAR,F
         INITV                    FENCE,PK
         INITV                    FIELD,F
         INITV                    IDENT,OF
         INITV                    INPUT,KF
         INITV                    LOCAL,F
         INITV                    OPSYN,F
         INITV                    PUNCH
         INITV                    REMDR,F
         INITV                    TABLE,F
         INITV                    TRACE,KF
         INITV                    VALUE,F
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
         EJECT
*
INITVR6  EQU   *                  START OF TABLE FOR SIX CHAR NAMES
         INITV                    ANCHOR,K
         INITV                    BREAKX,OF
         INITV                    DEFINE,F
         INITV                    DETACH,F
         INITV                    DIFFER,OF
         INITV                    FTRACE,K
         INITV                    LASTNO,K
         INITV                    NOTANY,OF
         INITV                    OUTPUT,KF
         INITV                    RETURN,L
         INITV                    REWIND,F
         INITV                    STOPTR,F
         INITV                    SUBSTR,F
         INITV                    UNLOAD,F
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
*
INITVR7  EQU   *                  START OF TABLE FOR SEVEN CHAR NAMES
         INITV                    COLLECT,F
         INITV                    CONVERT,F
         INITV                    ENDFILE,F
         INITV                    ERRTYPE,K
         INITV                    FRETURN,L
         INITV                    INTEGER,OF
         INITV                    NRETURN,L
         INITV                    REPLACE,F
         INITV                    REVERSE,F
         INITV                    RTNTYPE,K
         INITV                    SETEXIT,F
         INITV                    STCOUNT,K
         INITV                    STLIMIT,K
         INITV                    SUCCEED,PK
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
*
INITVR8  EQU   *                  START OF TABLE FOR EIGHT CHAR NAMES
         INITV                    ALPHABET,K
         INITV                    CONTINUE,L
         INITV                    DATATYPE,F
         INITV                    ERRLIMIT,K
         INITV                    FNCLEVEL,K
         INITV                    FULLSCAN,K
         INITV                    MAXLNGTH,K
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
*
INITVR9  EQU   *                  START OF TABLE FOR NINE CHAR NAMES
         INITV                    PROTOTYPE,F
         DC    X'FFFF'            DUMMY ENTRY TO END LIST
         TITLE 'SPITBOLP -- START OF CONTROL SECTION'
*
*        THE SPITBOLP CONTROL SECTION CONTAINS ALL THE PATTERN MATCHING
*        ROUTINES -- THESE ROUTINES ARE ADDRESSABLE UNDER EITHER THE
*        PBASE REGISTER OR UNDER RETURN WHICH IS THE PATTERN ROUTINE
*        TRANSFER REGISTER
*
         BEGIN P                  START OF SPITBOLP, SPITBLLP CSECT
         TITLE 'SPITBOLP -- FORMAT OF PATTERN MATCH STACKS'
*
*        THE PATTERN MATCHING PROCESS IS DRIVEN BY THREE STACKS
*
*        STACK ONE -- BACKUP STACK
*        ------------------------
*
*        THIS STACK CONTAINS AN ENTRY FOR EACH PATTERN ELEMENT
*        WHICH EXTENDS OR HAS AN ALTERNATIVE -- THE TOP ELEMENT
*        ON THIS STACK POINTS TO THE MOST RECENT SUCH PATTERN
*
*        EACH ENTRY HAS THE FOLLOWING FORMAT
*
*
*        +-------------------------------------------------------+
*        |                        S1PATOFS                       |
*        +-------------------------------------------------------+
*        |                        S1OLDCP                        |
*        +-------------------------------------------------------+
*        |                        S1NEWCP                        |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS OF OFFSETS OF FIELDS IN STACK 1 ENTRY
*        -------------------------------------------------
*
S1PATOFS EQU   0                  OFFSET TO PATTERN NODE MAKING ENTRY
*
S1OLDCP  EQU   4                  CURSOR POSITION BEFORE MATCH
*
S1NEWCP  EQU   8                  UPDATED CURSOR AFTER EXTENSION
*
*        PATTERNS ONLY MAKE AN ENTRY ON THIS STACK IF THEY HAVE AN
*        EXTENSION ROUTINE OR AN ALTERNATIVE OR BOTH (THE FEW
*        EXCEPTIONS TO THIS RULE ARE NOTED IN THE RELATED ROUTINES)
*
*        AT THE BOTTOM OF THE PATTERN STACK THERE IS A SPECIAL ENTRY
*        WHICH HANDLES MOVING OF THE ANCHOR IF ALLOWED
*        IT HAS A PATTERN OFFSET OF ZERO WHICH ALWAYS POINTS TO THE
*        ANCHEXT EXTEND ROUTINE -- SEE PATTERN BLOCK FORMAT
*
*        (PS1)                    POINTS TO THE NEXT AVAILABLE LOCATION
*        (PS2)                    POINTS PAST THE LAST LOCATION
*        (BPS)                    CONTAINS THE INCREMENT (12)
*
*        (THIS STACK BUILDS UP IN CORE)
*
*        IN ADDITION TO THIS STANDARD USAGE -- THE STAR PATTERN
*        (UNEVALUATED EXPRESSION) USES THE S1OLDCP FIELD IN A SPECIAL
*        WAY -- SEE PO$EXP1 FOR DETAILS OF THIS
*
*        RELOCATABLE FIELDS       S1OLDCP (FOR EXP SPECIAL CASE)
         EJECT
*
*        STACK TWO
*        ---------
*
*        THIS STACK IS USED FOR TWO QUITE DIFFERENT PURPOSES
*
*        1)    TO SAVE THE CURSOR FOR $ . ARBNO -- SEE PO$MARK
*
*        +-------------------------------------------------------+
*        |                        S2CP                           |
*        +-------------------------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
*        2)    TO SAVE PATTERN BASE AND OFFSET (PB) AND (PO) ON A
*              RECURSIVE PATTERN MATCH (UNEVALUATED EXPRESSION)
*
*        +-------------------------------------------------------+
*        |                        S2PB                           |
*        +-------------------------------------------------------+
*        |                        S2PO                           |
*        +-------------------------------------------------------+
*        |                        ///////                        |
*        +-------------------------------------------------------+
*
*
*        DEFINITIONS OF OFFSETS OF FIELDS IN STACK 2 ENTRY
*        -------------------------------------------------
*
S2CP     EQU   0                  SAVE CURSOR POINTER FOR $ . ARBNO
S2PB     EQU   0                  SAVE PATTERN BASE (PB) ON PAT RECURSN
S2PO     EQU   4                  SAVE PATTERN OFFSET (PO) ON PAT RECUR
*
*        S2OFS(PS2)               POINTS TO CURRENT ACTIVE ENTRY
*        (PS1)                    POINTS TO LOWEST AVAILABLE ENTRY
*        (BPS)                    CONTAINS THE DECREMENT (12)
*
*        (THIS STACK BUILDS DOWN IN CORE)
*
*        RELOCATABLE FIELDS       S2PB (S2CP IS SAFE BECAUSE TOO SMALL)
         EJECT
*
*        STACK ONE -- SPECIAL ENTRY FOR DOT ASSIGNMENT
*        ---------------------------------------------
*
*        THE FOLLOWING SPECIAL ENTRY IS MADE ON STACK ONE IN THE CASE
*        OF A DOT ASSIGNMENT. AT THE END OF PATTERN MATCHING (ON
*        A SUCCESSFUL MATCH), THE PATTERN STACK IS SCANNED FOR
*        THE DOTFLG FLAG WHICH INDICATES THIS TYPE OF ENTRY AND THE
*        APPROPRIATE ASSIGNMENTS ARE MADE
*
*        +-------------------------------------------------------+
*        |                         S1PO                          |
*        +-------------+-----------------------------------------+
*        |   DOTLOC    |                    S1PB                 |
*        +-------------+-------------+---------------------------+
*        |           S1BCP           |           S1ECP           |
*        +---------------------------+---------------------------+
*
S1PO     EQU   0                  PATTERN OFFSET FOR DOT PATTERN
DOTLOC   EQU   4                  LOCATION FOR DOTFLG
DOTFLG   EQU   MCODE              FLAG TO SIGNAL DOT ENTRY
*
*        DOTFLG OCCUPIES THE TYPE CODE POSITION IN THE PATTERN
*        ADDRESS WORD THAT IS SOMETIMES SAVED ON STACK1
*        THE ONLY OTHER FLAGS THAT MAY APPEAR IN THIS BYTE ARE PCODE
*        FOUND WITH A NORMAL PB STACK ENTRY (DEFERRED EXPRESSION)
*        X'80' OR X'40' USED TO SAVE AND RESTORE FAILSW FOR EXTENSION
*        ROUTINES AND AS A FLAG OVER EXTEND CALLS
*        THE CHOICE FOR DOTFLG IS LIMITED BY THE FOLLOWING CONSTRAINTS
*        RELOCBIT MUST BE ON, TO MAKE SURE THIS IS PROCESSED BY THE
*        GARBAGE COLLECTOR PTRPROCV CALL
*        IT SHOULD NOT BE SCODE, AS IN THE FUTURE THE GARBAGE COLLECTOR
*        MAY DO SPECIAL THINGS WITH STRING POINTERS
*
S1PB     EQU   4                  PATTERN BASE FOR DOT PATTERN
S1BCP    EQU   8                  CURSOR AT START OF MATCHED PART
S1ECP    EQU   10                 CURSOR AT END OF MATCHED PART
*
*        RELOCATABLE FIELDS       S1PB
         TITLE 'SPITBOLP -- PATTERN MATCH ROUTINES'
*
*        THESE ROUTINES PERFORM THE FUNCTION OF MATCHING ONE PATTERN
*        ELEMENT. THE FOLLOWING ARE THE CONDITIONS ON ENTRY --
*
*        (CP)                     CURSOR POINTER
*                                 (NUMBER OF REMAINING UNMATCHED CHARS)
*
*        (PB)                     PATTERN BLOK POINTER
*
*
*        (PO)                     OFFSET FROM (PB) OF PATTERN ELEMENT
*
*        (FSADR)                  ADDRESS OF LAST CHAR IN STG + 1
*
*
*
*        MOST OF THE ROUTINES EXIST IN TWO VERSIONS -- ONE TO BE USED
*        WHEN THERE IS NO ALTERNATIVE AND THE OTHER FOR USE WHEN
*        AN ALTERNATIVE IS PRESENT
*
*        NOTE THAT EVERY PATTERN ROUTINE FOR THE "NOOR" CASE IS
*        PRECEDED BY A HALF WORD OFFSET TO THE CODE FOR THE "OR" CASE
*        THIS IS TO ASSIST THE ALTERNATION ROUTINE IN CONTRUCTION OF
*        PATTERNS WHERE BLOCKS MAY BE SUPPLIED WITH ALTERNATIVES AND
*        MUST BE MODIFIED ACCORDINGLY
*
*        THE DEFERRED ENTRY POINTS FOR POS,RPOS,TAB,RTAB, AND LEN
*        MUST BE 14 BYTES BEHIND THE NON-DEFERRED CASES TO SATISFY
*        THE PATTERN CONSTRUCTION ROUTINES
*
         EJECT
*
*        THESE PATTERN ROUTINES BRANCH TO ONE OF THE FOLLOWING EXIT
*        POINTS ---
*
*        BACKUP                   USED WHEN AN ELEMNT HAVING NO
*                                 ALTERNATE FAILS -- CP,PO SETTINGS
*                                 ARE IRRELEVANT
*                                 (BACKS UP ON PATTERN STACK ONE)
*
*        LBACKUP                  LIKE BACKUP, BUT USED WHEN THE
*                                 FAILURE IS A LENGTH FAIL
*
*        FAIL                     USED WHEN AN ELEMENT WHICH HAS AN
*                                 ALTERNATIVE FAILS -- CP,PO MUST BE
*                                 (TAKES THE ALTERNATIVE)
*
*        LFAIL                    LIKE FAIL, BUT USED WHEN THE
*                                 FAILURE IS A LENGTH FAIL
*
*        SUCC                     USED ON SUCCESSFUL MATCH OF AN
*                                 ELEMENT WITH NO ALTERNATE -- PO MUST
*                                 BE SET AS ON ENTRY, AND CP UPDATED
*                                 PAST THE MATCHED PART
*                                 (TAKES THE "THEN" BRANCH)
*
*        SUCCS                    USED ON SUCCESSFUL MATCH OF AN
*                                 ELEMENT WITH AN ALTERNATIVE -- PO,CP
*                                 MUST BE SET AS ON ENTRY -- NCP IS SET
*                                 TO THE NEW VALUE OF CP AFTER MATCHING
*                                 (MAKES PO,CP ENTRY ON STACK 1 AND
*                                  BRANCHES TO "THEN" PATTERN)
*
*        SUCCSN                   USED WHEN AN ELEMENT HAVING AN
*                                 ALTERNATIVE SUCCESSFULLY MATCHES THE
*                                 NULL STRING
*                                 (SAME ACTION AS SUCCS SAVING AN LR)
*
*        SUCCSP                   LIKE SUCCS BUT USED WHEN THE STACK
*                                 ONE ENTRY HAS ALREADY BEEN MADE BY
*                                 THE CALLER (BUT STACK PTRS UNMOVED)
         EJECT
*
*        THE ROUTINES DESCRIBED ON THE PRECEDING PAGE AND ALL EXTENSION
*        ROUTINES EXIST IN TWO VERSIONS -- ONE FOR FULLSCAN AND ONE
*        FOR QUICKSCAN ROUTINES -- THE SETTING OF THE BASE REGISTER
*        DETERMINES WHICH SET ARE USED -- PBASE IS SET ON ENTRY TO A
*        PATTERN ACCORDING TO THE VALUE OF THE KEYWORD &FULLSCAN
*
*
*        HANDLING OF QUICKSCAN HEURISTICS
*        --------------------------------
*
*        THE SWITCH FAILSW IS USED AS A FLAG FOR LENGTH FAILURE
*        ALL PATTERNS WHICH CAN EXTEND SET FAILSW=FF TO INDICATE
*        TENTATIVE LENGTH FAILURE (THIS INCLUDES THE INITIAL ANCHOR
*        MOVEMENT IN UNANCHORED MODE) ANY PATTERN ELEMENT WHICH FAILS
*        WITH A LENGTH FAILURE BRANCHES TO LFAIL OR LBACKUP WHICH BOTH
*        LEAVE THE LENGTH-FAIL SETTING OF FAILSW UNCHANGED. ANY PATTERN
*        ELEMENT WHICH FAILS FOR ANY OTHER REASON BRANCHES TO FAIL OR
*        BACKUP WHICH SET FAILSW NON-ZERO TO INDICATE THAT AT LEAST
*        ONE ELEMENT HAS NOT LENGTH FAILED AND THAT THEREFORE EXTENSION
*        SHOULD BE ATTEMPTED -- THAT IS, WE ONLY INHIBIT EXTENSION IF
*        ALL SUCCEEDING PATTERN ELEMENTS CAUSE LENGTH FAILURE
*
*
*        ANOTHER HEURISTIC ACTIVE IN QUICKSCAN MODE IS THE TEST FOR
*        MINIMUM NUMBER OF CHARACTERS REMAINING -- THE MINMATCH FIELD
*        OF EVERY PBLOK CONTAINS THE MINIMUM NUMBER OF CHARACTERS
*        NECCESSARY FOR A SUCCESSFUL MATCH FOR THAT PBLOK AND ALL
*        PBLOKS CHAINED FROM IT -- THE SUCC AND SUCCS ROUTINES COMPARE
*        THIS FIELD AGAINST CP AND LFAIL OR LBACKUP IF THERE ARE TOO
*        FEW CHARACTERS REMAINING -- A COMPLICATION OCCURS WHEN WE
*        GO DOWN A LEVEL TO MATCH A SUB PATTERN (UNEVALUATED EXPR)
*        IN THIS CASE, THE REGISTER MINR IS USED TO HOLD THE NEGATIVE
*        OF THE MINIMUM NUMBER OF CHARACTERS REQUIRED FOR COMPLETION
*        OF MATCHING ON ALL HIGHER LEVELS -- THUS THE ACTUAL TEST MADE
*        IS WHETHER (CP+MINR) IS AT LEAST MINMATCH CHARS
*
*        ANOTHER HEURISTIC INVOLVES THE ASSUMPTION THAT UNEVALUATED
*        EXPRESSIONS MATCH AT LEAST ONE CHARACTER. THIS HEURISTIC IS
*        APPLIED BY SETTING A VALUE OF ONE IN THE MINMATCH FIELD OF
*        AFFECTED NODES -- NO SPECIAL CODE IS REQUIRED.
*
*        THE FINAL HEURISTIC INVOLVES THE EXTENSION OF ARBNO -- THIS
*        AVOIDS GETTING STUCK IN A LOOP MATCHING NULL -- SEE ARBNO
*        AND ITS EXTENSION ROUTINE ARBNOEXT FOR DETAILS
         EJECT
PATSUBS  EQU   *                  START OF PATTERN SUBROUTINES
         DROP  DB1                DB1 NOT AVAILABLE IN MATCH
         USING SPITBOLA,SYS       BASE REG FOR SYSTEM ROUTINES
         USING QPATSUBS,PBASE     SYMBOLS NEEDED ARE DEFINED IN
*                                 QUICKSCAN ROUTINES
*
*        POS ENTRY POINTS
*
*        FOR INTEGER CASE --
*        PARAM1                   POS ARGUMENT
*        EXTEND                   NONE
*
*        FOR DEFERRED EXPRESSION CASE --
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*
*
*        EXPRESSION ARGUMENT -- "NOOR" POINTER
*
         DC    Y(PO$POSD-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN ROUTINE BASE REG
PN$POSD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERN  01,001             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO POS IS NOT AN INTEGER
         XERN  13,001             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO POS IS NEGATIVE
*
*        INTEGER ARGUMENT -- "NOOR" POINTER
*
         DC    Y(PO$POS-*)        OFFSET TO CODE FOR "OR" CASE
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PN$POS   LH    R1,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH
         SR    R1,CP              SUBTRACT NUMBER OF CHARS LEFT
         C     R1,PARAM1(PB,PO)   COMPARE THIS LOC WITH ARG
         BE    SUCC               SUCCEED IF EQUAL
         BH    LBACKUP            IF TOO FAR, LENGTH-FAIL
         EJECT
*
*        POS ENTRY POINTS -- CONTINUED
*
*
*        POS FAILURE ROUTINE -- THIS ROUTINE OPTIMIZES THE OCCURENCE
*        OF POS AS THE FIRST ITEM IN A PATTERN -- IN UNANCHORED MODE
*        THE ANCHOR IS MERELY MOVED TO THE POINT OF OCCURENCE AND FUR-
*        THER ANCHOR MOVEMENT INHIBITED
*
         CH    PO,=Y(PATS)        SEE IF POS IS FIRST ELEMENT
         BNE   BACKUP             IN ANY OTHER CASE, NORMAL FAILURE
         CLI   ANCLOC(PDR),X'80'  CHECK FOR UNANCHORED MODE
         BE    PABORT             PATTERN ABORTS IN ANCHORED MODE
         C     PB,ORGPB(,PDR)     MUST BE ORIGINAL PATTERN BASE
         BNE   BACKUP             IF NOT, CAN'T OPTIMIZE
         S     CP,PARAM1(PB,PO)   SUBTRACT POS PARAMETER
         BM    PABORT             PATTERN ABORTS IF THIS IS OFF END
         ST    CP,STACK1+S1NEWCP(,PDR)      STORE AS ANCHOR MOVEMENT
         MVI   ANCLOC(PDR),X'80'  SET TO PREVENT FURTHER ANCHOR MOVMENT
         B     SUCC               SUCCEED
*
*        EXPRESSION ARGUMENT -- "OR" CASE
*
         USING *,RETURN           PATTERN ROUTINE BASE REG
PO$POSD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERR  01,001             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO POS IS NOT AN INTEGER
         XERR  13,001             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO POS IS NEGATIVE
*
*        INTEGER ARGUMENT -- "OR" CASE
*
         NOPR  0                  SPACE CORRECTLY
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PO$POS   LH    R1,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH
         SR    R1,CP              CALCULATE LOCATION FROM START
         C     R1,PARAM1(PB,PO)   CHECK FOR MATCH WITH ARGUMENT
         BE    SUCCSN             IF EQUAL, SUCCEED WITH NO CP MOVE
         BH    LFAIL              IF PAST, LENGTH FAILURE
         B     FAIL               ELSE NORMAL FAILURE
         EJECT
*
*        ENTRY POINTS FOR RPOS
*
*        FOR INTEGER CASE --
*        PARAM1                   INTEGER ARGUMENT TO RPOS
*        EXTEND                   NONE
*
*        FOR DEFERRED EXPRESSION CASE --
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*
*
*        EXPRESSION ARGUMENT -- "NOOR" CASE
*
         USING *,RETURN           PATTERN ROUTINE BASE REG
         DC    Y(PO$RPOSD-*)      OFFSET TO CODE FOR "OR" CASE
PN$RPOSD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERN  01,002             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO RPOS IS NOT AN INTEGER
         XERN  13,002             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO RPOS IS NEGATIVE
*
*        INTEGER ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$RPOS-*)       OFFSET TO CODE FOR "OR" CASE
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PN$RPOS  C     CP,PARAM1(PB,PO)   CHECK FOR MATCH WITH ARGUMENT
         BH    BACKUP             NORMAL FAIL IF NOT THERE YET
         BE    SUCC               SUCCEED IF THERE IS A MATCH
         B     LBACKUP            LENGTH FAIL IF ALREADY PAST
*
*        EXPRESSION ARGUMENT -- "OR" CASE
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$RPOSD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERR  01,002             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO RPOS IS NOT AN INTEGER
         XERR  13,002             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO RPOS IS NEGATIVE
*
*        INTEGER ARGUMENT -- "OR" CASE
*
         NOPR  0                  SPACE CORRECTLY
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PO$RPOS  C     CP,PARAM1(PB,PO)   CHECK FOR MATCH WITH ARGUMENT
         BH    FAIL               NORMAL FAIL IF NOT THERE YET
         BE    SUCCSN             ON MATCH, SUCCEED WITH NO CP MOVE
         B     LFAIL              LENGTH FAIL IF PAST ALREADY
         EJECT
*
*        ENTRY POINTS FOR RTAB
*
*        FOR INTEGER CASE --
*        PARAM1                   ARGUMENT TO RTAB
*        EXTEND                   NONE
*
*        FOR DEFERRED EXPRESSION CASE --
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*
*
*        EXPRESSION ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$RTABD-*)      OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN ROUTINE BASE REG
PN$RTABD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERN  01,003             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO RTAB IS NOT AN INTEGER
         XERN  13,003             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO RTAB IS NEGATIVE
*
*        INTEGER ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$RTAB-*)       OFFSET TO CODE FOR "OR" CASE
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PN$RTAB  C     CP,PARAM1(PB,PO)   TEST CURRENT LOCATION AGAINST ARG
         L     CP,PARAM1(PB,PO)   LOAD NEW CURSOR POSITION IN CASE OK
         BNL   SUCC               OK IF AT OR BEHIND INDICATED LOC
         B     LBACKUP            ELSE LENGTH FAIL
*
*        EXPRESSION ARGUMENT -- "OR" CASE
*
         USING *,RETURN           PATTERN ROUTINE BASE REG
PO$RTABD BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERR  01,003             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO RTAB IS NOT AN INTEGER
         XERR  13,003             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO RTAB IS NEGATIVE
*
*        INTEGER ARGUMENT -- "OR" CASE
*
         NOPR  0                  SPACE CORRECTLY
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PO$RTAB  L     NCP,PARAM1(PB,PO)  LOAD PARAMETER
         CR    NCP,CP             CHECK AGAINST NUMBER OF CHARS LEFT
         BNH   SUCCS              ALL OK IF NOT BEHIND CURRENT LOC
         B     LFAIL              ELSE LENGTH FAIL
         EJECT
*
*        ENTRY POINTS FOR TAB
*
*        FOR INTEGER CASE --
*        PARAM1                   TAB ARGUMENT
*        EXTEND                   NONE
*
*        FOR DEFERRED EXPRESSION CASE --
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*
*        EXPRESSION ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$TABD-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN ROUTINE BASE REG
PN$TABD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERN  01,004             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO TAB IS NOT AN INTEGER
         XERN  13,004             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO TAB IS NEGATIVE
*
*        INTEGER ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$TAB-*)        OFFSET TO CODE FOR "OR" CASE
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PN$TAB   L     R1,PARAM1(PB,PO)   LOAD TAB ARGUMENT
         LH    NCP,PSTGLEN(,PDR)  LOAD SUBJECT STRING LENGTH
         SR    NCP,R1             MINUS ARG = NUM CHARS TO BE LEFT
         CLR   NCP,CP             CHECK FOR PLUS, LE O6D CURSOR LOC
         LR    CP,NCP             LOAD NEW CURSOR LOCATION
         BNH   SUCC               SUCCEED IF NOT BEHIND CURRENT LOC
         B     LBACKUP            ELSE LENGTH FAIL
         EJECT
*
*        TAB ENTRY POINTS -- CONTINUED
*
*
*        EXPRESSION ARGUMENT -- "OR" CASE
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$TABD  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERR  01,004             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO TAB IS NOT AN INTEGER
         XERR  13,004             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO TAB IS NEGATIVE
*
*        INTEGER ARGUMENT -- "OR" CASE
*
         NOPR  0                  SPACE CORRECTLY
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PO$TAB   L     R1,PARAM1(PB,PO)   LOAD TAB ARGUMENT
         LH    NCP,PSTGLEN(,PDR)  LOAD SUBJECT STRING LENGTH
         SR    NCP,R1             GET NUM OF CHARS WHICH WILL BE LEFT
         CLR   NCP,CP             CHECK FOR PLUS, LE O6D CURSOR LOC
         BNH   SUCCS              SUCCEED IF NOT BEHIND CURRENT LOC
         B     LFAIL              ELSE LENGTH FAILURE
         EJECT
*
*        ENTRY POINTS FOR LEN
*
*        FOR INTEGER CASE --
*        PARAM1                   LEN ARGUMENT
*        EXTEND                   NONE
*
*        FOR DEFERRED EXPRESSION CASE --
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*
*        EXPRESSION ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$LEND-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN ROUTINE BASE REG
PN$LEND  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERN  01,005             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO LEN IS NOT AN INTEGER
         XERN  13,005             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO LEN IS NEGATIVE
*
*        INTEGER ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$LEN-*)        OFFSET TO CODE FOR "OR" CASE
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PN$LEN   S     CP,PARAM1(PB,PO)   SUBTRACT ARG FROM NUM CHARS LEFT
         BNM   SUCC               SUCCEED IF NOT OFF END OF STRING
         B     LBACKUP            ELSE LENGTH FAILURE
*
*        EXPRESSION ARGUMENT -- "OR" CASE
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$LEND  BAL   NCP,DEFEXPI        GET INTEGER AND STORE IN PARAM1
         XERR  01,005             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO LEN IS NOT AN INTEGER
         XERR  13,005             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO LEN IS NEGATIVE
*
*        INTEGER ARGUMENT -- "OR" CASE
*
         NOPR  0                  SPACE CORRECTLY
         DROP  RETURN             THIS ROUTINE MUST NOT USE A BASE REG
PO$LEN   LR    NCP,CP             COPY CURRENT LOCATION
         S     NCP,PARAM1(PB,PO)  SUBTRACT ARG FROM NUM CHARS LEFT
         BNM   SUCCS              SUCCEED WITH STACK IF NOT OFF END
         B     LFAIL              ELSE LENGTH FAILURE
         EJECT
*
*        ENTRY POINTS FOR @
*
*        FOR NAME CASE --
*        PARAM1                   NAME BASE
*        PARAM2                   NAME OFFSET
*        EXTEND                   NONE
*
*        FOR DEFERRED EXPRESSION ARGUMENT --
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*        EXPRESSION ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$@D-*)         OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$@D    BAL   NCP,DEFEXPN        EVAL EXPR TO GET NAME, MERGE *+14
*
*        NORMAL ARGUMENT -- "NOOR" CASE
*
         DC    Y(PO$@-*)          OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$@     L     BPS,PARAM1(PB,PO)  LOAD NAME BASE
         A     BPS,PARAM2(PB,PO)  ADD NAME OFFSET
*
*        DEFERRED CASE MERGES HERE
*
         LH    R2,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH
         SR    R2,CP              MINUS NUMBER OF CHARACTERS LEFT
         SR    R1,R1              INDICATE INTEGER RESULT
         BAL   NCP,PATASSGN       ASSIGN WITH OUTPUT ASSOC CHECK
         B     SUCC               AND SUCCEED
*
*        EXPRESSION ARGUMENT -- "OR" CASE
*
         USING *,RETURN           PATTERN BASE REG
PO$@D    BAL   NCP,DEFEXPN        EVAL EXPR TO GET NAME, MERGE *+14
*
*        NORMAL ARGUMENT -- "OR" CASE
*
         DC    Y(0)               SPACE FOR PROPER MERGE FROM DEFEXPN
         USING *,RETURN           PATTERN BASE REG
PO$@     L     BPS,PARAM1(PB,PO)  LOAD NAME BASE
         A     BPS,PARAM2(PB,PO)  ADD NAME OFFSET
*
*        DEFERRED CASE MERGES HERE
*
         LH    R2,PSTGLEN(,PDR)   LOAD SUBJECT STRING LENGTH
         SR    R2,CP              MINUS NUMBER OF CHARACTERS LEFT
         SR    R1,R1              INDICATE INTEGER RESULT
         BAL   NCP,PATASSGN       ASSIGN WITH OUTPUT ASSOC CHECK
         B     SUCCSN             AND SUCCEED WITH NO CURSOR MOVEMENT
         EJECT
*
*        ENTRY POINTS FOR ANY (NORMAL CASES -- NOT DEFERRED)
*
*        PARAM1                   POINTER TO TBLOK CONTAINING BIT TABLE
*        PARAM2                   TM    CTCHARS(R2),BITMASK
*        EXTEND                   NONE
*
*        ONE 256-CHARACTER TBLOK IS USED FOR 8 ANY OR NOTANY PATTERNS
*        THE MASK IN THE TM INSTRUCTION HAS THE SELECTED BIT ON
*        THE TBLOK BYTES HAVE THE PROPER BIT ON FOR SELECTED CHARS
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$ANY-*)        OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$ANY   LCR   R1,CP              MINUS NUMBER OF CHARS LEFT
         BZ    LBACKUP            LENGTH FAIL IF NO CHARS LEFT
         SR    R2,R2              CLEAR FOR FOLLOWING IC
         IC    R2,0(R1,FSADR)     PICK UP CHARACTER TO BE TESTED
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS
         EX    0,PARAM2(PB,PO)    EXECUTE THE TM INSTRUCTION
         BNO   BACKUP             FAIL IF BIT NOT ON
         BCT   CP,SUCC            STEP CURSOR AND SUCCEED
         B     SUCC               SUCCEED EVEN IF BCT FALLS THROUGH
*
*        CASE OF "OR" POINTER PRESENT
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$ANY   LCR   R1,CP              MINUS NUMBER OF CHARACTERS LEFT
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT
         SR    R2,R2              CLEAR FOR FOLLOWING IC
         IC    R2,0(R1,FSADR)     LOAD CHARACTER TO BE TESTED
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS
         EX    0,PARAM2(PB,PO)    EXECUTE THE TM INSTRUCTION
         BNO   FAIL               TAKE ALTERNATIVE IF BIT IS NOT ON
         LR    NCP,CP             COPY OLD LOCATION
         BCT   NCP,SUCCS          UPDATE POINTER AND SUCCEED
         B     SUCCS              SUCCEED EVEN IF BCT FALLS THROUGH
         EJECT
*
*        ANY ENTRY POINTS -- CONTINUED
*
*        DEFERRED ARGUMENT CASE
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$ANYD-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTER BASE REG
PN$ANYD  LTR   CP,CP              TEST FOR NO MORE CHARS LEFT
         BZ    LBACKUP            LENGTH FAIL IF SO
         BAL   NCP,DEFEXPS        GET A STRING
         XERN  01,006             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO ANY IS NOT A STRING
         XERN  13,006             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO ANY IS NULL
         BZ    BACKUP             FAIL IF NO MATCH FOUND
         BCT   CP,SUCC            ELSE CRANK CURSOR AND SUCCEED
         B     SUCC               BRANCH EVEN IF BCT FALLS THROUGH
*
*        CASE OF "OR" POINTER PRESENT
*
PO$ANYD  LTR   CP,CP              TEST FOR NO MORE CHARS LEFT
         BZ    LFAIL              LENGTH FAIL IF NO MORE LEFT
         BAL   NCP,DEFEXPS        ELSE GET A STRING
         XERR  01,006             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO ANY IS NOT A STRING
         XERR  13,006             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO ANY IS NULL
         BZ    FAIL               FAIL IF NO MATCH
         LR    NCP,CP             ELSE MOVE CURSOR
         BCT   NCP,SUCCS          SUCCEED CRANKING POINTER
         B     SUCCS              SUCCEED EVEN IF BCT FALLS THROUGH
         EJECT
*
*        ENTRY POINTS FOR NOTANY (NORMAL CASES -- NOT DEFFERED)
*
*        PARAM1                   POINTER TO TBLOK CONTAINING BIT TABLE
*        PARAM2                   TM   CTCHARS(R2),BITMASK
*        EXTEND                   NONE
*
*        ONE 256 CHARACTER TBLOK IS USED FOR UP TO 8 ANY AND NOTANY
*        PATTERNS. THE MASK IN THE TM INSTRUCTION HAS THE SELECTED BIT
*        ON. THE TBLOK BYTES HAVE THIS BIT ON FOR SELECTED CHARACTERS.
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$NANY-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$NANY  LCR   R1,CP              MINUS NUMBER OF CHARS LEFT
         BZ    LBACKUP            LENGTH FAIL IF NO CHARS LEFT
         SR    R2,R2              ELSE CLEAR FOR FOLLOWING IC
         IC    R2,0(R1,FSADR)     PICK UP CHARACTER TO BE TESTED
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS
         EX    0,PARAM2(PB,PO)    EXECUTE TM INSTRUCTION
         BO    BACKUP             FAIL IF BIT IS ON
         BCT   CP,SUCC            ELSE STEP CURSOR AND SUCCEED
         B     SUCC               SUCCEED EVEN IF BCT FALLS THROUGH
*
*        CASE OF "OR" POINTER PRESENT
*
         USING *,RETURN           PATTERN ROUTINE BASE REGISTER
PO$NANY  LCR   R1,CP              MINUS NUMBER OF CHARACTERS LEFT
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT
         SR    R2,R2              ELSE CLEAR FOR FOLLOWING IC
         IC    R2,0(R1,FSADR)     LOAD CHARACTER TO BE TESTED
         A     R2,PARAM1(PB,PO)   ADD TABLE ADDRESS
         EX    0,PARAM2(PB,PO)    EXECUTE THE TM INSTRUCTION
         BO    FAIL               FAIL IF BIT IS ON
         LR    NCP,CP             ELSE COPY OLD LOCATION
         BCT   NCP,SUCCS          SET NEW CURSOR POSITION AND SUCCEED
         B     SUCCS              SUCCEED EVEN IF BCT FALLS THROUGH
         EJECT
*
*        NOTANY ENTRY POINTS -- CONTINUED
*
*        DEFERRED ARGUMENT CASE
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$NANYD-*)      OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE
PN$NANYD LTR   CP,CP              TEST FOR NO MORE CHARS LEFT
         BZ    LBACKUP            LENGTH FAIL IF NO MORE
         BAL   NCP,DEFEXPS        ELSE GET A STRING
         XERN  01,007             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO NOTANY IS NOT A STRING
         XERN  13,007             EVALUTED RESULT OF DEFERRED ARGUMENT
*                                 TO NOTANY IS NULL
         BNZ   BACKUP             FAIL ON MATCH
         BCT   CP,SUCC            ELSE SUCCEED BUMPING CURSOR
         B     SUCC               BRANCH EVEN IF BCT FALLS THROUGH
*
*        CASE OF "OR" POINTER PRESENT
*
PO$NANYD LTR   CP,CP              TEST FOR NO MORE CHARS
         BZ    LFAIL              LENGTH FAIL IF NO MORE CHARS
         BAL   NCP,DEFEXPS        ELSE GET STRING
         XERR  01,007             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO NOTANY IS NOT A STRING
         XERR  13,007             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO NOTANY IS NULL
         BNZ   FAIL               FAIL ON MATCH
         LR    NCP,CP             MOVE CURSOR TO "NEW" REG
         BCT   NCP,SUCCS          SUCCEED BUMPING CURSOR
         B     SUCCS              BRANCH EVEN IF BCT FALLS THROUGH
         EJECT
*
*        ENTRY POINTS FOR SPAN (NORMAL CASE -- NOT DEFERRED)
*
*        PARAM1                   TBLOK ADDRESS
*        EXTEND                   NONE
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$SPAN-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$SPAN  L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS
         LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT
         BZ    LBACKUP            LENGTH FAILURE IF NO CHARS LEFT
         BCTR  R1,0               ADJUST COUNT OF CHARS LEFT FOR 360
         LR    NCP,FSADR          END OF STRING ADDRESS
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC
         LA    R0,256             CONSTANT 256 LOADED
         CR    R1,R0              DO WE HAVE A SHORT STRING LEFT?
         BL    PN$SPN2            SKIP IF YES
PN$SPN3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARACTERS
         BC    7,PN$SPN4          SKIP IF WE HIT AN UNMATCHED CHAR
         AR    NCP,R0             PUSH POINTER
         SR    R1,R0              DECREASE SIZE LEFT
         CR    R1,R0              IS STRING LEFT SHORT YET?
         BNL   PN$SPN3            BACK IN LOOP IF NOT
PN$SPN2  EX    R1,SPANTRT         CHECK LAST CHARACTERS
         BC    7,PN$SPN4          SKIP IF UNMATCHED CHARACTER
         SR    CP,CP              ELSE POINT TO END OF STRING
         B     SUCC               AND SUCCEED
PN$SPN4  SR    R1,FSADR           STOP CHR - END STG = -NUM CHARS LEFT
         LCR   NCP,R1             GET PROPER UPDATED POINTER
         CR    NCP,CP             WERE ANY CHARACTERS MATCHED?
         LR    CP,NCP             LOAD UPDATED CURSOR LOCATION
         BL    SUCC               AND SUCCEED IF CHARS WERE MATCHED
         B     BACKUP             ELSE FAIL IF NO CHARS MATCHED
         EJECT
*
*        SPAN ENTRY POINTS -- CONTINUED
*
*        DEFERRED CASE (PO$SPAND AND PN$SPAND MERGE TO SAVE SPACE)
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
         DC    Y(PO$SPAND-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN ROUTINE BASE
PN$SPAND EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$SPAND LTR   CP,CP              TEST FOR NO MORE CHARS
         BZ    LFAIL              LENGTH FAIL IF NO MORE CHARS
         BAL   NCP,DEFEXPS        GET A STRING
         USING *,NCP              BASE REGISTER SET BY DEFEXPS
         XERR  01,008             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO SPAN IS NOT A STRING
         XERR  13,008             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO SPAN IS NULL
         BZ    FAIL               FAILURE IF NO MATCH ON FIRST CHAR
         CH    R2,H1              IS ARGUMENT ONLY ONE CHARACTER?
         BE    PO$SPND1           SKIP TO USE IN CORE TBL IF 1 CHAR
         SR    R0,R0              INITIALIZE A REGISTER TO
         BCTR  R0,0               ALL ONE BITS FOR TABLE
         LR    R1,R0              COPY FOR TWO WORD STORE
         STM   R0,R1,8(PDR)       MAKE FIRST DBLWRD OF TABLE
         MVC   16(248,PDR),8(PDR) FINISH FILLING TABLE
         SR    BPS,BPS            GET A ZERO CONSTANT
         SR    R1,R1              CLEAR FOR USE IN LOOP
*
*        LOOP TO PLUG SELECTED CHARS ZERO
*
PO$SPNDL IC    R1,SCHARS(,RETURN) LOAD CHARACTER
         STC   BPS,8(PDR,R1)      PLUG TO ZERO = NON-STOP CHARACTER
         LA    RETURN,1(,RETURN)  POINT TO NEXT CHAR
         BCT   R2,PO$SPNDL        LOOP BACK IF MORE CHARS TO GO
*
*        PREPARE AND MERGE TO STANDARD ROUTINE
*
         LA    BPS,12             RESTORE BPS
         LA    R2,8-CTCHARS(,PDR) POINT TO TABLE FOR MERGE
         LA    RETURN,PO$SPAN     POINT BASE REG FOR STANDARD ROUTINE
         B     PO$SPNM-PO$SPAN(,RETURN)     JUMP TO MERGE POINT
*
*        COME HERE IF RETURNED ARGUMENT IS ONE CHARACTER LONG
*
PO$SPND1 L     R2,=A(SPANTBL)     LOAD ADDRESS OF SPITBOL TBL OF 1 CHAR
         SR    R1,R1              CLEAR FOR IC OF ARGUMENT CHARACTER
         IC    R1,SCHARS(,RETURN) LOAD ARGUMENT CHARACTER
         SR    R2,R1              GET TABLE ADDRESS FOR THIS CHARACTER
         LA    RETURN,PO$SPAN     SET UP BASE REGISTER FOR STANDARD SPN
         B     PO$SPNM-PO$SPAN(,RETURN)     AND JUMP TO MERGE POINT
         DROP  NCP,RETURN         DROP UNNECESSARY BASE REGISTERS
         EJECT
*
*        ENTRY POINTS FOR SPAN (CONTINUED)
*
*
*        CASE OF "OR" POINTER PRESENT
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$SPAN  L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS
*
*        DEFERRED CASE PO$SPAND MERGES HERE
*
PO$SPNM  LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT
         BCTR  R1,0               ELSE SUBTRACT ONE TO GET 360 LENGTH
         LR    NCP,FSADR          END OF STRING ADDRESS
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC
         LA    R0,256             CONSTANT 256
         CR    R1,R0              DO WE HAVE A SHORT STRING LEFT?
         BL    PO$SPN2            SKIP IF SHORT
PO$SPN3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARACTERS
         BC    7,PO$SPN4          SKIP IF UNMATCHED CHARACTER
         AR    NCP,R0             ELSE CRANK CHARACTER POINTER 256
         SR    R1,R0              SUBTRACT 256 FROM LENGTH
         CR    R1,R0              IS STRING LEFT SHORT YET?
         BNL   PO$SPN3            STAY IN LOOP IF NOT
PO$SPN2  EX    R1,SPANTRT         CHECK LAST CHARACTERS
         BC    7,PO$SPN4          SKIP IF CHARACTER UNMATCHED
         SR    NCP,NCP            ELSE POINT TO END OF STG
         B     SUCCS              AND SUCCEED WITH A STACK
PO$SPN4  SR    R1,FSADR           STOP CHR-END STG = -NUM CHARS LEFT
         LCR   NCP,R1             GET UPDATED CURSOR LOCATION
         CR    NCP,CP             WERE ANY CHARS MATCHED
         BL    SUCCS              SUCCEED WITH STACK IF CHARS MATCHED
         B     FAIL               ELSE FAIL IF NO CHARS MATCHED
*
SPANTRT  TRT   0(*-*,NCP),CTCHARS(R2)       TRT FOR LAST CHARACTERS
         EJECT
*
*        BREAKX ENTRY POINTS
*
*        CASE OF DEFERRED ARGUMENT
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   BRKXDEXT
*
*
         DC    Y(PO$BRKXD-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$BRKXD EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$BRKXD ST    CP,S1OLDCP(,PS1)   SAVE CURRENT CURSOR ON STACK
         LR    NCP,CP             SET FOR MERGE WITH EXTENSION ROUTINE
*
*        REENTER HERE WHEN EXTENDING
*
PO$BKXD1 LTR   CP,NCP             COPY CURSOR AND TEST FOR END
         BZ    LFAIL              LENGTH FAIL IF SO
         BAL   NCP,DEFEXPS        GET A STRING
         USING *,RETURN           RETURN WILL HAVE PROPER VALUE
         XERR  01,009             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO BREAKX IS NOT A STRING
         XERR  13,009             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO BREAKX IS NULL
         LR    R0,R2              COPY LENGTH OF RETURNED STRING
         LR    R2,RETURN          SAVE STRING STARTING ADDRESS
         LR    RETURN,NCP         SET UP PROMISED BASE REGISTER
         LR    NCP,CP             GET 'NEW' CURSOR
         L     CP,S1OLDCP(,PS1)   RESTORE OLD CURSOR
         BNZ   MATCHBKX           IMMEDIATE SUCCESS IF BREAK CHAR FND
         SR    R1,R1              CLEAR FOR IC USAGE
         CH    R0,H1              CHECK FOR ONE CHAR BREAK
         BE    PO$BKXD2           OFF TO SPECIAL CODE IF ONE CHAR CASE
         STD   ZR,8(,PDR)         STORE FIRST TABLE WORD
         MVC   16(248,PDR),8(PDR) FINISH FILLING TABLE
         EJECT
*
*        BREAKX ENTRY POINTS (CONTINUED)
*
*        LOOP TO PLUG SELECTED CHARACTERS (DEFFERED CASE)
*
PO$BKXDL IC    R1,SCHARS(,R2)     PICK UP NEXT CHARACTER
         STC   BPS,8(PDR,R1)      PLUG TO NON-ZERO = STOP CHARACTER
         LA    R2,1(,R2)          BUMP CHARACTER POINTER
         BCT   R0,PO$BKXDL        LOOP BACK IF MORE CHARS TO GO
*
*        NOW MERGE INTO STANDARD ROUTINE
*
         LA    RETURN,PO$BRKX     POINT BASE REG FOR STANDARD ROUTINE
         LA    R2,8-CTCHARS(,PDR) POINT TO TABLE FOR MERGE
         B     PO$BRKXM-PO$BRKX(,RETURN)    MERGE WITH STD ROUTINE
*
*        COME HERE TO USE SPITBOL TABLE FOR ONE CHARACTER BREAK
*
PO$BKXD2 IC    R1,SCHARS(,R2)     LOAD ARGUMENT CHARACTER
         L     R2,PSAVDB1(,PDR)   LOAD POINTER TO DATA AREA
         LA    R2,BREAKTBL-SPITBOLD(,R2)    POINT TO MASTER BREAK TABLE
         SR    R2,R1              GET BREAK TABLE ADDRESS FOR THIS CASE
         LA    RETURN,PO$BRKX     SET UP BASE REGISTER FOR MERGE
         B     PO$BRKXM-PO$BRKX(,RETURN)    MERGE WITH STD ROUTINE
         EJECT
*
*        BREAKX ENTRY POINTS -- CONTINUED
*
*        NORMAL CASE -- NOT DEFFERRED
*
*        PARAM1                   TBLOK POINTER
*        EXTEND                   BRKXEXT
*
*
         DC    Y(PO$BRKX-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$BRKX  EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$BRKX  LR    NCP,CP             INITIALIZE CURSOR
*
*        REENTER HERE WHEN EXTENDING
*
PO$BRKX1 L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS
*
*        MERGE HERE FROM DEFERRED CASE
*
PO$BRKXM LTR   R1,NCP             TEST NUMBER OF CHARS LEFT
         BZ    LFAIL              LENGTH FAIL IF NONE LEFT
         BCTR  R1,0               ADJUST FOR 360
         LCR   NCP,NCP            MINUS NUM CHARS LEFT
         AR    NCP,FSADR          POINT TO CURRENT NEXT CHAR
         LA    R0,256             CRANK FOR LOOP
         CR    R1,R0              CHECK FOR 256 CHARS OR LESS
         BL    PO$BRKX2           SKIP IF SO
*
*        LOOP TO TEST 256 CHARS AT A TIME
*
PO$BRKX3 TRT   0(256,NCP),CTCHARS(R2)       TEST 256 CHARS
         BNZ   PO$BRKX4           SKIP IF BREAK CHAR FOUND
         AR    NCP,R0             ELSE PUSH STRING POINTER
         SR    R1,R0              DECREMENT COUNT
         CR    R1,R0              HOW MANY CHARS LEFT?
         BNL   PO$BRKX3           LOOP BACK IF STILL MORE THAN 256
*
*        COME HERE TO TEST LAST CHARACTERS
*
PO$BRKX2 EX    R1,BREAKTRT        TEST LAST CHARS
         BZ    LFAIL              LENGTH FAIL IF NOTHING FOUND
*
*        COME HERE WHEN BREAK CHAR IS FOUND
*
PO$BRKX4 LCR   NCP,R1             MINUS LOC OF BREAK CHAR
         AR    NCP,FSADR          SET NCP PROPERLY
         B     MATCHBKX           FINISH MATCH IN PROPER MODE
         EJECT
*
*        ENTRY POINTS FOR BREAK (NORMAL CASE -- NOT DEFERRED)
*
*        PARAM1                   POINTER TO TBLOK
*        EXTEND                   NONE
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$BREAK-*)      OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$BREAK L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS
         LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT
         BZ    LBACKUP            FAIL IF NO CHARS LEFT
         BCTR  R1,0               ELSE MINUS ONE FOR 360 LENGTH
         LR    NCP,FSADR          ADDRESS OF END OF STRING
         SR    NCP,CP             MINUS CHARS LEFT = CURRENT ADDRESS
         LA    R0,256             GET CONSTANT 256
         CR    R1,R0              IS IT A SHORT STRING LEFT
         BL    PN$BRK2            IF SO, SKIP
PN$BRK3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARACTERS
         BC    7,PN$BRK4          BRANCH IF A BREAK CHARACTER FOUND
         AR    NCP,R0             ELSE CRANK CHARACTER LOCATION
         SR    R1,R0              CRANK DOWN COUNT OF CHARS LEFT
         CR    R1,R0              IS IT SMALL YET
         BNL   PN$BRK3            SKIP BACK IN LOOP IF NOT
PN$BRK2  EX    R1,BREAKTRT        TEST REMAINING CHARACTERS
         BC    8,LBACKUP          LENGTH FAIL IF NO BREQK CHAR FOUND
PN$BRK4  LCR   CP,R1              MINUS LOCATION OF STOP CHARACTER
         AR    CP,FSADR           PLUS STG END ADDR = NUM CHARS LEFT
         B     SUCC               SUCCEED
         EJECT
*
*        BREAK ENTRY POINTS -- CONTINUED
*
*        DEFERRED CASE (PO$BRKD AND PN$BRKD MERGE TO SAVE SPACE)
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   NONE
*
         DC    Y(PO$BRKD-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN ROUTINE BASE
PN$BRKD  EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$BRKD  LTR   CP,CP              TEST FOR NO MORE CHARS LEFT
         BZ    LFAIL              LENGTH FAIL IF SO
         BAL   NCP,DEFEXPS        GET A STRING
         USING *,NCP              BASE REGISTER SET BY DEFEXPS
         XERR  01,010             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO BREAK IS NOT A STRING
         XERR  13,010             EVALUATED RESULT OF DEFERRED ARGUMENT
*                                 TO BREAK IS NULL
         BNZ   SUCCSN             JUST SUCCEED IF BRK CHAR FOUND
         SR    R1,R1              CLEAR FOR IC USAGE
         CH    R2,H1              CHECK FOR ONE CHARACTER CASE
         BE    PO$BRKD1           OFF TO SPECIAL CODE IF ONE CHARACTER
         STD   ZR,8(,PDR)         INITIALIZE FIRST TABLE WORD
         MVC   16(248,PDR),8(PDR) FINISH CLEARING TABLE
*
*        LOOP TO PLUG SELECTED CHARS NON-ZERO
*
PO$BRKDL IC    R1,SCHARS(,RETURN) PICK UP NEXT CHARACTER
         STC   BPS,8(PDR,R1)      PLU TO NON-ZERO = STOP CHARACTER
         LA    RETURN,1(,RETURN)  POINT TO NEXT CHAR
         BCT   R2,PO$BRKDL        LOOP BACK TILL CHARS EXHAUSTED
*
*        NOW PREPARE TO MERGE WITH NORMAL ROUTINE
*
         LA    R2,8-CTCHARS(,PDR) POINT TO TABLE FOR MERGE
         LA    RETURN,PO$BREAK    SET BASE REG FOR STANDARD ROUTINE
         B     PO$BRKM            MERGE WITH STANDARD ROUTINE
*
*        COME HERE TO USE SPITBOL TABLE FOR ONE CHARACTER BREAK
*
PO$BRKD1 IC    R1,SCHARS(,RETURN) LOAD ARGUMENT CHARACTER
         L     R2,PSAVDB1(,PDR)   LOAD POINTER TO DATA AREA
         LA    R2,BREAKTBL-SPITBOLD(,R2)    POINT TO MASTER BREAK TABLE
         SR    R2,R1              CALCULATE TABLE ADDRSS
         LA    RETURN,PO$BREAK    SET BASE REG FOR STANDARD ROUTINE
         B     PO$BRKM            MERGE WITH STANDARD ROUTINE
         DROP  RETURN,NCP         DROP BASE REGISTERS
         EJECT
*
*        ENTRY POINTS FOR BREAK (CONTINUED)
*
*
*
*        CASE OF "OR" POINTER PRESENT
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$BREAK L     R2,PARAM1(PB,PO)   LOAD TBLOK ADDRESS
*
*        DEFERRED CASE PO$BRKD MERGES HERE
*
PO$BRKM  LTR   R1,CP              COPY AND TEST NUMBER OF CHARS LEFT
         BZ    LFAIL              LENGTH FAIL IF NO CHARS LEFT
         BCTR  R1,0               ELSE MINUS ONE FOR 360 LENGTH
         LR    NCP,FSADR          ADDRESS OF END OF STRING
         SR    NCP,CP             MINUS CHARS LEFT = CURRENT ADDRESS
         LA    R0,256             CONSTANT 256
         CR    R1,R0              DO WE HAVE A SHORT STRING LEFT?
         BL    PO$BRK2            SKIP IF SHORT
PO$BRK3  TRT   0(256,NCP),CTCHARS(R2)       CHECK 256 CHARS
         BC    7,PO$BRK4          SKIP IF BREAK CHARACTER FOUND
         AR    NCP,R0             ELSE BUMP CHARACTER POINTER BY 256
         SR    R1,R0              COUNT LENGTH LEFT DOWN 256 CHARS
         CR    R1,R0              IS STRING LEFT SHORT YET?
         BNL   PO$BRK3            LOOP BACK IF NOT
PO$BRK2  EX    R1,BREAKTRT        TEST LAST CHARACTERS
         BC    8,LFAIL            LENGTH FAIL IF NO BREAK CHAR FOUND
PO$BRK4  LCR   NCP,R1             MINUS ADDRESS OF STOP CHARACTER
         AR    NCP,FSADR          ADD END OF STG ADDR TO GET NUM CHARS
         B     SUCCS              AND SUCCEED
*
BREAKTRT TRT   0(*-*,NCP),CTCHARS(R2)       CHECK FINAL CHARACTERS
         EJECT
*
*        FAIL ENTRY POINTS
*
*        EXTEND                   NONE
*
*
*        NOTE -- STRICTLY, WE COULD INDICATE LENGTH FAILURE FOR FAIL
*        SINCE EXTENSION IS CLEARLY USELESS
*        HOWEVER, WHEN FAIL IS USED, HE MUST BE INTERESTED IN HOW THE
*        PATTERN IS BEING MATCHED, SO WE GIVE AN ORDINARY FAIL
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$FAIL-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$FAIL  B     BACKUP             AUTOMATIC FAILURE
*
*        CASE OF "OR" POINTER PRESENT
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$FAIL  B     FAIL               AUTOMATICALLY TAKE ALTERNATIVE
         EJECT
*
*        ENTRY POINTS FOR NULL PATTERN
*
*        EXTEND                   NONE
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$NULL-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$NULL  B     SUCC               JUST SUCCEED
*
*        CASE OF "OR" PATTERN PRESENT
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$NULL  B     SUCCSN             SUCCEED WITH NO CP MOVEMENT
         EJECT
*
*        ENTRY POINTS FOR ABORT
*
*        EXTEND                   NONE
*
*        "OR" AND "NOOR" CASES MERGE FOR ABORT
*
         DC    Y(PO$ABORT-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$ABORT EQU   *                  ENTRY FOR "NOOR" CASE
PO$ABORT B     PABORT             AUTOMATIC PATTERN ABORTION
         EJECT
*
*        ENTRY POINTS FOR SUCCEED
*
*        EXTEND                   SUCCEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR SUCCEED
*
         DC    Y(PO$SUCC-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$SUCC  EQU   *                  ENTRY FOR "NOOR" CASE
PO$SUCC  B     SUCCSN             JUST SUCCEED WITH NO CHARS
         EJECT
*
*        ENTRY POINTS FOR REM
*
*        EXTEND                   NONE
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$REM-*)        OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$REM   SR    CP,CP              CLEAR COUNT OF CHARS LEFT
         B     SUCC               AND SUCCEED
*
*        CASE OF "OR" POINTER PRESENT
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$REM   SR    NCP,NCP            SET NCP TO END OF STRING
         B     SUCCS              AND SUCCEED
         EJECT
*
*        ENTRY POINTS FOR FENCE
*
*        EXTEND                   FENCEEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR FENCE
*
         DC    Y(PO$FENCE-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE
PN$FENCE EQU   *                  ENTRY FOR "NOOR" CASE
PO$FENCE B     SUCCSN             SUCCEED WITH NO CURSOR MOVEMENT
         EJECT
*
*        ENTRY POINTS FOR ARB
*
*        EXTEND                   ARBEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR ARB
*
         DC    Y(PO$ARB-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$ARB   EQU   *                  ENTRY FOR "NOOR" CASE
PO$ARB   B     MATCHARB           GO TO ROUTINE APPROPRIATE TO SCAN MOD
         EJECT
*
*        ENTRY POINTS FOR ARBNO
*
*        PARAM1                   BACK POINTER TO START -- SEE $$ARBN
*        EXTEND                   ARBNOEXT
*
*
         DC    Y(PO$ARBNO-*)      (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE
PN$ARBNO EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$ARBNO B     MATCHABN           JUMP TO SPECIAL MATCH ROUTINE
         EJECT
*
*        ENTRY POINTS FOR BAL
*
*        EXTEND                   BALEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR BAL
*
         DC    Y(PO$BAL-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$BAL   EQU   *                  ENTRY FOR "NOOR" CASE
PO$BAL   LTR   NCP,CP             ANY CHARS LEFT?
         BNZ   MATCHBAL           IS SO, -> ROUTINE APPROPRIATE TO MODE
         B     LFAIL              ELSE LENGTH FAIL
         EJECT
*
*        ENTRY POINTS FOR STRING OF 256 CHARS OR LESS
*
*        PARAM1                   STG BASE       (PARAMS CONTAIN NOR-)
*        PARAM2                   LENGTH/OFFSET  (MAL STRING SPECIFIER)
*        EXTEND                   NONE
*
*        NOTE THAT WE NEVER NEED TO SIGNAL LENGTH FAILURE IN THIS
*        SINCE IT IS IRRELEVANT IN FULLSCAN MODE, AND IN QUICKSCAN
*        WE WOULD NOT HAVE BEEN CALLED UNLESS THERE WERE ENOUGH
*        CHARACTERS FOR A SUCCESSFUL MATCH
*
*
*        CASE OF "NOOR" POINTER
*
         DC    Y(PO$STRS-*)       OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$STRS  L     R1,PARAM1(PB,PO)   LOAD STRING POINTER
         AH    R1,PARAM1+SOFFSET(PB,PO)     ADD IN OFFSET
         LH    R2,PARAM1+SLENGTH(PB,PO)     LOAD LENGTH - 1
         LR    NCP,FSADR          POINT NCP TO END OF STG
         SR    NCP,CP             MINUS CHARS LEFT = CURRENT LOCATION
         EX    R2,STRSCLC         COMPARE CHARACTERS
         BNE   BACKUP             FAIL IF NO MATCH
         BCTR  CP,0               ADJUST ONE FOR 360 LENGTH FUDGE
         SR    CP,R2              MINUS NUM CHARS-1
         BNM   SUCC               SUCCEED UNLESS OF END OF STG
         B     LBACKUP            IN WHICH CASE, LENGTH FAILURE
*
*        CASE OF "OR" POINTER PRESENT
*
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PO$STRS  L     R1,PARAM1(PB,PO)   LOAD STRING POINTER
         AH    R1,PARAM1+SOFFSET(PB,PO)     ADD IN OFFSET
         LH    R2,PARAM1+SLENGTH(PB,PO)     LOAD LENGTH - 1
         LR    NCP,FSADR          POINT NCP TO END OF STG
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC
         EX    R2,STRSCLC         COMPARE CHARACTERS
         BNE   FAIL               TAKE ALTERNATIVE IF NO MATCH
         LR    NCP,CP             COPY OLD POSITION
         BCTR  NCP,0              MINUS ONE CHAR FOR 360 FUDGE
         SR    NCP,R2             SUBTRACT NUMBER OF CHARS - 1
         BNM   SUCCS              SUCCEED UNLESS OF END OF STG
         B     LFAIL              IN WHICH CASE, LENGTH FAILURE
*
STRSCLC  CLC   0(*-*,NCP),SCHARS(R1)        COMPARE CHARACTERS
         EJECT
*
*        ENTRY POINTS FOR STRING LONGER THAN 256 CHARACTERS
*
*        PARAM1                   STG BASE       (PARAMS CONTAIN NOR-)
*        PARAM2                   LENGTH/OFFSET  (MAL STRING SPECIFIER)
*        EXTEND                   NONE
*
*
*        "OR"/"NOOR" CASES MERGE FOR LONG STRINGS
*        (THIS PATTERN IS SO RARE THAT WE WILL TOLERATE THE UNNEEDED
*        STACK ENTRY IN THE "NOOR" CASE TO SAVE SPACE HERE)
*
         DC    Y(PO$STRL-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           SET PATTERN ROUTINE BASE REG
PN$STRL  EQU   *                  ENTRY FOR "NOOR" CASE
PO$STRL  LH    R1,PARAM1+SLENGTH(PB,PO)     LOAD LENGTH - 1
         L     R2,PARAM1(PB,PO)   LOAD STRING POINTER
         AH    R2,PARAM1+SOFFSET(PB,PO)     ADD IN STRING OFFSET
         LR    NCP,FSADR          POINT NCP PAST END OF STG
         SR    NCP,CP             MINUS NUM CHARS LEFT = CURRENT LOC
         LA    R0,256             GET CRANK CONSTANT
PO$STRL1 CLC   0(256,NCP),0(R2)   CHECK 256 BYTE CHUNK
         BNE   FAIL               FAIL IF NO MATCH
         AR    NCP,R0             PUSH PATTERN STG CHARACTER PTR
         AR    R2,R0              PUSH TEST STG CHARACTER PTR
         SR    R1,R0              CRANK COUNT DOWN
         CR    R1,R0              DO WE HAVE MORE THAN 256 CHARS LEFT
         BH    PO$STRL1           BACK IN LOOP IF YES
         EX    R1,STRLCLC         ELSE COMPARE REMAINING CHARACTERS
         BNE   FAIL               FAIL IF THEY DO NOT MATCH
         LH    R1,PARAM1+SLENGTH(,PB)       RELOAD LENGTH - 1
         LR    NCP,CP             COPY CURRENT LOCATION
         BCTR  NCP,0              MINUS ONE FOR 360 FUDGE
         SR    NCP,R1             MINUS NUMBER OF CHARS-1
         BNM   SUCCS              SUCCEED UNLESS OFF END OF STG
         B     LFAIL              IN WHICH CASE, LENGTH FAILURE
*
STRLCLC  CLC   0(*-*,NCP),SCHARS(R2)        COMPARE LAST CHARACTERS
         EJECT
*
*        ENTRY POINTS FOR EXPRESSION
*
*        THIS IS ONE OF THE MORE COMPLICATED PATTERN MATCH ROUTINES
*
*        EVERY PATTERN WHICH REFERENCES AN EXPRESSION CONSISTS OF
*        TWO LINKED NODES -- THE FIRST NODE HAS A PARAMETER POINTER
*        TO THE CODE -- TWO CASES ARE POSSIBLE ON MATCHING THIS FIRST
*        NODE (EXP1) --
*
*        1)    THE EXPRESSION IS A STRING OR IS CONVERTIBLE TO A STRING
*              IN THIS CASE, WE SEE IF THE STRING MATCHES -- IF IT DOES
*              NOT, THEN WE FAIL TO TAKE THE ALTERNATIVE -- IF IT DOES
*              MATCH, THEN WE BYPASS THE SECOND NODE AND CONTINUE
*              AFTER MAKING A NOTHING ENTRY ON STACK 2 -- THIS ENTRY
*              IS JUST PUT THERE TO BE REMOVED BY EXP1EXT IF BACKUP
*              OCCURS SUBSEQUENTLY
*
*        2)    THE ARGUMENT IS A PATTERN -- IN THIS CASE, WE MAKE
*              AN ENTRY ON STACK 2 TO SAVE THE PB FOR THIS PATTERN
*              AND THE PO FOR THE EXP2 NODE -- (MINR) IS SET TO
*              ACCOUNT FOR THE CHARS WHICH REMAIN AT THIS LEVEL
*              AND WE PROCEED TO MATCH THE NEW PATTERN AFTER SETTING PB
*
*
*        IF WE BACKUP "OUT OF" THE EXPRESSION PATTERN WE GO THROUGH
*        THE EXTENSION ROUTINE FOR EXP1 WHICH MERELY REMOVES THE
*        ENTRY ON STACK 2 AND SEEKS ALTERNATIVES
*        EXP1EXT IS ENTERED THROUGH ANCHEXT WITH PO POSITIVE
*
*        AFTER SUCCESSFULLY MATCHING THE EXPRESSION PATTERN, ITS PB
*        IS SAVED IN THE CP FIELD OF THE EXP2 ENTRY ON STACK 1, THIS IS
*        SO THAT EXP2EXT CAN RESTORE THE STACK 2 ENTRY AND RESTORE
*        THE PATTERN BASE SETTING FOR THE EXPRESSION PATTERN IN THE
*        EVENT THAT THE MATCH BACKS UP INTO A REGION ON STACK 1
*        LEFT THERE FROM ELEMENTS IN THE EXPRESSION PATTERN
*
*        NOTE THAT THE PATTERN EXP2 IS NEVER ACTUALLY MATCHED -- ONLY
*        ITS EXTENSION ROUTINE IS USED
         EJECT
*
*        ENTRY POINTS FOR EXPRESSION -- CONTINUED
*
*        PATTERN MATCH ROUTINE FOR EXP1
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER (VCODE OR ECODE)
*        EXTEND                   EXP1EXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR EXP1
*
         DC    Y(PO$EXP1-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN ROUTINE BASE REG
PN$EXP1  EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$EXP1  L     RETURN,PARAM2(PB,PO)         LOAD EXPRESSION POINTER
         CR    R0,R0              SET CONDITION CODE EQ FOR CALL IN PAT
         BAL   R1,$EVAL           EVALUATE
         USING *,R1               BASE REG SET FROM $EVAL
         B     FAIL               FAIL IF CODE FAILS
*
*        RETURN IS MADE WITH DB1 INTACT, SO PO MUST BE RESTORED
*
         USING SPITBOLD,DB1       TELL ASEMBLER OF BASE REGISTER
         ST    A1,EVALSV          STORE POINTER TO CHECK CODE
         CLI   EVALSV,PCODE       IS IT A PATTERN?
         DROP  DB1                GET RID OF BASE REGISTER
         BE    PO$EXP1P           SKIP IF IT IS A PATTERN
         BAL   RETURN,GETSTGS     GET A STRING SPEC
         USING *,RETURN           NEW BASE REGISTER
         B     PO$EXERR           OFF TO GIVE ERR IF NOT CONVERTABLE
         L     PO,PSAVPO(,PDR)    RESTORE PATTERN OFFSET
         LR    NCP,CP             COPY CURSOR POINTER
         LTR   A1+1,A1+1          TEST FOR NULL (LENGTH NEGATIVE)
         BM    PO$EXP1M           SKIP IN CASE OF NULL
         BCTR  NCP,0              FUDGE FOR 360 LENGTH
         SR    NCP,A1+1           SUBTRACT LENGTH MATCHED
         BNM   *+12               SKIP IF NOT OFF END OF STRING
         LM    A1,A1+1,PSAVBPS(PDR)         RESTORE REGISTERS
         B     LFAIL              AND GIVE LENGTH FAILURE
         LCR   R1,CP              MINUS NUM CHARS LEFT
         AR    R1,FSADR           ADD END OF STRING ADDR = CUR CHAR
         LA    R0,256             GET INVALUABLE CONSTANT
         CR    A1+1,R0            ARE WE SHORT OR LONG?
         BL    PO$EXP1S           SKIP IF SHORT
*
*        LOOP TO COMPARE LONG STRINGS
*
PO$EXP1L CLC   SCHARS(256,A1),0(R1)         CHECK 256 CHARACTERS
         BNE   PO$EXP1F           IF NE, FAIL
         AR    R1,R0              PUSH UP CHAR ADDR
         AR    A1,R0              PUSH UP CHAR ADDR
         SR    A1+1,R0            DECREASE COUNT
         CR    A1+1,R0            SHORT OR LONG LEFT?
         BNL   PO$EXP1L           SKIP IF LONG
         EJECT
*
*        COMPARISON OF <256 CHARACTERS
*
PO$EXP1S EX    A1+1,PO$EXPC       CHECK THOSE CHARACTERS
         BE    PO$EXP1M           IF EQUAL, SUCCEED
*
*        ENTRY FOR FAILURE (MUST RESTORE BPS,PS2)
*
PO$EXP1F LM    A1,A1+1,PSAVBPS(PDR)         RESTORE THE REGISTERS
         B     FAIL               AND FAIL
*
*        REENTRY IN CASE OF NULL RESULT
*
PO$EXP1M LM    A1,A1+1,PSAVBPS(PDR)         RESTORE REGISTERS
         STM   PO,CP,0(PS1)       MAKE STACK1 ENTRIES
         AH    PO,THEN(PB,PO)     POINT THROUGH EXP2 PATTERN
         B     SUCCSP             AND SUCCEED PAST STM
*
*        COME HERE WHEN DEFERRED EXPRESSION IS A PATTERN
*
         DROP  RETURN             DROP THIS REG (BACK TO USING R1)
PO$EXP1P LR    R0,A1              SAVE NEW PATTERN BASE
         LM    A1,A1+1,PSAVBPS(PDR)         RESTORE THE REGISTERS
         L     PO,PSAVPO(,PDR)    RESTORE PATTERN OFFSET
         SR    PS2,BPS            MAKE ROOM ON STACK 2
         AH    PO,THEN(PB,PO)    POINT TO EXP2 PATTERN
         SH    MINR,MINMATCH(PB,PO)        DECR MINR APPROPRIATELY
         STM   PB,PO,S2PB+S2OFS(PS2)        MAKE STACK 2 ENT FOR NOTHEN
         L     PO,NCODEBT         SPECIAL STACK ENTRY NEEDS RIGHT 3
*                                 BYTES ZERO, WITH SOME POSITIVE VALUE
         STM   PO,CP,0(PS1)       MAKE PO/CP ENTRY ON STACK 1
         LR    PB,R0              LOAD NEW PATTERN BASE
         LA    PO,PATS            LOAD NEW PATTERN OFFSET
         B     SUCCSN+8           SUCCEED SKIPPING OVER STM AND AH
         DROP  R1                 THROUGH WITH THIS REG NOW
*
PO$EXPC  CLC   SCHARS(*-*,A1),0(R1)         COMPARE IN CASE OF NOT PAT
*
*        COME HERE TO ISSUE ERROR MESSAGE
*
PO$EXERR BAL   RETURN,$EVALERR    DO PROPER THINGS FOR SETEXIT
         XERR  01,011             EVALUATED RESULT OF DEFERRED
*                                 EXPRESSION USED IN A PATTERN MATCH
*                                 IS NOT A STRING OR PATTERN
         EJECT
*
*        ENTRY POINTS FOR NOTHEN PSEUDO PATTERN
*
*        NOTHEN IS NOT REALLY A PATTERN, HOWEVER, IT IS ENTERED AS
*        THOUGH IT WERE, SO IT IS INCLUDED IN THIS SECTION
*
*        THERE ARE TWO CASES POSSIBLE --
*
*        1)    THE REAL END OF PATTERN, IN WHICH CASE WE GO THROUGH
*              THE FULL END OF PATTERN LOGIC INCLUDING DOT ASSIGNMENTS
*
*        2)    THE END OF AN EXPRESSION PATTERN (RECURSIVE CALL)
*              IN WHICH CASE, WE POP UP A LEVEL AND CONTINUE
*
*
         USING *,RETURN           STANDARD PATTERN BASE
NOTHEN   LR    R1,PB              SAVE PAT BASE OF POSSIBLE EXPR PAT
         LM    PB,PO,S2PB+S2OFS(PS2)        LOAD LAST PB & PO
         LTR   PB,PB              TEST FOR ZERO ENTRY SIGNALLING END
         BZ    ENDPAT             IF FOUND, SKIP TO END OF PATTERN RTN
         ST    PO,0(,PS1)         MAKE STACK 1 ENTRY TO GET EXP2EXT
         ST    R1,4(,PS1)         SAVE EXPR PB IN CP FIELD
         AH    MINR,MINMATCH(PB,PO)         RESTORE MIRN
         BXH   PS2,BPS,SUCCSN+4   REM STK 2 ENTRY, SUCCEED PAST STM
*
*        COME HERE FOR REAL END OF PATTERN
*
ENDPAT   L     NCP,STACK1+S1NEWCP(,PDR)     GET ANCHOR MOVEMENT
         L     PB,PSAVDB1(,PDR)   RELOAD DATA AREA ADDRESS
         USING SPITBOLD,PB        TELL ASSEMBLER
         L     PB,PDRLOC          RESTORE PDR FOR THIS LEVEL
         DROP  PB                 GET RID OF BASE REGISTER
         STH   CP,MATCHPE(,PB)    STORE ENDING CURSOR LOCATION
         STH   NCP,MATCHPB(,PB)   STORE BEGINNING CURSOR LOCATION
         CLI   DOTSW(PDR),0       WERE ANY DOTS DONE?
         BE    PATENDE            END OF PATTERN IF NOT
         LR    CP,PS1             COPY END OF STACK 1 ADDRESS
         LA    PO,3*4             LOAD STACK ENTRY SIZE INCREMENT
         LA    MINR,STACK1(,PDR)  GET START OF STACK ADDRESS
         LA    PBASE,PATENDL3-(FAIL-QPATSUBS)         PATENDL3=FAILHERE
         USING PATENDL3-(FAIL-QPATSUBS),PBASE         TELL ASSEMBLER
         DROP  RETURN             GET RID OF OLD BASE REGISTER
*
*        FIRST DO SOME INITIAL CALCULATIONS FOR STG SPECIFIERS
*        THIS CALC LEAVES THE OFFSET OF THE LAST CHARACTER OF THE
*        SUBJECT STRING AT THE LEFT OF PENDWRD, RIGHT HALF = 0
*
         LH    R2,PSTRING+SOFFSET(,PB)      GET ORIGINAL OFFSET
         AH    R2,PSTGLEN(,PB)    PLUS ORIGINAL LENGTH
         SLL   R2,16              POSITION ON THE LEFT
         ST    R2,PENDWRD(,PDR)   AND SAVE ON STACK FOR FUTURE USE
         SR    CP,PO              POINT TO LAST STACK 1 ENTRY
         EJECT
*
*        THIS LOOP CYCLES THROUGH STACK1 LOOKING FOR DOT ASSIGNMENTS
*        TO BE PERFORMED.         ASSIGNMENTS MUST BE DONE IN ORDER
*
PATENDL  CLI   DOTLOC(MINR),DOTFLG          IS THIS A DOT ENTRY?
         BE    PATENDL4           GO TO PROCESS IT IF SO
*
*        COME HERE TO PUSH STACK POINTER AND CHECK FOR END OF STACK1
*
PATENDL3 BXLE  MINR,PO,PATENDL    LOOP BACK IF NOT AT STACK END
         B     PATENDE            ELSE END OF PATTERN MATCH
*
*        COME HERE TO DEAL WITH A DOT ENTRY - SEE STACK 1 FORMAT
*
PATENDL4 LM    R1,R2,0(MINR)      LOAD PB AND PO
         LA    BPS,0(R1,R2)       GET PATTERN NODE ADDRESS
         TM    PFLAGS(BPS),PRELOC2          SECOND PARAM RELOCATABLE?
         BNO   PATENDL0           REGULAR (NON-DEFERRED) DOT IF NOT
*
*        COME HERE TO PROCESS DEFERRED NAME
*
         L     RETURN,PARAM2(,BPS)          LOAD EXPRESSION POINTER
         CR    R0,R0              SET CC FOR CALL BY PATTERN MATCH
         BAL   R1,$EVAL           EVALUATE NAME
         B     PATENDL3           SKIP ASSIGN IF NAME FAILS
         LA    BPS,0(A1,A1+1)     POINT TO NAME FIELD
         L     PS2,PSAVPS2(,PDR)  RESTORE PS2 FROM STACK
         L     PO,PSAVPO(,PDR)    RESTORE PO/DB1 FOR MATCHING
         B     PATENDL1           AND MERGE TO CALCULATE VALUE
*
*        COME HERE FOR NORMAL NAME (NOT DEFERRED)
*
PATENDL0 LM    R1,R2,PARAM1(BPS)  LOAD NAME AND OFFSET
         LA    BPS,0(R1,R2)       POINT TO NAME FIELD
         EJECT
*
*        NOW CALCULATE STRING SPECIFIER
*        SLENGTH = S1BCP-S1ECP-1
*        SOFFSET = SOFFSET(PSTRING)+SLENGTH(PSTRING)+1-S1BCP
*        PENDWRD = SOFFSET+SLENGTH ON LEFT SIDE OF A WORD
*        THE +1 COMES FROM A CARRY FROM THE SL
*
PATENDL1 LH    R2,S1BCP(,MINR)    LOAD STARTING CURSOR
         CH    R2,S1ECP(,MINR)    CHECK FOR NULL RESULT
         BNE   *+12               SKIP IF NOT NULL
         L     R1,NCODEBT         ELSE LOAD NULL SPECIFIER
         B     PATENDL2           AND SKIP TO DO ASSIGN
         AL    R2,PENDWRD(,PDR)   POSITION LAST CHARACTER OFFSETLEFT
         SL    R2,S1BCP(,MINR)    CALC NEW OFFSET-REAL LENGTH SEE PICS
         BCTR  R2,0               GET 360 LENGTH AND OFFSET
         L     R1,PSTRING(,PB)    GET STRING POINTER
*
*        COME HERE WITH SPECIFIER IN R1,R2  -  VAR BLK PTR IN BPS
*
PATENDL2 BAL   NCP,PATASSGN       DO ASSIGN WITH I/O CHECK
         B     PATENDL3           LOOP BACK TO CHECK FOR MORE DOTS
         USING QPATSUBS,PBASE     RESTORE THIS BASE REGISTER
         EJECT
*
*        ENTRY POINTS FOR "NOOR" PSEUDO PATTERN
*
*        THIS "PATTERN" IS GIVEN CONTROL WHEN THERE IS NO ALTERNATIVE
*        TO AN ELEMENT WHICH FAILS TO MATCH
*
*
         USING *,RETURN           USUAL PATTERN BASE
NOOR     B     LBACKUP            BACK UP ON STACK
         EJECT
*
*        ENTRY POINTS FOR MARK
*
*        MARK IS USED BY DOLLAR,DOT AND ARBNO ROUTINES TO SAVE THE
*        CURRENT CURSOR LOCATION ON STACK 2
*
*        EXTEND                   MARKEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR MARK
*
         DC    Y(PO$MARK-*)       (DUMMY) OFFSET TO "OR" CASE CODE
         USING *,RETURN           STANDARD PATTERN BASE
PN$MARK  EQU   *                  ENTRY FOR "NOOR" CASE
PO$MARK  SR    PS2,BPS            MAKE ROOM ON STACK 2
         ST    CP,S2CP+S2OFS(,PS2)          SAVE CURSOR ON STK 2
         B     SUCCSN             SUCCEED WITH NO CURSOR MOVEMENT
         EJECT
*
*        ENTRY POINTS FOR DOLLAR
*
*        CASE OF DEFERRED NAME
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   DOLEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR DEFERRED DOLLAR
*
         DC    Y(PO$DOLD-*)       (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$DOLD  EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$DOLD  BAL   NCP,DEFEXPN        EVAL EXPR TO GET NAME, MERGE *+14
         EJECT
*
*        ENTRY POINTS FOR DOLLAR -- CONTINUED
*
*        NORMAL CASE (NAME NOT DEFERRED)
*
*        PARAM1                   VARIABLE NAME BASE
*        PARAM2                   VARIABLE NAME OFFSET
*        EXTEND                   DOLEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR DOLLAR
*
         DC    Y(PO$DOL-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$DOL   EQU   *                  ENTRY POINT FOR "NOOR" CASE
PO$DOL   L     BPS,PARAM1(PB,PO)  LOAD NAME BASE
         A     BPS,PARAM2(PB,PO)  ADD NAME OFFSET TO GET ADDRESS
*
*        MERGE POINT FOR DEFERRED NAME CASE
*
PO$DOL0  L     NCP,S2CP+S2OFS(,PS2)         LOAD OLD CURSOR
         STM   PO,NCP,0(PS1)      SAVE ALL REGISTERS ON STACK1
*
*        NOTE PS2 NEEDS AN AR WITH BPS, AS DOES PS1
*
         L     R1,NCODEBT         LOAD IN CASE OF NULL RESULT
         CR    NCP,CP             CHECK FOR NULL RESULT
         BE    PO$DOL1            OFF TO ASSIGN IF NULL
         L     R2,PSAVDB1(,PDR)   RESTORE DATA AREA ADDRESS
         USING SPITBOLD,R2        TELL ASSEMBLER
         L     R2,PDRLOC          RESTORE REAL STACK LOCATION
         DROP  R2                 GET RID OF BASE REGISTER
         L     R1,PSTRING(,R2)    LOAD STRING BASE POINTER AND SCODE
         LA    R0,SCHARS(NCP,R1)  START OF STG ADDR + OLD CURSOR
         LR    R2,FSADR           COPY END OF STRING ADDRESS
         SR    R2,R0              CALCULATE SUBSTRING OFFSET
         SLL   R2,16              POSITION OFFSET
         SR    NCP,CP             OLD CURSOR - CURRENT = REAL LENGTH
         BCTR  NCP,0              -1 = 360 LENGTH
         ALR   R2,NCP             COMBINE LENGTH AND OFFSET
*
*        COME HERE TO MAKE ASSIGNMENT
*
PO$DOL1  BAL   NCP,PATASSGN       MAKE ASSIGNMENT WITH I/O CHECK
         AR    PS2,BPS            DELETE STACK2 ENTRY
         B     SUCCSN+4           SUCCEED SKIPPING STM
         EJECT
*
*        THIS ROUTINE IS CALLED BY @,$ AND ENDPAT(.) FOR ASSIGNMENTS
*        DURING PATTERN MATCHES. AN I/O CHECK IS MADE AND IF NECESSARY
*        A RECURSIVE CALL TO THE WRITE ROUTINE IS MADE USING EVAL
*
*        (BPS)                    VARIABLE ADDRESS (NAME+BASE)
*        BAL   NCP,PATASSGN       CALL FOR ASSIGNMENT
*        (BPS)                    RESTORED TO STANDARD VALUE (12)
*        (R0,RETURN,R1,R2)        DESTROYED
*
         DROP  RETURN             NO BASE REGISTER HERE
PATASSGN STM   R1,R2,VALUE(BPS)   MAKE THE ASSIGNMENT
         TM    VFLAGS(BPS),VOUA+VTRC        DO WE HAVE ACTIVE OUTPUT?
         LR    R0,BPS             SAVE VAR BLOCK ADDRESS
         LA    BPS,3*4            RESTORE STACK INCREMENT
         BCR   Z,NCP              RETURN TO CALLER IF NOT
         L     R1,PSAVDB1(,PDR)   ELSE LOAD DATA BASE REGISTER
         BALR  R2,0               GET A BASE REGISTER
         USING *,R2               TELL ASSEMBLER
         CR    R0,PDR             IS IT ABOVE DYNAMIC CORE?
         BH    PATASSG1           SKIP TO ASSIGN IF SO
         DROP  R2                 DROP TEMPORARY BASE
         C     R0,DYNAMB-SPITBOLD(,R1)      IS IT BELOW DYNAMIC CORE?
         BCR   NL,NCP             RETURN IF NOT NATURAL VARIABLE
*
*        HERE WE PERFORM THE ASSIGNMENT
*
PATASSG1 L     RETURN,EVALWCON    GET PSEUDO ROUTINE ADDRESS
         ST    R0,EVALVAR-SPITBOLD(,R1)     SAVE VAR BLK ADDR FOR CODE
         CR    R0,R0              SET CC FOR PAT MATCH CALL
         BAL   R1,$EVAL           DO THE WRITE OR TRACE
         B     FAIL               FAIL IF EVAL IS UNSUCCESSFUL
         LM    A1,A1+1,PSAVBPS(PDR)         IGNORE ANY RETURNED VALUE
         L     PO,PSAVPO(,PDR)    RESTORE PO/DB1
         BR    NCP                AND RETURN TO CALLER
         EJECT
*
*        THIS ROUTINE IS CALLED BY $ AND @ ROUTINES TO EVALUATE A NAME
*
*        (PB,PO)                  POINTS TO PATTERN NODE
*        BAL   NCP,DEFEXPN
*        -->   RETURN TO 10(NCP)
*        (BPS)                    RESULTING NAME POINTER
*        (RETURN)                 RESET TO PROVIDE BASE FOR MERGE
*        ALL OTHER PAT REGS RESTORED (EXCEPT NCP, CALLING REG)
*
*        NOTE THAT PARAM2 ALWAYS CONTAINS AN ECODE EXPRESSION PTR
*        SINCE VCODE ARGS WERE TREATED AS SIMPLE VARIABLE REFERENCES
*        DURING PATTERN CONSTRUCTION (SEE $$ATS1, $$DOTD, $$DOLD)
*
DEFEXPN  L     RETURN,PARAM2(PB,PO)         LOAD EXPRESSION POINTER
         CR    R0,R0              SET CC FOR PAT MATCH CALL
         BAL   R1,$EVAL           EVALUATE EXPRESSION
         B     FAIL               FAIL IF CODE FOR NAME FAILS
         L     PO,PSAVPO(,PDR)    RESTORE PO (=DB1)
         LA    BPS,0(A1,A1+1)     ADD NAME BASE/OFFSET
         L     PS2,PSAVPS2(,PDR)  RESTORE STACK 2 POINTER
         LA    RETURN,2(,NCP)     RESET BASE REG FOR MERGE BACK
         B     10(,NCP)           RETURN TO CALLER AT MERGE POINT
         EJECT
*
*        ENTRY POINTS FOR DOT
*
*
*        CASE OF DEFERRED NAME
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   DOTEXT
*
*
*
*        NORMAL CASE (NAME NOT DEFERRED)
*
*        PARAM1                   NAME BASE
*        PARAM2                   NAME OFFSET
*        EXTEND                   DOTEXT
*
*
*        "OR" AND "NOOR" CASES MERGE FOR DOT
*
         DC    Y(PO$DOT-*)        (DUMMY) OFFSET TO CODE FOR "OR" CASE
         USING *,RETURN           PATTERN BASE REG
PN$DOT   EQU   *                  ENTRY POINTS FOR "NOOR" CASE
PO$DOTD  EQU   *                  OR ENTRY FOR DEFERRED DOT
PN$DOTD  EQU   *                  NOOR ENTRY FOR DEFERRED DOT
PO$DOT   L     NCP,S2OFS(,PS2)    LOAD OLD CURSOR LOCATION
         AR    PS2,BPS            DELETE STACK 2 ENTRY
         MVI   DOTSW(PDR),1       INDICATE A DOT HAS BEEN DONE
         ST    PO,0(,PS1)         SAVE THIS PATTERN OFFSET
         ST    PB,S1PB(,PS1)      SAVE THIS PATTERN BASE
         MVI   DOTLOC(PS1),DOTFLG SET SPECIAL DOT FLAG
         ST    CP,8(,PS1)         SAVE ENDING CURSOR
         STH   NCP,S1BCP(,PS1)    SAVE BEGINING CURSOR
         B     SUCCSN+4           SUCCEED SKIPPING STM
         EJECT
*
*        ROUTINE TO EXPAND PATTERN MATCHING STACKS 1 AND 2
*        EACH CALL TO THIS ROUTINE EXPANDS STACK BY ITS ORIGINAL SIZE
*        IF GARBAGE COLLECTION IS NEEDED A DUMMY DEFERRED EXPRESSION
*        IS EXECUTED.
*        (NCP)                    A(PSTKOV)
*        (RETURN)                 EXIT ADDRESS
*
         USING PSTKOV,NCP         OUR BASE REGISTER
PSTKOV   L     R1,PSAVDB1(,PDR)   RECOVER DATA AREA ADDRESS
         L     R0,FRSAVE-SPITBOLD(,R1)      GET CURRENT FR ADDRESS
         LA    R1,PSTKENTS*3*4    CALCULATE ROOM TO BE ADDED
         AR    R0,R1              CALC FINAL CORE POINTER
         CR    R0,PDR             WILL WE OVERFLOW?
         BL    PSTKOV1            SKIP IF NO OVERFLOW
         LR    NCP,RETURN         SAVE RETURN ADDRESS
         LA    RETURN,EVALGCOL    GET ADDR OF DEFERRED CODE
         AL    RETURN,ECODEBT     MAKE SURE WE HAVE PROPER TYPE CODE
         CR    R0,R0              SET CALL FROM PAT MATCH
         BAL   R1,$EVAL           AND PROCESS THIS EXPRESSION
         NOP   0                  FAILURE IS IMPOSSIBLE
         L     PO,PSAVPO(,PDR)    RESTORE AFTER DB1 USE
         LM    A1,A1+1,PSAVBPS(PDR)         RESTORE REGS
         LR    RETURN,NCP         RESTORE LINKAGE
         L     NCP,=A(PSTKOV)     GET OUR BASE REG BACK
         BR    NCP                AND RE-ENTER
*
*        COME HERE WITH ENOUGH CORE FOR STACK MOVE
*
PSTKOV1  SR    PS1,R1             RELOCATE PS1
         SR    PDR,R1             RELOCATE PDR
         LR    R1,PS1             COPY NEW PS1 ADDR
         LA    R0,PSTKOFS+1(,PDR) GET BOTTOM OF MOVE + FUDGE
         SR    R1,R0              CALC 360 MOVE LENGTH
         LA    R0,256             GET VITAL CONSTANT
         LR    R2,PDR             COPY POINTER FOR MOVE
*
*        NOTE THAT FIRST MOVE WILL ALWAYS BE > 256AS INCREASE SIZE IS
*        COME HERE TO MOVE 256 CHARACTERS AT A TIME
*
PSTKOVML MVC   PSTKOFS(256,R2),PSTKOFS+PSTKENTS*3*4(R2)         MOVE
*                                 A 256 CHARACTER PIECE
         AR    R2,R0              PUSH TO AND FROM POINTER
         SR    R1,R0              DECREMENT LENGTH
         CR    R1,R0              IS IT LE 256 YET?
         BNL   PSTKOVML           MOVE LONG IF NOT
         EX    R1,PSTKOVMV        MOVE REMAINING CHARACTERS
         BR    RETURN             AND RETURN TO PROPER PLACE
*
PSTKOVMV MVC   PSTKOFS(*-*,R2),PSTKOFS+PSTKENTS*3*4(R2)         MOVE
*                                 REMAINING CHARACTERS
         DROP  NCP                GET RID OF STRANGE BASE REGISTER
         TITLE 'SPITBOLP -- PATTERN EXIT ROUTINES -- QUICKSCAN MODE'
*
*        IMPORTANT WARNING: IN THE FOLLOWING PAGES, THERE ARE SEVERAL
*        OCCURENCES OF LR,AR TO SET R1=NCP+MINR. IT LOOKS LIKE THESE
*        CAN BE REPLACED WITH A FASTER LA INSTRUCTION. THIS IS NOT
*        THE CASE SINCE SPAN, BREAK ETC. CAN LEAVE THE RESULT NEGATIVE
*        IN CASES WHERE MINR>0 AND THE LA WILL NOT WORK IN THIS CASE
*
QPATSUBS EQU   *                  START OF QUICKSCAN ROUTINES
         USING QPATSUBS,PBASE     QUICKSCAN BASE REG SETTING
*
*        SUCC                     SUCCEED (NO ALTERNATIVE)
*        (PO)                     PATTERN OFFSET
*        (CP)                     NEW SETTING OF CP
*
SUCC     AH    PO,THEN(PB,PO)     POINT OFFSET TO "THEN"
         LR    R1,CP              COPY CURSOR
         AR    R1,MINR            CALCULATE NUMBER OF CHARS LEFT
         CH    R1,MINMATCH(PB,PO) IS IT ENOUGH?
         L     RETURN,CODELOC(PB,PO)        LOAD CODE LOCATION ANYWAY
         BCR   NL,RETURN          AND OFF TO IT IF WE HAVE ENOUGH CHARS
         B     LFAIL1             ELSE INDICATE LENGTH FAILURE
*
*        LBACKUP                  BACKUP ON STACK 1 (LENGTH-FAILURE)
*
LBACKUP  SR    PS1,BPS            POP STACK 1
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FROM TOP ENTRY
         LH    R1,EXTEND(PB,PO)   LOAD EXTENSION ROUTINE OFFSET
         B     QPATSUBS(R1)       OFF TO EXTENSION ROUTINE
*
*        BACKUP                   BACKUP ON STACK 1 (SIGNAL NON-LENGTH)
*
BACKUP   MVI   FAILSW(PDR),X'00'  RESET LENGTH FAIL SWITCH
         SR    PS1,BPS            POP STACK 1
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FOR TOP ENTRY
         LH    R1,EXTEND(PB,PO)   LOAD EXTEND ROUTINE OFFSET
         B     QPATSUBS(R1)       OFF TO EXTENSION ROUTINE
*
*        FAIL                     FAIL (WITH AN ALTERNATIVE)
*        (PO)                     PATTERN OFFSET
*        (CP)                     UNCHANGED CURSOR POINTER LOC
*
FAIL     MVI   FAILSW(PDR),X'00'  RESET LENGTH FAIL SWITCH
         AH    PO,OR(PB,PO)       POINT PATTERN OFFSET TO ALTERNATIVE
         LR    R1,CP              COPY CURSOR
         AR    R1,MINR            ADD TO GET NUMBER OF CHARS LEFT
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS?
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BCR   NL,RETURN          OFF TO "OR" IF ENOUGH CHARACTERS
*                                 (ELSE MERGE WITH LFAIL)
         EJECT
*
*        LFAIL                    FAIL WITH ALTERNATIVE (LENGTH FAIL)
*        (PO)                     PATTERN OFFSET
*        (CP)                     UNCHANGED CURSOR LOCATION
*
LFAIL    LR    R1,CP              COPY CURSOR
         AR    R1,MINR            GET NUMBER OF CHARS LEFT
*
*        ENTER HERE WITH (R1) SET TO 1(CP,MINR)
*
LFAIL1   AH    PO,OR(PB,PO)       POINT PATTERN OFFSET TO ALTERNATIVE
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS LEFT?
         L     RETURN,CODELOC(PB,PO)        LOAD CODE LOCATION
         BCR   NL,RETURN          OFF TO "OR" CODE IF ENOUGH CHARACTERS
         B     LFAIL1             LOOP BACK TO TRY NEXT ALTERNATIVE
*
*        SUCCS                    SUCCEED MAKING A STACK 1 ENTRY
*        (PO)                     PATTERN OFFSET
*        (CP)                     UNCHANGED CURSOR POINTER
*        (NCP)                    UPDATED CURSOR LOCATION
*
SUCCS    STM   PO,CP,0(PS1)       STORE PAT OFFSET, CURSOR LOC ON STACK
*
*        SUCCSP                   ENTRY AFTER MAKING STACK 1 ENTRY
*
SUCCSP   LR    CP,NCP             UPDATE CURSOR LOCATION
         AH    PO,THEN(PB,PO)     POINT PATTERN OFFSET TO 'THEN'
         LR    R1,NCP             COPY NEW CURSOR
         AR    R1,MINR            GET NUMBER OF CHARS LEFT
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS LEFT?
         BL    SUCCS1             SKIP IF NOT
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BXLE  PS1,BPS,0(RETURN)  OFF TO CODE BUMPING STACK
         B     PSTAKOV            JUMP TO GIVE STACK OVERFLOW
*
*        COME HERE IF MINMATCH TEST FAILS (INSUFFICIENT CHARACTERS LEFT
*
SUCCS1   BXLE  PS1,BPS,LFAIL1     BUMP STACK, TAKE 'OR' WITH R1 SET
         LA    RETURN,LFAIL       SET PROPER STACK OVERFLOW EXIT ADDR
*
*        PSTAKOV                  ENTRY TO INCREASE PAT STACK SIZE
*
PSTAKOV  L     NCP,=A(PSTKOV)     GET ROUTINE ADDRESS
         BR    NCP                AND OFF TO IT
         EJECT
*
*        SUCCER                   SUCCEED AFTER SUCCESSFUL EXTENSION
*        (PO)                     PATTERN OFFSET
*        (CP)                     UPDATED CURSOR LOCATION
*
SUCCER   ST    CP,S1NEWCP(,PS1)   STORE UPDATED CURSOR ON STACK 1
         AR    PS1,BPS            BUMP STACK ONE PTR (CANNOT OVERFLOW)
         AH    PO,THEN(PB,PO)     POINT TO "THEN"
         LR    R1,CP              COPY CURSOR
         AR    R1,MINR            GET NUMBER OF CHARS LEFT
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARS LEFT?
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BCR   NL,RETURN          OFF TO "THEN" IF ENOUGH CHARS
         B     LFAIL1             ELSE LENGTH FAIL (TAKE ALTERNATIVE)
*
*        SUCCSN                   LIKE SUCCS, BUT WITH NO CP MOVEMENT
*        (PO)                     PATTERN OFFSET
*        (CP)                     UNCHANGED CURSOR POINTER
*
SUCCSN   STM   PO,CP,0(PS1)       MAKE STACK ENTRY
         AH    PO,THEN(PB,PO)     POINT TO "THEN"
         LR    R1,CP              COPY CURSOR
         AR    R1,MINR            GET NUMBER OF CHARACTERS LEFT
         CH    R1,MINMATCH(PB,PO) DO WE HAVE ENOUGH CHARACTERS LEFT?
         BL    SUCCS1             SKIP IF NOT
         L     RETURN,CODELOC(PB,PO)        ELSE LOAD CODE POINTER
         BXLE  PS1,BPS,0(RETURN)  OFF TO CODE BUMPING STACK
         B     PSTAKOV            STACK OVERFLOW IF WE FALL THROUGH
         TITLE 'SPITBOLP -- SPECIAL MATCH ROUTINES -- QUICKSCAN MODE'
*
*        IN THIS SECTION ARE MATCH ROUTINES WHICH DIFFER IN FULL
*        AND QUICKSCAN MODES
*
*        ARB MATCH ROUTINE
*
MATCHARB LR    NCP,CP             SET FOR INITIAL MATCH OF NULL
*                                 (MERGE WITH BKX ROUTINE - SAME CODE)
*
*        COMPLETE MATCH FOR BREAKX
*
MATCHBKX TS    FAILSW(PDR)        TEST AND RESET FAIL SWITCH
         BNZ   *+8                SKIP IF NON-ZERO
         AL    CP,X80             TURN ON CP SIGN BIT TO SAVE FAILSW
         STM   PO,NCP,0(PS1)      MAKE STACK ONE ENTRY
         B     SUCCSP             AND SUCCEED
*
*        ARBNO MATCH ROUTINE
*
MATCHABN L     NCP,S2CP+S2OFS(,PS2)         CURSOR BEFORE MATCH OF ARG
         ST    NCP,S1NEWCP(,PS1)  SAVE ON STACK 1 FOR LATER RESTORATION
         BXH   PS2,BPS,SUCCSN     SUCCEED WITH NO CURSOR MOVEMENT
*        NOTE -- ABOVE BXH DOES BRANCH -- SEE PRINCIPLES OF OPERATION
*
*        MATCH ROUTINE FOR BAL
*
MATCHBAL BAL   RETURN,GBAL        SCAN OUT A BLANKCED STRING
         TS    FAILSW(PDR)        SET FAIL SWITCH
         STM   PO,NCP,0(PS1)      MAKE STACK 1 ENTRY
         B     SUCCSP             AND SUCCEED
         TITLE 'SPITBOLP -- EXTENSION ROUTINES -- QUICKSCAN MODE'
*
*        CONDITIONS ON ENTRY TO EXTENSION ROUTINE
*
*        (PO)                     PATTERN OFFSET
*        (CP)                     OLD CURSOR POINTER
*        (NCP)                    MOST RECENT UPDATED CURSOR VALUE
*
*        ON EXIT FROM AN EXTENSION ROUTINE --
*
*        ON SUCCESSFUL EXTENSION            SET CP TO UPDATED CURSOR
*                                           LOC -- BRANCH TO SUCCER
*
*        ON FAILURE TO EXTEND               LEAVE CP,PO SET AS ON ENTRY
*                                           BRANCH TO FAIL OR LFAIL
*                                           DEPENDING ON WHETHER FAIL
*                                           IS A LENGTH FAIL
*
*        ARBEXT                   ARB EXTENSION ROUTINE
*
ARBEXT   TS    FAILSW(PDR)        TEST AND SET FAIL SWITCH
         BZ    ARBEX1             SKIP IF IT IS OK TO EXTEND
         LTR   CP,CP              ELSE SIGN OF CP SHOWS OLD SETTING
         BP    LFAIL              POSITIVE = SET, SO RETURN
         LA    CP,0(,CP)          CLEAR OUT THE SIGN BIT
         B     FAIL               AND FAIL, RESETTING FAILSW TO X'00'
*
*        COME HERE WHEN IT IS OK TO EXTEND
*
ARBEX1   LR    CP,NCP             LOAD NEW LOCATION
         BCT   CP,SUCCER          SUCCEED BUMPING CURSOR
         B     SUCCER             BRANCH EVEN IF BCT FALLS THROUGH
*
*        BALEXT                   BAL EXTENSION ROUTINE
*
BALEXT   TS    FAILSW(PDR)        TEST AND SET LENGTH FAIL FLAG
         BNZ   FAIL               BAL INDICATES NON-LENGTH FAIL HERE
         BAL   RETURN,GBAL        IF WE HAD A NON-LENGTH FAIL, THEN EXT
         LR    CP,NCP             LOAD UPDATED CURSOR LOCATION
         B     SUCCER             AND TAKE EXTENSION ROUTINE SUCCESS
*
*        SUCCEXT                  SUCCEED EXTENSION ROUTINE
*
SUCCEXT  BAL   R2,PTIMTST         TEST FOR OVERTIME
         B     SUCCER             AND SIGNAL SUCCESSFUL "EXTENSION"
*
*        FENCEEXT                 FENCE EXTENSION ROUTINE
*
FENCEEXT B     PABORT             FENCE ABORTS WHEN BACKED INTO
         EJECT
*
*        ANCHEXT                  ANCHOR POINT MOVEMENT ROUTINE
*
ANCHEXT  LTR   PO,PO              TEST HIGH ORDER BYTE OF OFFSET
         BNZ   EXP1EXT            B IF ANCHORED OR END OF EXPRESSION
         TS    FAILSW(PDR)        ELSE TEST & SET LENGTH FAIL SWITCH
         BNZ   PABORT             PATTERN ABORT IF NO NON-LENGTH FAIL
         LR    CP,NCP             LOAD UPDATED CURSOR LOCATION
         BCTR  CP,0               BUMP CURSOR ONE CHARACTER
         ST    CP,S1NEWCP(,PS1)   STORE ANCHOR MOVEMENT
         AR    PS1,BPS            BUMP STACK (CANNOT OVERFLOW)
         LA    PO,PATS            SET OFFSET BACK TO FIRST PATTERN
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         CH    CP,MINMATCH(PB,PO) CHECK CHARS LEFT (MINR=0 HERE)
         BCR   NL,RETURN          JUMP TO PATTERN IF CHARS LEFT
         B     LFAIL              ELSE INDICATE LENGTH FAILURE
*
*        NOTE THAT IF WE RETURN TO ANCHEXT AFTER ALL OF THIS 'OR' CHAIN
*        LENGTH FAILS FAILSW WILL STILL BE SET, SO WE WILL ABORT
*
*        NOEXT                    USED IN NODES THAT CANNOT EXTEND
*
NOEXT    EQU   LFAIL              TAKE "OR" POINTER
*
*        DOTEXT                   DOT EXTENSION ROUTINE
*
DOTEXT   LH    CP,S1ECP(,PS1)     GET CURRENT CURSOR POINTER
         LH    NCP,S1BCP(,PS1)    GET CURSOR AT START OF DOT PATTERN
*
*        DOLEXT                   DOLLAR EXTENSION ROUTINE
*
DOLEXT   SR    PS2,BPS            GET ROOM ON STACK 2
         ST    NCP,S2CP+S2OFS(,PS2)         RESTORE STK2 ENTRY
         B     LBACKUP            AND BACKUP WITHOUT SIGNALLING LFAIL
         EJECT
*
*        ENTRY POINTS FOR EXPRESSION (EXP1)
*
*
*        EXP1EXT                  EXTENSION ROUTINE FOR 1ST EXP PATTERN
*
EXP1EXT  BM    PABORT             ABORT IF ANCHORED CALL FROM ANCHEXT
         LM    PB,PO,S2PB+S2OFS(PS2)        GET PB & PO TO EXP2 PAT
         AH    MINR,MINMATCH(PB,PO)         RESTORE MINR
         SH    PO,=Y(LPRM2-PATS)  SET OFFSET TO EXP1 PATTERN
*
*        MARKEXT                  MARK EXTENTION ROUTINE AND END OF EXP
*
MARKEXT  BXH   PS2,BPS,LFAIL      REMOVE STACK 2 ENTRY AND TAKE "OR"
*
*        EXP2EXT                  EXTENSION ROUTINE FOR 2ND EXP PATTERN
*
EXP2EXT  SR    PS2,BPS            MAKE ROOM ON STACK 2
         STM   PB,PO,S2PB+S2OFS(PS2)        RESTORE STACK 2 ENTRY
         SH    MINR,MINMATCH(PB,PO)         RESET MINR FOR LOWER LEVEL
         LR    PB,CP              LOAD PATTERN BASE FOR * PATTERN
         B     LBACKUP            AND BACK UP
*
*        ARBNOEXT                 ARBNO EXTENSION ROUTINE
*
ARBNOEXT LTR   CP,CP              DID WE ALREADY TRY A REMATCH?
         BM    ARBNEXT1           SKIP IF SO
*
*        COME HERE AFTER FAILURE IN FOLLOWING PATTERN, REMATCH
*        THE ARBNO PATTERN UNLESS LAST ITERATION MATCHED NULL
*
         SR    PS2,BPS            RECREATE STACK 2 ENTRY (MARK)
         ST    CP,S2CP+S2OFS(,PS2)          SAVE NEW STARTING CURSOR
         CR    CP,NCP             DID LAST ARBNO PATTERN MATCH ANYTHING
         BE    LBACKUP            IF NOT, BACK INTO ALTERNATIVES
         MVI   S1OLDCP(PS1),X'80' ELSE SIGNAL NEGATIVE FOR REENTRY
         S     PO,PARAM1(PB,PO)   POINT BACK TO START OF ARBNO PAT
         B     SUCCER+4           SUCCEED PAST STM, MAKE STACK 1 ENTRY
*
*        COME HERE SECOND TIME ROUND, RESTORE OLD STARTING CURSOR
*
ARBNEXT1 ST    NCP,S2CP+S2OFS(,PS2)         STORE OLD STARTING CURSOR
         B     LBACKUP            FORCE ALTERNATIVES
         EJECT
*
*        BRKXEXT                  BREAKX EXTEND ROUTINE
*
BRKXEXT  SR    R0,R0              CLEAR A ZERO
         LTR   CP,CP              TEST CP SIGN (OLD FAILSW SETTING)
         BM    *+6                ZERO IS RIGHT FOR CP MINUS
         BCTR  R0,0               ELSE GET A FF
         LA    CP,0(,CP)          CLEAR OUT FLAG IN CP REGARDLESS
         TS    FAILSW(PDR)        TEST FAILSW SETTING
         STC   R0,FAILSW(PDR)     RESTORE OLD FAILSW SETTING
         BNZ   LFAIL              NO USE EXTENDING IF ALL LENGTH FAIL
         L     RETURN,CODELOC(PB,PO)        ELSE RELOAD BASE (CODE LOC)
         USING PO$BRKX,RETURN     TELL ASSEMBLER
         BCT   NCP,PO$BRKX1       OFF TO MERGE POINT EATING BREAK CHAR
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT
*
*        BRKXDEXT                 BREAKXD EXTEND ROUTNE
*
BRKXDEXT SR    R0,R0              GET POTENTIAL ZERO FAILSW
         LTR   CP,CP              TEST OLD FAILSW VALUE
         BM    *+6                SKIP IF IT WAS ZERO
         BCTR  R0,0               ELSE GET A X'FF'
         LA    CP,0(,CP)          CLEAR OUT FLAG IN CP
         TS    FAILSW(PDR)        TEST, RESET FAIL SWITCH
         STC   R0,FAILSW(,PDR)    STORE OLD FAILSW SETTING
         BNZ   LFAIL              LENGTH FAIL IF ALL AHEAD LFAILED
         L     RETURN,CODELOC(PB,PO)        RELOAD PAT CODE BASE REG
         USING PO$BRKXD,RETURN    TELL ASSEMBLER
         BCT   NCP,PO$BKXD1       OFF TO MERGE POINT EATING BRK CHAR
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT
         DROP  RETURN             GET RID OF BASE REGISTER
         TITLE 'SPITBOLP -- PATTERN EXIT ROUTINES -- FULLSCAN MODE'
FPATSUBS EQU   *                  START OF FULLSCAN ROUTINES
         USING FPATSUBS,PBASE     FULL SCAN BASE REGISTER SETTING
*
*        NOTE -- THE ROUTINES IN THIS SECTION MUST HAVE THE SAME OFFSET
*        FROM FPATSUBS AS THEIR QUICKSCAN COUNTERPARTS DO FROM QPATSUBS
*        IN ORDER TO ASSURE THIS THE PORG MACRO IS USED
*
*NAME    PORG  ,                  POSITIONS THE ROUTINE CORRESPONDING
*                                 TO NAME CORRECTLY (IT ALSO CHECKS
*                                 FOR A BACKWARD ORIGIN)
*
*        SUCC                     SUCCEED (NO ALTERNATIVE)
*        (PO)                     PATTERN OFFSET
*        (CP)                     NEW SETTING OF CP
*
SUCC     PORG  ,                  POSITION
         AH    PO,THEN(PB,PO)     POINT TO "THEN"
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BR    RETURN             OFF TO "THEN" CODE
*
*        LBACKUP                  BACKUP ON STACK 1 (LENGTH FAILURE)
*
LBACKUP  PORG  ,                  POSITION
         SR    PS1,BPS            POP STACK 1
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FROM TOP ENTRY
         LH    R1,EXTEND(PB,PO)   LOAD EXTENSION ROUTINE OFFSET
         B     FPATSUBS(R1)       OFF TO EXTENSION ROUTINE
*
*        BACKUP                   BACKUP ON STACK 1 (SIGNAL NON-LENGTH)
*
BACKUP   PORG  ,                  POSITION
         SR    PS1,BPS            POP STACK 1
         LM    PO,NCP,0(PS1)      LOAD PO,CP,NCP FROM TOP ENTRY
         LH    R1,EXTEND(PB,PO)   LOAD EXTENSION ROUTINE OFFSET
         B     FPATSUBS(R1)       OFF TO EXTENSION ROUTINE
*
*        FAIL                     FAIL WITH ALTERNATIVE
*        (PO)                     PATTERN OFFSET
*        (CP)                     UNCHANGED CURSOR POINTER LOC
*
FAIL     PORG  ,                  POSITION
         AH    PO,OR(PB,PO)       POINT TO ALTERNATIVE
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BR    RETURN             OFF TO CODE FOR "OR"
         EJECT
*
*        LFAIL                    FAIL WITH ALTERNATIVE (LENGTH FAIL)
*
LFAIL    PORG  ,                  POSITION
         AH    PO,OR(PB,PO)       LOAD POINTER TO ALTERANTIVE
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BR    RETURN             OFF TO CODE FOR "OR"
*
*        SUCCS                    SUCCEED MAKING A STACK 1 ENTRY
*        (PO)                     PATTERN OFFSET
*        (CP)                     UNCHANGED CURSOR POINTER
*        (NCP)                    UPDATED CURSOR POINTER
*
SUCCS    PORG  ,                  POSITION
         STM   PO,CP,0(PS1)       STORE PAT PTR, CURSOR LOC ON STACK1
*
*        SUCCSP                   ENTRY AFTER MAKING STACK ONE ENTRY
*
SUCCSP   PORG  ,                  POSITION (ACTUALLY DOES NOTHING)
         AH    PO,THEN(PB,PO)     POINT TO "THEN"
         LR    CP,NCP             LOAD UPDATED CURSOR LOC
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BXLE  PS1,BPS,0(RETURN)  OFF TO "THEN" BUMPING STACK
         B     FPSTAKOV           STACK OVERFLOW IF FALL THROUGH
*
*        PSTAKOV                  ENTRY TO INCREASE STACK 1 & 2 SIZE
*
PSTAKOV  PORG  ,                  POSITION
         L     NCP,=A(PSTKOV)     GET BASE REGISTER FOR ROUTINE
         BR    NCP                AND OFF TO IT
*
*        SUCCER                   SUCCEED AFTER SUCCESSFUL EXTENSION
*        (PO)                     PATTERN OFFSET
*        (CP)                     UPDATED CURSOR LOCATION
*
SUCCER   PORG  ,                  POSITION
         ST    CP,S1NEWCP(,PS1)   STORE NEW UPDATED CURSOR LOC
         AH    PO,THEN(PB,PO)     LOAD POINTER TO "THEN"
         L     RETURN,CODELOC(PB,PO)        LOAD CODE LOCATION
         BXLE  PS1,BPS,0(RETURN)  OFF TO "THEN" BUMPING STACK
*                                 (ABOVE BXLE CANNOT FALL THROUGH)
*
*        SUCCSN                   LIKE SUCCS, BUT WITH NO CP MOVEMENT
*        (PO)                     PATTERN OFFSET
*        (CP)                     UNCHANGED CURSOR POINTER
*
SUCCSN   PORG  ,                  POSITION
         STM   PO,CP,0(PS1)       MAKE STACK ENTRY
         AH    PO,THEN(PB,PO)     LOAD POINTER TO "THEN"
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         BXLE  PS1,BPS,0(RETURN)  OFF TO CODE BUMPING STACK
         B     FPSTAKOV           STACK OVERFLOW IF FALL THROUGH
         TITLE 'SPITBOLP -- SPECIAL MATCH ROUTINES -- FULLSCAN MODE'
*
*        IN THIS SECTION ARE ROUTINES FOR MATCHING WHICH DIFFER IN
*        FULLSCAN AND QUICKSCAN MODES
*
*
*        MATCH ROUTINE FOR ARB
*
MATCHARB PORG  ,                  POSITION
         LR    NCP,CP             SET FOR INITIAL MATCH OF NULL
*                                 (MERGE WITH CODE FOR BRKX)
*
*        COMPLETE MATCH FOR BREAKX
*
MATCHBKX PORG  ,                  POSITION (SHOULD DO NOTHING)
         STM   PO,NCP,0(PS1)      MAKE STACK 1 ENTRY
         B     FSUCCSP            AND SUCCEED
*
*        ARBNO MATCH ROUTINE
*
MATCHABN PORG  ,                  POSITION
         BXH   PS2,BPS,FSUCCSN    REMOVE MARK ENTRY AND SUCCEED
*
*        MATCH ROUTINE FOR BAL
*
MATCHBAL PORG  ,                  POSITION
         BAL   RETURN,GBAL        SCAN OUT A BALANCED STRING
         STM   PO,NCP,0(PS1)      MAKE PO/CP/NCP STACK 1 ENTRY
         B     FSUCCSP            AND SUCCEED
         TITLE 'SPITBOLP -- EXTENSION ROUTINES -- FULLSCAN MODE'
*
*        CONDITIONS ON ENTRY TO EXTENSION ROUTINE
*
*        (PO)                     PATTERN OFFSET
*        (CP)                     OLD CURSOR POINTER
*        (NCP)                    MOST RECENT UPDATED CURSOR VALUE
*
*        ON EXIT FROM AN EXTENSION ROUTINE --
*
*        ON SUCCESSFUL EXTENSION            SET CP TO UPDATED CURSOR
*                                           LOC -- BRANCH TO SUCCER
*
*        ON FAILURE TO EXTEND               LEAVE CP,PO SET AS ON ENTRY
*                                           BRANCH TO FAIL OR LFAIL
*                                           DEPENDING ON WHETHER FAIL
*                                           IS A LENGTH FAIL
*
*
*        THE FOLLOWING DEFINITIONS MUST BE USED WHEN UNDER CONTROL OF -
*        USING FPATSUBS,PBASE
*
FSUCCER  EQU   SUCCER+FPATSUBS-QPATSUBS     FULLSCAN NAME FOR SUCCER
FFAIL    EQU   FAIL+FPATSUBS-QPATSUBS       FULLSCAN NAME FOR FAIL
FLFAIL   EQU   LFAIL+FPATSUBS-QPATSUBS      FULLSCAN NAME FOR LFAIL
FSUCCSN  EQU   SUCCSN+FPATSUBS-QPATSUBS     FULLSCAN NAME FOR SUCCSN
FSUCC    EQU   SUCC+FPATSUBS-QPATSUBS       FULLSCAN NAME FOR SUCC
FSUCCSP  EQU   SUCCSP+FPATSUBS-QPATSUBS     FULLSCAN NAME FOR SUCCSP
FSUCCS   EQU   SUCCS+FPATSUBS-QPATSUBS      FULLSCAN NAME FOR SUCCS
FLBACKUP EQU   LBACKUP+FPATSUBS-QPATSUBS    FULLSCAN NAME FOR LBACKUP
FEXP1EXT EQU   EXP1EXT+FPATSUBS-QPATSUBS    FULLSCAN NAME FOR EXP1EXT
FPSTAKOV EQU   PSTAKOV+FPATSUBS-QPATSUBS    FULLSCAN NAME FOR PSTAKOV
*
*
*        ARBEXT                   ARB EXTENSION ROUTINE
*
ARBEXT   PORG  ,                  POSITION
         LTR   NCP,NCP            TEST NUMBER OF CHARS LEFT
         BZ    FLFAIL             LENGTH FAIL IF NO CHARS LEFT
         BAL   R2,PTIMTST         TEST FOR OVERTIME
         LR    CP,NCP             COPY CURSOR
         BCT   CP,FSUCCER         OFF TO SUCCER BUMPING STACK
         B     FSUCCER            BRANCH EVEN IF BCT FALLS THROUGH
*
*        BALEXT                   BAL EXTENSION ROUTINE
*
BALEXT   PORG  ,                  POSITION
         BAL   RETURN,GBAL        EXTEND MATCHED PART
         LR    CP,NCP             LOAD UPDATED LOCATION
         B     FSUCCER            SUCCEED
         EJECT
*
*        SUCCEXT                  SUCCEED EXTENSION ROUTINE
*
SUCCEXT  PORG  ,                  POSITION
         BAL   R2,PTIMTST         TEST FOR OVERTIME
         B     FSUCCER            AND SUCCEED
*
*        FENCEEXT                 FENCE EXTENSION ROUTINE
*
FENCEEXT PORG  ,                  POSITION
         B     PABORT             PATTERN ABORT WHEN BACKED INTO
*
*        ANCHNEXT                 ANCHOR POINT MOVEMENT ROUTINE
*
ANCHEXT  PORG  ,                  POSITION
         LTR   PO,PO              TEST MODE (HIGH ORDER BIT OF OFFSET)
         BNZ   FEXP1EXT           B IF ANCHORED OR END OF EXPRESSION
         BCTR  NCP,0              MOVE CURSOR ONE CHARACTER
         ST    NCP,S1NEWCP(,PS1)  STORE ANCHOR MOVEMENT
         AR    PS1,BPS            BUMP STACK POINTER (CANNOT OVERFLOW)
         LA    PO,PATS            INITIALIZE OFFSET TO FIRST PATTERN
         L     RETURN,CODELOC(PB,PO)        LOAD CODE POINTER
         LTR   CP,NCP             SET AND TEST CURSOR POSITION
         BCR   NM,RETURN          OFF TO CODE UNLESS OF END OF STRING
         B     PABORT             IN WHICH CASE -- ABORT MATCH
*
*        NOEXT                    USED IN NODES THAT CANNOT EXTEND
*
*NOEXT   EQU   LBACKUP            BACK UP ON STACK ONE
*
*        DOTEXT                   DOT EXTENSION ROUTINE
*
DOTEXT   PORG  ,                  POSITION
         LH    CP,S1ECP(,PS1)     GET CURRENT CURSOR POINTER
         LH    NCP,S1BCP(,PS1)    GET CURSOR AT START OF DOT PATTERN
*
*        DOLEXT                   DOLLAR EXTENSION ROUTINE
*
DOLEXT   PORG  ,                  POSITION (SHOULD DO NOTHING)
         SR    PS2,BPS            GET ROOM ON STACK 2
         ST    NCP,S2CP+S2OFS(,PS2)         RESTORE STACK 2 ENTRY
         B     FLBACKUP           AND BACKUP
         EJECT
*
*        EXP1EXT                  EXTENSION ROUTINE FOR 1ST EXP PATTERN
*
EXP1EXT  PORG  ,                  POSITION
         BM    PABORT             ABORT IF ANCHORED ON CALL FROM ANCHEX
         LM    PB,PO,S2PB+S2OFS(PS2)        GET PB & PO TO EXP2
         AH    MINR,MINMATCH(PB,PO)         RESTORE MINR
         SH    PO,=Y(LPRM2-PATS)  SET OFFSET TO EXP1 PATTERN
*
*        MARKEXT                  MARK EXTENTION ROUTINE AND END OF EXP
*
MARKEXT  PORG  ,                  THIS SHOULD HAVE NO EFFECT
         BXH   PS2,BPS,FLFAIL     REMOVE STACK 2 ENTRY AND TAKE "OR"
*
*        EXP2EXT                  EXTENSION ROUTINE FOR 2ND EXP PATTERN
*
EXP2EXT  PORG  ,                  POSITION
         SR    PS2,BPS            MAKE ROOM ON STACK 2
         STM   PB,PO,S2PB+S2OFS(PS2)        RESTORE STACK 2 ENTRY
         SH    MINR,MINMATCH(PB,PO)         RESET MINR FOR LOWER LEVEL
         LR    PB,CP              LOAD PATTERN BASE FOR * PATTERN
         B     FLBACKUP           AND BACKUP
*
*        ARBNOEXT                 ARBNO EXTENSION ROUTINE
*
ARBNOEXT PORG  ,                  POSITION
         BAL   R2,PTIMTST         TEST FOR OVERTIME
         SR    PS2,BPS            RECREATE DUMMY STACK 2 ENTRY
         S     PO,PARAM1(PB,PO)   POINT BACK TO REMATCH
         B     FSUCC              AND SUCCED TO REMATCH PATTERN
*
*        BRKXEXT                  BREAKX EXTEND ROUTINE
*
BRKXEXT  PORG  ,                  POSITION
         L     RETURN,CODELOC(PB,PO)        RELOAD CODE LOCATION
         USING PO$BRKX,RETURN     TELL ASSEMBLER BASE IS LOADED
         BCT   NCP,PO$BRKX1       JUMP TO MERGE POINT EATING BREAK CHAR
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT
*
*        BRKXDEXT                 BREAKXD EXTEND ROUTINE
*
BRKXDEXT PORG  ,                  POSITION
         L     RETURN,CODELOC(PB,PO)        RELOAD CODE LOCATION
         USING PO$BRKXD,RETURN    TELL ASSEMBLER
         BCT   NCP,PO$BKXD1       JUSMP TO MERGE POINT EATING BREAK CHR
         B     LFAIL              LFAIL IF NO CHARACTERS LEFT
         DROP  RETURN
*
         DC    20F'0'             PATCH SPACE FOR SPITBOLP
         USING SPITBOLD,DB1       DB1 IS DATA BASE REGISTER AGAIN
         TITLE 'SPITBOLX -- START OF CONTROL SECTION'
*
*        THIS CONTROL SECTION CONTAINS RUN TIME ROUTINES WHICH ARE NOT
*        ADDRESSABLE UNDER THE SYS REGISTER IN SPITBOLA
*
*        EACH ROUTINE IN THIS SECTION MUST ESTABLISH ITS OWN
*        ADDRESSABILITY -- IN MANY CASES, THE ACTUAL ENTRY POINTS ARE
*        IN SPITBOLA, WHICH SETS A BASE REGISTER AND BRANCHES TO THE
*        APPROPRIATE LOCATION IN SPITBOLX
*
*
*        NOTE THAT ALL ROUTINES IN THIS CONTROL SECTION ARE ALWAYS
*        RESIDENT (UNLIKE THE FUNCTIONS IN SPITBOLF)
*
         BEGIN X                  START OF SPITBOLX, SPITBLLX CSECT
         USING SPITBOLA,SYS       THIS BASE REG IS USED THROUGHOUT
         TITLE 'SPITBOLX -- REGISTER DEFINITIONS'
*
*        DEFINITIONS OF BRANCH CODES FOR BCR INSTRUCTIONS
*
NO       EQU   14                 CONDITION CODE FOR NOT ONES
NL       EQU   11                 CONDITION CODE FOR NOT LOW CONDITION
NZ       EQU   7                  CONDITION CODE FOR NOT ZERO CONDITION
H        EQU   2                  CONDITION CODE FOR HIGH
L        EQU   4                  CONDITION CODE FOR LOW
P        EQU   2                  CONDITION CODE FOR POSITIVE
NE       EQU   7                  CONDITION CODE FOR THE NE CONDITION
NH       EQU   13                 CONDITION CODE FOR NOT HIGH
NP       EQU   13                 CONDITION CODE FOR NOT POSITIVE
E        EQU   8                  CONDITION CODE FOR EQUAL CONDITION
M        EQU   4                  CONDITION CODE FOR MINUS BRANCH
Z        EQU   8                  CONDITION CODE FOR ZERO
O        EQU   1                  CONDITION CODE FOR ONES
NM       EQU   11                 CONDITION CODE FOR NOT MINUS
CZ       EQU   2                  CONDITION CODE FOR CARRY (ZERO RESLT)
*
*        REGISTER DEFINITIONS FOR EXECUTE PACKAGE
*
*R0      EQU   0                  SCRATCH REGISTER
*R1      EQU   1                  SCRATCH REGISTER
*R2      EQU   2                  SCRATCH REGISTER
FR       EQU   3                  FREE STORAGE POINTER
A1       EQU   4                  A1,A1+1 ACCUMULATOR 1
A2       EQU   6                  A2,A2+1 ACCUMULATOR 2
DB1      EQU   8                  1ST DATA BASE
DB2      EQU   9                  2ND DATA BASE
DB3      EQU   10                 3RD DATA BASE
DB4      EQU   11                 4TH (VARIABLE) DATA BASE
FRETURN  EQU   12                 FAILURE RETURN REGISTER
RETURN   EQU   13                 RETURN REGISTER (PRIMARY LINKAGE REG)
SYS      EQU   14                 SYSTEM BASE REGISTER
PDR      EQU   15                 MAIN STACK POINTER
*
*        THE FOLLOWING DEFINITIONS ARE USED DURING PATTERN MATCHING
*
FSADR    EQU   3                  POINTS ONE PAST STRING BEING MATCHED
BPS      EQU   4                  CONTAINS THE STACK INCREMENT 12
PS2      EQU   5                  STACK 2 POINTER (ALSO STACK 1 LIMIT)
PS1      EQU   6                  STACK 1 POINTER
PB       EQU   7                  PATTERN BASE REGISTER
PO       EQU   8                  PATTERN OFFSET REGISTER
CP       EQU   9                  CURSOR (NUMBER OF CHARACTERS LEFT)
NCP      EQU   10                 UPDATED (NEW) CURSOR LOCATION
MINR     EQU   11                 MINUS NUM CHARS NEEDED ON HIGHER LEVS
PBASE    EQU   12                 PATTERN BASE (QPATSUBS OR FPATSUBS)
         TITLE 'SPITBOLX -- STACK USAGE AND DEFINITIONS'
*
*              STACK USAGE
*
*              NOTE THAT IT IS DESIRABLE TO ALLIGN STM FIELDS ON
*              DOUBLE WORD BOUNDARIES FOR THE LARGER MACHINES     TO
*              ACCOMPLISH THIS IT IS NECESSARY THAT EACH STACK MOVEMENT
*              BE A MULTIPLE OF 8 BYTES     INCLUDE A PAD WORD IF NEC.
*
STACKTOP EQU   2048               TOP OF CURRENT STACK LEVEL
*
LASTEM   EQU   STACKTOP           LAST TEMPORARY ON LEVEL ABOVE
*
PDRBPTR  EQU   STACKTOP-4         POINTER TO LAST PDR LOCATION ABOVE US
*
FBLOKLOC EQU   PDRBPTR-4          FUNCTION BLOCK ADDRESS
*                                 FUNCTION TEMPS ARE ON LEVEL ABOVE
*
RETFLOC  EQU   FBLOKLOC-4         CODE RETURN ADDR FROM THIS FUNCTION
*
FRETFLOC EQU   RETFLOC-4          FAILURE RETURN ADDR (DBL WORD ALLIGN)
*
EVLINK   EQU   FRETFLOC-4         LINKAGE FOR EVAL
*
MATCHPB  EQU   EVLINK-2           CURSOR POINTER AT START OF MATCH
*
MATCHPE  EQU   MATCHPB-2          CURSOR POINTER AT END OF MATCH
*
PNAME    EQU   MATCHPE-8          NAME BLOCK FOR PAT ASSIGN (DBLWRD)
*
PSTRING  EQU   PNAME-8            ORIGINAL STRING SPEC FOR PAT ASSGN
*                                 DOUBLE WORD ALLIGN
*
STACKBOT EQU   PSTRING            BOTTOM OF STANDARD STACK INFORMATION
*
STACKSIZ EQU   STACKTOP-STACKBOT  SIZE OF STANDARD STACK INFORMATION
*
TEM#1    EQU   STACKBOT-8         FIRST TEMPORARY LOCATION (DBLWRD)
*
TEM#2    EQU   TEM#1-8            SECOND TEMPORARY LOCATION
*
TEM#3    EQU   TEM#2-8            THIRD TEMPORARY LOCATION
*
TEM#4    EQU   TEM#3-8            FOURTH TEMPORARY LOCATION
*
*        THE FOLLOWING ARE ALTERNATE NAMES FOR LOCATIONS USED OVER
*        A CALL TO A PROGRAMER DEFINED TRACE FUNCTION
*        EVERYTHING ON THE LEVEL PUSHED BY PDTRC IS USABLE SINCE
*        THE CALLED FUNCTION WILL PUSH ANOTHER LEVEL
*
TRLINK   EQU   EVLINK             LINKAGE IS SAVED OVER EVLINK
*
TRVTRC   EQU   MATCHPE            INTEGER VALUE OF &TRACE SAVED IN
*                                 MATCHPE OVER PROG DEF TRACE CALL
TRVBLOCK EQU   PSTRING            SAVE VARIABLE BLOCK ADDR IN PSTRING
*                                 SINCE IT IS NOT RELOCATABLE
         EJECT
*
*        STACK LOCATIONS USED DURING PATTERN MATCH
*        NOTE THAT STACK1 & 2 MAY BE EXPANDED BY MOVING PDR DURING
*        A MATCH.  THEREFORE ONLY THOSE LOCATIONS AT STACK 1 AND BELOW
*        CAN BE REFERENCED SYMBOLICALLY WITHOUT PICKING UP PDRLOC
*
RETLOCP  EQU   STACKBOT-4         RETURN LOCATION FROM PATTERN MATCH
*
FRETLOCP EQU   RETLOCP-4          FAILURE RETURN FROM PAT MATCH DBLWORD
*
STACK2   EQU   FRETLOCP-4         TOP OF PATTERN STACK 2
*
S2OFS    EQU   2*3*4              2 ENTRY OFFSET ON STACK 2 FOR OVERFLO
*
PSTKENTS EQU   100                ALLOW 100 STACK 1 & 2 ENTRIES AT
*                                 START. THIS IS EXPANSION AMOUNT ALSO.
*
STACK1   EQU   STACK2-PSTKENTS*3*4          BOTTOM OF STACK 1
*
ORGPB    EQU   STACK1-4           STARTING PATTERN BASE
*
PSTGLEN  EQU   ORGPB-2            LENGTH FIELD FROM PSTRING
*              THIS IS DONE SO LENGTH CAN BE GOTTEN W/O LOAD OF PDRLOC
*
DOTSW    EQU   PSTGLEN-1          SWITCH SET TO ZERO IF NO DOTS DONE
*
FAILSW   EQU   PSTGLEN-2          FAILURE FLAG FOR PATTERN MATCH
*
PENDWRD  EQU   FAILSW             PATEND SAVEAREA - OLD VALS NT NEEDED
*
PSAVDB1  EQU   FAILSW-4           LOCATION TO SAVE DATAAREA ADDR IN MAT
*
PSAVPBAS EQU   PSAVDB1-4          CURRENT SCAN MODE BASE
*
PSAVMINR EQU   PSAVPBAS-4         NEGATIVE CHARS REQUIRED ABOVE US
*
PSAVNCP  EQU   PSAVMINR-4         CURRENT NCP VALUE
*
PSAVCP   EQU   PSAVNCP-4          CURRENT CURSOR VALUE
*
PSAVPO   EQU   PSAVCP-4           CURRENT PATTERN OFFSET
*
PSAVPB   EQU   PSAVPO-4           CURRENT PATTERN BASE
*
PSAVPS1  EQU   PSAVPB-4           CURRENT STACK 1 LOCATION (DBL WORD)
*
PSAVPS2  EQU   PSAVPS1-4          CURRENT STACK 2 LOCATION
*
PSAVBPS  EQU   PSAVPS2-4          STACK INCREMENT (12) (DOUBLE WORD)
         EJECT
*
PSTKOFS  EQU   PSAVBPS/8*8        RESERVE ROOM AT BOTTOM FOR CHARACTER
*                                 TABLES  MUST BE >= 256+8 BYTES
*
PATSPACE EQU   STACKTOP-PSTKOFS   ROOM FOR PATTERN STACK BEFORE EXPAND
*
ANCLOC   EQU   STACK1+S1PATOFS    LOCATION OF ANCHOR FLAG (SEE $$PTN2)
*
         TITLE 'SPITBOLX -- GARBAGE COLLECTOR'
*
*        THE GARBAGE COLLECTOR OPERATES IN FOUR PASSES AS FOLLOWS
*
*        PASS 1
*        ------
*
*        THIS IS A MARKING PHASE SIMILAR TO THAT USED IN LISP -- WITH
*        THE ADDITIONAL OPERATION OF BACK-CHAINING ALL REFERENCES.
*        THE "GARBAGE COLLECTION FIELD" OF EACH BLOCK IN THE DYNAMIC
*        STORAGE AREA IS USED TO POINT TO A LINKED LIST OF ADDRESSES
*        WHICH SHOULD POINT TO THE BLOCK AFTER RELOCATION. IF THIS
*        FIELD IS ZERO AFTER PASS 1 THEN THE BLOCK IS NOT IN USE AND
*        MAY BE DELETED.
*
*        PASS 2
*        ------
*
*        IN THIS PASS, A POINTER IS MOVED THROUGH THE DYNAMIC STORAGE
*        AREA, AND ANOTHER POINTER KEEPS TRACK OF WHERE THE BLOCKS
*        THAT ARE STILL IN USE WILL END UP WHEN THEY ARE FINALLY MOVED
*        NO ACTUAL MOVING OF BLOCKS TAKES PLACE IN THIS PASS. WHEN WE
*        COME TO A BLOCK THAT IS IN USE, ALL POINTERS TO THE BLOCK
*        ARE RELOCATED. THE GARBAGE COLLECTION FIELDS ARE SET TO FORM
*        A LINKED LIST OF BLOCKS IN USE FOR THE NEXT PASS.
*
*        PASS 3
*        ------
*
*        PASS 3 IS ONLY USED IF LABELS OR OTHER POINTERS INTO
*        RELOCATABLE CODE (CODE,EVAL) ARE TO BE RELOCATED. DURING PASS
*        THREE, ANY SUCH POINTERS ARE RELOCATED USING THE NEW VALUE
*        IN THE CODNLOC FIELD SET DURING PASS TWO.
*
*        PASS 4
*        ------
*
*        IN THE LAST PASS, WE GO DOWN THE CHAIN OF BLOCKS IN USE,
*        MOVING THEM TO THEIR NEW LOCATIONS AND ZEROING THE GCF.
         EJECT
*
*        REGISTER DEFINITIONS FOR GCOL
*
OLD      EQU   A1                 POINTER TO OLD FREE CORE LOCATION
NEW      EQU   A2                 POINTER TO NEW FREE CORE LOCATION
LAST     EQU   A2+1               POINTER TO LAST BLOCK IN USE (PASS2)
MSK      EQU   A1+1               HOLDS X'00FFFFFF' TO MASK ADDRESSES
LIM      EQU   FR                 END OF DYNAMIC STORAGE AREA
GR1      EQU   DB2                PASS 1 PTR TO FIELD TO BE PROCESSED
MINUS8   EQU   DB3                PASS 1 BXH DECREMENT REGISTER
GR3      EQU   DB4                PASS 1 BXH END REGISTER, BLK PTR
GR2      EQU   FRETURN            PASS 1 BAL REGISTER FOR PTRPROC
BOT      EQU   OLD                BOTTOM OF DYNAMIC STORAGE (PASS 1)
CLIM     EQU   GR1                PASS 2 SBLOKCOMPRESS CHAR USED
COLD     EQU   GR2                PASS 2 SBLOK PTS TO USED CHARACTERS
CNEW     EQU   GR3                PASS 2 SBLOK COMPRESS DESTINATION ADD
COFF     EQU   MINUS8             PASS 2 DELETED CHARACTERS AHEAD REG
*
*
*        ENTRY AND INITIALIZATION FOR PASS 1
*
*        NOTE THAT IT IS VERY IMPORTANT THAT THE FIRST PTRPROC CALL BE
*        AFTER THE LABEL GCOLBASE - MAKE SURE THIS OCCURS
*        REGISTER USAGE/CONTENTS RULES ARE VERY STRICT
*        (GR3)                    NON-ZERO MULTIPLE OF FOUR IN PASS1
*        (R2)                     UPPER 3 BYTES ZERO IN PASS1
*        CHECK SPECIFIC ROUTINES FOR OTHER RULES
*
         USING GCOL,R1            BASE REG SET AT ENTRY POINT
GCOL     STM   0,15,GCOLSV        SAVE REGISTERS
         LR    NEW,FR             SET FOR CHECK IN CASE CORE IS EMPTY
         AP    GCOLCNT,=P'1'      INCREMENT COUNT OF COLLECTIONS
         LR    RETURN,R1          SWITCH BASE REGS
         USING GCOL,RETURN        TELL ASSEMBLER
         DROP  R1                 DROP TEMP BASE
         L     MSK,=X'00FFFFFF'   LOAD MASK REGISTER
         L     BOT,DYNAMB         LOAD START OF FREE CORE
         LH    MINUS8,=H'-8'      INITIALIZE BXH REGISTER
         SR    R2,R2              CLEAR R2 FOR PTRPROC USE
         MVI   ZTBL+X'47',1       SETUP TRT TABL TO SCAN FOR CODE NOP'S
         MVI   LABRLFLG,0         RESET LABEL RELOCATION FLAG
         LR    GR3,FR             MAKE SURE GR3 IS DIVISIBLE BY 4
         STD   ZR,GPCHAIN         CLEAR GPCHAIN, GECHAIN
*
*        THE FOLLOWING CODE IMPLEMENTS THE HEURISTIC APPROACH OF
*        DOING A SUPER (COMPACTING) GARBAGE COLLECTION AT LEAST
*        EVERY TEN NORMAL COLLECTIONS SO THAT WE DO NOT MESS AROUND
*        DOING LOTS OF COLLECTIONS WHICH COULD BE AVOIDED
*
         CLI   GCOLCNT+2,X'9C'    LOW ORDER DIGIT OF COUNT = 9 ?
         BNE   GCOL1              SKIP IF NOT
         OI    GCOLNRG,GCMPRSS    ELSE SET FOR COMPRESSION
         EJECT
*
*        PASS 1
*        ------
*
*        COME HERE TO CHECK FOR SPECIAL CASE OF GBGCLF CALL
*
GCOL1    L     PDR,PDRLOC         RESET STACK TO BASE OF THIS LEVEL
         TM    GCOLNRG,GGBGCLF    CHECK FOR GBGCLF CALL
         BNO   PASS1S             SKIP IF NOT GBGCLF CALL
*
*        FOR GBGCLF, BACK OFF RETURN TO RECALL THE FUNCTION
*
         ST    PDR,GCOLSV+4*PDR   SET TO GET PROPER PDR FOR FUNC RETRY
         LA    GR1,TEM#1+8(,PDR)  INITIALIZE PTR TO NO TEMPS
         L     R2,RETLOC          LOAD RETURN LOCATION
         SH    R2,H12             BACK OFF TWELVE BYTES
         CLC   6(2,R2),SRPDRR1    IS THIS SR  PDR,R1 ?
         BNE   *+12               SKIP IF NO TEMPS IN USE BEFORE FUNC
         SH    GR1,4(,R2)         ELSE ADJUST PTR FOR EXTRA TEMPS
         SH    R2,H6              ADJUST FOR SR, AND LA
         TM    6(R2),DB4*16       IS DB4 THE BASE REGISTER?
         BNO   *+8                SKIP IF NOT
         SH    R2,H4              BACK FOR L DB4,BASEADDR
         ST    R2,GCOLSV+4*RETURN SAVE RETURN LOCATION
         EX    0,0(,R2)           EXECUTE INSTRUC TO GET NUMBER OF ARGS
         SLL   R0,3               *8=ROOM ON STACK
         SR    GR1,R0             ADJUST PTR FOR FUNCTION ARG TEMPS
         SR    R2,R2              RECLEAR R2 FOR PTRPROC CALLS
*
*        COME HERE WITH BOT = LIM TO SET UP BASE REGISTER FOR GCOLCHK
*
GCOLCHK1 LA    RETURN,GCOLBASE    SET UP BASE REGISTER VALUE
         USING GCOLBASE,RETURN    TELL ASSEMBLER
         CR    BOT,LIM            PROTECT AGAINST INITIAL COLLECT CALL
         BL    PASS1SE            PROCESS TEMPS IF CORE USED
         B     GCOLCHK            EXIT IF NO CORE USED
         USING GCOL,RETURN        PUT BACK OLD BASE REGISTER
*
SRPDRR1  SR    PDR,R1             USED TO CHECK FOR STK ADJ IN FUNC CAL
         EJECT
*
*        PASS 1 -- CONTINUED
*        -------------------
*
*        FIRST UNWIND THE PDR STACK
*
*        THIS FIRST SECTION  (WHICH IS SOMEWHAT MESSY) SCANS THE CODE
*        AT THE POINT OF CALL TO DETERMINE HOW MANY TEMPORARIES ARE IN
*        USE -- GR1 IS SET TO POINT TO LAST TEMPORARY IN USE
*
PASS1S   CR    BOT,LIM            CHECK FOR CORE EMPTY
         BNL   GCOLCHK1           JUMP IF CORE IS EMPTY
         L     R1,RETLOC          ELSE LOAD CODE RETURN LOCATION
         LA    GR1,TEM#1+8(,PDR)  INITIALIZE GR1 TO NO TEMPS IN USE
         B     PASS1SL            OFF TO TEST FIRST INSTRUCTION
*
*        WE LOOK FORWARD THROUGH THE CODE TO FIND THE NEXT TEMPORARY
*        REFERENCED.  IF THE REFERENCE IS A LM THEN THE S ADDR IS THAT
*        OF THE LAST TEMP WE MUST SAVE.  IF THE REFERENCE IS A STM
*        THE LAST TEMP WE SAVE IS 8 BYTES HIGHER
*
*        COME HERE TO BUMP PAST FOUR BYTE INSTRUCTION
*
PASS1RX1 LA    R1,4(,R1)          SKIP PAST FOUR BYTES
*
*        COME HERE TO TEST NEXT INSTRUCTION (FOR RR OR RX)
*
PASS1SL  TM    0(R1),X'C0'        TEST FOR RR INSTRUCTION
         BM    PASS1SRX           SKIP IF NOT
         CLI   0(R1),X'3E'        IS IT AN AUR?
         LA    R1,2(,R1)          ALWAYS SKIP OVER 2 BYTES
         BNE   PASS1SL            LOOP BACK IF NOT END OF STATEMENT
         B     PASS1ST            ELSE ALL DONE IF AUR
*
*        COME HERE IF FOUR BYTE INSTRUCTION
*
PASS1SRX CLC   0(4,R1),BEVLR1     B $$EVLR AT END OF EXPRESSION?
         BE    PASS1ST            END OF CODE SCAN IF SO (NO TEMPS)
         TM    2(R1),PDR*16       ELSE IS IT PDR REFERENCE (PDR=15)
         BNO   PASS1RX1           SKIP PAST INSTRUCTION IF NOT
         LH    R0,2(,R1)          GET S ADDRESS
         CLI   0(R1),X'98'        IS IT A LM?
         BE    *+16               FOUND HIGHEST TEMP IF SO
         CLI   0(R1),X'90'        ELSE IS IT STM?
         BNE   PASS1RX1           SKIP OVER IT IF NOT
         AH    R0,H8              POINT TO LAST TEMP USED
         STH   R0,GBGLA+2         STORE S ADDRESS FOR LA
         EX    0,GBGLA            LOAD ADDRESS OF LAST TEMP USED
*
*        COME HERE TO SET UP BASE REGISTER FOR REST OF COLLECT
*
PASS1ST  LA    RETURN,GCOLBASE    POINT BASE REGISTER TO NEW LOCATION
         USING GCOLBASE,RETURN    TELL ASSEMBLER
         CNOP  0,4                GCOLBASE MUST BE FULLWORD ALLIGNED
GCOLBASE EQU   *                  BASE ADDR POINT AFTER INITIALIZATION
         EJECT
*
*        PASS 1 -- CONTINUED
*        -------------------
*
*        COME HERE WHEN CURRENT LEVEL OF STACK IS NOT PATTERN MATCH
*        (GR1) POINTING TO HIGHEST TEMPORARY LOCATION IN USE
*
         CNOP  0,4                TAKE BOUNDARY ALLIGN OUT OF LOOP
PASS1SE  LA    LAST,TEM#1(,PDR)   GET LOWEST POSSIBLE TEMPORARY LOC
         CR    GR1,LAST           DO WE ACTUALLY HAVE TEMPS IN USE?
         BH    PASS1EM            SKIP IF NOT
         LPR   NEW,MINUS8         GET BXLE CONSTANT=+8
*
*        LOOP TO PROCESS TEMPORARIES IN USE AT THIS LEVEL
*
         CNOP  0,4                ALLIGNMENT FOR BAL
         BAL   GR2,PTRPROCV       PROCESS A TEMPORARY
         BXLE  GR1,NEW,*-4        LOOP UNTIL ALL PROCESSED
*
*        NOW DEAL WITH PSTRING,PNAME IF IN USE (PNAME NON-ZERO)
*
PASS1EM  CE    ZR,PNAME(,PDR)     TEST TO SEE IF PNAME IN USE
         BE    PASS1ET            SKIP IF NOT IN USE
*
*        COME HERE TO PROCESS PSTRING AND PNAME
*
         CNOP  0,4                ALLIGN NEXT TWO PTRPROC CALLS
PASS1EP  LA    GR1,PNAME(,PDR)    POINT TO PNAME
         BAL   GR2,PTRPROC        PROCESS IT (CANNOT BE NULL)
         LA    GR1,PSTRING(,PDR)  POINT TO PSTRING
         BAL   GR2,PTRPROCV       PROCESS IT
*
*        ENTER HERE WITH EVERYTHING DEALT WITH EXCEPT FBLOKLOC
*        THIS LOCATION TELLS US WHAT THE PREVIOUS LEVEL OF THE STACK IS
*
*        1)    FBLOKLOC > 0       PREVIOUS LEVEL WAS FUNCTION CALL
*                                 (FBLOKLOC POINTS TO FBLOK)
*
*        2)    FBLOKLOC = 0       CURRENT LEVEL IS UNEVALUATED EXPR
*                                 PREVIOUS LEVEL IS PATTERN MATCH
*                                 IF CC IN EVLINK IS ZERO
*
*        3)    FBLOKLOC < 0       FLAG FOR BOTTOM OF STACK
*
PASS1ET  L     R0,FBLOKLOC(,PDR)  LOAD TO TEST IT
         LTR   R0,R0              TEST IT
         BP    PASS1F             SKIP IF FUNCTION
         BM    PASS1V             SKIP IF END OF STACK, ELSE MERGE
         EJECT
*
*        PASS 1 -- CONTINUED
*        -------------------
*
*
*        IF FBLOKLOC WAS ZERO, THEN THIS LEVEL OF THE STACK
*        WAS AN EVALUATION OF AN UNEVALUATED EXPRESSION.  IF THE
*        CONDITION CODE FIELD IN EVLINK IS ZERO, THE LEVEL ABOVE US
*        IS A PATTERN MATCH.
*
         TM    EVLINK(PDR),X'30'  TEST CONDITION CODE
         BNZ   PASS1F1            MERGE WITH FUNCTION PROCESSION IF
*                                 IT IS EVAL FUNCTION CALL
*
*        COME HERE IF LEVEL ABOVE IS A PATTERN MATCH
*        NOTE THAT THE LOWEST PDR USED IN MATCH IS CURRENT PDR+PATSPACE
*
         CNOP  0,4                ALLIGN PTRPROC CALLS ON FULLWORD
         LA    GR1,ORGPB+PATSPACE(,PDR)     POINT TO PATTERN POINTER
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,PSAVPB+PATSPACE(,PDR)    POINT TO CURRENT PB IN REG
         BAL   GR2,PTRPROC        PROCESS IT
         L     LAST,PSAVPS1+PATSPACE(,PDR)  GET TOP OF STACK1 ADDR
         LA    NEW,3*4            GET BXLE INCREMENT
         LA    GR1,STACK1+S1OLDCP+PATSPACE(,PDR)      POINT TO FIRST
*              (DUMMY) FIELD ON STACK 1 - MAKES SURE THERE IS A FIELD
         CNOP  0,4                ALLIGN BAL CALL TO PTRPROC
         BAL   GR2,PTRPROCV       PROCESS IT
         BXLE  GR1,NEW,*-4        LOOP UNTIL ALL ENTRIES ARE PROCESSED
*
*        COME HERE TO PROCESS STACK 2 ENTRIES
*
         L     GR1,PSAVPS2+PATSPACE(,PDR)   GET CURRENT STACK 2 POINTER
         LA    GR1,S2OFS+S2PB(,GR1)         POINT TO FIRST RELOC FIELD
         L     PDR,PDRBPTR(,PDR)  POSITION PDR TO PAT MATCH LEVEL
         LA    LAST,STACK2-2*3*4+S2PB(,PDR) POINT TO END OF STACK 2
         CNOP  0,4                ALLIGN CALL TO PTRPROC
         BAL   GR2,PTRPROCV       PROCESS IT
         BXLE  GR1,NEW,*-4        LOOP UNTIL STACK PROCESSED
         LA    GR1,RETLOCP(,PDR)  POINT TO PATTERN RETURN SAVE LOC
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE LABEL
         LA    GR1,FRETLOCP(,PDR) POINT TO PATTERN FRETURN SAVE LOC
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE LABEL
*
*        COME HERE WITH STACKS PROCESSED TO FINISH UP
*
         B     PASS1EP            PROCESS PNAME, PSTRING, & NEXT LEVEL
         EJECT
*
*        PASS 1 -- CONTINED
*        ------------------
*
*
*        COME HERE WHEN PREVIOUS LEVEL IS A FUNCTION CALL
*
         CNOP  0,4                ALLIGN CALL TO PTRPROC
PASS1F   LA    GR1,FBLOKLOC(,PDR) POINT TO FUNCTION BLOCK POINTER
         BAL   GR2,PTRPROC        PROCESS FUNCTION POINTER
*
*        MERGE HERE FOR CASE OF EVAL FUNCTION CALLED ABOVE US
*
PASS1F1  LA    GR1,RETFLOC(,PDR)  POINT TO SAVED VALUE OF (RETURN)
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE CODE LOC
         LA    GR1,FRETFLOC(,PDR) POINT TO SAVED VALUE OF (FRETURN)
         BAL   GR2,PTRPROCL       PROCESS POSSIBLE RELOCATABLE CODE LOC
         LA    GR1,LASTEM(,PDR)   POINT TO LAST TEMPORARY ON LEVEL UP
         L     PDR,PDRBPTR(,PDR)  RESTORE PDR FOR LEVEL ABOVE
         B     PASS1SE            AND OFF TO PROCESS TEMPORARIES
*
*        COME HERE WHEN STACK HAS BEEN PROCESSED
*        NOW WE MUST PROCESS 8-BYTE CONSTANT BLOCKS IN VARIABLE BLOCKS
*        THIS IS DONE ONLY DURING CONSTANT EXPRESSION EVALUATION OR IF
*        THE COMPILER HAS BEEN USED AT EXECUTE TIME (CRELFLG SET)
*
         CNOP  0,4                ALLIGN PTRPROC CALL IN LOOP
PASS1V   CLI   CRELFLG,0          TEST SPECIAL FLAG
         BZ    PASS1VB            SKIP TO PROCESS VAR BLKS IF OFF
         SR    NEW,NEW            SET OFFSET TO $$BAS1 ENTRY
*
*        LOOP TO PROCESS A 4K VARIABLE BLOCK FOR CONSTANTS
*        NOTE THAT THE FIRST POINTER PROCESSED IN EACH BLOCK IS THE
*        CBLKEND WORD, WHICH ASSURES AT LEAST ONE 8 BYTE ENTRY
*        PROCESSING THIS FIELD WORKS SINCE LEFTMOST BYTE IS ZERO
*
PASS1C   L     LAST,$$BAS1(NEW)   LOAD NEXT BASE TABLE ENTRY
         LA    LAST,VALUE(,LAST)  POINT TO ACTUAL START OF BLOCK
         LA    GR1,CBLKEND(,LAST) POINT TO FIRST CONSTANT BLK (DUMMY)
         L     GR3,CBLKBOT(,LAST) LOAD ADDRESS OF LOWEST CONSTANT BLOCK
         AR    GR3,MINUS8         BACK UP TO SATISFY BXH ON LAST LOOP
         CNOP  0,4                MAKE SURE PTRPROC CALL IS ALLIGNED
         BAL   GR2,PTRPROCV       PROCESS A CONSTANT BLOCK
         BXH   GR1,MINUS8,*-4     LOOP UNTIL ALL BLOCKS PROCESSED
         LA    NEW,4(,NEW)        PUSH TO NEXT BASE TABLE ENTRY
         CH    NEW,CURBASE        HAVE WE EXCEEDED BASE TABLE ENTRIES?
         BNH   PASS1C             LOOP BACK IF NOT
         LTER  SINC,SINC          ARE WE IN CONSTANT EXPRESSIONS?
         BZ    PASS1SP            NO NEED TO PROC VARBLKS IF SO
         EJECT
*
*        HERE WE PROCESS VARIABLE BLOCKS FOR THE NORMAL CASE OF A
*        GARBAGE COLLECTION DURING EXECUTION PROPER
*
         CNOP  0,4                PUT PTRPROC CALLS ON FULLWORD
PASS1VB  L     LAST,HASHTBAD      LOAD ADDRESS OF MAIN HASH TABLE
         LA    NEW,HASHTBNS+1     GET BCT VALUE FOR LOOP
         B     PASS1VE            AND GO OFF TO LOAD A SLOT VALUE
*
*        COME HERE WHEN A VARIABLE BLOCK IS FOUND TO PROCESS FIELDS
*
PASS1VL  LA    GR1,VALUE(,GR3)    POINT TO VALUE FIELD
         BAL   GR2,PTRPROCV       AND PROCESS IT
         LA    GR1,VFUNC(,GR3)    POINT TO FUNCTION POINTER
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,VIOPTR(,GR3)   POINT TO IOBLOCK POINTER
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,VNAME(,GR3)    POINT TO NAME FIELD
         BAL   GR2,PTRPROC        PROCESS IT (WE KNOW RELOC BIT IS ON)
         LA    GR1,VLABL(,GR3)    LOAD LABEL POINTER
         BAL   GR2,PTRPROCL       PROCESS IT WITH SPECIAL LABEL ROUTINE
         L     GR3,VLINK(,GR3)    MOVE OUT ON LINK
*
*        COME HERE TO CHECK FOR ZERO LINK FIELD
*
PASS1VN  NR    GR3,MSK            CLEAR LEFT BYTE, SET CONDITION CODE
         BNZ   PASS1VL            PROCESS VARIABLE IF NOT END OF LINK
*
*        COME HERE TO PICK UP NEXT HASH SLOT ENTRY
*
PASS1VE  L     GR3,VLINK(,LAST)   PICK UP NEXT SLOT VALUE
         LA    LAST,4(,LAST)      PUSH SLOT POINTER
         BCT   NEW,PASS1VN        OFF TO TEST FOR LINK END IF NOT TBLND
*
*        COME HERE WHEN WE HAVE PROCESSED ALL VARIABLE BLOCKS
*
*        NOW DEAL WITH SPECIAL SYSTEM RELOCATABLE FIELDS
*
*
         CNOP  2,4                ALLIGN FOLLOWING PTRPROC CALLS
PASS1SP  LA    GR1,ANYTPTR        POINT TO TABLE POINTER FOR ANY/NOTANY
         LR    GR3,FR             SET GR3 NONZERO, DIVISIBLE BY 4
         BAL   GR2,PTRPROCS       PROCESS IT IF TABLE IS IN USE
         CE    ZR,ANYTPTR         DO WE HAVE A TABLE IN USE?
         BNZ   *+8                SKIP IF SO
         MVI   ANYMASK,0          CLEAR MASK TO GET NEW TABLE NEXT TIME
         LA    GR1,PCFRSAVE       POINT TO PATTERN CONCAT RELOCATABLE
         BAL   GR2,PTRPROCS       PROCESS IT IF USED ELSEWHERE TOO
         CE    ZR,PCFRSAVE        TEST FOR UNUSED ADDRESS FOR PAT ADDR
         BNZ   *+8                SKIP IF ADDRESS FIELD SAVED
         STE   ZR,SCNTSAVE        ELSE CLEAR OUT STATEMENT NUMBER TOO
         EJECT
*
*        NOW RELOCATE SAVED REGISTERS IF REQUESTED
*
         CNOP  0,4                ALLIGN PTRPROC CALLS TO FULLWORD
         TM    GCOLNRG,GRELOC1+GRELOC2      TEST FOR RELOC OF REGS
         BZ    PASS1SP0           SKIP IF NONE
         BM    *+12               SKIP IF ONLY ONE
         LA    GR1,GCOLSV+4*A2    POINT TO SAVED VALUE OF A2
         BAL   GR2,PTRPROCV       PROCESS IT AS VALUE
         LA    GR1,GCOLSV+4*A1    POINT TO SAVED VALUE OF A1
         BAL   GR2,PTRPROCV       PROCESS IT AS VALUE
*
*        COME HERE TO PROCESS POINTERS USED FOR TRACING
*
PASS1SP0 LA    GR1,FNCLTRC        POINT TO FNCLEVEL CHAIN HEAD
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,STCNTTRC       POINT TO CHAIN HEAD FOR STCOUNT
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,ETYPTRC        POINT TO PTR FOR ERRTYPE TRACE
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,FCTRCCHN       POINT TO CALL TRACE CHAIN HEAD
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,FRTRCCHN       POINT TO RETURN TRACE CHAIN
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR3,OPTRTABL-4     STOP ADDRESS FOR OPTR TABLE RELOC
         LA    GR1,NOPTRS*4(,GR3) FIRST (LAST) TABLE ENTRY TO RELOC
*
*        COME HERE TO PROCESS NEXT UNDEFINED OPERATOR TABLE ENTRY
*
PASS1SPA BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,4(,GR1)        CORRECT FOR BXH SUBTRACT OF EIGHT
         BXH   GR1,MINUS8,PASS1SPA          DECREMENT TBL ENTRY PTR, LP
         EJECT
*
*        NOW WE MUST PROCESS THE POINTER USED TO OPTIMIZE CONCATENATION
*        WE ONLY WISH TO HOLD THE STRING IF THERE IS ANOTHER POINTER
*        TO THE ENTIRE STRING, SINCE THAT IS THE OPTIMIZATION
*        REQUIREMENT.
*
         LM    NEW,LAST,CONCFRSV+4          LOAD SBLOK PTR,OFFSET & LEN
         LTR   NEW,NEW            TEST FOR POINTER IN USE
         BZ    PASS1SPX           SKIP IF NOT USED
         STE   ZR,CONCFRSV+4      ZERO POINTER IN CASE WE ABANDON IT
         CE    ZR,0(,NEW)         IS ANYONE ELSE POINTING TO IT?
         BE    PASS1SPX           ABANDON STRING IF NO OTHER POINTERS
         CLI   0(NEW),SBLOK       MAKE SURE THIS IS AN SBLOK
         BNE   PASS1SPX           ABANDON IT IF PATTERN BLOCK
         L     GR1,0(,NEW)        LOAD START OF POINTER CHAIN
*
*        THIS LOOP GOES OUT ON CHAIN LOOKING FOR AN IDENTICAL SUBSTRG
*
PASS1SPL C     LAST,4(,GR1)       DO THE SUBSTRINGS MATCH?
         BE    PASS1SP1           PROCESS POINTER IF MATCH
         TM    3(GR1),1           CHECK FOR END OF POINTER CHAIN
         L     GR1,0(,GR1)        MOVE OUT ON POINTER CHAIN
         BNO   PASS1SPL           AND LOOP BACK IF NOT AT END
         B     PASS1SPX           ELSE NOT ALL IN USE, SO ABANDON IT
*
*        COME HERE WHEN SBLOK SHOULD BE RETAINED - PROCESS POINTER
*
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD
PASS1SP1 ST    NEW,CONCFRSV+4     RESTORE POINTER FOR CONCAT OPTIMIZE
         LA    GR1,CONCFRSV+4     POINT TO FIELD TO BE RELOCATED
         BAL   GR2,PTRPROC        PROCESS IT - WE KNOW IT IS RELOCATABL
         EJECT
*
*        PASS 1 -- CONTINUED
*        -------------------
*
*        NOW WE MUST PROCESS MISCELLANEOUS CODE LOCATIONS SINCE THEY
*        MAY REFER TO RELOCATABLE CHUNKS OF CODE. HOWEVER, WE DO NOT
*        PERFORM THIS PROCESSING IF WE ARE AT FUNCTION LEVEL ZERO AND
*        WE WERE CALLED FROM THE ORIGINAL GENERATED CODE. THIS HELPS
*        TO AVOID HANGING ONTO UNNECCESSARY GARBAGE CODE BLOCKS.
*
PASS1SPX EQU   *                  PASS1 ENTRY - (GR3) IS NON-ZERO
*
*        THE FOLLOWING CODE IS ALSO USED IN PASS 3 WHERE SIMILAR
*        PROCESSING MUST BE PERFORMED
*
PASS13SL CE    ZR,V$FNCLEV        TEST FUNCTION LEVEL
         BNZ   PASS1LLL           SKIP TO PROCESS IF &FNCLEVEL#0
         L     R0,RETLOC          LOAD CURRENT CODE LOCATION
         NR    R0,MSK             CLEAR POSSIBLE UPPER BYTE
         CR    R0,BOT             BEFORE DYNAMIC CORE?
         BL    PASS13SE           SKIP PROCESSING IF SO
         CR    R0,LIM             BEYOND DYNAMIC CORE?
         BNL   PASS13SE           SKIP PROCESSING IF PAST DYNAMIC CORE
*
*        HERE WE MUST PROCESS THESE LOCATIONS
*        (GR1)                    WILL BE DESTROYED IF LTBLOK ADDRESS
*
         CNOP  0,4                ALIGN PTRPROCL CALL
PASS1LLL LA    GR1,SRETSV         POINT TO TABLE SAVE LOCATION
         BAL   GR2,PTRPROCL       PROCESS IT
         LA    GR1,RETURN*4+GCOLSV          POINT TO GCOL RETURN REG
         BAL   GR2,PTRPROCL       PROCESS IT
         LA    GR1,FRETURN*4+GCOLSV         POINT TO SAVED FRETURN ADDR
         BAL   GR2,PTRPROCL       AND PROCESS IT
         LA    LAST,LINKLOCS      POINT TO START OF LOCATIONS
         LA    GR1,LINKLOCS       POINT TO LOCATIONS, KEEP ALIGNMENT
         LA    NEW,ENDLINKS       LOAD END OF LIST ADDRESS FOR TESTS
*
*        COME HERE TO PROCESS NEXT ENTRY IN LOCATION TABLE
*
         CNOP  0,4                MAKE SURE WE ARE STILL ON FULLWORD
PASS1LL  BAL   GR2,PTRPROCL       PROCESS POINTER
         LA    LAST,4(,LAST)      POINT TO NEXT LOCATION
         LR    GR1,LAST           COPY POINTER IN CASE GR1 DESTROYED
         CR    GR1,NEW            CHECK FOR TABLE END
         BL    PASS1LL            BACK IF MORE TO GO
*
*        HERE WHEN THIS LABEL PROCESSING IS COMPLETE
*
PASS13SE LTR   GR3,GR3            TEST PASS1/PASS3 FLAG
         BNZ   PASS2              OFF TO PASS 2 IF WE ARE ENDING PASS 1
         B     PASS4              ELSE START PASS 4 IF ENDING PASS 3
         EJECT
*
*        PTRPROC -- BLOK PROCESSING ROUTINES
*        -----------------------------------
*
*
*        PDFBLOKP                 PROGRAM DEFINED DATATYPE FUNCTION
*
         CNOP  0,4                ALLIGN CALL TO PTRPROC
PDFBLOKP LA    GR1,PDMODL+4(,GR3) POINT TO THE POINTER TO THIS BLOCK
         BAL   GR2,PTRPROC        USE PTRPROC TO PROCESS IT
         LA    R2,PDFBLOK         GET BLOCK CODE FOR RESTORE
         B     PTRPOP             RETURN
*
*        FFBLOKP                  FIELD FUNCTION
*
         CNOP  0,4                ALLIGN CALL TO PTRPROC
FFBLOKP  LA    GR1,PDFPTR(,GR3)   PICK UP PDFBLOK POINTER ADDRESS
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,FFBLNEXT(,GR3) POINT TO NEXT FFBLOK WITH SAME NAME
         BAL   GR2,PTRPROC        PROCESS IT
         LA    R2,FFBLOK          GET BLOCK CODE FOR RESTORE
         B     PTRPOP             ALL DONE
*
*        PDBLOKP                  PROGRAM DEFINED DATATYPE
*
         CNOP  2,4                ALLIGN CALL TO PTRPROC ON FULLWORD
PDBLOKP  IC    R2,NBYTESD(,GR3)   LOAD LENGTH OF BLOCK
         LA    GR1,0(R2,GR3)      POINT PAST BLOCK
         AR    GR1,MINUS8         POINT TO LAST VALUE FIELD
         BAL   GR2,PTRPROCV       PROCESS A VALUE FIELD
         BXH   GR1,MINUS8,*-4     LOOP UNTIL ALL FIELDS PROCESSED
         LA    GR1,PDFPTR(,GR3)   POINT TO PDFBLOK POINTER
         BAL   GR2,PTRPROC        AND PROCESS IT
         LA    R2,PDBLOK          RESTORE PROPER BLOCK CODE
         B     PTRPOP             AND RETURN
*
*        ABLOKP                   ARRAY
*
*        NOTE THAT THE SUBFACS AND ASPEC ARE TREATED AS VALUE FIELDS
*
         CNOP  0,4                ALLIGN CALL TO PTRPROCV ON FULLWORD
ABLOKP   L     GR1,NBYTESA(,GR3)  LOAD LENGTH OF BLOCK
         AR    GR1,GR3            POINT PAST LAST VALUE FIELD
         AR    GR1,MINUS8         POINT TO LAST VALUE FIELD
         BAL   GR2,PTRPROCV       PROCESS VALUE FIELD
         BXH   GR1,MINUS8,*-4     LOOP UNTIL ALL FIELDS PROCESSED
         LA    R2,ABLOK           GET BLOCK CODE FOR RESTORE
         B     PTRPOP             AND RETURN
         EJECT
*
*        PTRPROC -- BLOK PROCESSING ROUTINES -- CONTINUED
*        ------------------------------------------------
*
*
*        LTBLOKP                  LABEL TRACE BLOCK
*
*        ON ENTRY TO LTBLOKP LTLOC HAS ALREADY BEEN PROCESSED
*
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD
LTBLOKP  LA    GR1,LTTAG(,GR3)    POINT TO POSSIBLE TRACE TAG
         BAL   GR2,PTRPROCV       VALUE PROCESS IT
         LA    GR1,LTGOTO(,GR3)   POINT TO LABEL LOCATION
         BAL   GR2,PTRPROCL       LABEL PROCESS IT
         LA    R2,LTBLOK          GET BLOCK CODE FOR RESTORE
         B     PTRPOP             AND RETURN
*
*        TBBLOKP                  TABLE
*
         CNOP  2,4                ALLIGN PTRPROC CALL TO FULLWORD
TBBLOKP  L     GR1,TBDIVIDE(,GR3) LOAD NO. OF SLOTS * 4
         LA    GR1,TBLPTRS-4(GR1,GR3)       POINT TO LAST TABLE ENTRY
         SR    GR3,MINUS8         TEMPORARILY MOVE UP FOR BXH LIMIT
         BAL   GR2,PTRPROC        PROCESS HASH POINTER
         LA    GR1,4(,GR1)        DO LA TO COUNTER PART OF DECREMENT
         BXH   GR1,MINUS8,*-8     LOOP UNTIL ALL POINTERS PROCESSED
         AR    GR3,MINUS8         POINT TO BLOCK AGAIN
         LA    R2,TBBLOK          GET BLOCK CODE FOR RESTORE
         B     PTRPOP             AND RETURN
*
*        TEBLOKP                  TABLE ELEMENT
*
         CNOP  0,4                ALIIGN PTRPROC CALL TO FULLWORD
TEBLOKP  LA    GR1,TEVALUE(,GR3)  POINT TO VALUE
         BAL   GR2,PTRPROCV       VALUE PROCESS IT
         LA    GR1,TLINK(,GR3)    POINT TO LINK FIELD
         BAL   GR2,PTRPROC        PROCESS IT
         LA    GR1,TENAME(,GR3)   POINT TO NAME POINTER
         BAL   GR2,PTRPROCV       VALUE PROCESS IT
         LA    R2,TEBLOK          GET TYPE CODE FOR RESTORE
         B     PTRPOP             RETURN
         EJECT
*
*        PTRPROC -- BLOK PROCESSING ROUTINES -- CONTINUED
*        ------------------------------------------------
*
*
*        IOBLOKP                  IOBLOCK
*
         CNOP  0,4                ALLIGN PTRPROC CALLS
IOBLOKP  LA    GR1,OFORMAT(,GR3)  POINT TO OUTPUT FORMAT
         BAL   GR2,PTRPROCV       PROCESS IT
         LA    GR1,IOTAG(,GR3)    POINT TO TRACE TAG
         BAL   GR2,PTRPROCV       VALUE PROCESS IT
         LA    R2,IOBLOK          GET BLOCK CODE FOR RESTORE
         B     PTRPOP             AND RETURN
*
*        CBLOKP                   CODE BLOCK
*
         CNOP  0,4                ALLIGN CALLS TO PTRPROC
CBLOKP   LA    GR1,CODNLOC(,GR3)  POINT TO CODE BLOCK POINTER
         BAL   GR2,PTRPROC        PROCESS IT
         LA    R2,CBLOK           GET BLOCK CODE FOR RESTORE
         B     PTRPOP             AND RETURN
*
*        TRBLOK                   TRACE BLOCK
*
         CNOP  0,4                ALIIGN PTRPROC CALLS TO FULLWORD
TRBLOKP  LA    GR1,TRTAG(,GR3)    POINT TO TAG
         BAL   GR2,PTRPROCV       VALUE PROCESS IT
         LA    GR1,TRCLINK(,GR3)  POINT TO POSSIBLE LINK
         BAL   GR2,PTRPROC        PROCESS IT
         LA    R2,TRBLOK          GET BLOCK CODE FOR RESTORE
         B     PTRPOP             AND RETURN
         EJECT
*
*        PBLOKP                   PATTERN
*
         CNOP  2,4                ALLIGN PTRPROC CALL TO FULLWORD
PBLOKP   LH    GR1,PTLENG(,GR3)   LOAD LENGTH OF BLOCK
         AR    GR1,GR3            POINT PAST BLOCK
         ST    GR1,PNOTHEN(,GR3)  SAVE END OF BLOCK ADDR IN RESTORABLE
*                                 FIELD FOR COMPARES
         LA    GR1,PATS(,GR3)     POINT TO FIRST PATTERN ELEMENT
*
*        LOOP THROUGH PATTERN ELEMENTS
*
PBLOKP0  TM    PFLAGS(GR1),PRELOC2          IS EITHER PARAM RELOCATABLE
         BZ    PBLOKP2            SKIP IF NO RELOCATABLE PARAMETERS
         BM    PBLOKP1            SKIP IF PARAM 1 IS RELOCATABLE
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD
         BAL   GR2,PTRPROCP       CALL SPECIAL PATTERN EXPR PTR ROUTINE
         LA    GR1,4(,GR1)        BUMP PAST REST OF NODE
         B     PBLOKP3            AND MERGE WITH END OF BLOK CHECK
*
*        COME HERE WHEN PARAMETER ONE IS RELOCATABLE
*
         CNOP  0,4                ALLIGN PTRPROC CALL TO FULLWORD
PBLOKP1  LA    GR1,PARAM1(,GR1)   POINT TO RELOCATABLE PARAMETER
         BAL   GR2,PTRPROC        PROCESS IT
         SH    GR1,=Y(PARAM1)     RESTORE ELEMENT POINTER
*
*        COME HERE TO SKIP PAST NODE
*
PBLOKP2  TM    PFLAGS(GR1),PARM1+PARM2      TEST NUMBER OF PARAMS
         BZ    *+16               SKIP IF NONE
         BM    *+8                SKIP IF ONE
         LA    GR1,4(,GR1)        BUMP GR1 FOR PARAM2
         LA    GR1,4(,GR1)        BUMP GR1 FOR PARAM1
         LA    GR1,PARAM1(,GR1)   BUMP GR1 FOR REST OF BLOCK
*
*        COME HERE TO TEST FOR BLOK COMPLETELY PROCESSED
*
PBLOKP3  C     GR1,PNOTHEN(,GR3)  ARE WE AT END OF BLOCK?
         BL    PBLOKP0            LOOP BACK IF NOT
         L     GR1,=A(NOTHEN)     GET VALUE IN DESTROYED WORD
         ST    GR1,PNOTHEN(,GR3)            AND RESTORE THE WORD
         LA    R2,PBLOK           GET BLOCK CODE FOR RESTORE
         B     PTRPOP             ELSE EXIT
*
*        THIS IS A CHECK TO MAKE SURE THAT PTRPROC CALLS ARE MADE
*        WITH VALID RETURN ADDRESS (SEE PTRPROC)
*        IF THIS TEST FAILS, THE SPACE BETWEEN THE FIRST AND
*        LAST PTRPROC CALLS MUST BE REDUCED (MOVE PTRPROC ROUTINE)
*        OR ALLIGN PTRPROC CALLS TO A DOUBLE WORD BOUNDARY
*
         LA    R0,GCOLBASE+4*255-*          ALL CALLS MUST BE SAVEABLE
*                                           IN ONE BYTE
         ORG   *-4                GET RID OF GARBAGE CODE
         EJECT
*
*        PASS 1
*        ------
*
*        PTRPROC -- ROUTINE TO PROCESS A RELOCATABLE POINTER
*
*        PTRPROCV -- PROCESSES ONLY IF RELOCBIT IS TURNED ON
*
*        PTRPROCS -- PROCESSES ONLY IF THE BLOCK IS ALREADY IN USE
*
*        THIS ROUTINE IS RECURSIVE AND SAVES THREE ITEMS OVER EACH
*        CALL, ALTHOUGH NO STACK IS USED. THE FINAL RESULT OF ALL
*        CALLS TO PTRPROC IS A BACKCHAIN OF REFERENCES TO EACH BLOCK
*        IN FREE CORE CHAINED FROM THE GARBAGE COLLECTION FIELD.
*        THE END OF THE CHAIN IS INDICATED BY THE LOW ORDER BIT
*        (BIT POSITION 31) BEING TURNED ON.
*
*        THE VALUES SAVED OVER CALLS ARE THE ADDRESS FIELDS (RIGHTMOST
*        THREE BYTES) OF GR1 AND GR3, AND THE CALLER'S ADDRESS AS
*        INDICATED BY THE VALUE IN GR1. ALL OF THESE ITEMS MUST BE
*        MULTIPLES OF FOUR. ADDITIONALLY (GR2-RETURN) MUST NOT
*        EXCEED 1020 (= 4*255).
*
*        ON EXIT, THE RIGHT HAND THREE BYTES OF GR1 & GR3 ARE RESTORED,
*        WITH THEIR LEFT BYTES SET TO ZERO. GR2 MAY NOT BE RESTORED,
*        BUT CONTROL IS ALWAYS RETURNED TO THE FULLWORD ADDRESS
*        INDICATED BY GR2 ON ENTRY. ALSO ON EXIT (AND ENTRY TO A
*        BLOCK PROCESSING ROUTINE), R2 HAS ITS LEFT THREE BYTES ZERO,
*        AND HENCE MAY BE USED FREELY FOR IC'S WITHOUT AN SR.
*        THE LEFT THREE BYTES OF (R2) MUST BE ZERO ON ENTRY TO PTRPROC.
*
*        WHEN A BLOCK IS FOUND THAT NEEDS PROCESSING (BACKCHAIN=0),
*        THE GR3 VALUE IS SAVED AT THE ADDRESS CONTAINED IN GR1
*        SINCE THIS IS THE END OF THE CHAIN. THE LOW ORDER BIT IS
*        SET ON TO IDENTIFY THE END OF THE CHAIN. GR2 IS SAVED BY CAL-
*        CULATING THE OFFSET FROM (RETURN) AND DIVIDING BY 4, LEAVING
*        AN EIGHT BIT VALUE. THE BLOCK TYPE CODE IS LOADED AND THE
*        CODED GR2 VALUE STORED IN ITS PLACE. THE PROPER BLOCK ROUTINE
*        IS THEN ENTERED.
*
*        ON EXIT FROM A BLOCK PROCESSING ROUTINE, (R2) MUST CONTAIN THE
*        PROPER BLOCK CODE FOR RESTORATION. PTRPOP LOADS THE START
*        OF THE BACKCHAIN AND FOLLOWS IT DOWN TILL IT FINDS THE END OF
*        THE CHAIN (BIT 31 TURNED ON). GR3 IS LOADED WITH THE FIELDS
*        CONTENTS (AFTER TURNING OFF THE FLAG BIT), AND GR1 IS LEFT
*        POINTING TO THE FIELD (ITS ORIGINAL VALUE ON ENTRY).
*        THE CODED 8-BIT VALUE OF GR2 IS THEN LOADED AND THE PROPER
*        BLOCK CODE RESTORED. CONTROL IS RETURNED TO THE CALLER BY
*        BRANCHING TO RETURN+4*(8-BIT CODE).
         EJECT
*
*        PASS 1 -- PTRPROC -- CONTINUED
*        ------------------------------
*
*        (R2)                     LEFT THREE BYTES ZERO
*        (GR1)                    POINTER TO FIELD TO BE PROCESSED
*        (GR3)                    INFORMATION TO BE SAVED OVER CALL
*                                 MUST BE MULTIPLE OF 4 AND NONZERO
*        BAL   GR2,PTRPROC(V,S)   (THIS CALL MUST BE FULLWORD ALLIGNED)
*
*        PTRPROCV -- ENTRY TO TEST RELOCBIT BEFORE PROCESSING
*
PTRPROCV TM    0(GR1),RELOCBIT    TEST FOR RELOCATABLE DATA CODE
         BCR   NO,GR2             IMMEDIATE RETURN IF NOT RELOCATABLE
         L     R1,0(,GR1)         LOAD POINTER TO BE PROCESSED
         NR    R1,MSK             CLEAR UPPER BYTE
         CR    R1,BOT             BELOW DYNAMIC AREA?
         BCR   L,GR2              RETURN IF SO (NOT RELOCATABLE)
         CR    R1,LIM             ABOVE DYNAMIC AREA?
         BCR   NL,GR2             RETURN IF SO (NOT RELOCATABLE)
         CLI   0(GR1),ECODE       IS THIS AN EXPRESSION PTR
         BNE   PTRPROCM           JUMP IF NOT TO MERGE
         B     PTRPROCE           ELSE JUMP TO SPECIAL EXPRESSION RTNE
*
*        NORMAL ENTRY POINT -- PTRPROC
*
PTRPROC  L     R1,0(,GR1)         LOAD POINTER TO BE PROCESSED
         NR    R1,MSK             REMOVE UPPER BYTE
         CR    R1,BOT             BELOW DYNAMIC AREA?
         BCR   L,GR2              RETURN IF SO
         CR    R1,LIM             ABOVE DYNAMIC AREA?
         BCR   NL,GR2             RETURN IF SO (NOT RELOCATABLE)
*
*        MERGE HERE FROM PTRPROCV ENTRY
*
PTRPROCM IC    R2,DTYPE(,R1)      LOAD BLOCK CODE
         L     R0,GCOLPTR(,R1)    LOAD BACKPOINTER CHAIN HEAD
         ST    GR1,GCOLPTR(,R1)   PUT THIS POINTER ON CHAIN
         NR    R0,MSK             STRIP BYTE, TEST IF CHAIN EXISTS?
         BZ    PTRPUSH            JUMP TO MAKE RECURSIVE CALL IF NOT
*
*        COME HERE IF BLOCK HAS ALREADY BEEN PROCESSED
*
         STC   R2,DTYPE(,R1)      RESTORE BLOCK CODE
         IC    R2,0(,GR1)         SAVE LEFT BYTE OF FIELD TO PROCESS
         ST    R0,0(,GR1)         COMPLETE BACK CHAIN
         STC   R2,0(,GR1)         RESTORE LEFT BYTE
         BR    GR2                RETURN TO CALLER
*
*        COME HERE WHEN AN UNPROCESSED BLOCK IS FOUND WHICH DOES NOT
*        CONTAIN ANY RELOCATABLE POINTERS
*
PTRPROC1 STC   R2,DTYPE(,R1)      RESTORE BLOCK CODE
         MVI   3(GR1),1           TURN ON END OF CHAIN BIT
         BR    GR2                RETURN TO CALLER
         EJECT
*
*        PASS 1 -- PTRPROC -- CONTINUED
*        ------------------------------
*
*        COME HERE WHEN AN UNPROCESSED BLOCK IS ENCOUNTERED
*        (R1) POINTS TO THE BLOCK TO BE PROCESSED
*        (R2) CONTAINS THE BLOCK CODE OF THE BLOCK TO BE PROCESSED
*
PTRPUSH  CH    R2,=Y(HNRLBLOK)    DOES THIS BLOCK CONTAIN RELOC PTRS?
         BNH   PTRPROC1           NO CALL NEEDED IF NOT
         LA    GR3,1(,GR3)        ELSE SUPPLY END OF CHAIN BIT
         IC    R0,0(,GR1)         SAVE LEFT BYTE OF FIELD TO PROCESS
         ST    GR3,0(,GR1)        SAVE GR3 AT END OF CHAIN, SET END BIT
         STC   R0,0(,GR1)         RESTORE LEFT BYTE
         SR    GR2,RETURN         GET RETURN (GR2) VALUE AS OFFSET
         SRL   GR2,2              COMPRESS TO 8 BITS BY DIVISION BY 4
         STC   GR2,DTYPE(,R1)     SAVE 8 BIT CODED GR2 VALUE
         LR    GR3,R1             COPY BLOCK ADDRESS
         B     GTRATB(R2)         GO TO PROPER BLOCK PROCESSING ROUTINE
*
*        JUMP TABLE FOR BLOCK PROCESSING ROUTINES
*
GTRATB   EQU   *-IOBLOK           SET PROPER STARTING LOCATION
         B     IOBLOKP            INPUT/OUTPUT BLOCK
         B     ABLOKP             ARRAY BLOCK
         B     PDBLOKP            PROGRAM DEFINED DATATYPE BLOCK
         B     FFBLOKP            FIELD FUNCTION BLOCK
         B     PDFBLOKP           PROG DEFINED DATATYPE FUNCTION BLOCK
         B     PBLOKP             PATTERN BLOCK
         B     TBBLOKP            TABLE BLOCK
         B     TEBLOKP            TABLE ELEMENT BLOCK
         B     CBLOKP             CODE BLOCK
         B     TRBLOKP            TRACE BLOCK
         ORG   GTRATB+LTBLOK      POSITION LAST ENTRY
         B     LTBLOKP            LABEL TRACE BLOCK
         EJECT
*
*        PASS 1 -- PTRPROC -- CONTINUED
*        ------------------------------
*
*        ENTRY TO PROCESS A POINTER THAT NEEDS TO BE RELOCATED ONLY
*        IF SOME OTHER VALUE FIELD POINTS TO THE BLOCK AS WELL.
*        IF THE BLOCK IS NOT IN USE, THE POINTER IS SET TO ZERO.
*
PTRPROCS L     R1,0(,GR1)         LOAD BLOCK ADDRESS
         CE    ZR,0(,R1)          IS THERE A BACK CHAIN?
*                                 NOTE: THIS TEST WORKS EVEN IF R1=0
         BNE   PTRPROC            IF SO, OFF TO RELOCATE THIS POINTER
         STE   ZR,0(,GR1)         ELSE ZERO POINTER
         BR    GR2                AND RETURN
*
*        RETURN HERE TO POP STACK AFTER PROCESSING A BLOCK
*        (GR3) POINTS TO THE BLOCK JUST PROCESSED
*        (R2) POINTS TO THE BLOCK CODE FOR RESTORATION
*
PTRPOP   SR    GR2,GR2            CLEAR REGISTER TO RESTORE RETURN ADDR
         IC    GR2,DTYPE(,GR3)    LOAD 8-BIT CODED VALUE OF SAVED GR2
         STC   R2,DTYPE(,GR3)     RESTORE BLOCK CODE
         SLL   GR2,2              MULTIPLY BY FOUR TO GET OFFSET
         LR    GR1,GR3            POINT TO HEAD OF BACK CHAIN
*
*        LOOP TO MOVE DOWN TO END OF BACKCHAIN
*
PTRPOPL  L     GR1,0(,GR1)        MOVE TO NEXT ENTRY ON CHAIN
         TM    3(GR1),1           END OF CHAIN BIT ON?
         BNO   PTRPOPL            LOOP BACK IF NOT END OF CHAIN
         L     GR3,0(,GR1)        AT END OF CHAIN, RESTORE SAVED GR3
         NR    GR3,MSK            CLEAR UPPER BYTE OF GR3
         NR    GR1,MSK            CLEAR UPPER BYTE OF GR1
         BCT   GR3,0(RETURN,GR2)  RETURN TO CALLER, DELETE EOC FLAG
         EJECT
*
*        PASS 1 -- CONTINUED
*        -------------------
*
*        PTRPROCE -- SPECIAL ROUTINE TO PROCESS AN EXPRESSION POINTER
*        (ECODE) SUCH VALUES ARE PROCESSED AS LABEL POINTERS AND
*        CHAINED FROM GECHAIN THROUGH THEIR SECOND WORDS FOR
*        LATER PROCESSING IN PASS THREE (WHERE THE VALUE IS RELOCATED)
*
PTRPROCE L     R0,GECHAIN         LOAD CURRENT HEAD OF CHAIN
         ST    GR1,GECHAIN        STORE NEW CHAIN HEAD POINTER
         ST    R0,4(,GR1)         LINK TO CHAIN, MERGE PTRPROCL
*
*        PTRPROCL -- PROCESS POSSIBLE RELOCATABLE LABEL FIELD
*        THIS ROUTINE IS ALSO USED IN PASS 3
*
*        (GR1)                    POINTS TO FIELD TO BE PROCESSED
*        (GR3)                    NON-ZERO -- PASS 1, ZERO -- PASS 3
*        (LAST),(NEW)             MUST NOT BE CHANGED BY THIS CALL
*        CNOP  0,4                IF PASS1 CALL
*        BAL   GR2,PTRPROCL
*        (GR1)                    MODIFIED IF LTBLOK POINTER FOUND
*
PTRPROCL L     R1,0(,GR1)         LOAD POINTER
         NR    R1,MSK             STRIP UPPER BYTE
         CR    R1,BOT             BELOW DYNAMIC MEMORY?
         BCR   L,GR2              RETURN IF SO , NOT RELOCATABLE
         CR    R1,LIM             ABOVE DYNAMIC MEMORY?
         BCR   NL,GR2             RETURN IF SO, NOT RELOCATABLE
         MVI   LABRLFLG,1         ELSE SET SPECIAL LABEL FLAG
         CLI   0(R1),LTBLOK       ARE WE POINTING TO AN LTBLOK?
         BNE   PTRPRCL0           SKIP IF NOT TO PROCESS LABEL
*
*        HERE WE KNOW FIELD BEING PROCESSED CONTAINS AN LTBLOK PTR
*        OUR ACTION IS DETERMINED BY SETTING OF PASS1/3 SWITCH (GR3)
*
         LTR   GR3,GR3            TEST PASS SWITCH
         BZ    PTRPRC3L           SKIP IF PASS3
*
*        COME HERE FOR PASS1 PROCESSING OF LTBLOK POINTER
*        WE MODIFY (GR1) TO POINT TO LTLOC FIELD IN LTBLOK, THEN
*        PASS CONTROL TO PTRPROCM WHICH PROCESSES REMAINDER OF LTBLOK
*        IF THE LTBLOK HAS ALREADY BEEN PROCESSED, WE ARE DONE
*
         CE    ZR,GCOLPTR(,R1)    HAS THIS BLOCK BEEN PROCESSED?
         LA    GR1,LTLOC(,R1)     POINT TO LTLOC IN CASE IT HASN'T
         BZ    PTRPROCM           MERGE WITH PTRPROC IF NOT YET DONE
         BR    GR2                ELSE RETURN TO CALLER
*
*        COME HERE IN PASS3 TO SET NEW LTBLOK ADDRESS IN POINTER
*        AND PROCESS LTGOTO FIELD
*
PTRPRC3L MVC   1(3,GR1),LTLOC+1(R1)         MOVE IN NEW LTBLOK ADDRESS
         LA    GR1,LTGOTO(,R1)    POINT TO LABEL FIELD IN LTBLOK
         B     PTRPROCL           AND LOOP BACK TO PROCESS IT
         EJECT
*
*        PASS1 -- PTRPROCL -- CONTINUED
*        ------------------------------
*
*        HERE WE SEARCH AHEAD IN THE CODE FOR THE NEXT NOP INSTRUCTION
*        WHOSE SECOND HALFWORD CONTAINS AN OFFSET BACK TO THE
*        START OF THE CODE BLOCK SO THAT WE CAN PROCESS THE CODE BLOCK
*
*
*        SEVERAL CALLERS MERGE AT THIS POINT WITH GR1,GR2,GR3 SET AS
*        ABOVE, AND ALSO (R1) POINTING TO THE RELOCATABLE CODE
*
PTRPRCL0 BCTR  R1,0               ON ENTRY, BACKOFF R1
PTRPRCL1 TRT   1(256,R1),ZTBL     SCAN AHEAD FOR X'47' (NOP OPCODE)
         BNZ   PTRPRCL2           SKIP IF X'47' FOUND
         LA    R1,256(,R1)        ELSE PUSH POINTER
         B     PTRPRCL1           LOOP BACK TO KEEP SCANNING
*
*        COME HERE WHEN WE FIND AN X'47', IS IT A NOP INSTRUCTION?
*
PTRPRCL2 CLI   1(R1),X'00'        TEST FOR ZERO MASK FIELD
         BNE   PTRPRCL1           KEEP SCANNING IF NOT A NOP
*
*        COME HERE WITH (R1) POINTING TO THE NOP INSTRUCTION
*
         LH    R0,2(,R1)          LOAD HALFWORD OFFSET TO START OF BLK
         N     R0,=X'0000FFFF'    REMOVE POSSIBLE SIGN BITS
         AR    R0,R0              CONVERT HALFWORDS TO BYTES
         SR    R1,R0              POINT BACK TO START OF BLOCK
         LTR   GR3,GR3            TEST CASES
         BZ    PTRPRC33           SKIP IF CALL IS IN PASS 3
*
*        HERE IF IN PASS 1
*
         CE    ZR,0(,R1)          CODE BLOCK ALREADY PROCESSED?
         BCR   NZ,GR2             RETURN TO CALLER IF SO
*
*        IF BLOCK HAS NOT BEEN PROCESSED, SET BACK PTR TO CODNLOC FIELD
*
         LA    R0,CODNLOC(,R1)    POINT TO CODNLOC FIELD
         ST    R0,GCOLPTR(,R1)    STORE AS HEAD OF BACK CHAIN
         MVI   DTYPE(R1),CBLOK    RESTORE BLOCK CODE
         MVI   CODNLOC+3(R1),1    SET END OF CHAIN BIT
         BR    GR2                RETURN TO CALLER
*
*        HERE IF IN PASS 3
*
PTRPRC33 L     R0,CODNLOC(,R1)    LOAD NEW LOCATION
         LA    R1,0(,R1)          STRIP POSSIBLE UPPER BYTE
         SR    R0,R1              CALCULATE RELOCATION FACTOR
         A     R0,0(,GR1)         RELOCATE LABEL POINTER
         ST    R0,0(,GR1)         STORE RELOCATED VALUE
         BR    GR2                RETURN TO CALLER
         EJECT
*
*        PASS 1 -- PTRPROC -- CONTINUED
*        ------------------------------
*
*
*        PTRPROCP -- SPECIAL ROUTINE FOR RELOCATABLE EXPRESSION PTR
*        IN PATTERN NODE (PARAM2). SUCH A POINTER IS PROCESSED AS A
*        LABEL AND ALSO THE ENTRIES ARE CHAINED FROM GPCHAIN THROUGH
*        THE PARAM1 FIELD WHICH IS ALWAYS AVAILABLE IN THIS CASE.
*
PTRPROCP L     R1,PARAM2(,GR1)    POINT TO CODE LOCATION
         NR    R1,MSK             CLEAR UPPER BYTE
         CR    R1,BOT             BELOW DYNAMIC MEMORY?
         BL    PTRPRCP1           SKIP IF SO (NOT RELOCATABLE)
         CR    R1,LIM             ABOVE DYNAMIC MEMORY?
         BNL   PTRPRCP1           SKIP IF SO (NOT RELOCATABLE)
*
*        HERE WE HAVE A RELOCATABLE EXPRESSION POINTER
*
         L     R0,GPCHAIN         LOAD CURRENT HEAD OF CHAIN
         ST    GR1,GPCHAIN        STORE NEW HEAD OF CHAIN
         ST    R0,PARAM1(,GR1)    LINK THIS BLOCK TO REST OF CHAIN
         LA    GR1,PARAM2(,GR1)   POINT TO PARAM2
         B     PTRPRCL0           MERGE INTO PTRPROCL
*
*        HERE IF POINTER IS NOT RELOCATABLE
*
PTRPRCP1 LA    GR1,PARAM2+4(,GR1) POINT PAST THIS NODE
         B     PBLOKP3            MERGE BACK INTO PBLOK ROUTINE
         EJECT
*
*        PASS 2
*        ------
*
PASS2    LA    LAST,PASS3S        INITIALIZE CHAIN OF BLOCKS IN USE
         STE   ZR,PASS3S          ZERO IN CASE NOTHING ANYWHERE
         L     OLD,DYNAMB         LOAD START OF DYNAMIC STORAGE
         LR    NEW,OLD            INITIALIZE POINTER TO NEW BLOCKS
         MVI   0(FR),SBLOK+1      END OF FREE CORE MUST NOT BE SBLOK
*
*        LOOP THROUGH ALL BLOCKS IN STORAGE
*
PASS2L   SR    R2,R2              CLEAR FOR IC AND GETLENGTH CALL
         IC    R2,DTYPE(,OLD)     GET BLOCK TYPE
         EX    0,BLOKLEN(R2)      LOAD BLOCK LENGTH INTO R2
         L     R1,GCOLPTR(,OLD)   LOAD GARBAGE COLLECT FIELD
         NR    R1,MSK             REMOVE BLOCK CODE
         BNZ   PASS2LU            SKIP IF THE BLOCK IS IN USE
         CLI   DTYPE(OLD),CBLOK   IS BLOCK BEING FREED CODE?
         BNE   PASS2C             SKIP IF NOT
*
*        HERE WE ARE FREEING A CODE BLOCK, RETURN THE 32 BYTE BLOCKS
*        OF CONSTANTS IT USED TO THE FREELIST (SEE FIND8 FOR DETAILS)
*
         L     R1,CODECCHN(,OLD)  LOAD POINTER TO HEAD OF LIST
         LTR   GR2,R1             ANY BLOCKS REFERENCED? (+ MOVE PTR)
         BZ    PASS2C             SKIP IF NOT
*
*        IF THERE ARE BLOCKS, POINT (GR2) TO LAST BLOCK ON CHAIN
*
         BAL   GR1,*+8            SET LOOP ADDR & JUMP INTO LOOP
         L     GR2,0(,GR2)        POINT TO NEXT BLOCK
         STE   ZR,8(,GR2)         CLEAR CONSTANTS IN BLOCK
         STE   ZR,16(,GR2)        . . . .
         STE   ZR,24(,GR2)        . . . .
         CE    ZR,0(,GR2)         END OF CHAIN?
         BCR   NZ,GR1             LOOP BACK IF NOT
*
*        NOW LINK THE CHAIN OF BLOCKS INTO THE FREELIST
*
         L     R0,CONSCHAN        CURRENT CHAIN POINTER
         ST    R0,0(,GR2)         LINK TO END OF NEW CHAIN
         ST    R1,CONSCHAN        SET NEW HEAD TO POINT TO THIS CHAIN
         B     PASS2C             SKIP (BLOCK IS NOT IN USE)
*
*        HERE FOR BLOCK WHICH IS IN USE
*
PASS2LU  IC    R0,DTYPE(,LAST)    SAVE BLOCK CODE IN LAST BLOCK
         ST    OLD,GCOLPTR(,LAST) SAVE POINTER TO NEXT BLOCK IN USE
         STC   R0,DTYPE(,LAST)    RESTORE BLOCK TPE IN LAST BLOCK
         LR    LAST,OLD           UPDATE CHAIN ADDRESS OF BLOCKS IN USE
         LR    R0,R2              COPY LENGTH IN CASE NOT SBLOK
         EJECT
*
*        AT THIS POINT WE TEST FOR THE FOLLOWING SPECIAL CASE --
*
*        DUE TO THE WAY IN WHICH SUB-STRINGS ARE CREATED -- IT IS
*        POSSIBLE TO HAVE SBLOKS IN STORAGE WHICH ARE ONLY PARTLY IN
*        USE.  DEALING WITH THIS SITUATION FULLY REQUIRES A SLOW
*        PROCEDURE AND IS THEREFORE DONE ONLY WHEN NECESSARY (ON
*        COLLECT CALLS AND WHEN A GBGCL CALL DOES NOT CREATE ENOUGH
*        SPACE)
*
*
*        WHEN THE FLAG GCMPRSS IS SET ON IN GCOLNRG THE FOLLOWING
*        PROCEDURE IS USED.
*
*        SBLOKS FOUR WORDS OR SHORTER ARE LEFT AS THEY ARE
*        FOR LONGER SBLOKS (EXCEPT THOSE WITH ONLY ONE BACKPOINTER)
*        A NEW CHAIN IS CONSTRUCTED WHICH IS SORTED BY OFFSET
*        AFTER FORMING THE CHAIN A PASS IS MADE DOWN IT TO MOVE USED
*        PORTIONS OF THE STRING TOWARD THE FRONT OF THE BLOCK,
*        RELOCATING OLD OFFSET FIELDS AS NECESSARY. USED CHARACTERS
*        ARE DETERMINED AS FOLLOWS -
*        INITIALIZE COLD TO THE OFFSET OF THE LOWEST USED PIECE
*        AND CLIM TO COLD+SLENGTH+1, I.E. THE EQUIVALENT OFFSET ADDRESS
*        JUST PAST THE LAST USED CHARACTER.  COFF IS SET TO THE NUMBER
*        OF CHARACTERS OF GARBAGE AHEAD OF COLD.  CNEW POINTS TO THE
*        NEXT POSITION TO MOVE CHARACTERS, AND HENCE IS INITIALIZED
*        TO OLD.  (COFF = COLD+OLD-CNEW)
*        MOVE DOWN THE CHAIN EXAMINING OFFSETS.  IF CLIM EQUALS OR
*        EXCEEDS THE OFFSET THEN THE SUBSTRING IS INCLUDED IN OR
*        ADJACENT TO THE CURRENT STRING OF CHARACTERS BEING ACCUMULATED
*        FOR A MOVE.  IF CLIM IS LESS THAN THE NEXT OFFSET THEN THERE
*        IS A GAP TO BE ELIMINATED.  THE ACCUMULATED STRING
*        OF GOOD CHARACTERS IS MOVED FORWARD FROM (COLD+OLD) TO (NEW)
*        ITS REAL LENGTH IS (CLIM-COLD) (NOTE THAT MVC LOOP USES REAL
*        LENGTH AND HENCE MOVES AN EXTRA CHARACTER, CAUSING NO HARM)
*        THEN CNEW IS UPDATED PAST MOVED CHARACTER, AND COLD, ETC.
*        ARE SET UP AS AT INITIALIZATION USING THE CURRENT POINTER
*        AS THE CHAIN HEAD.
*        WHEN CLIM >= OFFSET, A CHECK IS MADE OF CLIM VS OFFSET+LENGTH
*        IF CLIM IS NOT GREATER, THEN NEW CHARACTERS ARE BEING ADDED
*        BY THIS POINTER, SO CLIM IS SET TO OFFSET+LENGTH(360)+1
*        CHAIN END IS MARKED BY THE RIGHTMOST BIT BEING ON, WITH THE
*        NEXT LEFT BIT BEING USED TO SIGNAL END WHEN LOOP IS USED
*        FOR THE FINAL CHARACTER MOVE(AND IS TURNED OFF AFTER USE)
*
*        AN ADDITIONAL OPTIMIZATION INVOLVES THE COMBINING OF ADJACENT
*        SBLOK'S IN FREE CORE IF THE COMBINED LENGTH IS LESS THAN 32K
*        THIS IS DONE BY CHECKING THE NEXT BLOCK TO SEE IF IT IS AN
*        SBLOK.  IF SO, ADD ITS POINTERS (IF ANY) TO THE HEAD OF THE
*        CHAIN OF THE ORIGINAL SBLOK TO SPEED SORTING.  THE POINTERS
*        FROM THE ATTACHED SBLOK MUST HAVE THEIR OFFSET INCREASED BY
*        THE LENGTH OF THE SBLOK PRECEEDING IT
*
         EJECT
         TM    GCOLNRG,GCMPRSS    IS THIS A DESPERATE COLLECT?
         BNO   PASS2RL            SKIP THIS ROUTINE IF NOT
         CLI   DTYPE(OLD),SBLOK   IS THIS AN SBLOK?
         BNE   PASS2RL            NOTHING SPECIAL IF NOT
*
*        THIS LOOP ATTACHES SUBSEQUENT SBLOKS TO THE FIRST SBLOK
*
PASS2SBS LA    GR1,0(R2,OLD)      GET ADDRESS OF BLOCK PAST THIS SBLOK
         CLI   0(GR1),SBLOK       IS NEXT ITEM AN SBLOK?
         BNE   PASS2SBT           ALL DONE WITH SBLOK COMBINE IF NOT
         LR    GR2,R2             COPY LENGTH OF OLD SBLOK
         SLL   GR2,16             POSITION IN OFFSET FIELD
         AH    R2,STLENGTH(,GR1)  GET LENGTH OF POTENTIAL NEW SBLOK
         CH    R2,=X'7FFF'        CHECK AGAINST MAXIMUM POSSIBLE
         BH    PASS2SBT           ALL DONE WITH COMBINE IF GE 32K
         STH   R2,STLENGTH(,OLD)  STORE LENGTH OF NEW SBLOK
         CE    ZR,GCOLPTR(,GR1)   IS ANYTHING CHAINED TO NEW SBLOK?
         BE    PASS2SBS           NO POINTER PROCESSING IF NOT
         LR    GR3,GR1            COPY ADDRESS OF NEW SBLOK PART
*
*        THIS LOOP MOVES OUT ON CHAIN ATTACHED TO NEW SBLOK PART
*        UPDATING THE OFFSET FIELD BY LENGTH OF OLD SBLOK
*
PASS2SBL L     GR3,0(,GR3)        MOVE OUT ON CHAIN
         L     R0,4(,GR3)         LOAD OFFSET/LENGTH WORD
         AR    R0,GR2             INCREMENT OFFSET PORTION
         ST    R0,4(,GR3)         STORE UPDATED OFFSET/LENGTH
         TM    3(GR3),1           IS THIS END OF CHAIN?
         BZ    PASS2SBL           LOOP BACK IF NOT END OF CHAIN
*
*        NOW LINK POINTERS FROM COMBINED BLOCK TO ORIGINAL CHAIN
*
         ST    R1,0(,GR3)         ADD OLD CHAIN AT END OF NEW CHAIN
         MVI   0(GR3),SCODE       MAKE SURE IT HAS AN SCODE
         L     R1,GCOLPTR(,GR1)   LOAD NEW HEAD OF CHAIN ADDRESS
         ST    R1,GCOLPTR(,OLD)   SAVE A COPY OF IT IN SBLOK
         B     PASS2SBS           LOOP BACK TO FIND MORE SBLOKS
*
*        COME HERE WHEN SBLOK COMBINATION IS COMPLETE
*        REGISTERS R0 AND R2 MUST BE RESET TO SBLOK LENGTH
*
PASS2SBT LH    R2,STLENGTH(,OLD)  RESTORE R2 = SBLOK SIZE
         LR    R0,R2              AND COPY IT INTO R0
         CH    R2,=H'16'          IS IT LONGER THAN 16 CHARACTERS?
         BNH   PASS2RL            NOT WORTH THE TROUBLE IF NOT
         TM    3(R1),1            LOOK FOR END OF CHAIN FLAG
         BO    PASS2SB4           CHAIN ALREADY BUILT IF ONE MEMBERED
         MVI   DTYPE(OLD),SCODE   FIX UP BLOCK SO NO IC, STC NEEDED
         SR    R2,R2              INITIALIZE COUNT OF NEW CHAIN MEMBERS
         L     GR1,0(,R1)         POINT TO 2ND CHAIN MEMBER
         MVI   3(R1),1            SET OFFICIAL CHAIN END IN NEW CHAIN
         EJECT
*
*        COME HERE TO MOVE OUT ON ORIGINAL CHAIN
*
PASS2SB1 LH    R0,SOFFSET(,GR1)   LOAD OFFSET OF ELEMENT NEEDING PLACE
         LR    GR2,OLD            GET FIRST BLK ADDR, SORTED CHAIN
         L     GR3,GCOLPTR(,GR2)  GET POINTER TO FIRST BLK W/OFFSET
         LA    R1,1(,R2)          COPY COUNT+1 OF CHAIN ITEMS
         LR    R2,R1              SAVE AS NEW COUNT
*
*        LOOP TO FIND PLACE ON SORTED CHAIN FOR NEW ELEMENT
*
PASS2SB2 CH    R0,SOFFSET(,GR3)   COMPARE OFFSETS
         BNH   PASS2SB3           FOUND PLACE IF NEW <= OLD
         LR    GR2,GR3            UPDATE 1 BACK POINTER
         L     GR3,0(,GR2)        MOVE OUT ON CHAIN
         BCT   R1,PASS2SB2        LOOP UNLESS END OF SORTED CHAIN
*
*        COME HERE TO INSERT ELEMENT INTO SORTED CHAIN
*
PASS2SB3 ST    GR1,0(,GR2)        LINK INTO CHAIN BEFORE CMPRD OFFSET
         LR    GR2,GR1            SAVE ADDRESS OF NEW POINTER
         TM    3(GR1),1           TEST FOR END OF CHAIN
         L     GR1,0(,GR1)        MOVE OUT ON UNSORTED CHAIN
         ST    GR3,0(,GR2)        COMPLETE LINK IN OF NEW POINTER
         BNO   PASS2SB1           GET NEXT POINTER IF NOT END OF CHAIN
         MVI   DTYPE(OLD),SBLOK   FIX UP BLOCK CODE
         EJECT
*
*        COME HERE WITH SORTED CHAIN SET UP
*
PASS2SB4 LA    R0,256             GET VITAL CONSTANT
         L     R2,GCOLPTR(,OLD)   GET ADDRESS OF FIRST CHAIN MEMBER
         LR    CNEW,OLD           FIRST MOVED CHARS TO START OF BLOCK
         SR    CLIM,CLIM          MAKE SURE CLIM VALUE UPDATED
         LH    R1,SOFFSET(,R2)    POINT TO FIRST SAVED CHARACTERS
         B     PASS2SBE           AND MAKE ENTRY TO FIX POINTERS
*
*        COME HERE TO MOVE OUT ON CHAIN AND EXAMINE NEW OFFSET
*
PASS2SBA L     R2,0(,R2)          GET ADDRESS OF NEXT POINTER
         LH    R1,SOFFSET(,R2)    LOAD OFFSET FOR THIS POINTER
         CR    CLIM,R1            IS FIELD ALREADY INCLUDED?
         BNL   PASS2SBF           OFF TO RELOCATE OFFSET IF SO
*
*        COME HERE TO MOVE A GROUP OF USED CHARACTERS FORWARD IN BLOCK
*
PASS2SBB LTR   COFF,COFF          NO MOVE NEEDED IF OFFSETDIF=0
         BZ    PASS2SBD+4         JUST UPDATE CNEW IF CHARS IN POSITION
         SR    CLIM,COLD          GET REAL LENGTH OF CHARACTERS TO MOVE
         AR    COLD,OLD           GET ACTUAL FROM ADDRESS
         CR    CLIM,R0            CAN WE DO IT IN ONE MOVE?
         BL    PASS2SBD           SKIP IF POSSIBLE
*
*        LOOP TO MOVE DOWN 256 CHARACTERS AT A TIME
*
PASS2SBC MVC   SCHARS(256,CNEW),SCHARS(COLD)          MOVE BLOCK OF CHA
         AR    CNEW,R0            PUSH 'TO' POINTER
         AR    COLD,R0            PUSH 'FROM' POINTER
         SR    CLIM,R0            DECREMENT LENGTH LEFT
         CR    CLIM,R0            SMALL ENOUGH FOR ONE MVC?
         BNL   PASS2SBC           LOOP BACK IF NOT
*
*        COME HERE TO MOVE LAST (<=256) CHUNK OF CHARACTERS
*
PASS2SBD EX    CLIM,PASS2SBM      DO VARIABLE LENGTH MVC
         AR    CNEW,CLIM          BUMP NEW CHAR ADDR PAST LAST CHAR
*
*        COME HERE TO SET UP POINTERS FOR NEXT BLOCK IN USE
*
PASS2SBE LR    COLD,R1            SET OFFSET OF USED CHARACTERS
         LA    COFF,0(COLD,OLD)   GET ADDRESS OF USED CHARACTERS
         SR    COFF,CNEW          GET OFFSET TO NEW LOCATION
         EJECT
*
*        COME HERE TO RELOCATE OFFSET FIELD AND MAKE SURE ALL
*        USED CHARACTERS ARE COVERED BY CLIM
*
PASS2SBF SR    R1,COFF            SUBTRACT NO. OF DELETED CHARACTERS
         STH   R1,SOFFSET(,R2)    STORE AS NEW OFFSET
         AR    R1,COFF            RESTORE CURRENT OFFSET
         AH    R1,SLENGTH(,R2)    ADD IN 360 LENGTH OF PTR
         CR    CLIM,R1            CLIM MUST BE > SINCE 360 LEN USED
         BH    *+8                SKIP IF ALL CHARS ARE INCLUDED
         LA    CLIM,1(,R1)        ELSE GET PROPER CLIM
         TM    3(R2),1            IS THIS END OF CHAIN?
         BNO   PASS2SBA           LOOP BACK IF NOT
         XI    3(R2),2            SET OR UNSET SPECIAL END FLAG
         LH    R1,SOFFSET(,R2)    SAVE LAST OFFSET OVER MVC CALL
         TM    3(R2),2            IS FLAG SET TO DO LAST MVC?
         BO    PASS2SBB           SKIP IF SO, R1 SET FOR NO RELOCATION
         STH   COLD,SOFFSET(,R2)  RESTORE CORRECT OFFSET SAVED BEFORE
         LA    R0,SCHARS+BOUND(,CNEW)       GET ADDRSS PAST NEW SBLOK
         N     R0,FULLWRD         PUT AT FULLWORD ADDRESS
         SR    R0,OLD             GET LENGTH OF NEW SBLOK
         LH    R2,STLENGTH(,OLD)  RESTORE OLD BLOCK LENGTH
         STH   R0,STLENGTH(,OLD)  STORE NEW BLOCK LENGTH
         L     R1,GCOLPTR(,OLD)   RESTORE INITIAL POINTER TO REFERENCES
*
*        LOOP TO RELOCATE POINTERS POINTING TO THIS BLOCK
*
PASS2RL  TM    3(R1),1            TEST FOR END OF CHAIN
         L     GR1,0(,R1)         LOAD NEXT LINK ENTRY
         IC    GR2,0(,R1)         SAVE UPPER BYTE
         ST    NEW,0(,R1)         STORE NEW POINTER VALUE
         STC   GR2,0(,R1)         RESTORE UPPER BYTE
         LR    R1,GR1             UPDATE POINTER TO NEXT LINK
         BNO   PASS2RL            BACK TO RELOC NXT FLD IF NOT CHN END
         AR    NEW,R0             UPDATE 'NEW' POINTER
*
*        REENTER HERE FOR BLOCK NOT IN USE
*
PASS2C   AR    OLD,R2             UPDATE CURRENT POINTER
         CR    OLD,LIM            ALL DONE?
         BL    PASS2L             LOOP BACK IF NOT
         IC    R2,DTYPE(,LAST)    ELSE SAVE BLOK CODE ON LAST BLOCK
         STE   ZR,GCOLPTR(,LAST)  SET ZERO FOR END OF CHAIN
         STC   R2,DTYPE(,LAST)    RESTORE BLOK CODE
         B     PASS3              SKIP TO PASS 3
PASS2SBM MVC   SCHARS(*-*,CNEW),SCHARS(COLD)
         EJECT
*
*        PASS 3
*        ------
*
*        RELOCATE RELOCATABLE CODE POINTERS IF ANY
*
*        AT THIS STAGE, PASS 2 HAS PROCESSED ANY CODE BLOCKS FOUND
*        TO BE IN USE DURING PASS 1. THUS THE CODNLOC FIELD OF EACH
*        CODE BLOCK CORRECTLY INDICATES ITS NEW LOCATION AND PROVIDES
*        THE NECCESSARY INFORMATION FOR RELOCATION. THE ACTUAL
*        RELOCATION IS PERFORMED IN THE PTRPROCL ROUTINE WITH GR3=0
*
*        INITIALIZE TO PROCESS ECODE VALUES ON GECHAIN
*
PASS3    L     LAST,GECHAIN       LOAD PTR TO FIRST ECODE ON CHAIN
         L     BOT,DYNAMB         RELOAD START OF MEMORY ADDRESS
         SR    GR3,GR3            INDICATE PASS3 FOR PTRPROCL
         B     PASS3B             MERGE INTO LOOP
*
*        LOOP THROUGH ENTRIES ON GECHAIN
*
PASS3L1  L     R1,0(,GR1)         LOAD EXPRESSION POINTER
         L     LAST,4(,GR1)       LOAD LINK POINTER TO NEXT ECODE
         BAL   GR2,PTRPRCL0       PROCESS EXPR PTR (MUST BE RELOC HERE)
*
*        HERE TO MOVE OUT ON CHAIN (MERGE HERE FIRST TIME)
*
PASS3B   LTR   GR1,LAST           MOVE OUT AND TEST FOR END OF CHAIN
         BNZ   PASS3L1            LOOP BACK IF MORE TO GO
*
*        INITIALIZE PROCESSING OF PATTERN EXPR PTRS ON CPCHAIN
*
         L     LAST,GPCHAIN       LOAD HEAD OF CHAIN
         B     PASS3C             JUMP INTO LOOP
*
*        LOOP THROUGH ENTRIES ON GPCHAIN
*
PASS3L2  L     R1,PARAM2(,GR1)    LOAD EXPR POINTER FOR PTRPROCL
         L     LAST,PARAM1(,GR1)  LOAD FORWARD LINK POINTER
         LA    GR1,PARAM2(,GR1)   POINT TO FIELD TO RELOCATE
         BAL   GR2,PTRPRCL0       MERGE INTO PTRPROCL
*
*        HERE TO MOVE OUT ON CHAIN, MERGE HERE FIRST TIME THROUGH
*
PASS3C   LTR   GR1,LAST           MOVE OUT ON CHAIN AND TEST FOR END
         BNZ   PASS3L2            LOOP BACK IF MORE TO GO
*
*        THE REMAINING SECTION NEED ONLY BE DONE IF THE SPECIAL
*        LABEL RELOCATE FLAG HAS BEEN SET (SEE PTRPROCL)
*
         CLI   LABRLFLG,0         ANY LABEL PTRS TO RELOCATE?
         BZ    PASS4              ALL DONE WITH PASS 3 IF NOT
         L     LAST,HASHTBAD      POINT TO VARIABLE BLOCK HASH TABLE
         EJECT
*
*        PASS 3 -- CONTINUED
*        -------------------
*
*        LOOP THROUGH SLOTS IN HASH TABLE
*
PASS3L   L     NEW,VLINK(,LAST)   POINT TO FIRST VAR BLOCK ON CHAIN
*
*        LOOP THROUGH VARIABLE BLOCKS ON ONE CHAIN
*
PASS3LL  NR    NEW,MSK            STRIP UPPER BYTE AND TEST
         BZ    PASS3E             SKIP IF END OF THIS CHAIN
         LA    GR1,VLABL(,NEW)    ELSE POINT TO LABEL FIELD
         BAL   GR2,PTRPROCL       PROCESS IT
         L     NEW,VLINK(,NEW)    MOVE OUT ON CHAIN
         B     PASS3LL            LOOP BACK
*
*        HERE TO MOVE TO NEXT HASH SLOT
*
PASS3E   LA    LAST,4(,LAST)      POINT TO NEXT SLOT
         C     LAST,HASHTBEN      MORE SLOTS TO GO?
         BL    PASS3L             LOOP BACK IF SO
*
*        NOW PROCESS CODE POINTERS ON MAIN STACK (PDR)
*
         L     PDR,PDRLOC         RESET STACK POINTER TO TOP LEVEL
*
*        LOOP THROUGH LEVELS OF STACK, SEE PASS 1 FOR EXPLANATION
*        OF THE INTERPRETAION OF THE FBLOKLOK AND EVLINK FIELDS
*
PASS3SL  L     R0,FBLOKLOC(,PDR)  LOAD FUNCTION BLOCK POINTER
         LTR   R0,R0              TEST IT
         BP    PASS3F             SKIP IF FUNCTION ON THIS LEVEL
         BM    PASS13SL           AT STACK END, PROCESS SPECIAL LOCS
         TM    EVLINK(PDR),X'30'  IF UNEVAL EXPR, TEST CONDITION CODE
         BNZ   PASS3F             SKIP IF EVAL FUNCTION CALL
*
*        HERE WE HAVE A PATTERN MATCH ON THE PREVIOUS LEVEL
*
         L     PDR,PDRBPTR(,PDR)  POP PDR TO PATTERN LEVEL
         LA    GR1,RETLOCP(,PDR)  POINT TO RETURN SAVE LOC
         BAL   GR2,PTRPROCL       PROCESS IT
         LA    GR1,FRETLOCP(,PDR) POINT TO FRETURN SAVE LOC
         BAL   GR2,PTRPROCL       PROCESS IT
         B     PASS3SL            LOOP BACK FOR NEXT STACK LEVEL
*
*        HERE WE HAVE A FUNCTION CALL
*
PASS3F   LA    GR1,RETFLOC(,PDR)  POINT TO SAVED VALUE OF (RETURN)
         BAL   GR2,PTRPROCL       PROCESS IT
         LA    GR1,FRETFLOC(,PDR) POINT TO SAVED VALUE OF (FRETURN)
         BAL   GR2,PTRPROCL       PROCESS IT
         L     PDR,PDRBPTR(,PDR)  POINT TO PREVIOUS STACK LEVEL
         B     PASS3SL            LOOP BACK FOR NEXT LEVEL
         EJECT
*
*        PASS 4
*        ------
*
*        THIS IS THE PASS WHERE WE ACTUALLY MOVE THE BLOCKS
*
PASS4    L     NEW,DYNAMB         LOAD START OF DYNAMIC CORE
         L     OLD,PASS3S         INITIALIZE POINTER TO BLOCKS IN USE
         LA    GR2,256            GET CRANK CONSTANT
         B     PASS4M3            JUMP INTO LOOP
*
*        LOOP THROUGH RELOCATING BLOCKS
*
PASS4L   SR    R2,R2              CLEAR FOR IC, GETLENG CALL
         IC    R2,DTYPE(,OLD)     LOAD BLOCK TYPE
         L     GR1,GCOLPTR(,OLD)  LOAD POINTER TO NEXT BLOCK
         STE   ZR,GCOLPTR(,OLD)   CLEAR OUT GBGCOL FIELD
         STC   R2,DTYPE(,OLD)     RESTORE BLOCK CODE
         EX    0,BLOKLEN(R2)      GET LENGTH OF BLOCK IN R2
         CR    R2,GR2             TEST FOR SHORT (<=256 CHARACTERS)
         BL    PASS4M2            SKIP IF SHORT
*
*        LOOP TO MOVE LONG BLOCK IN 256-BYTE CHUNKS
*
PASS4LM  MVC   0(256,NEW),0(OLD)  MOVE 256-BYTE CHUNK
         AR    NEW,GR2            ADVANCE NEW BLOCK POINTER
         AR    OLD,GR2            ADVANCE OLD BLOCK POINTER
         SR    R2,GR2             DECREASE COUNT OF CHARACTERS LEFT
         CR    R2,GR2             TEST FOR LONG (>256 CHARACTERS LEFT)
         BNL   PASS4LM            LOOP BACK IF YES
*
*        REENTER HERE FOR SHORT BLOCK <= 256 CHARS
*
PASS4M2  EX    R2,PASS4MM         MOVE REMAINING CHARACTERS
         AR    NEW,R2             UPDATE NEW BLOCK POINTER
         LR    OLD,GR1            UPDATE OLD BLOCK IN USE POINTER
*
*        ENTER HERE FOR FIRST BLOCK
*
PASS4M3  NR    OLD,MSK            STRIP UPPER BYTE OF POINTER
         BNZ   PASS4L             LOOP BACK UNLESS ZERO (END OF CHAIN)
         C     LIM,CONCFRSV       CHECK CONCAT SAVEAREA PTR FOR HERE
         STE   ZR,CONCFRSV        ZERO IN CASE OF NE
         BNE   *+8                SKIP IF NOT EQUAL
         ST    NEW,CONCFRSV       ELSE UPDATE IT
         C     LIM,PCFRSAVE       CHECK FOR COLLECT FROM PAT BUILDER
         BNE   *+8                SKIP IF NOT IN MIDDLE OF PAT BUILD
         ST    NEW,PCFRSAVE       ELSE STORE NEW FREE CORE ADDRESS
         L     OLD,GCOLSV+4*FR    LOAD OLD FR VALUE
         ST    NEW,GCOLSV+4*FR    STORE NEW FR POINTER
         CLI   CLLCTFL,X'FF'      CHECK FOR COLLECT CALL
         BE    GCOLEXIT           SKIP SPACE CHECK IF SO, JUMP TO EXIT
         CR    NEW,OLD            SEE IF WE MADE SOME ROOM
         BNL   PASS4ERR           OUT OF CORE IF NO CHANGE
         EJECT
*
*
*        MERGE HERE FOR CASE OF CORE EMPTY ON ORIGINAL CALL
*
GCOLCHK  C     NEW,GCOLSV+4*PDR   IS OUR NEW CORE < PDR?
         BNL   PASS4ERR           OUT OF CORE IF NOT LOW
*
*        EXIT POINT
*
GCOLEXIT LM    0,15,GCOLSV        RESTORE ALL REGISTERS
         MVI   ZTBL+X'47',0       RESET ZTBL TO ZEROS
         BR    RETURN             AND RETURN TO CALLER
*
PASS4MM  MVC   0(*-*,NEW),0(OLD)  MOVE REMAINING CHARS OF BLOCK
*
*        COME HERE IF GARBAGE COLLECT DID NOT WORK (MEMORY OVERFLOW)
*
PASS4ERR LM    0,15,GCOLSV        RESTORE REGS IN CASE OF SETEXIT
         MVI   ZTBL+X'47',0       RESET ZTBL TO ZEROS
         XI    GCOLNRG,GCMPRSS    FLIP SETTING OF SPCL GBGCL BIT
         TM    GCOLNRG,GCMPRSS    TEST CURRENT SETTING
         BCR   O,R1               COLLECT AGAIN IF NOW SET TO COMPRESS
         XERR  06,001             OVERFLOW IN MAIN DYNAMIC STORAGE AREA
*
*        NOTE THAT AT THE CURRENT TIME, RECOVERY FROM THIS ERROR
*        IS NOT ALWAYS RELIABLE SINCE SOME ROUTINES BUILD ON FR BEFORE
*        CHECKING. IF THIS HAPPENS IN A LOOP, PDR DESTRUCTION OCCURS
         TITLE 'SPITBOLX -- INPUT-OUTPUT ROUTINES'
*
*        WRITE OUTPUTS ITS ARGUMENT OR DATATYPE NAME IF NOT A STRING
*
         USING *,A2+1             BASE REGISTER
WRITE    ST    RETURN,WRETLOC     SAVE RETURN LOCATION
         TM    VFLAGS(A2),VTRC    CHECK FOR VALUE TRACE
         BNO   WRITE0             SKIP IF NO TRACE
*
*        COME HERE IF WE HAVE A VALUE TRACE TO PERFORM
*
         ST    DB4,PSTRING+4(,PDR)          SAVE BASE OVER TRACE CALL
         L     DB4,=A(DTERTNS)    GET TRACE ROUTINE BASE REGISTER
         B     VALTRACE-DTERTNS(,DB4)       CALL VALUE TRACE ROUTINE
*
*        COME HERE FOR ORDINARY WRITE CASE
*
WRITE0   CE    ZR,V$OUTPUT        HAS OUTPUT BEEN TURNED OFF?
         BE    WRITEX             B IF OFF
         BAL   RETURN,GETSTGS     CONVERT TO STRING
         BAL   RETURN,$$DTTP      GET DATATYPE NAME IF NOT CONVERTIBLE
         BALR  RETURN,0           ESTABLISH A NEW BASE REG
         USING *,RETURN           TELL ASSEMBLER
         DROP  A2+1               DROP OLD BASE, IT GETS CLOBBERED
         L     R1,VIOPTR(,A2)     LOAD POINTER TO FILE INFORMATION
         L     R0,OFILE(,R1)      LOAD INTERFACE FILE POINTER
         L     A2,OFORMAT(,R1)    GET FORMAT ADDRESS
         AH    A2,OFORMAT+SOFFSET(,R1)      ADD IN OFFSET
         LA    A2,SCHARS(,A2)     POINT TO FIRST CHARACTER
         LH    A2+1,OFORMAT+SLENGTH(,R1)    GET 360 LENGTH OF FORMAT
         LA    A2+1,1(,A2+1)      GET REAL LENGTH OF FORMAT
         CLI   OFORMAT(R1),NCODE  CHECK FOR NULL CASE
         BNE   *+6                SKIP IF NOT
         SR    A2+1,A2+1          IF NULL, SET LENGTH OF FORMAT = 0
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER OF STRING
         LA    A1+1,1(,A1+1)      GET REAL LENGTH OF STRING
         C     R0,PRINTDCB        SET CC FOR PRINTER/PUNCH IN CASE ERR
         L     R2,VOUTPUTS        LOAD ADDRESS OF OUTPUT ROUTINE
         BALR  R1,R2              CALL ROUTINE
         B     SYSERROR           JUMP TO SIGNAL ERROR ON ERROR RETURN
         LTR   R0,R0              CHECK FOR TOO MANY RECORDS WRITTEN
         BNZ   WRITEX             JUMP TO EXIT IF OK
         SPM   R1                 ELSE RECALL CC FROM PRINT/PUNCH CHECK
         BNE   *+8                SKIP IF PUNCH CASE, ELSE PRINT CASE
         XERR  11,001             PAGE LIMIT EXCEEDED
         XERR  11,002             CARD LIMIT EXCEEDED
*
*        MERGE HERE TO EXIT
*
WRITEX   L     RETURN,WRETLOC     RESTORE RETURN REGISTER
         BR    RETURN             AND RETURN TO CODE
*
VOUTPUTS DC    V(SYSWRITE)        ADDRESS OF OUTPUT ROUTINE
         DROP  RETURN             DROP BASE REG
         EJECT
*
*        PROCESSING ON READ CALL
*
*        THIS ROUTINE CHECKS FOR AN INPUT ASSOCIATION AND PERFORMS
*        ANY NECCESSARY INPUT OPERATION
*
         USING *,A2+1             OUR BASE REG
READ     LR    A2,A1              GET VARIABLE BLOCK PTR IN CORRECT REG
         CE    ZR,V$INPUT         HAS INPUT BEEN TURNED OFF?
         BE    READ4A             GET RESULT IF OFF
         TM    VFLAGS(A2),VINP+VINA         IS VAR INPUT ASSOCIATED?
         BNO   READ4A             GET RESULT IF NOT
*
*        COME HERE WHEN WE KNOW VARIABLE IS READ ASSOCIATED
*
         L     A1,VIOPTR(,A2)     GET POINTER TO IOBLOK
         L     R0,IFILE(,A1)      GET INTERFACE FILE POINTER
         L     R2,VSYSMAXL        GET ADDR OF INTERFACE ROUTINE TO GIVE
*                                 MAXIMUM POSSIBLE RECORD LENGTH
         BALR  R1,R2              AND CALL IT
         B     SYSERROR           GIVE ERROR MESSAGE IF COME HERE
         LR    R2,R0              COPY MAXIMUM RECORD LENGTH
*
*        COME HERE TO CHECK FOR COLLECT NEEDED
*
READ0A   LA    R1,SCHARS+BOUND(R2,FR)       GET FINAL FREE CORE ADDR
         CR    R1,PDR             WILL WE OVERFLOW?
         BL    READ0              SKIP IF NOT
*
*        COME HERE IF A GARBAGE COLLECTION IS REQUIRED. A SPECIAL
*        SITUATION ARISES WHEN READSAVE HAS SAVED THE VALUE OF A2,A2+1
*        IF THE READ CALL WAS PRECEDED BY LR A2,A1 LR A2+1,A1+1, THEN
*        IT MUST BE RELOCATED, OTHERWISE IT IS GARBAGE AND MUST NOT BE.
*
         ST    RETURN,RETLOC      SAVE RETURN ADDRESS
         CLI   READFLG,1          READSAVE SAVED VALUE OF A2,A2+1?
         BNE   READGG             IF NOT, READSAVE IS OK
         SH    RETURN,H8          ELSE POINT BACK TO POSSIBLE LR INS
         CLC   0(4,RETURN),READCI DO WE HAVE LR A2,A1 LR A2+1,A1+1?
         BE    READGG             IF SO, READSAVE IS VALID
         STE   ZR,READSAVE        ELSE READSAVE IS GARBAGE, CLEAR IT
*
*        HERE CALL THE GARBAGE COLLECTOR
*
READGG   BAL   RETURN,GBGCL0      COLLECT
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS
         L     A1,VIOPTR(,A2)     RELOAD POINTER TO IOBLOK
         B     READ0A             AND BACK TO CHECK FOR SPACE
         EJECT
*
*        COME HERE WITH ENOUGH ROOM FOR MAX LENGTH RECORD
*
READ0    L     R0,IFILE(,A1)      GET INTERFACE FILE POINTER
         LA    A1,SCHARS(,FR)     POINT TO BUFFER ADDRESS
         L     R2,VREAD           GET ADDRESS OF INTERFACE READ ROUTINE
         BALR  R1,R2              AND CALL IT
         B     SYSERROR           THIS IS THE ERROR RETURN
*
*        RE-ENTER HERE IF RECORD OK
*
         LTR   A1+1,R0            COPY AND TEST RECORD LENGTH
         BCR   M,FRETURN          FAIL IF NEGATIVE (END OF FILE)
         BZ    READNUL            JUMP IF ZERO (NULL RECORD READ)
         L     R2,VIOPTR(,A2)     GET ADDRESS OF IOBLOK
         L     R2,IFORMAT+4(,R2)  LOAD INTEGER RECORD LENGTH
         LTR   R2,R2              WAS A LENGTH SPECIFIED?
         BZ    *+12               SKIP IF NOT
         CR    A1+1,R2            ELSE WAS SIZE OF RECORD READ GREATER?
         BNH   *+6                SKIP IF INPUTED RECORD MEETS SPECS
         LR    A1+1,R2            ELSE USE FORMAT LENGTH
         BCTR  A1+1,0             ADJUST TO 360 LENGTH
         CE    ZR,V$TRIM          HAS TRIM BEEN TURNED OFF?
         BE    READ1              SKIP TRIM IF IT HAS
         LA    R1,0(A1,A1+1)      POINT TO LAST CHARACTER
         LA    A1+1,1(,A1+1)      GET REAL LENGTH
         BALR  R2,0               SET LOOP REGISTER
*
*        LOOP TO REMOVE TRAILING BLANKS
*
         CLI   0(R1),C' '         IS IT A BLANK?
         BNE   READTD             TRIM DONE IF NOT
         BCTR  R1,0               BACK UP 1 CHARACTER
         BCTR  A1+1,R2            CHECK LENGTH REMAINING, LOOP IF DONE
*
*        COME HERE IF RETURNED RESULT IS NULL
*
READNUL  MVI   VALUE(A2),NCODE    SET RESULT=NULL
         B     READ4A             OFF TO GET VALUE IN REGISTER
         EJECT
*
*        COME HERE TO FIX LENGTH AFTER TRIM
*
READTD   BCTR  A1+1,0             GET 360 LENGTH
*
*        COME HERE IF NO TRIM TO BE DONE (MERGE AFTER TRIM)
*
READ1    C     A1+1,V$MAXLN       IS THIS GT &MAXLNGTH?
         BL    *+8                360 LENGTH MUST BE LESS THAN MAXLEN
         XERR  11,003             INPUT RECORD LONGER THAN &MAXLNGTH
         STE   ZR,0(,FR)          SET SBLOK=GCOLPTR=0
         LA    R2,SCHARS+BOUND+1(,A1+1)     PUSH OVER PROPER BOUNDARY
         N     R2,FULLWRD         PUT ON PROPER BOUNDARY
         STH   R2,STLENGTH(,FR)   STORE LENGTH IN BLOCK
         ST    FR,VALUE(,A2)      SAVE POINTER TO THIS BLOCK
         MVI   VALUE(A2),SCODE    SET RESULT=STRING
         ST    A1+1,VALUE+4(,A2)  STORE OFFSET(=0) AND 360 LENGTH
         AR    FR,R2              PUSH FREE CORE POINTER PAST BLOCK
*
*        COMMON EXIT ROUTINE TO LOAD VALUE
*
READ4A   CLI   READFLG,1          RETURN VALUE IN A1?
         BNE   READ5              B IF SHOULD RETURN IN A2
         LM    A1,A1+1,VALUE(A2)  GET VALUE IN A1,A1+1
         LM    A2,A2+1,READSAVE   RESTORE A2 VALUE IN CASE OF DOIO CALL
         BR    RETURN             AND RETURN TO CALLER
*
*        ENTER HERE IF RESULTS ARE NEEDED IN A2,A2+1
*
READ5    LM    A2,A2+1,VALUE(A2)  GET VALUE TO RETURN
         LM    A1,A1+1,READSAVE   RESTORE A1 VALUE
         BR    RETURN             AND RETURN TO CALLER
*
READMV   MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE IN CHARS
VREAD    DC    V(SYSREAD)         ROUTINE TO READ A RECORD
VSYSMAXL DC    V(SYSMAXL)         INTERFACE ROUTINE TO RETURN MAX RL
*
*        INSTRUCTIONS USED IN READSAVE GARBAGE COLLECT TEST
*
READCI   LR    A2,A1              LR INSTRUCS INDICATING READSAVE OK
         LR    A2+1,A1+1          .
         DROP  A2+1               DROP READ BASE REGISTER
         TITLE 'SPITBOLX -- ROUTINE FOR DATATYPE FUNCTION'
*
*        CONDITIONS ON ENTRY
*
*        (A1,A1+1)                ARGUMENT
*        (R2)                     BASE REG
*
         USING DATATPP,R2         SET BASE REG FOR ASSEMBLER
DATATPP  ST    A1,DATATSV         STORE ARGUMENT TO TEST TYPE
         CLI   DATATSV,DCODE      TEST FOR PROGRAM DEFINED DATATYPE
         BNE   DATATPS            SKIP IF NOT PROG DEFINED DATATYPE
*
*        CASE OF PROGRAM DEFINED DATATYPE
*
         L     A1,PDFPTR(,A1)     PICK UP POINTER TO PDFBLOK
         L     A1,PDFNPTR(,A1)    PICK UP POINTER TO DATATYPE NAME
         LM    A1,A1+1,VNAME(A1)  PICK UP NAME
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE FOR ALL OTHER CASES
*
DATATPS  LA    A1,4               SET INCREMENT FOR BXLE
         LA    A1+1,DATATBLE      SET FOR END TEST
         LA    R1,DATATBL         POINT TO TABLE OF ENTRIES
*
*        SEARCH THROUGH FOR MATCH ON DATA TYPES
*
DATAPL   CLC   DATATSV(1),0(R1)   IS THIS THE RIGHT TYPE?
         BE    *+8                SKIP IF SO
         BXLE  R1,A1,DATAPL       LOOP BACK
*
*        WE FALL THROUGH ABOVE BXLE ONLY IF DATATYPE IS EXTERNAL
*
DATAPL1  L     A1,DATATPBS        LOAD BASE ADDRESS OF STRING
         AH    A1,2(,R1)          ADD OFFSET
         SR    A1+1,A1+1          CLEAR LENGTH FIELD AND SET OFFSET=0
         IC    A1+1,1(,R1)        LOAD LENGTH
         BR    RETURN             RETURN TO CALLER
         EJECT
*
*        TABLE OF DATATYPE NAMES
*
DTP      EQU   *                  ADDRESS OF START OF TABLE
DTPS     DC    C'STRING'          SCODE,NCODE
DTPI     DC    C'INTEGER'         ICODE
DTPR     DC    C'REAL'            RCODE
DTPP     DC    C'PATTERN'         PCODE
DTPA     DC    C'ARRAY'           ACODE
DTPM     DC    C'NAME'            MCODE
DTPT     DC    C'TABLE'           TCODE
DTPE     DC    C'EXPRESSION'      ECODE,VCODE
DTPW     DC    C'DREAL'           WCODE
DTPC     DC    C'CODE'            CCODE
DTPX     DC    C'EXTERNAL'        EXTERNAL CODE
*
         CNOP  0,4                ALLIGN
DATATPBS DC    AL1(SCODE)         BASE POINTER (STRING CODE)
         DC    AL3(DTP-SCHARS)    OFFSETTED BASE ADDRESS OF NAMES
*
*        TABLE TO SEARCH FOR RIGHT NAME
*
*
DATATBL  EQU   *                  START OF TABLE
         DC    AL1(SCODE,5,0,DTPS-DTP)      STRING
         DC    AL1(ICODE,6,0,DTPI-DTP)      INTEGER
         DC    AL1(ACODE,4,0,DTPA-DTP)      ARRAY
         DC    AL1(RCODE,3,0,DTPR-DTP)      REAL
         DC    AL1(TCODE,4,0,DTPT-DTP)      TABLE
         DC    AL1(NCODE,5,0,DTPS-DTP)      STRING
         DC    AL1(MCODE,3,0,DTPM-DTP)      NAME
         DC    AL1(PCODE,6,0,DTPP-DTP)      PATTERN
         DC    AL1(ECODE,9,0,DTPE-DTP)      EXPRESSION
         DC    AL1(VCODE,9,0,DTPE-DTP)      EXPRESSION
         DC    AL1(WCODE,4,0,DTPW-DTP)      DREAL
         DC    AL1(CCODE,3,0,DTPC-DTP)      CODE
         DC    AL1(0,7,0,DTPX-DTP)          EXTERNAL
DATATBLE EQU   *-8                LAST ENTRY (EXCLUDING EXTERNAL)
         DROP  R2                 DROP DATATP BASE REG
         TITLE 'SPITBOLX -- KEYWORD ACCESS ROUTINES'
*
*        KEYWORD FETCH ROUTINE ENTERED FROM $$KGET IN SPITBOLA
*
         USING KGETC,R2           BASE REGISTER SET BY $$GET
KGETC    ST    RETURN,RETLOC      SAVE IN CASE OF ERRORS
         LA    A1,0(,A1)          CLEAR UPPER BYTE
         CR    A1,FR              IS THIS BLOCK ABOVE FREE CORE?
         BH    KGETC1             NATURAL VARIABLE IF SO, SKIP
         C     A1,DYNAMB          IS IT BELOW FREE CORE?
         BL    KGETC1             SKIP IF LOW(NATURAL VARIABLE)
         XERR  05,001             AN ATTEMPT WAS MADE TO ACCESS THE
*                                 KEYWORD ATTRIBUTE OF A NON-NATURAL
*                                 VARIABLE
*
*        COME HERE IF THE KEYWORD BLOCK IS IN THE ADDRESSABLE REGION
*
KGETC1   SR    R1,R1              CLEAR FOR IC
         IC    R1,VKEY(,A1)       LOAD KEYWORD VALUE
*
*        DUMP FUNCTION ENTERS HERE
*        CH ARE DONE TO MAKE DUMP MERGE EASY
*
KGETC2   CH    R1,=Y(KREGGET)     IS THIS KEYWORD SIMPLY ACCESSABLE?
         BL    KGTRYP             CHECK FOR PATTERN GET IF NOT
         SR    A1,A1              INDICATE INTEGER RESULT
         L     A1+1,V$ABEND-K$ABEND(R1)    LOAD KEYWORD VALUE
         BR    RETURN             AND RETURN TO CALLER
*
*        COME HERE TO CHECK FOR SPECIAL GET OR PATTERN KEYWORDS
*
KGTRYP   CH    R1,=Y(KPATGET)     TEST FOR PATTERN KEYWORD
         BL    KSPECGTB(R1)       ELSE SPECIAL GET, OFF TO PROPER CODE
         L     A1,KGPATTB(R1)     LOAD PATTERN VALUE
         BR    RETURN             AND RETURN TO CALLER
         EJECT
*
*        KEYWORD NUMBERS MUST BE IN THE FOLLOWING SPECIAL ORDER
*        THOSE WHICH ARE PROTECTED AND HAVE SPECIAL GET ROUTINES
*        &ALPHABET
*        THOSE WHICH ARE PROTECTED AND ARE PATTERNS
*        THOSE WHICH ARE PROTECTED AND HAVE GET=LOAD
*        THOSE WHOSE PUT=STORE AND GET=LOAD
*        THOSE WHICH HAVE SPECIAL PUT ROUTINES AND GET=LOAD
*        &ERRTYPE
*        IN ADDITION INITIALIZATION DIFFICULTIES SHOULD BE CONSIDERED
*        AND THE LARGEST VALUE MUST BE LESS THAN X'80' FOR PLUS VFUNC
*
*        NOTE THAT THE ENTRIES FOR &FNCLEVEL, &TRACE, &FTRACE MUST
*        CONTIGUOUS, SEE CODING AT FUNCTION ENTRY AND EXIT.
*
K$UNDEFI EQU   0                  KEYWORD VALUE FOR UNDEFINED KEYWORD
K$LASTNO EQU   K$UNDEFI+4         KEYWORD VALUE FOR &LASTNO
K$RTNTYP EQU   K$LASTNO+4         KEYWORD VALUE FOR &RTNTYPE
K$STCOUN EQU   K$RTNTYP+4         KEYWORD VALUE FOR &STCOUNT
K$STNO   EQU   K$STCOUN+4         KEYWORD VALUE FOR &STNO
K$ALPHAB EQU   K$STNO+4           KEYWORD VALUE FOR &ALPHABET
K$ABORT  EQU   K$ALPHAB+4         KEYWORD VALUE FOR &ABORT
K$ARB    EQU   K$ABORT+4          KEYWORD VALUE FOR &ARB
K$BAL    EQU   K$ARB+4            KEYWORD VALUE FOR &BAL
K$FAIL   EQU   K$BAL+4            KEYWORD VALUE FOR &FAIL
K$FENCE  EQU   K$FAIL+4           KEYWORD VALUE FOR &FENCE
K$REM    EQU   K$FENCE+4          KEYWORD VALUE FOR &REM
K$SUCCEE EQU   K$REM+4            KEYWORD VALUE FOR &SUCCEED
K$FNCLEV EQU   K$SUCCEE+4         KEYWORD VALUE FOR &FNCLEVEL
K$TRACE  EQU   K$FNCLEV+4         KEYWORD VALUE FOR &TRACE
K$FTRACE EQU   K$TRACE+4          KEYWORD VALUE FOR &FTRACE
K$ABEND  EQU   K$FTRACE+4         KEYWORD VALUE FOR &ABEND
K$CODE   EQU   K$ABEND+4          KEYWORD VALUE FOR &CODE
K$DUMP   EQU   K$CODE+4           KEYWORD VALUE FOR &DUMP
K$ERRLIM EQU   K$DUMP+4           KEYWORD VALUE FOR &ERRLIMIT
K$INPUT  EQU   K$ERRLIM+4         JEYWORD VALUE FOR &INPUT
K$OUTPUT EQU   K$INPUT+4          KEYWORD VALUE FOR &OUTPUT
K$TRIM   EQU   K$OUTPUT+4         KEYWORD VALUE FOR &TRIM
K$MAXLNG EQU   K$TRIM+4           KEYWORD VALUE FOR &MAXLNGTH
K$STLIMI EQU   K$MAXLNG+4         KEYWORD VALUE FOR &STLIMIT
K$ANCHOR EQU   K$STLIMI+4         KEYWORD VALUE FOR &ANCHOR
K$FULLSC EQU   K$ANCHOR+4         KEYWORD VALUE FOR &FULLSCAN
K$ERRTYP EQU   K$FULLSC+4         KEYWORD VALUE FOR &ERRTYPE
*
KPATGET  EQU   K$ALPHAB+4         LOWEST KEYWORD NUMBER FOR PATTERNS
*
KPROPUT  EQU   K$FNCLEV           HIGHEST PROTECTED KEYWORD
*
KREGGET  EQU   K$SUCCEE+4         LOWEST KEYWORD FOR REGULAR LOAD
*
KSPCPUT  EQU   K$MAXLNG           KEYWORD NUMBER OF LOWEST SPECIAL PUT
         EJECT
*
*        COME HERE FOR KEYWORDS REQUIRING SPECIAL GETS
*        ALSO COME HERE IF VARIABLE DOES NOT HAVE A KEYWORD ATTRIBUTE
*        NOTE THAT SPECIAL GETS COULD BE PUT IN TABLE WITH KEY NUMBERS
*        BEING ROUTINE OFFSET, NO NECESSARILY MULTIPLE OF FOUR!
*
KSPECGTB EQU   *-0                KEYWORD NUMBERS START AT ZERO HERE
*        ENTRY FOR UNDEFINED KEYWORD (VKEY=0)
         XERR  05,002             REFERENCE TO UNDEFINED KEYWORD
*        ENTRY FOR &LASTNO
         B     KGETLSTN           OFF TO CODE FOR &LASTNO
*        ENTRY FOR &RTNTYPE
         B     KGETRTNT           OFF TO CODE FOR &RTNTYPE
*        ENTRY FOR &STCOUNT
         B     KGETSTCN           OFF TO CODE FOR &STCOUNT
*        ENTRY FOR &STNO
         B     KGETSTNO           OFF TO SPECIAL CODE FOR &STNO
*        ENTRY FOR &ALPHABET  -  MUST BE LAST TABLE ENTRY
         LM    A1,A1+1,ALPHPTR    LOAD SPECIFIER FOR &ALPHABET
         BR    RETURN             THIS EXIT TO CALLER IS FOR &ALPHABET
*
*        TABLE OF PATTERN SPECIFIERS NAMES COME FROM PATTERN MACRO
*
         CNOP  0,4                ALLIGN FOLLING VALUES TO FULLWORD
KGPATTB  EQU   *-K$ABORT          FIRST ENTRY IS ABORT
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(ABORTPAT)      ADDRESS OF ABORT PATTERN
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(ARBPAT)        ADDRESS OF ARB PATTERN
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(BALPAT)        ADDRESS OF BAL PATTERN
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(FAILPAT)       ADDRESS OF FAIL PATTERN
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(FENCEPAT)      ADDRESS OF FENCE PATTERN
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(REMPAT)        ADDRESS OF REM PATTERN
         DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(SUCCPAT)       ADDRESS OF SUCCEED PATTERN
*
*        SPECIFIER FOR &ALPHABET
*
ALPHPTR  DC    AL1(SCODE)         TYPE CODE FOR STRING
         DC    AL3(ALPHBET-SCHARS)          ADDRSS WITH OFFSET FOR ALPH
         DC    AL2(0,256-1)       SOFFSET=0,SELNGTH=255
         EJECT
*
*        ABORT PATTERN
*
         PATTERN   NAME=ABORT,MIN=0
*
*        ARB PATTERN
*
         PATTERN   NAME=ARB,EXTEND=YES,MIN=0
*
*        BAL PATTERN
*
         PATTERN   NAME=BAL,EXTEND=YES,MIN=1
*
*        FAIL PATTERN
*
         PATTERN   NAME=FAIL,MIN=0
*
*        FENCE PATTERN
*
         PATTERN   NAME=FENCE,EXTEND=YES,MIN=0
*
*        REM PATTERN
*
         PATTERN   NAME=REM,MIN=0
*
*        SUCCEED PATTERN
*
         PATTERN   NAME=SUCC,EXTEND=YES,MIN=0
*
*        MARK PATTERN (USED BY $ . ARBNO)
*
         PATTERN   NAME=MARK,MIN=0,EXTEND=YES
*
*        DEFINITIONS OF NAMES USED IN INITV TABLE
*
P$ABORT  EQU   ABORTPAT           ABORT
P$ARB    EQU   ARBPAT             ARB
P$BAL    EQU   BALPAT             BAL
P$FAIL   EQU   FAILPAT            FAIL
P$FENCE  EQU   FENCEPAT           FENCE
P$REM    EQU   REMPAT             REM
P$SUCCEE EQU   SUCCPAT            SUCCEED
         EJECT
*
*        LOAD VALUE OF &STNO
*
KGETSTNO LR    R1,DB4             SAVE DB4 ENTRY VALUE
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REG
         USING DTERTNS,DB4        TELL ASSEMBLER
         BAL   A2,CALCSTNO        CALL STMNT NUMBER ROUTINE
         LR    DB4,R1             RESTORE DB4 ENTRY VALUE
         DROP  DB4                END OF THIS BASE REG
         BR    RETURN             RETURN TO CALLER
*
*        LOAD VALUE OF &STCOUNT
*
KGETSTCN LER   FA,SCNT            LOAD COUNT VALUE
         SU    FA,STSTART         SUBTRACT STARTING VALUE
         STE   FA,KGETSV          STORE IN WORK AREA
         MVI   KGETSV,0           CLEAR EXPONENT
         L     A1+1,KGETSV        LOAD AS INTEGER
         A     A1+1,V$STCNT       ADD IN NO. OF STMTS ALREADY COUNTED
         SR    A1,A1              INDICATE INTEGER RESULT
         BR    RETURN             RETURN TO CALLER
*
*        LOAD VALUE OF &LASTNO
*
KGETLSTN MVC   RETLOC(4),$$LAST   SET LOC OF LAST STMNT
         LR    R1,DB4             SAVE DB4 ENTRY VALUE
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REG
         USING DTERTNS,DB4        TELL ASSEMBLER
         BAL   A2,CALCSTNO        CALL STMNT NUMBER ROUTINE
         LR    DB4,R1             RESTORE DB4 ENTRY VALUE
         DROP  DB4                DROP SPECIAL BASE REG
         BR    RETURN             RETURN TO CALLER
*
*        LOAD VALUE OF &RTNTYPE
*
KGETRTNT IC    R1,V$RETYPE        PICK UP VALUE OF SWITCH
         L     A1,INITVPTR        LOAD POINTER TO INITV NAMES
         L     A1+1,RTYPTAB(R1)   LOAD OFFSET AND LENGTH OF NAME
         BR    RETURN             AND RETURN TO CALLER
*
*        TABLE OF OFFSETS AND LENGTHS FOR RETURN TYPE NAMES
*
         CNOP  0,4                ALLIGN TO FULLWORD
RTYPTAB  DC    Y(E$RETURN-INITVR1)          OFFSET TO RETURN ENTRY
         DC    Y(6-1)             360 LENGTH OF 'RETURN'
         DC    Y(E$FRETUR-INITVR1)          OFFSET TO FRETURN ENTRY
         DC    Y(7-1)             360 LENGTH OF 'FRETURN'
         DC    Y(E$NRETUR-INITVR1)          OFFSET TO NRETURN ENTRY
         DC    Y(7-1)             360 LENGTH OF 'NRETURN)
         DROP  R2                 GET RID OF BASE REGISTER
         EJECT
*
*        KEYWORD STORE ROUTINE ENTERED FROM $$KPUT IN ADDRESSABLE AREA
*
         USING KPUTC,DB3          BASE REGISTER SET BY $$KPUT
KPUTC    ST    RETURN,RETLOC      STORE IN CASE OF ERROR
         LA    R1,0(,A1)          COPY VBLOK PTR, STRIP UPPER BYTE
         LR    A1,A2              COPY VALUE TO ASSIGN TO (A1,A1+1)
         LR    A1+1,A2+1          .
         LR    A2,R1              COPY VBLOK POINTER
         CR    A2,FR              IS BLOCK ABOVE FREE CORE?
         BH    KPUTC1             SKIP IF NATURAL VARIABLE
         C     A2,DYNAMB          NTURAL VAR ONLY IF BELOW FREE CORE
         BL    KPUTC1             SKIP IF NATURAL VARIABLE
         XERR  05,003             AN ATTEMPT WAS MADE TO CHANGE THE
*                                 VALUE OF A KEYWORD ASSOCIATED WITH
*                                 A NON-NATURAL VARIABLE
*
*        COME HERE IF VARIABLE IS NATURAL
*
KPUTC1   SR    A2+1,A2+1          CLEAR FOR IC
         IC    A2+1,VKEY(,A2)     LOAD KEYWORD NUMBER
         CLI   VKEY(A2),KPROPUT   IS THE KEYWORD PROTECTED?
         BH    KPUTC2             BRANCH TO PUT IF NOT PROTECTED
         LTR   A2+1,A2+1          IS IT NON-EXISTANT KEYWORD?
         BNZ   *+8                SKIP IF DEFINED & PROTECTED
         XERR  05,004             ATTEMPT TO CHANGE THE VALUE OF AN
*                                 UNDEFINED KEYWORD
         XERR  05,005             ATTEMPT TO CHANGE THE VALUE OF A
*                                 PROTECTED KEYWORD
*
*        COME HERE IF THE KEYWORD EXISTS AND IS NOT PROTECTED
*
KPUTC2   BAL   RETURN,GETINT      CONVERT NEW VALUE TO INTEGER
         XERR  01,012             VALUE TO BE STORED IN A KEYWORD
*                                 CAN NOT BE CONVERTED TO INTEGER
         L     RETURN,RETLOC      RESTORE CALLERS ADDRESS
         LR    R2,DB3             COPY BASE REGISTER ADDRESS
         DROP  DB3                GET RID OF OLD BASE REGISTER
         USING KPUTC,R2           TELL ASSEMBLER OF NEW BASE REGISTER
         L     DB3,$$BAS3         RESTORE DATA BASE REGISTER
         CLI   VKEY(A2),KSPCPUT   DO WE USE A SPECIAL PUT FOR KEYWORD?
         BNL   KSPCPTB(A2+1)      BRANCH TO PROPER ROUTINE IF SPECIAL
         ST    A1+1,V$ABEND-K$ABEND(A2+1)   STORE KEYWORD VALUE
         BR    RETURN             AND RETURN TO CALLER
*
*        STORE VALUE OF &ANCHOR
*
KPUTANCH ST    A1+1,V$ANCHOR      SAVE VALUE OF &ANCHOR
         LTR   A1+1,A1+1          IS IT ZERO FOR UNANCHORED?
         BZ    *+8                SKIP IF SO
         LA    A1+1,X'80'         GET BIT SETTING FOR ANCHORED
         STC   A1+1,ANCHMODE      STORE AS SIGN BIT IN FLAG WORD
         BR    RETURN             RETURN TO CALLER
         EJECT
*
*        STORE VALUE OF &FULLSCAN
*
KPUTSCAN ST    A1+1,V$SCAN        STORE VALUE OF &FULLSCAN
         L     R1,=A(QPATSUBS)    TENTATIVELY SET QUICKSCAN VALUE
         LTR   A1+1,A1+1          TEST NEW VALUE
         BZ    *+8                SKIP IF VALUE IS QUICKSCAN
         L     R1,=A(FPATSUBS)    ELSE GET BASE FOR FULLSCAN
         ST    R1,SCANMODE        SAVE FOR PAT MATCH USE
         BR    RETURN             AND RETURN TO CALLER
*
*        STORE VALUE OF &MAXLNGTH
*
KPUTMAXL CH    A1+1,=Y(32758)     CHECK AGAINST LARGEST SPITBOL VALUE
         BNH   *+8                SKIP TO DO STORE IF NOT INVALID SIZE
         XERR  11,004             ATTEMPT TO SET VALUE OF &MAXLNGTH
*                                 GREATER THAN ALLOWED BY SYSTEM
         ST    A1+1,V$MAXLN       SAVE NEW VALUE 3F &MAXLENGTH
         BR    RETURN             AND RETURN TO CALLER
*
*        STORE VALUE OF &STLIMIT
*
KPUTSTLM LER   FA,SCNT            COPY CURRENT STATEMENT COUNT
         SU    FA,STSTART         CALCULATE NO. OF STATEMENTS EXECUTED
         STE   FA,SCNTSAVE        STORE FOR LOAD INTO GENERAL REGISTER
         L     R1,SCNTSAVE        LOAD INTO GENERAL REGISTER
         LA    R1,0(,R1)          CLEAR OUT X'7F' EXPONENT
         STE   ZR,SCNTSAVE        PREVENT INVALID PAT CONCAT OPT
         A     R1,V$STCNT         ADD IN STMTS ALREADY COUNTED
         SR    A1+1,R1            COMPUTE NO. STMTS LEFT TO EXECUTE
         BNM   *+8                SKIP ERROR MESSAGE IF HAVE'T OVERFLOW
         XERR  11,005             &STLIMIT SET TO A VALUE LESS THAN THE
*                                 NUMBER OF STATEMENTS ALREADY EXECUTED
         ST    R1,V$STCNT         STORE COUNT OF STMTS ALREADY EXECUTED
         AR    R1,A1+1            GET NEW STLIMIT VALUE
         ST    R1,V$STLIM         STORE FOR EASY REFERENCE
         LER   SCNT,SINC          LOAD MINIMUM SCNT VALUE IN CASE
*                                 REMAINING STLIMIT VALUE GE 2**24
         C     A1+1,=X'00FFFFFF'  CAN THIS BE SET IN ONE ASSIGNMENT?
         BNL   KPTSTLM1           SKIP IF CON'T DO IN ONE SETUP
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE
         ST    A1+1,STSTART       STORE SETTING IN TEMPORARY
         MVI   STSTART,X'7F'      ADD EXPONENT
         SU    SCNT,STSTART       CALCULATE NEW SCNT VALUE
*
*        COME HERE WITH SCNT SET TO PROPER VALUE
*
KPTSTLM1 STE   SCNT,STSTART       STORE NEW STARTING VALUE
         BR    RETURN             AND RETURN TO CALLER
         EJECT
*
*        TABLE OF POINTERS FOR SPECIAL PUT KEYWORDS
*        NOTE THAT PUT KEYWORDS MUST NOT DESTROY OLD VALUES
*        BEFORE ISSUING ERROR MESSAGES, IN CASE OF A SETEXIT
*
KSPCPTB  EQU   *-KSPCPUT          SET UP FOR PROPER TABLE ENTRY
         B     KPUTMAXL           OFF TO CODE FOR &MAXLNGTH
         B     KPUTSTLM           OFF TO CODE FOR &STLIMIT
         B     KPUTANCH           OFF TO CODE FOR & ANCHOR
         B     KPUTSCAN           OFF TO CODE FOR &FULLSCAN
*
*        THIS IS THE LAST TABLE ENTRY - ERRTYPE
*
KPUTETYP ST    A1+1,V$ERRTYP      SAVE USER ERROR CODE
         LTR   A1+1,A1+1          IS VALUE SET ZERO?
         BCR   E,RETURN           RETURN IF SO (DO NOT TRAP)
         L     DB4,=A(DTERTNS)    LOAD ERROR ROUTINES BASE REGISTER
         USING DTERTNS,DB4        TELL ASSEMBLER
         B     EXERRCM            OFF TO MERGE WITH ERROR CIRCUIT
         DROP  DB4                GET RID OF BASE REGISTER
         TITLE 'SPITBOLX -- EXTERNAL FUNCTION CALL ROUTINE'
*
*        THIS ROUTINE IS CALLED FROM AN EFBLOK TO CALL AN
*        EXTERNALLY LOADED FUNCTION
*
*        THE ACTUAL ENTRY POINT $$LOAD IS IN SPITBOLA
*
         USING LOADC,DB3          BASE REGISTER SET IN SPITBOLA
LOADC    LH    DB2,EFNARGS(,DB4)  LOAD NUMBER OF ARGUMENTS
         CR    R0,DB2             DO WE HAVE THE RIGHT NUMBER?
         BL    $$WNAG             FILL IN WITH NULLS IF NOT
         STM   FRETURN,RETURN,FRETLOC       SAVE RETURN ADDRESSES
         LR    FRETURN,DB2        SAVE NUMBER OF ARGS
         BCTR  DB2,0              NO. OF ARGS - 1
         SLL   DB2,2              *4
         LCR   A2+1,DB2           GET -((NO. OF ARGS - 1)*4))
         LA    DB2,LOADARGS(DB2,PDR)        GET ADDR OF LAST CALL PARAM
         AR    A2+1,A2+1          GET MULTIPLE OF 8 STACK REF
         LA    A2,LOADPRMS(,PDR)  POINT TO LOCATION TO BUILD DATA
         LA    A2+1,TEM#1(A2+1,PDR)         POINT TO LAST ARG ON STACK
         AL    A2,X80             SET SIGN BIT ON FOR LAST ARG IN LIST
*
*        LOOP TO SAVE ARG ADDRESSES AND POINTERS
*
LOADCL   ST    A2,0(,DB2)         STORE ARG POINTER TO DATA
         LM    A1,A1+1,0(A2+1)    GET PARAMETER
         SR    R1,R1              CLEAR FOR IC
         IC    R1,EFTARGS-1(DB4,FRETURN)    GET TYPE OF CONVERT NEC.
         B     LOADCL(R1)         AND CONVERT IT
*
LDSVAREA EQU   48                 PDR OFFSET FOR CALL SAVEAREA
LOADARGS EQU   LDSVAREA+9*8       PDR OFFSET OF PARAMETER LIST
LOADPRMS EQU   LOADARGS+64*4      START OF ACTUAL DATA ARGUMENTS
*
*        CONVERT ARGUMENT TO REAL
*
LOADRL   BAL   RETURN,GETREAL     CONVERT ARG TO REAL
         XERR  01,013             REAL ARGUMENT FOR LOADED FUNCTION IS
*                                 NOT A REAL
         LR    A1,A1+1            MOVE REAL NUMBER TO PROPER REGISTER
         B     LOADCNC            JUMP TO COMMON LOOP EXIT POINT
*
*        CONVERT ARGUMENT TO INTEGER
*
LOADIN   BAL   RETURN,GETINT      CONVERT ARG TO INTEGER
         XERR  01,014             INTEGER ARGUMENT TO LOADED FUNCTION
*                                 IS NOT AN INTEGER
         LR    A1,A1+1            MOVE INTEGER TO PROPER REG
         B     LOADCNC            JUMP TO COMMON EXIT POINT
         EJECT
*
*        CONVERT ARGUMENT TO STRING
*
LOADST   BAL   RETURN,GETSTG      CONVERT ARGUMENT TO STRING
         XERR  01,015             STRING ARGUMENT TO LOADED FUNCTION
*                                 IS NOT A STRING
         ST    A1+1,LOADF1        STORE OFFSET/LENGTH
         AH    A1,LOADF1-4+SOFFSET          ADD OFFSET
         LH    A1+1,LOADF1-4+SLENGTH        LOAD LENGTH
         LA    A1+1,1(,A1+1)      GET REAL LENGTH FROM 360 LENGTH
         LA    A1,SCHARS(,A1)     GET RID OF SCHARS OFFSET
         CLI   GETSV,NCODE        IS ARGUMENT NULL?
         BNE   *+8                SKIP IF NOT
         SR    A1,A1              ELSE CLEAR TO ZEROS
         SR    A1+1,A1+1          ....
         CR    FR,PDR             HAVE WE OVERFLOWED CORE?
         BL    LOADCNC            JUMP TO COMMON POINT IF NOT
         LM    FRETURN,RETURN,FRETLOC       RESTORE CALLING REGISTERS
         STE   ZR,FRETLOC         SET LOCATION UNUSED
         B     GBGCLF             GARBAGE COLLECT AND START OVER
*
*        CONVERT ARGUMENT TO DREAL
*
LOADDR   BAL   RETURN,GETDREAL    CONVERT ARG TO DREAL
         XERR  01,016             DREAL ARGUMENT TO LOADED FUNCTION IS
*                                 NOT A DREAL
         SLDL  A1,8               POSITION PROPERLY FOR SYSTEM
*
*        COMMON EXIT (ALSO COME HERE IF NO CONVERT)
*
LOADCNC  STM   A1,A1+1,0(A2)      STORE PREPARED ARGUMENT IN PLACE
         LA    A2+1,8(,A2+1)      POINT TO NEXT ARGUMENT LOCATION
         LA    A2,8(,A2)          POINT TO NEXT DATA LOCATION
         SH    DB2,H4             POINT TO NEXT PARAM ADDR FIELD
         BCT   FRETURN,LOADCL     BACK UP 1 CONVERT BYTE AND LOOP
*
*        ALL ARGUMENTS ARE STORED -- NOW SET UP CALL PARAMETERS
*
         STE   0,LOADF1           SAVE FLOATING REG 0
         LR    DB2,SYS            SAVE SYSTEM BASE REGISTER
         DROP  SYS                CANNOT USE SYS FROM NOW ON
         USING SPITBOLA,DB2       USE DB2 INSTEAD AS BASE REG
         SR    A1,A1              RESET FAIL RETURN SWITCH
         LA    1,LOADARGS(,PDR)   POINT TO PARAMETER ADDRESS LIST
         LA    13,LDSVAREA(,PDR)  USE PDR STACK FOR SAVEAREA
         L     15,EFCODE(,DB4)    POINT TO ENTRY POINT
         BALR  14,15              MAKE OUR CALL
         EJECT
*
*        COME HERE ON RETURN FROM THE EXTERNAL FUNCTION
*
         B     *+6                SKIP IF SUCCESS RETURN
         LR    A1,14              SET FAIL RETURN IF RETURN TO 4(,14)
         LR    SYS,DB2            RESTORE STANDARD SYSTEM BASE REG
         USING SPITBOLA,SYS       TELL ASSEMBLER
         DROP  DB2                DROP OUT TEMPORARY BASE
         LE    SINC,=X'7F000001'  RESTORE STATEMENT COUNT INCREMENT
         STD   0,LOADF0           SAVE POSSIBLE REAL RESULT
         LE    0,LOADF1           RESTORE FLOATING REG 0
         SDR   ZR,ZR              RE-ZERO OUR ZERO REG
         L     PDR,PDRLOC         RESTORE PDR STACK POINTER
         LM    FRETURN,RETURN,FRETLOC       RESTORE RETURN ADDRESSES
         STE   ZR,FRETLOC         INDICATE LOC NO LONGER IN USE
*
*        NOW DEAL WITH RETURNED VALUE
*
LOADRTNS SR    R2,R2              CLEAR FOR IC
         IC    R2,EFTRSL(,DB4)    LOAD TYPE CNVRT BYTE FOR RETURNED VAL
         LR    DB4,DB3            SWITCH BASE REGISTERS
         USING LOADC,DB4          TELL ASSEMBLER
         DROP  DB3                ...
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGS
         LTR   A1,A1              TEST FAIL RETURN SWITCH
         BCR   NZ,FRETURN         FAIL IF FAIL SWITCH IS SET
         B     LOADRTNS(R2)       ELSE JUMP TO PROPER EXIT ROUTINE
*
*        COME HERE IF RETURNED RESULT IS AN INTEGER
*
LOADRIN  LR    A1+1,R0            ACQUIRE INTEGER VALUE
         SR    A1,A1              INDICATE INTEGER
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE IF RETURNED RESULT IS A REAL
*
LOADRRL  L     A1+1,LOADF0        LOAD RETURNED REAL VALUE
         L     A1,RCODEBT         INDICATE REAL TYPE
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE IF RETURNED RESULT IS DREAL
*
LOADRDR  LM    A1,A1+1,LOADF0     LOAD RETURNED RESULT
         SRDL  A1,8               SHIFT TO GET ROOM FOR TYPE CODE
         AL    A1,WCODEBT         ADD IN TYPE CODE
         BR    RETURN             AND RETURN TO CALLER
*
*        COME HERE IF RETURNED RESULT IS A STRING
*
LOADRST  LR    R1,R0              COPY POINTER TO ADDRESS/LENGTH BLOCK
         LM    R0,R1,0(R1)        LOAD ADDRESS LENGTH OF STRING
         BCTR  R1,0               GET 360 LENGTH OF RETURNED STRING
         LTR   A1+1,R1            MOVE AND TEST LENGTH
         BM    LOADRNL            SKIP IF RETURNED RESULT IS NULL
         LR    R2,R0              COPY POINTER TO STRING
         EJECT
*
*        COME HERE TO CHECK FOR POSSIBLE COLLECT
*
LOADRSTA LA    A2,SCHARS+BOUND+1(A1+1,FR)   POINT PAST NEW SBLOK
         N     A2,FULLWRD         ALIGN TO FULLWORD (= NEW FR VALUE)
         CR    A2,PDR             WILL THERE BE ROOM?
         BL    LOADRST0           SKIP IF NO COLLECT NEEDED
         BAL   RETURN,GBGCL0      ELSE GARBAGE COLLECT
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS
         B     LOADRSTA           AND BACK TO CHECK FOR COLLECT NEEDED
*
*        COME HERE WITH ENOUGH ROOM FOR SBLOK IN FREE CORE
*
LOADRST0 LA    R0,256             GET VITAL CONSTANT
         LR    A1,FR              COPY POINTER TO START OF BLOCK
         CR    R1,R0              MORE THAN 256 CHARACTERS TO MOVE?
         BL    LOADRST2           SKIP IF NOT
*
*        LOOP TO MOVE 256 CHARACTERS AT A TIME
*
LOADRST1 MVC   SCHARS(256,FR),0(R2)         MOVE 256 CHARACTERS
         AR    R2,R0              BUMP SOURCE POINTER
         AR    FR,R0              BUMP DESTINATION POINTER
         SR    R1,R0              DECREMENT COUNT OF CHARS LEFT
         CR    R1,R0              STILL MORE THAN 256 CHARS TO GO?
         BNL   LOADRST1           LOOP BACK IF SO
*
*        COME HERE TO MOVE LAST OR ONLY CHUNK OF 256 CHARS OR LESS
*
LOADRST2 EX    R1,LOADRMV         MOVE REMAINING CHARACTERS
         SR    A2,A1              CALCULATE LENGTH OF SBLOK
         STH   A2,STLENGTH(,A1)   STORE SBLOK LENGTH
         STE   ZR,0(,A1)          SET DTYPE=SBLOK=0 , GCOLPTR=0
         AL    A1,SCODEBT         SUPPLY STRING TYPE BYTE
         LA    FR,0(A1,A2)        BUMP FR PAST BLOCK
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE TO RETURN A NULL RESULT
*
LOADRNL  L     A1,NCODEBT         LOAD NULL DATA CODE
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE WHEN NO TYPE CONVERSION IS REQUIRED
*
LOADRNC  LR    R2,R0              COPY POINTER TO RESULT
         LM    A1,A1+1,0(R2)      AND LOAD RESULT INTO A1,A1+1
         BR    RETURN             RETURN TO CALLER
         DROP  DB4                DROP BASE REGISTER
*
LOADRMV  MVC   SCHARS(*-*,FR),0(R2)         MOVE CHARS TO SBLOK
         TITLE 'SPITBOLX -- INDIRECT ADDRESSING ROUTINE'
*
*        ENTER FROM ADDRESSABLE AREA WITH DOLLFLG SET
*
         USING DOLLC,R2           BASE REGISTER SET AT ENTRY POINT
DOLLC    ST    RETURN,RETLOC      SAVE RETURN LOCATION FOR ERRORS
*
*        ENTER HERE WHEN RETLOC HAS BEEN INITIALIZED ALREADY (GETNAME)
*
DOLLC1   ST    A1,DOLLWORK        STORE ARGUMENT TO CHECK TYPE CODE
*                                 NOTE: DOLLSAV IS A LINKAGE LOCATION
*                                 AND CANNOT BE USED FOR A NON-LABEL
         CLI   DOLLWORK,MCODE     IS IT A NAME?
         BE    DOLLCM             SPECIAL ROUTINE IF NAME
         CLI   DOLLWORK,NCODE     IS ARGUMENT NULL?
         BE    DOLLNULL           OFF TO GIVE PROPER ERROR IF SO
         ST    RETURN,DOLLSAV     SAVE LINK BACK TO CALLER
         DROP  R2                 GETSTG WILL DESTROY OUR BASE REGISTER
         BAL   RETURN,GETSTG      CONVERT OUR ARGUMENT TO STRING
         USING *,RETURN           TEMPORARY BASE REGISTER FOR ERROR
         B     DOLLCERR           OFF TO CHECK CALLER ON ERROR
         DROP  RETURN             GET RID OF BASE REGISTER
         L     R2,=A(VARLOC)      LOAD ADDRESS OF COMMON HASH ROUTINE
         BALR  R1,R2              AND CALL IT
         SR    A1+1,A1+1          OFFSET = 0 FOR NATURAL VARIABLE
         L     RETURN,DOLLSAV     RESTORE CALLER'S ADDRESS
         AL    A1,MCODEBT         SUPPLY MCODE IN CASE CALL BY NAME
*
*        COME HERE WITH NATURAL VARIABLE POINTER TO EXIT
*
DOLLCX   TM    DOLLFLG,$GETNM+$BYNAM        TEST TYPE OF CALL
         BCR   M,RETURN           RETURN IF ORDINARY CALL BY NAME
         BO    4(,RETURN)         GETNAME RETURN MUST SKIP OVER ERROR
*
*        COME HERE IF CALL WAS BY VALUE
*
         TM    VFLAGS(A1),VINA    IS THIS BLOCK INPUT ASSOCIATED?
         BO    $$READ             USE READ CIRCUITRY IF SO
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE FROM BLOCK
         BR    RETURN             AND RETURN TO CALLER
*
*        COME HERE ON NON-STRING ERROR TO CHECK FOR GETNAME CALL
*
DOLLCERR L     RETURN,DOLLSAV     RESTORE RETURN IN CASE OF GETNAME
         TM    DOLLFLG,$GETNM     WAS THIS A GETNAME CALL?
         BCR   O,RETURN           GIVE GETNAME ERROR IF GETNAME CALL
         XERR  01,017             OPERAND OF UNARY $ IS NOT A STRING OR
*                                 A NAME
         EJECT
*
*        COME HERE IF ARGUMENT=NAME
*
         USING DOLLC,R2           BASE REGISTER IS STILL GOOD HERE
DOLLCM   LA    R1,0(,A1)          COPY PTR WITH LEFT BYTE STRIPPED
         CR    R1,FR              ARE WE BELOW FREE CORE END?
         BNL   DOLLCX             EXIT WITH STD VARIABLE IF ABOVE CORE
         C     R1,DYNAMB          ARE WE ABOVE BOTTOM OF FREE CORE?
         BL    DOLLCX             NOT VARIABLE IF NOT
*
*        COME HERE IF NAME WAS OF SOMETHING IN FREE CORE
*
         TM    DOLLFLG,$BYNAM     WERE WE CALLED BY NAME?
         BCR   O,RETURN           DONE IF SO (=ERROR RETURN FOR GTNM)
         AR    A1,A1+1            ADD OFFSET TO NAME
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE FROM BLOCK
         BR    RETURN             AND RETURN TO CALLER
*
*        COME HERE WITH NULL ARGUMENT TO GIVE PROPER ERROR RETURN
*
DOLLNULL TM    DOLLFLG,$GETNM     WERE WE CALLED BY GETNAME?
         BCR   O,RETURN           RETURN TO GETNAME ERROR IF SO
         XERR  13,011             OPERAND OF UNARY $ IS NULL
         DROP  R2                 DROP BASE REGISTER
         TITLE 'SPITBOLX -- PATTERN CONCATENATION AND ALTERNATION'
*
*        THIS ROUTINE HANDLES BOTH THE CONCATENATION AND ALTERNATION
*        OF PATTERNS -- THESE MERGE SINCE MUCH OF THE CODE IS COMMON
*        FIRST WE CHECK FOR POSSIBLE OPTIMIZATION -- IF LEFT ARGUMENT
*        CAN BE DESTROYED AND IT IS AT TOP OF CORE, WE DON'T NEED TO
*        COPY IT.  ALSO THIS IS THE CASE IF ONLY THE RIGHT ARG IS
*        ABOVE THE LEFT ARGUMENT IN CORE
*        THE LEFT ARGUMENT CAN BE DESTROYED IF IT WAS CREATED DURING
*        THIS STATEMENT.  THIS IS TRUE IF SCNT=SCNTSAVE
*
*        CONDITIONS ON ENTRY
*
*        (A1)                     POINTS TO LEFT PATTERN
*        (A2)                     POINTS TO RIGHT PATTERN
*        PRETLOC                  RETURN LOCATION
*        RETURN                   BASE REGISTER
*        PATFLAG                  X'00' - ALTERNATION , X'FF' - CONCAT
*
         USING *,RETURN           BASE REGISTER PRESET BY $$CNCT
PATSUB   CE    SCNT,SCNTSAVE      DID WE CREATE A PATTERN OR CONCAT
*                                 IN THIS STATEMENT ALREADY?
         BNE   PATSUB1A           NO OPTIMIZATION IF NOT
         LA    R2,0(,A1)          CLEAR LEFT BYTE FOR TEST
         C     R2,PCFRSAVE        LEFT ARG MUST BE FROM THIS STATEMENT
         BL    PATSUB2            NO OPTIMIZATION IF IT WAS NOT
         AH    R2,PTLENG(,A1)     POINT PAST PATTERN
         CR    R2,FR              IS LEFT ARG AT TOP OF CORE?
         BNE   PATSUB0            IF NOT, CHECK FOR RIGHT ARG ABOVE
*
*        COME HERE WHEN LEFT ARGUMENT IS AT TOP OF CORE AND IT CAN BE
*        DESTROYED.  THIS SAVES A COPY AND DELAYS GARBAGE COLLECTION
*
         LH    R1,PTLENG(,A2)     GET LENGTH OF RIGHT ARGUMENT
         AR    R1,FR              POINT PAST WHERE FR WILL BE (16 BYTES
*                                 EXTRA ARE INCLUDED IN THIS TEST)
         CR    R1,PDR             WILL WE OVERFLOW CORE?
         BNH   PATSUB1            DO MOVE IF NOT
         B     GBGCL2             CALL GARBAGE COLLECTOR, SAVING TWO
*                                 ARGUMENTS, RE-ENTER AT PATSUB
*
*        COME HERE TO CHECK TO SEE IF ONLY RIGHT ARG IS ABOVE LEFT ARG
*
PATSUB0  LA    R1,0(,A2)          GET ADDRESS OF RIGHT ARG FOR TEST
         CR    R2,R1              DOES LEFT ARG TOUCH RIGHT ARG?
         BNE   PATSUB2            NO OPT IF NOT
         AH    R1,PTLENG(,A2)     POINT PAST RIGHT ARG
         CR    R1,FR              IS RIGHT ARG AT TOP OF CORE?
         BNE   PATSUB2            NO OPT IF NOT
         EJECT
*
*        COME HERE TO MOVE RIGHT ARG JUST ABOVE LEFT ARG
*
PATSUB1  LA    R0,256             GET VITAL CONSTANT
         LH    A1+1,PTLENG(,A2)   GET LENGTH OF PAT 2
         AH    A1+1,PATSADJ+2     GET 360 LENGTH OF COPIED PART
         LH    R1,PTLENG(,A1)     GET REAL LENGTH OF LEFT ARG
         LA    R1,1(R1,A1+1)      PLUS REAL LENGTH OF RIGHT ARG
         CH    R1,=X'7FFF'        CHECK FOR EXCEEDING 32K
         BH    PSIZERR            GIVE ERROR MESSAGE IF TOO LARGE
         STH   R1,PTLENG(,A1)     IF OK, STORE IN BLOCK
         LR    A2+1,R2            COPY 'TO' POINTER
         CR    A1+1,R0            CAN WE DO IT IN 1 MOVE?
         BL    PCLMOVE            B IF POSSIBLE
*
*        LOOP TO MOVE PATTERN IN 256 BYTE CHUNKS
*
PCBMOVE  MVC   0(256,A2+1),PATS(A2)         MOVE A BIG PIECE
         AR    A2+1,R0            UPDATE 'TO' ADDRESS
         AR    A2,R0              UPDATE 'FROM' ADDRESS
         SR    A1+1,R0            BACK OFF LENGTH
         CR    A1+1,R0            DO WE NEED A BIG MOVE?
         BNL   PCBMOVE            B IF YES
*
*        COME HERE TO MOVE <= 256 BYTES
*
PCLMOVE  EX    A1+1,PCMOVE        MOVE REMAINING CHARACTERS
         LA    FR,1(A1+1,A2+1)    POINT TO NEW FREE CORE
         B     PATSUB3            MERGE WITH NON-OPTIMUM CASE
*
PCMOVE   MVC   0(*-*,A2+1),PATS(A2)         MOVE IN VARIABLE NUM CHARS
*
*        COME HERE WHEN CREATING FIRST PATTERN IN A STATEMENT
*
PATSUB1A STE   SCNT,SCNTSAVE      SAVE STATEMENT COUNT FOR FUTURE CHECK
         ST    FR,PCFRSAVE        SAVE START OF PATS FOR THIS STMNT
*
*        COME HERE IF NO OPTIMIZATION IS POSSIBLE
*
PATSUB2  LH    A1+1,PTLENG(,A1)   SAVE LENGTH OF LEFT PATTERN
         STH   A1+1,PATCNLN       SAVE IN TEMPORARY LOCATION
*
*        NOW WE FUDGE UP TWO STRING POINTERS TO USE THE STRING CON-
*        CATENATION ROUTINE TO JOIN THE PATTERNS TOGETHER
*
         SH    A1+1,=Y(SCHARS+1)  FUDGE LEFT PATTERN LENGTH
         LH    A2+1,PTLENG(,A2)   LOAD RIGHT PATTERN LENGTH
         A     A2+1,PATSADJ       ADD FUDGE
         BAL   RETURN,SCONC       CONCATENATE AS STRINGS
         EJECT
*
*        OPTIMIZED AND NON-OPTIMIZED CASES MERGE HERE WITH
*        (RETURN) SET AS A BASE REGISTER POINTING HERE
*
PATSUB2A MVI   DTYPE(A1),PBLOK    RESET TYPE TO PATTERN BLOCK
*
*        NOW GET PTR TO RIGHT PATTERN AND END OF NEW BLOCK
*
         LA    R2,0(,A1)          POINT TO NEW BLOCK (STRIP UPPER BYTE)
         AH    R2,PATCNLN         POINT R2 TO IMAGE OF RIGHT ARG
*
*        OPTIMIZED CASE MERGES HERE WITH REGISTERS SET
*
PATSUB3  LA    A2+1,4             CONSTANT TO BUMP PATTERN POINTERS
*
*        THE FOLLOWING LOOP CYCLES THROUGH THE PATTERNS IN THE RIGHT
*        ARGUMENT ADJUSTING ALL NOTHEN AND NOOR POINTERS TO POINT BACK
*        TO THE NEW PNOTHEN AND PNOOR FIELDS -- THIS IS DONE FOR BOTH
*        ALTERNATION AND CONCATENATION
*
         LR    A2,R2              INITIALIZE POINTER TO FIRST PATTERN
         BALR  RETURN,0           SET NEW BASE REGISTER
         USING *,RETURN           TELL ASSEMBLER
PATC0    TM    THEN(A2),X'80'     TEST FOR NEGATIVE THEN PTR (NOTHEN)
         BNO   *+14               SKIP IF NOT NOTHEN
         LA    R0,PNOTHEN(,A1)    ELSE POINT TO NEW PNOTHEN FIELD
         SR    R0,A2              CALCULATE OFFSET FROM PAT PTR
         STH   R0,THEN(,A2)       STORE AS NEW NOTHEN POINTER
         TM    OR(A2),X'80'       TEST FOR NEGATIVE OR POINTER (NOOR)
         BNO   *+14               SKIP IF NOT NOOR
         LA    R0,PNOOR(,A1)      ELSE POINT TO NEW PNOOR FIELD
         SR    R0,A2              CALCULATE OFFSET FROM PAT PTR
         STH   R0,OR(,A2)         STORE AS NEW NOOR POINTER
         TM    PFLAGS(A2),PARM1+PARM2       TEST NUMBER OF PARAMETERS
         BZ    *+12               SKIP IF NO PARAMETERS
         BM    *+6                SKIP IF ONE PARAMETER
         AR    A2,A2+1            ADJUST POINTER FOR PARAM2
         AR    A2,A2+1            ADJUST POINTER FOR PARAM1
         LA    A2,12(,A2)         ADJUST POINTER FOR OTHER FIELDS
         CR    A2,FR              HAVE WE REACHED THE END OF THE PAT?
         BCR   L,RETURN           LOOP BACK IF NOT
         EJECT
*
*        NOW TEST ALTERNATION/CONCATENATION CASES
*
         CLI   PATFLAG,X'00'      TEST CASES
         BNE   PATSUBC            SKIP ON CONCATENATION CASE
*
*        FOR ALTERNATION -- GO THROUGH FIRST OR CHAIN IN LEFT PATTERN
*        UNTIL WE FIND THE NOOR POINTER -- CHANGE IT TO POINT TO THE
*        RIGHT PATTERN -- ALSO CHANGE CODELOC TO POINT TO THE "OR" CASE
*        USING THE OFFSET (SEE PATSUBS)
*
         LA    R1,PATS(,A1)       POINT TO FIRST LEFT ARG PAT NODE
ALT0     LH    R0,OR(,R1)         LOAD 'OR' POINTER
         AR    R1,R0              POINT TO NEXT MEMBER ON OR CHAIN
         LTR   R0,R0              WAS THIS THE NEGATIVE 'OR' (NOOR)?
         BP    ALT0               LOOP BACK IF NOT (WAS STD 'OR')
         SR    R1,R0              ELSE FIX UP R1 TO POINT TO LAST NODE
*
*        COME HERE FOR ALTERNATION WHEN BLOCK WITH "NOOR" IS FOUND
*
PATSUBA  SR    R2,R1              GET OFFSET TO RIGHT ARG
         IC    R0,PFLAGS(,R1)     SAVE THE FLAG BYTE
         STH   R2,OR(,R1)         STORE AS NEW "OR" POINTER
         L     R2,CODELOC(,R1)    LOAD POINTER TO "NOOR" CASE CODE
         BCTR  R2,0               MINUS ONE
         BCTR  R2,0               MINUS TWO POINTS TO CODE OFFSET
         AH    R2,0(,R2)          ADD OFFSET TO POINT TO "OR" CASE CODE
         ST    R2,CODELOC(,R1)    STORE AS NEW CODE POINTER
         STC   R0,PFLAGS(,R1)     RESTORE THE FLAG BYTE
         B     PATSUBX            JUMP TO EXIT
*
*        CONCATENATION CASE -- THE NEXT STEP IS TO CYCLE DOWN THE MAIN
*        "OR" CHAIN IN THE RIGHT PATTERN TO FIND THE MINIMUM NUMBER OF
*        CHARACTERS REQUIRED FOR ITS MATCH
*
PATSUBC  LR    A2,R2              GET POINTER TO FIRST RIGHT ARG PAT
         LH    R0,MINMATCH(,A2)             INITIALIZE R0 = MIN MATCH
*
*        LOOP TO CYCLE THROUGH COMPARING MINMATCH WITH SMALLEST SO FAR
*
PATSUBC1 LH    R1,OR(,A2)         LOAD NEXT 'OR' OFFSET
         LTR   R1,R1              TEST FOR NEGATIVE 'OR' POINTER (NOOR)
         BM    PATSUBC2           SKIP IF NO MORE TO GO (NOOR)
         AR    A2,R1              ELSE POINT TO ALTERNATIVE
         CH    R0,MINMATCH(,A2)   TEST MINMATCH WITH SMALLEST SO FAR
         BL    PATSUBC1           LOOP BACK IF NOT SMALLEST SO FAR
         LH    R0,MINMATCH(,A2)   IF SMALLEST SO FAR, ACQUIRE MINMATCH
         B     PATSUBC1           AND LOOP BACK
         EJECT
*
*        CONTINUING THE CONCATENATION CASE, WE NOW HAVE THE MINIMUM
*        NUMBER OF CHARACTERS REQUIRED TO MATCH THE RIGHT HAND PATTERN
*        THIS QUANTITY MUST BE ADDED TO ALL MINMATCH FIELDS IN THE
*        LEFT HAND PATTERN -- ALSO IN THE LOOP THROUGH THE LEFT ARG
*        PATTERNS, ALL "NOTHEN" POINTERS ARE CHANGED TO POINT TO THE
*        RIGHT ARGUMENT PATTERN
*
PATSUBC2 LA    A2,PATS(,A1)       INITIALIZE POINTER TO LEFT ARG PTRS
*
*        REENTRY POINT TO LOOP THROUGH LEFT ARG PATTERNS
*
PATSUBC3 TM    THEN(A2),X'80'     TEST FOR NEGATIVE THEN PTR (NOTHEN)
         BNO   *+12               SKIP IF NOT NOTHEN
         LR    R1,R2              ELSE COPY POINTER TO RIGHT ARG PATS
         SR    R1,A2              CALCULATE OFFSET
         STH   R1,THEN(,A2)       STORE AS "THEN" POINTER
         LH    R1,MINMATCH(,A2)   LOAD OLD MINMATCH FIELD
         AR    R1,R0              ADD MINMATCH REQUIRED FOR RIGHT ARG
         STH   R1,MINMATCH(,A2)   STORE ALTERED MINMATCH FIELD
         TM    PFLAGS(A2),PARM1+PARM2       TEST NUMBER OF PARAMETERS
         BZ    *+12               SKIP IF NONE
         BM    *+6                SKIP IF ONLY ONE
         AR    A2,A2+1            BUMP POINTER FOR PARAM2
         AR    A2,A2+1            BUMP POINTER FOR PARAM1
         LA    A2,12(,A2)         BUMP POINTER FOR OTHER FIELDS
         CR    A2,R2              TEST FOR ALL DONE
         BL    PATSUBC3           LOOP BACK IF NOT
*
*        COMMON EXIT POINT FOR ALTERNATION AND CONCATENATION
*
PATSUBX  LA    A1,0(,A1)          CLEAR UPPER BYTE FROM NEW BLOCK PTR
         AL    A1,PCODEBT         SUPPLY TYPE CODE (PCODE)
         MVI   0(A1),PBLOK        MARK BLOCK IN STORAGE AS PATTERN
         L     RETURN,PRETLOC     LOAD RETURN LOCATION
         BR    RETURN             RETURN
         DROP  RETURN             DROP BASE REG
*
*        THE FOLLOWING IS USED TO ADJUST THE STRING OFFSET AND STRING
*        LENGTH FIELDS OF A PATTERN VALUE SO THAT ONLY THE ACTUAL
*        NODE DATA IS USED. NOTE THAT THE EXTRA -1 IN THE OFFSET ADJUST
*        ALLOWS FOR THE OVERFLOW ON ADDING THE NEGATIVE LENGTH ADJUST
*
         CNOP  0,4                ALLIGN
PATSADJ  DC    Y(PATS-SCHARS-1)   SET OFFSET TO POINT TO NODES
         DC    Y(0-PATS-1)        ADJUST LENGTH ACCORDINGLY
         TITLE 'SPITBOLX -- RETURN POINTS FOR USER DEFINED FUNCTIONS'
*
*        FRETURN                  FAILURE RETURN
*
L$FRETUR MVI   V$RETYPE,4         SET FAILURE RETURN VALUE
         BALR  R1,0               GET BASE REGISTER
         USING *,R1               TELL ASSEMBLER
         B     RSTORE             JUMP TO COMMON RESTORE ROUTINE
*
*        NRETURN                  RETURN BY NAME
*
L$NRETUR MVI   V$RETYPE,8         SET RETURN BY NAME VALUE
         BALR  R1,0               SET UP A BASE REGISTER
         USING *,R1               TELL ASSEMBLER
         B     RSTORE             JUMP TO COMMON RESTORE ROUTINE
*
*        RETURN                   NORMAL RETURN BY VALUE
*
L$RETURN MVI   V$RETYPE,0         SET SUCCESS RETURN VALUE
*
*        COME HERE TO RESTORE ARGUMENTS
*
RSTORE   BALR  DB3,0              SET BASE REGISTER FOR RSTORE
         USING *,DB3              TELL ASSEMBLER
         DROP  R1                 DROP ENTRY BASE REGISTER
         ST    RETURN,$$LAST      SAVE IN CASE OF &LASTNO
*
*        LOOP TO STRIP EXPRESSION LEVELS FROM STACK (SETEXIT CASES)
*
RESTOREL CE    ZR,FBLOKLOC(,PDR)  OK FBLOK POINTER ON STACK?
         BL    RESTOREC           JUMP IF OK TO CONTINUE
         L     PDR,PDRBPTR(,PDR)  ELSE POP STACK
         BZ    RESTOREL           LOOP BACK IF EXPRESSION LEVEL
*
*        ELSE WE ARE AT THE BOTTOM OF THE STACK, NOTE THAT PDR GETS
*        RELOADED FROM PDRLOC UNDOING THE GARBAGE LOAD FROM PDRBPTR
*
         XERR  08,001,S           RETURN FROM LEVEL ZERO
*
*        COME HERE WITH PROPER STACK LEVEL FOR RETURN
*
RESTOREC LM    A1+1,A2+1,V$FNCLEV LOAD FNCLEV,TRACE,FTRACE
         BCTR  A1+1,0             DECREMENT &FNCLEV
         ALR   A2,A2+1            TEST &TRACE AND &FTRACE FOR ZERO
         BNZ   RESTORET           SKIP TO TRY TRACE IF BOTH NOT ZERO
         ST    A1+1,V$FNCLEV      ELSE STORE UPDATED &FNCLEVEL
         EJECT
*
*        RE-ENTRY FROM FUNCTION TRACE REGISTERS AS ON ENTRY
*
FTRACERE L     R0,PDRBPTR(,PDR)   LOAD CORRECT PDR LOC IN CASE OF ERRS
         ST    R0,PDRLOC          STORE IN CURRENT PDR LOCATION
         L     DB4,FBLOKLOC(,PDR) GET ADDRESS OF FBLOK
         L     RETURN,FNAME(,DB4) GET VARIABLE BLOCK ADDRESS FOR NAME
         LR    FRETURN,PDR        SAVE CURRENT STACK LOCATION
         LM    A1,A1+1,VALUE(RETURN)        LOAD RETURNED VALUE
         LA    PDR,LASTEM-TEM#1(,PDR)       POINT TO TEMPS LEVEL ABOVE
         LH    R2,FNARGS(,DB4)    GET NUMBER OF ARGUMENTS
         AH    R2,FNLOCS(,DB4)    ADD NUMBER OF LOCALS
         BZ    NAMREST            SKIP IF NO ARGS OR LOCALS TO RESTORE
         SLL   R2,2               MULTIPLY BY FOUR
         AR    R2,DB4             POINT PAST LAST ARG BLOCK ADDRESS
         LR    R1,DB4             SET LIMIT FOR REVERSE ORDER RESTORE
         L     R0,=F'-4'          LOAD MINUS FOUR AS BXH INCREMENT
*
*        LOOP TO RESTORE ARGS AND LOCALS IN REVERSE ORDER
*
RESTLOOP L     DB4,FARGS-4(,R2)   LOAD POINTER TO BLOCK
         LA    PDR,8(,PDR)        POP STACK TO SAVED VALUE
         LM    A2,A2+1,TEM#1(PDR) LOAD SAVED VALUE
         STM   A2,A2+1,VALUE(DB4) RESTORE VALUE
         BXH   R2,R0,RESTLOOP     LOOP BACK UNTIL ALL DONE
*
*        NOW RESTORE THE FUNCTION NAME VALUE
*
NAMREST  LM    A2,A2+1,LASTEM(FRETURN)      LOAD SAVED VALUE
         STM   A2,A2+1,VALUE(RETURN)        RESTORE VALUE
         LM    FRETURN,RETURN,FRETFLOC(FRETURN)       GET RETN ADDRS
         LM    DB2,DB3,$$BAS2     RELOAD DBS (DB2 IN CASE OF TRACE)
         DROP  DB3                DROP RESTORED BASE REGISTER
         EJECT
*
*        NOW TEST TYPE OF RETURN
*
         CLI   V$RETYPE,4         CHECK TYPE OF RETURN
         L     PDR,PDRLOC         RESET STACK POINTER
         BCR   L,RETURN           RETURN FOR SUCCESS CASE
         BCR   E,FRETURN          FAIL ON FRETURN CASE
*
*        FALL THROUGH HERE IF RETURN BY NAME (NRETURN)
*
         CLC   0(4,RETURN),BFRVN  TEST FOR B $$FRVN (CALL BY NAME)
         BNE   $$DL1V             IF BY VALUE, USE $ BY VALUE ROUTINE
         LA    RETURN,4(,RETURN)  ELSE FUDGE RETURN PAST ERROR CALL
         B     $$DL1N             AND RETURN VIA $ BY NAME
*
*        COME HERE TO ATTEMPT TO GIVE TRACE FOR FUNCTION RETURN
*
RESTORET L     DB4,=A(DTERTNS)    LOAD TRACE BASE REGISTER
         USING DTERTNS,DB4        TELL ASSEMBLER
         SLR   A2,A2+1            FIX &TRACE AND TEST ITS VALUE
         BZ    RFTRC              OFF TO DO FTRACE IF &TRACE = ZERO
         B     RTRC               ELSE TRY TO DO STANDARD TRACE
         DROP  DB4                GET RID OF THIS BASE REGISTER
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION ROUTINE FOR LEN, ETC.'
*
*        PATSET -- COMMON ROUTINE USED BY LEN,POS,RPOS,TAB,RTAB
*
*        (A1,A1+1)                ARGUMENT
*        BAL   A2,PATSET
*        DC    YL2(CODELOC-PATSUBS)         MINMATCH=ARG
*              OR
*        DC    YL2(CODELOC-PATSUBS+X'8000') MINMATCH=0
*        ->  ERROR EXIT FOR ARGUMENT NOT CONVERTIBLE TO INTEGER
*        ->  ERROR EXIT FOR INTEGER NEGATIVE
*
*        NOTE ACTUAL ENTRY POINT IS IN ADDRESSABLE REGION
*
         USING *,A2+1             BASE REG SET AT ENTRY POINT
PATSETC  ST    A1,PATSETSV        SAVE FUNCTION ARG FOR TEST
         TM    PATSETSV,EXPRBIT   TEST FOR EXPRESSION
         BNO   PATSETI            SKIP IF NOT EXPRESSION
         LH    A2,0(,A2)          LOAD PATSET PARAMETER
         MVI   PATSETSV,QF+PARM1+PARM2+PRELOC2        MPBLOK FIRST BYTE
         MVI   PATSETSV+1,LPRM2   2ND BYTE FOR MPBLOK
         SH    A2,=H'14'          BACK OFF CODELOC TO CORRECT LOCATION
         LR    A1+1,A1            POSITION TO SET EXPR AS PARAM2
         SR    R2,R2              SET MINMATCH = 0
         B     PATSET2            SKIP TO COMMON EXIT
*
*        ENTRY FOR INTEGER ARGUMENT (NOT EXPRESSION)
*
PATSETI  ST    RETURN,RETLOC      SAVE RETURN LOCATION
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         B     2(,A2)             ERROR EXIT IF UNCONVERTIBLE
         LTR   A1,A1+1            MOVE INTEGER TO PARAM 1 AND TEST
         BM    6(,A2)             ERROR EXIT IF NEGATIVE
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         SR    R2,R2              PREPARE MINMATCH = 0
         MVI   PATSETSV,QF+PARM1  1ST BYTE FOR MPBLOK
         MVI   PATSETSV+1,LPRM1   2ND BYTE FOR MPBLOK
         LH    A2,0(,A2)          LOAD PATSET PARAMETER
         LTR   A2,A2              TEST FOR MINMATCH = ARG BIT
         BM    PATSET2            SKIP TO COMMON EXIT ROUTINE IF MINUS
         LR    R2,A1              ELSE SET MINMATCH = ARG
*
*        COMMON EXIT POINT
*
PATSET2  N     A2,=X'00007FFF'    REMOVE MINMATCH = ARG BIT
         STH   A2,PATSETSV+2      STORE CODELOC FOR MPBLOK
         LA    R1,PATSETSV        POINT TO MPBLOK ARGUMENTS
         B     MPBLOKX            MAKE BLOCK AND RETURN TO CODE
         DROP  A2+1               DROP PATSET BASE REG
         TITLE 'SPITBOLX -- PATTERN REPLACEMENT ROUTINE'
*
*        THIS IS A CONTINUATION OF THE ROUTINE AT $$PATA
*
         USING *,DB2              BASE REGISTER SET BY $$PATA
PATAC    ST    RETURN,RETLOC      SAVE RETURN LOCATION
         BAL   RETURN,GETSTG      CONVERT TO STRING
         XERR  01,018             REPLACING RIGHT HAND SIDE IN PATTERN
*                                 REPLACEMENT IS NOT A STRING
         STM   A1,A1+1,PART2      STORE PART 2
*
*        NOW GET PART 1
*
*              SLENGTH=SLENGTH(PSTRING)-MATCHPB
*              SOFFSET=SOFFSET(PSTRING)
*
         LM    A1,A1+1,PSTRING(PDR)         LOAD PSTRING SPECIFIER
         SH    A1+1,MATCHPB(,PDR) ADJUST LENGTH -- NOTE MAY GO NEGATIVE
         ST    A1+1,PART1+4       STORE OFFSET & LENGTH OF PART 1
*
*        NOW GET PART 3
*
*              SLENGTH=MATCHPE-1
*        SOFFSET=SOFFSET(PSTRING)+SLENGTH(PSTRING)+1-SLENGTH(PART3)
*
         LH    R1,MATCHPE(,PDR)   PREPARE TO CALCULATE LENGTH
         SH    R1,H1              CALCULATE LENGTH
         BM    PART3N             SKIP IF NEGATIVE (PART 3 NULL)
         LR    A2,A1              ELSE COPY BASE ADDRESS
         LH    A2+1,PSTRING+SOFFSET(,PDR)   GET SOFFSET(PSTRING)
         AH    A2+1,SLENGTH+PSTRING(,PDR)   ADD IN SLENGTH(PSTRING)
         SR    A2+1,R1            SUBTRACT SLENGTH(PART3)
         SLL   A2+1,16            SHIFT TO SOFFSET FIELD
         OR    A2+1,R1            STICK IN LENGTH
         CLI   PART2,NCODE        IS SECOND PART NULL?
         BNE   PATA2              SKIP IF NON-NULL
         EJECT
*
*        AT THIS POINT, WE HAVE FOUND THAT PART 2 IS NULL
*
         TM    PART1+SLENGTH,X'80'          CHECK PART 1 LENGTH
         BNO   PATA1              POSITIVE LENGTH = NON-NULL, SKIP
*
*        HERE, WE HAVE FOUND THAT PARTS 1,2 ARE NULL, SO ASSIGN PART 3
*
         LR    A1,A2              MOVE PART 3
         LR    A1+1,A2+1               TO ACCUMULATOR 1
         B     PATASN             AND SKIP TO ASSIGNMENT
*
*        COME HERE WITH PARTS 2,3 NON-NULL
*
PATA2    TM    PART1+SLENGTH,X'80'          TEST LENGTH OF PART 1
         BNO   PATA3              SKIP IF POSITIVE (NON-NULL)
*
*        COME HERE WITH PART 1 NULL, PARTS 2,3 NON-NULL
*
         LM    A1,A1+1,PART2      POSITION PART 2 AND MERGE
*
*        COME HERE WITH PART 2 NULL, PARTS 1,3 NON-NULL
*
PATA1    BAL   RETURN,SCONC       CONCATENATE THE TWO NON-NULL PARTS
         B     PATASN             AND JUMP TO ASSIGN
*
*        COME HERE WITH PART 3 NULL
*
PART3N   TM    PART1+SLENGTH,X'80'          CHECK PART 1
         BO    PATA4              SKIP IF PART 1 NULL
         CLI   PART2,NCODE        IS SECOND PART NULL?
         BE    PATASN             SKIP IF SO TO ASSIGN
*
*        HERE WE HAVE PARTS 1,2 NON-NULL -- PART 3 NULL
*
         LM    A2,A2+1,PART2      LOAD SECOND PART
         BAL   RETURN,SCONC       CONCATENATE
         B     PATASN             JUMP TO ASSIGN
*
*        COME HERE WITH ONLY PART 2 NON-NULL
*
PATA4    LM    A1,A1+1,PART2      LOAD PART 2
         B     PATASN             SKIP TO ASSIGN
         EJECT
*
*        COME HERE WITH ALL PARTS NON-NULL
*
*        FIRST CONCATENATE PARTS 1,2
*
PATA3    STM   A2,A2+1,PART1      SAVE PART 3 FOR MOMENT
         LM    A2,A2+1,PART2      LOAD PART 2 FOR CONCATENATION
         BAL   RETURN,SCONC       CONCATENATE PARTS 1,2
         LM    A2,A2+1,PART1      RELOAD PART 3
         BAL   RETURN,SCONC       CONCATENATE ON PART 3
*
*        COME HERE TO ASSIGN VALUE
*
PATASN   LM    A2,A2+1,PNAME(PDR) LOAD NAME AND OFFSET
         STE   ZR,PNAME(,PDR)     SET TO ZERO TO INDICATE NOT NEEDED
         AR    A2,A2+1            ADD OFFSET TO NAME BASE
         L     DB2,$$BAS2         RELOAD DB2
         DROP  DB2                DROP BASE REGISTER
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         B     WRIT               DO ASSIGN WITH I/O CHECK
         TITLE 'SPITBOLX -- PATTERN ENTRY POINT ROUTINE'
*
*        THIS IS A CONTINUATION OF THE PROCESSING AT $$PTN2,$$PTV2
*
         USING PTV2C,DB2          BASE REGISTER SET BY $$PTV2
PTV2C    STM   FRETURN,RETURN,FRETLOCP(PDR) SAVE REGS
         ST    RETURN,RETLOC      THIS IS FOR TRACE ETC...
         CR    FR,PDR             CHECK FOR MEMORY OVERFLOW WITH ERRLIM
         BNL   PATMAT3B           FORCE COLLECT IF MEMORY OVERFLOW
*
*        RE-ENTER HERE IN CASE GETPAT CALL IS DONE
*
PATMATG  STM   A1,A1+1,PSTRING(PDR)         SAVE PSTRING (SUBJECT STG)
         ST    A2,ORGPB(,PDR)               SAVE PATTERN POINTER
         CLI   PSTRING(PDR),SCODE IS SUBJECT A STRING?
         BE    PATMAT3            SKIP IF YES
         BAL   RETURN,GETSTG      CONVERT SUBJECT TO STRING
         XERR  01,019             PATTERN MATCH SUBJECT IS NOT A STRING
         CLI   PSTRING(PDR),NCODE IS SUBJECT NULL?
         BNE   *+8                SKIP IF NOT
         LM    A1,A1+1,NULLSTR    ELSE GET NULL BLOCK
         STM   A1,A1+1,PSTRING(PDR)         SAVE IT IN PSTRING
*
*        COME HERE WITH PSTRING ALL SET UP (AS A STRING)
*
PATMAT3  ST    FR,FRSAVE          SAVE FREE CORE POINTER
         CLI   ORGPB(PDR),PCODE   IS PATTERN A PATTERN?
         BE    PATMAT4            SKIP IF IT IS
         LR    A1,A2              ELSE MOVE "PATTERN"
         LR    A1+1,A2+1               TO ACCUMULATOR 1
         BAL   RETURN,GETSTGS     CONVERT "PATTERN" TO A STRING
         B     PATMAT3A           SKIP IF UNCONVERTIBLE
         LA    R0,256             GET THAT CONSTANT FOR LONG STRINGS
         CR    A1+1,R0            IS PATTERN A LONG STRING
         BL    PATMATS            IF NOT, OFF TO SPECIAL STRING CIRCUIT
         LR    A1,A2              COPY ORIGNIAL SPECIFIER TO ALLOW
         LR    A1+1,A2+1          FOR RELOCATION IF COLLECT DONE
*
*        WE COME HERE IN CASE THE PATTERN IS AN EXPRESSION OR A LONG
*        STRING (THE LATTER CASE IS ABSURD AND NOT WORTH OPTIMIZING)
*        IN THESE CASES -- WE CONVERT TO PATTERN AND MERGE
*
PATMAT3A BAL   RETURN,GETPAT      CONVERT TO PATTERN
         XERR  01,020             THE PATTERN IN A PATTERN MATCH IS NOT
*                                 A STRING OR A PATTERN
         LR    A2,A1              COPY PATTERN POINTER TO CORRECT REG
         LM    A1,A1+1,PSTRING(PDR)         RESTORE PSTRING FOR COLLCT
         CR    FR,PDR             DO WE NEED A COLLECT?
         BL    PATMATG            RE-ENTER IF NOT
*
*        COME HERE IF COLLECT NECESSARY
*
PATMAT3B BAL   RETURN,GBGCL2      DO A COLLECT
         B     PATMATG            AND THEN RE-ENTER
         EJECT
*
*        IN THE CASE WHERE THE PATTERN IS A STRING, IT WOULD BE
*        INNEFICIENT TO USE THE FULL PATTERN MATCH LOGIC -- SO THIS
*        CASE IS HANDELED SEPARATELY
*
*        REGISTER USAGE
*
*        (R0)                     CONSTANT 256
*        (R1)                     SUBJECT STRING SCAN POINTER
*        (A1)                     POINTS TO PATTERN STRING
*        (A1+1)                   360 LENGTH OF PATTERN STRING
*        (A2+1)                   MAX NUMBER OF ANCHOR MOVES REMAINING
*        (DB4)                    ANCHOR MOVEMENT
*
PATMATS  SR    DB4,DB4            CLEAR ANCHOR MOVEMENT
         L     R1,PSTRING(,PDR)             PICK UP SUBJECT STRING BASE
         AH    R1,PSTRING+SOFFSET(,PDR)     AND OFFSET
         LA    R1,SCHARS(,R1)     ADJUST TO POINT TO FIRST CHARACTER
         LH    A2+1,PSTRING+SLENGTH(,PDR)   LOAD 360 LENGTH OF SUBJECT
         SR    A2+1,A1+1          SUBJ LENG - PAT LENG = ANCHOR MOVES
         BM    PABORTMM           PATTERN ABORTS IF SUBJECT TOO SHORT
         LTR   A1+1,A1+1          TEST FOR NULL PATTERN
         BM    PATMTAN            ALWAYS MATCH ON A NULL PATTERN
         TM    ANCHMODE,X'80'     TEST ANCHOR MODE
         BO    PATMTA             SKIP ON ANCHORED CASE
*
*        COME HERE IN UNANCHORED MODE -- WE USE ZTBL IN SPITBOLR
*        (PLUGGED WITH THE FIRST PATTERN CHARACTER) TO SEARCH THROUGH
*        THE STRING, DOING A COMPARE WHEREVER THE TRT STOPS
*
         SR    RETURN,RETURN      CLEAR FOR IC INSTRUCTION
         IC    RETURN,SCHARS(,A1)           LOAD FIRST PATTERN CHAR
         LA    RETURN,ZTBL(RETURN)          POINT TO LOCATION TO PLUG
*
*        THIS IS THE LOOP TO SEARCH FOR THE NEXT TRT STOPPING PLACE
*
PATMATLP LR    DB3,R1             SAVE PRESENT SCAN LOCATION
         CR    A2+1,R0            DO WE HAVE 256 CHARS LEFT OR LESS
         BL    PATMATS1           SKIP IF SO
         MVI   0(RETURN),1        PLUG SCAN TABLE
         TRT   0(256,R1),ZTBL     ELSE CHECK 256 CHARACTERS
         MVI   0(RETURN),0        UNPLUG SCAN TABLE
         BNZ   PATMTF             JUMP IF WE FIND SOMETHING
         AR    R1,R0              ELSE CRANK SUBJECT STRING POINTER
         AR    DB4,R0             CRANK ANCHOR MOVEMENT
         SR    A2+1,R0            DECREMENT NUMBER OF MOVES LEFT
         B     PATMATLP           AND LOOP BACK
         EJECT
*
*        PATTERN MATCH AGAINST STRING -- CONTINUED
*
*
*        COME HERE TO TEST 256 CHARACTERS OR LESS
*
PATMATS1 MVI   0(RETURN),1        PLUG SCAN TABLE
         EX    A2+1,PATTRT        TEST REMAINING CHARSACTERS
         MVI   0(RETURN),0        UNPLUG SCAN TABLE
         BZ    PABORTMM           ABORT IF NOTHING FOUND
*
*        COME HERE WHEN THE TRT STOPS ON THE RIGHT CHARACTER
*
PATMTF   SR    DB3,R1             GET MINUS NUMBER OF CHARACTERS SKIPPD
         AR    A2+1,DB3           DECREMENT NUMBER OF MOVES LEFT
         SR    DB4,DB3            INCREMENT ANCHOR MOVEMENT
         EX    A1+1,PATCMP        TEST FULL STRING AGAINST PATTERN
         BE    PATMTAN            JUMP IF WE HAVE FOUND A MATCH
         LA    R2,1               GET INCREMENT/DECREMENT IN REGISTER
         AR    DB4,R2             BUMP ANCHOR FOR CHARACTER TESTED
         AR    R1,R2              BUMP SCAN POINTER
         SR    A2+1,R2            DECREMENT NUMBER OF MOVES LEFT
         BNM   PATMATLP           LOOP BACK IF MORE MOVES TO GO
         B     PABORTMM           ABORT IF NO MATCH FOUND
*
*        COME HERE FOR TEST IN ANCHORED MODE
*
PATMTA   EX    A1+1,PATCMP        COMPARE CHARACTERS
         BNE   PABORTMM           ABORT IF NO MATCH
*
*        COME HERE ON SUCCESSFUL MATCH (ANOCHORED AND UNANCHORED)
*
PATMTAN  LH    A2,PSTRING+SLENGTH(,PDR)     LOAD 360 LENGTH OF SUBJECT
         LA    A2,1(,A2)          GET REAL LENGTH
         SR    A2,DB4             DECREMENT BY ANCHOR MOVEMENT
         STH   A2,MATCHPB(,PDR)   STORE INITIAL CURSOR POSITION
         SR    A2,A1+1            ADJUST FOR CHARACTERS MATCHED
         BCTR  A2,0               PLUS ONE MORE FOR 360 FUDGED LENGTH
         STH   A2,MATCHPE(,PDR)   STORE FINAL CURSOR POSITION
         B     PATENDEM           AND JUMP TO END OF PATTERN EXIT
*
PATCMP   CLC   0(*-*,R1),SCHARS(A1)         MATCH SUBJECT & PATTERN
PATTRT   TRT   0(*-*,R1),ZTBL
         DROP  DB2                GET RID OF BASE REGISTER
         EJECT
*
*        COME HERE WITH PSTRING AND ORGPB CORRECTLY SET UP
*        FOR FULL PATTERN MATCH LOGIC
*
PATMAT4  SR    MINR,MINR          CLEAR CHAR NEEDED ABOVE REG
         L     PBASE,SCANMODE     GET PROPER BASE FOR MODE
         ST    DB1,PSAVDB1(,PDR)  SAVE DATA AREA ADDRESS ON STACK
         L     PO,ANCHMODE        GET ANCH OR UNANCH, CLOBBER DB1
         DROP  DB1                NO LONGER A BASE REGISTER
         LH    CP,PSTRING+SLENGTH(,PDR)     LOAD STRING LENGTH
         LA    CP,1(,CP)          +1 = INITIAL CURSOR (CHARS TO MATCH)
         ST    CP,FAILSW(,PDR)    CLEAR DOTSW AND STORE PSTGLEN
*                                 = REAL SUBJECT STRING LENGTH AT STKBT
         TS    FAILSW(PDR)        SET LENGTH FAIL SWITCH
         L     FSADR,PSTRING(,PDR)          LOAD BASE ADDRESS OF STRING
         LA    FSADR,SCHARS(FSADR,CP)       POINT TO END OF STRING + 1
         AH    FSADR,PSTRING+SOFFSET(,PDR)  ADD IN CHAR OFFSET
         LR    PB,A2              GET PATTERN POINTER
         LA    PS1,STACK1+12(,PDR)          GET STACK1 ADDR
         LA    PS2,STACK2-S2OFS-3*4(,PDR)   GET STACK2 ADDRESS
         LA    BPS,12             GET STACK INCREMENT
         LR    NCP,CP             COPY CHAR ADDR FOR FIRST STACK ENTRY
         STM   PO,NCP,STACK1(PDR) MAKE FIRST ENTRY
         LA    PO,PATS            GET PATTERN BASE
         STE   ZR,S2OFS+S2PB(,PS2)          MAKE TOP OF STACK ENTRY
         USING QPATSUBS,PBASE     GET QUICK BASE REG
         B     SUCC+4             OFF TO PAT MATCH
         DROP  PBASE              DROP PATTERN REG
*
*        NULLSTR -- DUMMY NULL STRING WITH SLENGTH = -1
*
         CNOP  0,4                ALLIGN
NULLSTR  DC    AL1(SCODE)         STRING CODE
         DC    AL3(*)             BASE ADDRESS MUST BE ADDRESSABLE
         DC    Y(0)               SOFFSET = 0
         DC    H'-1'              SLENGTH = -1
         USING SPITBOLD,DB1       BASE REGISTER OK AGAIN
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION FOR ANY/NOTANY'
*
*        NTNANY                   COMMON ROUTINE FOR ANY/NOTANY
*
*        DB2 SHOWS WHICH CASE WE HAVE --
*
*        DB2 = 0                  NOTANY
*        DB2 = NTNANYA-NTNANYN    ANY
*
         USING NTNANY,DB3         BASE REGISTER SET AT ENTRY POINT
NTNANY   LA    R0,1(,A1+1)        LOAD REAL LENGTH TO (R0)
         SR    R1,R1              CLEAR FOR FOLLOWING IC
         IC    R1,ANYMASK         PICK UP CURRENT MASK
         SRA   R1,1               MOVE TO NEXT BIT POSITION
         BNZ   NTNANY1            SKIP UNLESS WE RAN OUT OF BITS
*
*        COME HERE TO GET A NEW TBLOK, WE JUST USED OLD ONE UP
*
         STE   ZR,GCOLPTR(,FR)    SET GCOLPTR = 0
         MVI   DTYPE(FR),TBLOK    SET BLOK CODE
         STE   ZR,CTCHARS(,FR)    ZERO FIRST TABLE WORD
         STE   ZR,CTCHARS+4(,FR)  CLEAR SECOND TABLE WORD
         MVC   CTCHARS+8(248,FR),CTCHARS(FR)          DO OPT MVC
         ST    FR,ANYTPTR         SAVE NEW TBLOK POINTER
         LA    FR,CTCHARS+256(,FR)          BUMP FR
         LA    R1,X'80'           SET LEFT MOST BIT POSITION TO START
*
*        COME HERE WITH TABLE ALL SET UP TO GO
*
NTNANY1  STC   R1,ANYMASK         STORE NEW BIT MASK
         LR    A2,A1              SAVE STRING POINTER
         LM    A1,A1+1,ANYPARAM   LOAD PARAMETER VALUES (ANYTPTR/TM ..)
         EJECT
*
*        NTNANY (COMMON ROUTINE FOR ANY/NOTANY) -- CONTINUED
*
*        LOOP TO TURN SELECTED BITS ON
*
ANYLOOP  SR    A2+1,A2+1          CLEAR FOR IC
         IC    A2+1,SCHARS(A2)    LOAD CHARACTER
         AR    A2+1,A1            ADD TBLOK POINTER
         EX    R1,SETBIT          TURN ON MASK BIT IN SELECTED CHAR
         LA    A2,1(,A2)          STEP TO NEXT CHARACTER
         BCT   R0,ANYLOOP         BACK TILL COUNT EXHAUSTED
*
*        TBLOK ALL SET UP, TEST CASES
*
         LA    R2,1               SET MINMATCH VALUE
         B     NTNANYN(DB2)       JUMP TO PROPER EXIT POINT
         DROP  DB3                GET RID OF THIS BASE REGISTER
*
*        EXIT POINT FOR NOTANY CASE
*
NTNANYN  BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2)      TWO PARMS, 1 REL
         DC    YL2(PN$NANY-PATSUBS)         CODELOC OFFSET
*
*        EXIT POINT FOR ANY CASE
*
NTNANYA  BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2)      TWO PARAMS, 1 REL
         DC    YL2(PN$ANY-PATSUBS)          CODELOC OFFSET
*
SETBIT   OI    CTCHARS(A2+1),*-*  TURN SELECTED BIT ON
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION FOR SPAN'
*
*        THIS ROUTINE IS PASSED CONTROL FROM SPITBOLA TO CONSTRUCT
*        THE PATTERN FOR A SPAN WHOSE ARGUMENT IS A STRING
*
*        (DB3)                    BASE REGISTER
*        (A1)                     ADDRESS OF STRING
*        (A1+1)                   360 LENGTH OF STRING
*
         USING SPANPP,DB3         BASE REGISTER SET BY CALLER
SPANPP   LA    R2,1               SET MINMATCH PARAMETER = 1
         LTR   A1+1,A1+1          TEST 360 LENGTH
         BZ    SPANPP1            SKIP ON ONE CHARACTER CASE
*
*        HERE WE MUST BUILD A NEW TBLOK FOR A MULIPLE CHARACTER CASE
*
         STE   ZR,GCOLPTR(,FR)    CLEAR OUT GCOL POINTER
         MVI   DTYPE(FR),TBLOK    SET PROPER BLOCK CODE
         MVI   CTCHARS(FR),X'FF'  SET RUN CHARACTER
         MVC   CTCHARS+1(255,FR),CTCHARS(FR)          PROPAGATE
         LA    R1,1(,A1+1)        GET REAL NUMBER OF CHARS
         SR    DB2,DB2            CLEAR FOR IC
         SR    R0,R0              CLEAR TO GET A ZERO TO STORE
*
*        LOOP TO PLUG SELECTED CHARS AS ZEROS
*
SPANPPL  IC    DB2,SCHARS-1(A1,R1)          PICK UP CHARACTER
         STC   R0,CTCHARS(FR,DB2) PLUG TABLE
         BCT   R1,SPANPPL         LOOP TILL ALL PLUGGED
*
*        NOW CHECK FOR SPECIAL CASE OF SAME TABLE AS SCANTB3
*        I.E. SPAN('0123456789'), IF SO, USE IT
*
         CH    A1+1,=H'9'         IS 360 COUNT OF CHARS 9?
         BNE   SPANPPX            IF NOT, SKIP FOR NORMAL EXIT
         L     A1,=A(SCANTB3-CTCHARS)       ELSE LOAD SCANTB3 IN CASE
         OC    CTCHARS+C'0'(10,FR),CTCHARS+C'0'(FR)   ALL ZEROS?
         BZ    SPANPPS            IF SO, SKIP TO USE SCANTB3
         EJECT
*
*        HERE FOR A NORMAL EXIT
*
SPANPPX  LR    A1,FR              COPY ADDRESS OF TBLOK TO PARAM REG
         LA    FR,CTCHARS+256(,FR)          PUSH FREE PTR PAST BLOCK
         BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT
         DC    AL1(PARM1+PRELOC1+QF,LPRM1)  ONE PARAM, RELOCATABLE
         DC    AL2(PN$SPAN-PATSUBS)         MATCH OFFSET
*
*        HERE FOR THE ONE CHARACTER CASE. HERE WE CALCULATE
*        AN APPROPRIATE ADDRESS IN THE MASTER SPAN TABLE
*
SPANPP1  SR    R1,R1              CLEAR FOR IC
         IC    R1,SCHARS(,A1)     LOAD CHARACTER VALUE
         L     A1,=A(SPANTBL)     POINT TO MASTER SPAN TABLE REF POINT
         SR    A1,R1              CALCULATE PROPER STARTING ADDR
*
*        MERGE HERE TO EXIT FOR SCANTB3 CASE (A1 = TABLE ADDRESS)
*
SPANPPS  BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT
         DC    AL1(PARM1+QF+PSPANFLG,LPRM1) ONE PARAM, SPECIAL FLAG
         DC    AL2(PN$SPAN-PATSUBS)         MATCH OFFSET
*
         DROP  DB3                DROP BASE REG
         TITLE 'SPITBOLX -- PATTERN CONSTRUCTION FOR BREAK,BREAKX'
*
*        THIS ROUTINE IS PASSED CONTROL FROM SPITBOLA TO CONSTRUCT
*        PATTERNS FOR BREAK, BREAKX CALLS WITH STRING ARGUMENTS
*
*        (DB3)                    BASE REG (+ FOR BREAK, - FOR BREAKX)
*        (A1)                     ADDRESS OF STRING (-SCHARS)
*        (A1+1)                   360 LENGTH OF STRING
*
         USING BREAKPP,DB3        BASE REG SET BY CALLER
BREAKPP  LTR   A1+1,A1+1          TEST LENGTH
         BZ    BREAKPP1           SKIP ON ONE CHARACTER CASE
*
*        HERE WE MUST BUILD A NEW TBLOK FOR A MULTIPLE CHARACTER CASE
*
         STE   ZR,GCOLPTR(,FR)    CLEAR GCOL POINTER
         MVI   DTYPE(FR),TBLOK    SET PROPER BLOCK CODE
         MVC   CTCHARS(256,FR),ZTBL         CLEAR TABLE TO ZEROS
         LA    R1,1(,A1+1)        GET REAL NUMBER OF CHARS
         SR    DB2,DB2            CLEAR FOR IC
         LA    R0,X'FF'           GET STOP CHAR TO PLUG
*
*        LOOP TO PLUG SELECTED CHARS AS NON-ZERO
*
BREAKPPL IC    DB2,SCHARS-1(A1,R1)          PICK UP CHARACTER
         STC   R0,CTCHARS(FR,DB2) PLUG TABLE
         BCT   R1,BREAKPPL        LOOP TILL ALL PLUGGED
*
*        TABLE IS NOW ALL SET UP
*
         LR    A1,FR              COPY ADDRESS OF NEW BLOCK
         LA    FR,CTCHARS+256(,FR)          PUSH FREE PTR PAST BLOCK
         B     BREAKPPX           JUMP TO EXIT
         EJECT
*
*        HERE FOR CASE OF ONE CHARACTER ARGUMENT. IN THIS
*        CASE WE CALCULATE AN APPROPRIATE STARTING ADDRESS IN THE
*        MASTER BREAK TABLE
*
BREAKPP1 SR    R1,R1              CLEAR FOR IC
         IC    R1,SCHARS(,A1)     LOAD CHARACTER VALUE
         LA    A1,BREAKTBL        POINT TO MASTER BREAK TABLE
         SR    A1,R1              CALCULATE PROPER STARTING ADDRESS
*
*        COMMON EXIT POINT (A1 POINTS TO TABLE)
*
BREAKPPX SR    R2,R2              SET MINMATCH = 0
         LTR   DB3,DB3            TEST CASES
         BM    BRKXEX             JUMP ON BREAKX CASE
*
*        EXIT POINT FOR BREAK
*
         BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK, EXIT
         DC    AL1(PARM1+PRELOC1+QF,LPRM1)  ONE PARAM, RELOCATABLE
         DC    AL2(PN$BREAK-PATSUBS)        MATCH OFFSET
*
*        EXIT POINT FOR BREAKX
*
BRKXEX   BAL   R1,MPBLOKXR        RESTORE DBS, MAKE BLOCK AND EXIT
         DC    AL1(PARM1+PRELOC1+QF,LPRM1)  ONE PARAM, RELOCATABLE
         DC    AL2(PN$BRKX-PATSUBS+X'8000')
         DC    AL2(BRKXEXT-QPATSUBS)
*
         DROP  DB3                GET RID OF BASE REGISTER
         TITLE 'SPITBOLX -- GETPAT -- CONVERT TO PATTERN'
*
*        THE ENTRY POINT FOR THIS ROUTINE (GETPAT) AND THE
*        DESCRIPTION OF THE CALLING SEQUENCE CAN BE FOUND IN SPITBOLA
*
         USING GETPATC,DB2        OUR BASE REGISTER
GETPATC  ST    A1,GETPSV          SAVE ARGUMENT FOR CODE TESTS
         CLI   GETPSV,PCODE       IS IT A PATTERN ALREADY?
         BE    GETPATXT           IF SO, JUMP TO EXIT
         TM    GETPSV,EXPRBIT     TEST FOR EXPRESSION
         BO    GETPATE            SKIP IF EXPRESSION
         CLI   GETPSV,NCODE       TEST FOR NULL
         BNE   GETPATS            SKIP IF NON-NULL ARGUMENT
*
*        CASE OF NULL -- CONVERTED TO NULL PATTERN
*
         L     A1,NULLPTR         LOAD POINTER TO NULL PATTERN
         B     GETPATXT           JUMP TO EXIT
*
*        HERE ARGUMENT IS EITHER CONVERTIBLE TO STRING OR ILLEGAL
*
GETPATS  ST    RETURN,GETPSV      SAVE LINK REG
         BAL   RETURN,GETSTG      CONVERT TO STRING
         B     GETPATX            JUMP IF UNCONVERTIBLE TO GIVE ERROR
         L     RETURN,GETPSV      RELOAD RETURN REG
         LA    R2,1(,A1+1)        GET LENGTH OF STRING + SOME GARBAGE
         N     R2,=X'00007FFF'    ISOLATE LENGTH FOR MINMATCH
         CH    R2,H256            TEST FOR 256 CHARACTERS OR LESS
         BH    GETPATS2           SKIP IF LONGER
         EJECT
*
*        GETPAT -- CONTINUED
*
*
*        CASE OF STRING OF 256 CHARACTERS OR LESS
*
         BAL   R1,MPBLOK          MAKE PATTERN BLOCK
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2) 2 PARAMS, 1 RELOC
         DC    YL2(PN$STRS-PATSUBS)         CODE LOCATION
         B     GETPATXT           JUMP TO EXIT
*
*        CASE OF STRING LONGER THAN 256 CHARACTERS
*
GETPATS2 BAL   R1,MPBLOK          MAKE PATTERN BLOCK
         DC    YL1(QF+PARM1+PARM2+PRELOC1,LPRM2) 2 PARAMS, 1 RELOC
         DC    YL2(PN$STRL-PATSUBS)         CODE LOCATION
*
*        COMMON SUCCESS EXIT POINT
*
GETPATXT LM    DB2,DB3,GETPATSV   RESTORE REGS
         B     4(,RETURN)         RETURN TO CALLER
*
*        HERE FOR ERROR RETURN
*
GETPATX  L     RETURN,GETPSV      RELOAD RETURN LOCATION
         LM    DB2,DB3,GETPATSV   RELOAD REGISTERS
         BR    RETURN             GIVE ERROR RETURN
*
*        NULL PATTERN
*
         CNOP  0,4                ALLIGN TO FULLWORD
         PATTERN   NAME=NULL,MIN=0
         EJECT
*
*        GETPAT -- CONTINUED
*
*
*        COME HERE FOR CASE OF EXPRESSION
*
*
*        FOR AN EXPRESSION, WE BUILD A TWO NODE PATTERN -- EXP1 HAS
*        ONE PARAMETER POINTING TO THE CODE OR VARIABLE AND IS LINKED
*        THROUGH ITS THEN FIELD TO AN EXP2 NODE -- SEE PATTERN ENTRY
*        POINTS FOR EXP1 AND EXP1,EXP2 EXTENSION ROUTINES
*
GETPATE  LR    A1+1,A1            POSITION EXPR PTR TO STORE IN PARAM2
         LA    R2,1               SET MINMATCH = 1
         BAL   R1,MPBLOK          MAKE EXP1 BLOCK WITH ROOM FOR EXP2
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2+LPRM0-PATS) 1 PRM + XTR
         DC    AL2(PN$EXP1-PATSUBS+X'8000') CODE LOC + EXTEND FLAG
         DC    AL2(NOEXT-QPATSUBS)          EXTEND OFFSET
         LA    R0,LPRM2-PATS      GET OFFSET FROM EXP1 TO EXP2
         STH   R0,THEN+PATS(,A1)  MAKE THEN OFFSET OF EXP1 --> EXP2
         MVC   LPRM2(12,A1),GETPEXP2        MOVE IN SECOND NODE (EXP2)
         B     GETPATXT           EXIT VIA COMMON POINT
*
*        MODEL FOR EXP2 NODE IN PATTERN CONSTRUCTED ABOVE
*
         CNOP  0,4                ALLIGN
GETPEXP2 DC    AL1(0)             PFLAGS = 0 (NO PARAMETERS)
         DC    AL3(SPITBOLP)      CODE LOC (SEE BELOW)
         DC    AL2(0)             MINMATCH = 0
         DC    AL2(EXP2EXT-QPATSUBS)        EXTEND OFFSET
         DC    AL2(PNOTHEN-LPRM2)           "NOTHEN OFFSET"
         DC    AL2(PNOOR-LPRM2)             "NOOR" OFFSET
         DROP  DB2                GET RID OF THIS BASE REGISTER
*
*        NOTE THAT THE CODELOC IN EXP2 IS NEVER USED (ONLY THE
*        EXTENSION ROUTINE IS USED). HOWEVER, IT IS IMPORTANT TO HAVE A
*        REASONABLE VALUE SO THAT THE OBJECT MODULE RESTART ROUTINE
*        DOES NOT CLOBBER THE FLAGS BYTE WHEN IT RELOCATES THE NODE
         TITLE 'SPITBOLX -- MPBLOK -- MAKE PATTERN BLOCK'
*
*        THIS ROUTINE IS CONTINUED FROM THE ENTRY POINT IN THE
*        ADDRESSABLE AREA (AT MPBLOK AND MPBLOKX) SEE THESE ENTRY
*        POINTS FOR A DESCRIPTION OF THE ARGUMENTS ETC..
*
         USING MPBLOKC,DB3        BASE REG SET AT ENTRY POINT
MPBLOKC  MVC   0(LPRM0,FR),MODPAT MOVE DUMMY FOR ALL BUT PARAMS
         STM   A1,A1+1,PARAM1+PATS(FR)      STORE PARAMS (IF ANY)
         CE    SCNT,SCNTSAVE      ALREADY BUILT A PATTERN THIS STMNT?
         BE    *+12               ALREADY SET UP IF SO
         STE   SCNT,SCNTSAVE      ELSE SAVE THIS STATEMENT NUMBER
         ST    FR,PCFRSAVE        AND SAVE FIRST PATTERN ADDRESS
         LR    A1,FR              SAVE ADDRESS OF NEW PBLOK
         AL    A1,PCODEBT         SUPPLY PATTERN CODE BYTE
         SR    A1+1,A1+1          CLEAR FOR IC
         IC    A1+1,1(,R1)        PICK UP GIVEN LENGTH
         STC   A1+1,PTLENG+1(,FR) STORE IN NEW BLOCK
         LH    R0,2(,R1)          PICK UP CODE POINTER
         N     R0,=X'00007FFF'    REMOVE POSSIBLE EXTEND FLAG BIT
         A     R0,=A(PATSUBS)     ADD BASE LOCATION
         ST    R0,CODELOC+PATS(,FR)         STORE CODE POINTER
         MVC   PFLAGS+PATS(1,FR),0(R1)      MOVE PFLAGS INTO PLACE
         LA    R0,NOEXT-QPATSUBS  SET DEFAULT NOEXT EXTEND ADDRESS
         TM    2(R1),X'80'        CHECK FOR EXTEND ROUTINE GIVEN
         BNO   *+12               WE HAVE CORRECT PTR IF NON SUPPLIED
         LH    R0,4(,R1)          PICK UP SUPPLIED EXTEND OFFSET
         LA    R1,2(,R1)          FUDGE RETURN FOR TWO EXTRA BYTES
         STH   R0,EXTEND+PATS(,FR)          STORE EXTEND ROUTINE OFFSET
         STH   R2,MINMATCH+PATS(,FR)        STORE MINMATCH VALUE
         AR    FR,A1+1            BUMP FREE POINTER
*
*        COME HERE TO EXIT -- BLOCK CONSTRUCTION COMPLETE
*
PBLOKL   CLI   PBLOKSW,0          TEST CALL CASES
         L     DB3,$$BAS3         RESTORE CLOBBERED BASE REG
         DROP  DB3                GET RID OF BASE REGISTER
         BNZ   4(,R1)             RETURN TO CALLER FOR MPBLOK CALL
         CR    FR,PDR             ELSE CHECK FOR GARBAGE COLLECT
         BCR   L,RETURN           RETURN TO CODE IF OK
         B     GBGCL1S            ELSE DO A GARBAGE COLLECT FIRST
*
*        MODEL PATTERN BLOCK
*
MODPAT   DC    AL1(PBLOK)         BLOK CODE FOR PATTERN BLOCK
         DC    AL3(0)             GARBAGE COLLECT FIELD
         DC    Y(*-*)             PTLENG (GETS FILLED IN)
         DC    Y(ANCHEXT-QPATSUBS)          OFFSET FOR NO EXTENSION
         DC    AL4(NOTHEN)        CODELOC FOR "NOTHEN"
         DC    AL1(QF)            SET NOTHEN MINMATCH NEGATIVE
         DC    AL3(NOOR)          CODELOC FOR "NOOR"
         DC    2AL4(0)            FIELDS WHICH GET FILLED IN
         DC    AL2(PNOTHEN-PATS,PNOOR-PATS) NOTHEN & NOOR NEGATIVE OFS
         TITLE 'SPITBOLX -- ARRAY REFERENCE ROUTINES'
*
*        ROUTINE TO HANDLE REFERENCE TO A SINGLY SUBSCRIPTED ARRAY
*        (MIGHT ALSO BE A REFERENCE TO A TABLE)
*
*        CONDITIONS ON ENTRY
*
*        R2                       PRESET BASE REGISTER
*        A1,A1+1                  SUBSCRIPT
*        A2,A2+1                  ARRAY POINTER
*        NAMEFL                   0 -- BY NAME  ,  X'FF' -- BY VALUE
*
         USING *,R2               BASE REGISTER
SUBSC1   ST    A2,SUBSCSV         STORE ARRAY POINTER TO TEST CODE
         CLI   SUBSCSV,ACODE      TEST FOR CASE OF ARRAY
         BE    SUBSC1N            SKIP IF IT IS AN ARRAY
         ST    RETURN,RETLOC      ELSE STORE RETURN LOCATION
         CLI   SUBSCSV,TCODE      TEST FOR TABLE
         BE    TBLOOK             JUMP TO PROCESS A TABLE REFERENCE
         XERR  03,001             ARRAY REFERENCE WITH ONE SUBSCRIPT
*                                 REFERENCES AN OBJECT WHICH IS
*                                 NEITHER AN ARRAY NOR A TABLE
SUBSC1N  CLI   NSUBS(A2),1        TEST FOR ONE SUBSCRIPT
         BNE   SUBSERR3           ERROR IF NOT SINGLE SUBSCRIPTED
         LTR   A1,A1              IF OK, TEST SUBSCRIPT FOR INTEGER
         BZ    SUBSC1A            SKIP IF IT IS AN INTEGER
         ST    RETURN,RETLOC      SAVE RETURN LOCATION
         BAL   RETURN,GETINT      GET AN INTEGER VALUE
         XERR  01,021             SUBSCRIPT IN REFERENCE TO ONE
*                                 DIMENSIONAL ARRAY IS NOT AN INTEGER
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         L     R2,SUBSC1AD        RELOAD BASE REGISTER FOR THIS ROUTINE
*
*        MERGE HERE IF SUBSCRIPT WAS ALREADY AN INTEGER
*
SUBSC1A  SH    A1+1,SUBLBD(,A2)   SUBTRACT LOW BOUND (GET ZERO ORIGIN)
         LH    R0,SUBDIM(,A2)     LOAD DIMENSION
         CLR   A1+1,R0            CHECK FOR SUBSCRIPT IN RANGE
         BCR   NL,FRETURN         FAIL IF OUT OF RANGE
         SLL   A1+1,3             SUBSCRIPT * 8 TO REFERENCE DATA
         CLI   NAMEFL,0           TEST BY VALUE OR BY NAME
         BE    SUBSC1NM           SKIP IF BY NAME
*
*        HERE TO RETURN BY VALUE
*
         L     A1,AVALS(A2,A1+1)  LOAD FIRST WORD OF VALUE
         L     A1+1,AVALS+4(A2,A1+1)        LOAD SECOND WORD OF VALUE
         BR    RETURN             RETURN TO CALLER
*
*        HERE TO RETURN BY NAME
*
SUBSC1NM LA    A1+1,AVALS-VALUE(,A1+1)      SET PROPER OFFSET
         LA    A1,0(,A2)          COPY ARRAY PTR, STRIP UPPER BYTE
         AL    A1,MCODEBT         SUPPLY PROPER NAME CODE
         BR    RETURN             RETURN TO CALLER
         DROP  R2                 DROP BASE REG
         EJECT
*
*        ROUTINE TO HANDLE MULTIPLY SUBSCRIPTED REFERENCE TO ARRAY
*
*
*        CONDITIONS ON ENTRY
*
*        STACK (TEM#1,TEM#2..)    SUBSCRIPT VALUES
*        A1,A1+1                  ARRAY POINTER
*        R0                       NUMBER OF SUBSCRIPTS
*        A2                       PRESET BASE REGISTER
*        NAMEFL                   0 -- BY NAME  ,  X'FF' -- BY VALUE
*
         USING *,A2               BASE REGISTER
SUBSCM   ST    A1,SUBSCSV         STORE ARRAY POINTER TO TEST CODE
         CLI   SUBSCSV,ACODE      IS IT AN ARRAY?
         BNE   SUBSERR2           GIVE ERROR IF NOT ARRAY
         SR    R1,R1              CLEAR R1 FOR IC
         IC    R1,NSUBS(A1)       LOAD NUMBER OF DIMENSIONS
         SR    R1,R0              COMPARE WITH NUM SUBS (CLEARING R1)
         BNZ   SUBSERR3           GIVE ERROR IF WRONG NUMBER OF SUBS
         LA    A2+1,TEM#1(PDR)    INITIALIZE POINTER TO SUBSCRIPTS
         LR    R2,A1              INITIALIZE POINTER TO BOUNDS
*
*        REGISTER USAGE IN THIS LOOP
*
*        A2+1                     SUBSCRIPT POINTER
*        A2                       BASE REGISTER
*        R0                       SUBSCRIPT COUNTER (COUNTS DOWN)
*        R1                       ACCUMULATING INDEX (RESULT)
*        R2                       POINTER TO SUBSCRIPT BOUNDS
*
SUBSCML  LM    A1,A1+1,0(A2+1)    PICK UP NEXT SUBSCRIPT
         LTR   A1,A1              IS IT AN INTEGER
         BZ    SUBSCM2            SKIP IF IT IS
         ST    RETURN,RETLOC      SAVE RETURN LOCATION
         STM   R0,R2,SUBSCSV+4    SAVE LOOP REGISTERS
         BAL   RETURN,GETINT      GET AN INTEGER
         XERR  01,022             SUBSCRIPT IN REFERENCE TO MULTI-
*                                 DIMENSIONAL ARRAY IS NOT AN INTEGER
         LM    R0,R2,SUBSCSV+4    RESTORE LOOP REGISTERS
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         EJECT
*
*        REENTER HERE IF INTEGER
*
SUBSCM2  SH    A1+1,SUBLBD(R2)    SUBTRACT LOW BOUND
         BM    FAILR              FAIL ON OUT OF RANGE IF MINUS
         CH    A1+1,SUBDIM(R2)    CHECK AGAINST HIGH BOUND
         BNL   FAILR              FAIL IF OUT OF RANGE
         M     A1,SUBFAC(R2)      IF IN RANGE -- MULTIPLY BY FACTOR
         AR    R1,A1+1            ADD INTO RESULT
         SH    A2+1,H8            MOVE POINTER TO NEXT SUBSCRIPT
         LA    R2,8(R2)           MOVE TO NEXT SET OF BOUNDS
         BCT   R0,SUBSCML         JUMP BACK FOR NEXT SUBSCR IF MORE
*
*        COME HERE AT END OF LOOP
*
         L     PDR,PDRLOC         RESET STACK POINTER
         MVI   SUBSCSV,MCODE      SET NAME CODE IN ARRAY PTR
         L     A1,SUBSCSV         LOAD ARRAY PTR WITH MCODE
         SR    R2,A1              ARRAY BOUNDS PTR AT END - ARRAY START
         LA    A1+1,AVALS-8-VALUE(R1,R2)    CALCULATE OFFSET
         TS    NAMEFL             TEST FOR BY NAME OR VALUE
         BCR   Z,RETURN           ALL DONE IF BY NAME
         AR    A1,A1+1            ELSE ADD IN OFFSET
         LM    A1,A1+1,VALUE(A1)  PICK UP VALUE
         BR    RETURN             AND RETURN
         DROP  A2                 DONT NEED THIS BASE REG ANY MORE
*
SUBSERR2 XERR  03,002,S           MULTI-DIMENSIONAL ARRAY REFERENCE
*                                 REFERS TO AN OBJECT WHICH IS NOT AN
*                                 ARRAY
*
SUBSERR3 XERR  03,003,S           WRONG NUMBER OF SUBSCRIPTS IN AN
*                                 ARRAY REFERENCE
         TITLE 'SPITBOLX -- TABLE REFERENCE ROUTINE'
*
*        THIS ROUTINE IS ENTERED FROM SUBSC1 FOR A TABLE REFERENCE
*        IT IS ALSO USED BY THE CONVERT FUNCTION (CONVERT TO TABLE)
*        NOTE THAT CONVERT EXPECTS DB1-DB3 TO BE INTACT ON RETURN
*
*        CONDITIONS ON ENTRY --
*
*        (R2)                     BASE REG (POINTS TO SUBSC1)
*        (A1,A1+1)                SUBSCRIPT
*        (A2)                     TABLE POINTER
*        NAMEFL                   0 -- BY NAME , X'FF' -- BY VALUE
*
*        ON RETURN, THE REQUIRED NAME OR VALUE IS IN (A1,A1+1)
*
*        TABLES ARE MAINTAINED AS HASH TABLES USING A CENTRAL STRUCTURE
*        (TBLOK) WHICH CONTAINS N POINTERS TO CHAINS OF INDIVIDUAL
*        ELEMENTS (TEBLOK'S). THE NUMBER N IS SPECIFIED IN THE
*        CALL TO THE TABLE FUNCTION. THIS ROUTINE PERFORMS A HASH TO
*        DETERMINE THE CHAIN TO BE SEARCHED AND THEN SEARCHES DOWN
*        THE CHAIN LOOKING FOR A MATCH. THERE ARE FOUR POSSIBLE
*        RESULTS AS FOLLOWS --
*
*        BLOCK FOUND, CALL BY VALUE         LOAD VALUE FROM TEBLOK
*        BLOCK FOUND, CALL BY NAME          RETURN ADDRESS OF TEBLOK
*        BLOCK NOT FOUND, CALL BY VALUE     RETURN NULL
*        BLOCK NOT FOUND, CALL BY NAME      BUILD TEBLOK & RETURN ADDR
*
*        IN THE LATTER CASE, THE NEW TEBLOK IS LINKED INTO THE
*        APPROPRIATE CHAIN AT THE HEAD OF THE CHAIN
*
*        THE HASH FUNCTION VARIES WITH DATATYPE AS DESCRIBED BELOW
*
         USING SUBSC1,R2          BASE REG FOR THIS ROUTINE
TBLOOK   STM   A1,A1+1,SUBSCSV    SAVE "SUBSCRIPT"
         STM   FRETURN,RETURN,SRETFSV       SAVE FRETURN, RETURN POINT
         CLI   SUBSCSV,SCODE      STRING CASE?
         BE    TBLOOKS            SKIP IF STRING
         LTR   A1,A1              FURTHER CHECK ON TYPE CODE
         BNP   TBLOOK2            SKIP IF INEGER, REAL OR DREAL
         CLI   SUBSCSV,NCODE      NULL?
         BE    TBLOOKNL           SKIP IF NULL
         CLI   SUBSCSV,MCODE      NAME?
         BE    TBLOOK2            SKIP TO TEST BOTH WORDS IF NAME
         EJECT
*
*        HERE FOR ALL DATATYPES EXCEPT NUMERIC, STRING, NAME, NULL
*        IN THESE CASES, USE THE TYPE CODE FOR THE HASH
*
         LR    R1,A1              COPY FIRST WORD
         SRL   R1,32-8            POSITION TYPE CODE FOR HASH
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH
*
*        RETURN HERE TO CHECK FOR MATCH WITH A NODE (SEE TBHASH)
*        IN THIS CASE, ALL WE NEED TO CHECK IS THE FIRST WORD
*
         C     A1,TENAME(,R1)     DOES THIS MATCH?
         BNE   TBLOOKN            SKIP IF NO
         B     TBLOOKY            SKIP IF YES
*
*        COME HERE FOR INTEGER, REAL, DREAL, NAME
*        IN THESE CASES THE HASH USES THE SECOND WORD OF THE VALUE
*
TBLOOK2  LR    R1,A1+1            USE SECOND WORD AS HASH ARG
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH
*
*        RETURN HERE TO CHECK FOR MATCH, HERE WE CHECK FOR BOTH WORDS
*
         C     A1+1,TENAME+4(,R1) CHECK SECOND WORDS
         BNE   TBLOOKN            SKIP IF NO MATCH
         C     A1,TENAME(,R1)     ELSE CHECK FIRST WORD
         BE    TBLOOKY            SKIP IF BOTH WORDS MATCH
         B     TBLOOKN            ELSE NO MATCH
*
*        HERE FOR NULL SUBSCRIPT
*
TBLOOKNL SR    R1,R1              USE ZERO FOR HASH
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH
*
*        HERE TO CHECK FOR THE NULL ENTRY WE WANT
*
         CLI   TENAME(R1),NCODE   IS NAME OF THIS NODE NULL?
         BNE   TBLOOKN            SKIP IF NOT
         BE    TBLOOKY            SKIP IF YES (FOUND)
*
*        HERE FOR STRING CASE, USE THE FOLLOWING FOR THE HASH --
*
*        LENGTH > 4    (360 LENGTH) XOR (1ST 4 CHRS) XOR (LAST 4 CHRS)
*        LENGTH = 4    (FOUR CHARS)
*        LENGTH < 4    (WHOLE STRING PADDED ON RIGHT WITH X'00')
*
TBLOOKS  AH    A1,SUBSCSV+SOFFSET           POINT TO STRING
         LH    A1+1,SUBSCSV+SLENGTH         LOAD STRING LENGTH
         CH    A1+1,H3            CHECK LENGTH
         BH    TBLOOKSL           SKIP IF LONGER THAN 4 CHARACTERS
         EJECT
*
*        HERE WE HAVE A STRING SHORTER THAN 5 CHARACTERS
*
         STE   ZR,TBLSV           CLEAR AREA TO X'00'
         EX    A1+1,TBLOOKSM      MOVE WHAT CHARS WE HAVE
         L     R1,TBLSV           LOAD CHARS AS HASH
         B     TBLOOKS1           SKIP TO MERGE
*
*        HERE FOR STRINGS LONGER THAN FOUR CHARACTERS
*
TBLOOKSL MVC   TBLSV(4),SCHARS(A1)          GET FIRST 4 CHARS
         LR    R1,A1+1            COPY 360 LENGTH
         X     R1,TBLSV           EXCLUSIVE OR WITH FIRST 4 CHARS
         LA    A2+1,0(A1,A1+1)    POINT TO END OF STRING
         MVC   TBLSV(4),SCHARS+1-4(A2+1)    MOVE LAST FOUR CHARS
         X     R1,TBLSV           EXCLUSIVE OR LAST FOUR CHARS
         CH    A1+1,H256          CHECK FOR SHORT/LONG STRING
         BNL   TBLOOKS2           SKIP IF LONG STRING
*
*        HERE FOR SHORT STRINGS
*
TBLOOKS1 BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH
*
*        RETURN HERE TO CHECK FOR MATCH WITH PARTICULAR BLOCK ON CHAIN
*
         CH    A1+1,TENAME+SLENGTH(,R1)     LENGTHS MATCH?
         BNE   TBLOOKN            NO MATCH IF UNEQUAL LENGTHS
         CLI   TENAME(R1),SCODE   ELSE IS IT REALLY A STRING?
         BNE   TBLOOKN            NO MATCH IF NOT
         L     A2+1,TENAME(,R1)   ELSE LOAD STRING BASE POINTER
         AH    A2+1,TENAME+SOFFSET(,R1)     ADD OFFSET
         EX    A1+1,TBLOOKCS      ARE STRINGS IDENTICAL?
         BNE   TBLOOKN            SKIP IF NOT
         BE    TBLOOKY            SKIP IF YES
*
*        HERE FOR STRINGS LONGER THAN 255 CHARACTERS
*
TBLOOKS2 ST    A2,TBLSV           SAVE TABLE POINTER
         BAL   FRETURN,TBHASH     CALL ROUTINE TO CALCULATE HASH
*
*        HERE TO COMPARE FOR LONG STRING MATCH. TO HECK WITH SPEED
*        IN THIS HIGHLY UNUSUAL CASE, USE IDENT FOR THE COMPARISON
*
         LM    A1,A1+1,TENAME(R1) LOAD NAME
         LM    A2,A2+1,SUBSCSV    LOAD SUBSCRIPT
         BAL   RETURN,$$IDNT      USE IDENT FOR THE COMPARISON
         L     A2,TBLSV           RESTORE TABLE POINTER
         BNE   TBLOOKN            BRANCH IF NO MATCH
         B     TBLOOKY            BRANCH IF MATCH
*
TBLOOKSM MVC   TBLSV(*-*),SCHARS(A1)        MOVE UP TO 4 CHRS FOR HASH
TBLOOKCS CLC   SCHARS(*-*,A1),SCHARS(A2+1)  CHECK FOR MATCHING NAMES
         EJECT
*
*        COMMON HASH ROUTINE USED FOR ALL DATATYPES
*
*        TBHASH IS CALLED FOR PARTICULAR CASES BY --
*
*        (R1)                     ARGUMENT FOR HASH
*        (R2)                     BASE REG FOR ROUTINE
*        (A2)                     POINTER TO TABLE
*        BAL   FRETURN,TBHASH
*
*        ON RETURN, THE FOLLOWING ARE THE CONDITIONS
*
*        (R0)                     OFFSET TO PROPER HASH SLOT IN TABLE
*        (R1)                     POINTER TO FIRST TEBLOK ON CHAIN
*        (A1,A1+1,A2,A2+1)        UNCHANGED
*        (FRETURN)                STILL POINTS PAST CALL
*
*        THE CALL TO TBHASH IS IMMEDIATELY FOLLOWED BY A ROUTINE THAT
*        CHECKS TO SEE IF THE TEBLOK POINTED TO BY (R1) IS THE ONE
*        WHICH MATCHES THE ARGUMENT SUBSCRIPT. IF IT IS, CONTROL IS
*        PASSED TO TBLOOKY, ELSE CONTROL IS PASSED TO TBLOOKN.
*
*        THE HASH IS CALCULATED AS THE N RESIDUE OF THE HASH ARGUMENT
*        WHERE N IS THE NUMBER OF HEADERS IN THE TABLE
*
TBHASH   SR    R0,R0              CLEAR FOR DIVIDE
         SLL   R1,2               HASH ARGUMENT *4 TO INDEX BY WORDS
         D     R0,TBDIVIDE(,A2)   DIVIDE TO CALCULATE HASH FUNCTION
         LR    R1,R0              COPY OFFSET
         L     R1,TBLPTRS(R1,A2)  LOAD POINTER TO FIRST TEBLOK
         LTR   R1,R1              IS THERE A BLOCK
         BCR   NZ,FRETURN         IF SO, RETURN TO COMPARISON ROUTINE
         B     TBLOOKB            ELSE OFF TO HANDLE NON-EXISTANT VALUE
*
*
*        HERE IF THERE IS NO MATCHING NODE ON THE HASH CHAIN
*
TBLOOKN  L     R1,TLINK(,R1)      LINK TO NEXT NODE ON CHAIN
         LTR   R1,R1              IS THERE ONE?
         BCR   NZ,FRETURN         RETURN TO CHECK IT IF SO
         EJECT
*
*        HERE IF THIS ENTRY DOES NOT ALREADY EXIST IN THE TABLE
*        IF THE CALL WAS BY VALUE, WE RETURN NULL
*        IF THE CALL WAS BY NAME, WE CREATE A NEW TEBLOK
*
TBLOOKB  LM    FRETURN,RETURN,SRETFSV       RELOAD RETURN REGS
         L     A1,NCODEBT         LOAD NULL IN CASE BY VALUE
         CLI   NAMEFL,0           BY VALUE OR NAME?
         BCR   NE,RETURN          RETURN IF BY VALUE (RETURN NULL)
         LM    A1,A1+1,SUBSCSV    LOAD SUBSCRIPT (IN CASE OF COLLECT)
*
*        HERE TO BUILD A NEW TEBLOK
*
TBLOOKB0 LA    R1,TESIZE(,FR)     SEE WHERE FREE CORE WILL END UP
         CR    R1,PDR             WILL THERE BE ROOM
         BL    TBLOOKB1           SKIP IF THERE IS ROOM
         BAL   RETURN,GBGCL2      COLLECT SAVING TABLE POINTER
         L     RETURN,SRETSV      RESTORE RETURN ADDRESS
         B     TBLOOKB0           BACK TO CHECK SPACE AGAIN
*
*        HERE AFTER CHECKING FOR SUFFICIENT SPACE
*
TBLOOKB1 AR    A2,R0              POINT TO PROPER HASH CHAIN SLOT
         L     R0,TBLPTRS(,A2)    LOAD OLD HEAD OF CHAIN POINTER
         ST    FR,TBLPTRS(,A2)    SET NEW BLOCK AS HEAD OF CHAIN
         ST    R0,TLINK(,FR)      LINK THIS BLOCK TO REST OF CHAIN
         STE   ZR,GCOLPTR(,FR)    CLEAR GCOL FIELD
         MVI   DTYPE(FR),TEBLOK   SET BLOCK CODE
         MVI   TEVALUE(FR),NCODE  SET VALUE = NULL
         STM   A1,A1+1,TENAME(FR) STORE SUBSCRIPT IN NAME FIELD
         LR    A1,FR              COPY ADDRESS OF TEBLOK
         AL    A1,MCODEBT         SUPPLY STANDARD NAME CODE
         SR    A1+1,A1+1          SET ZERO (TEVALUE-VALUE) OFFSET
         LR    FR,R1              BUMP FREE REG PAST BLOCK
         BR    RETURN             RETURN TO CALLER
*
*        HERE IF A MATCHING BLOCK IS FOUND
*
TBLOOKY  LM    FRETURN,RETURN,SRETFSV       RELOAD RETURN REGS
         CLI   NAMEFL,0           CHECK FOR NAME OR VALUE
         BE    TBLOOKYN           SKIP IF BY NAME
         LM    A1,A1+1,TEVALUE(R1)          IF BY VALUE, LOAD VALUE
         BR    RETURN             AND RETURN
*
*        HERE FOR FOUND MATCHING BLOCK, CALLED BY NAME
*
TBLOOKYN LR    A1,R1              COPY BLOCK POINTER
         AL    A1,MCODEBT         SUPPLY NAME CODE
         SR    A1+1,A1+1          CLEAR OFFSET
         BR    RETURN             RETURN TO CALLER
*
         DROP  R2                 DROP TABLE BASE REG
         TITLE 'SPITBOLX -- MISCELLANEOUS ERROR EXITS'
*
$$NOGO   XERR  08,002,S           TRANSFER TO UNDEFINED LABEL
*
DREALO   XERR  10,001             OVERFLOW IN + - / OR * OF TWO DREALS
*
REALO    XERR  10,002,S           OVERFLOW IN + - / OR * OF TWO REALS
*
REALDZ   XERR  10,003,S           REAL DIVISION BY ZERO
*
DREALDZ  XERR  10,004             DREAL DIVISION BY ZERO
*
EXPWRO   XERR  10,005             OVERFLOW IN REAL ** INTEGER OR
*                                 DREAL ** INTEGER
*
DVDIZ    XERR  10,006,S           INTEGER DIVISION BY ZERO
*
*        THIS IS A PSEUDO FFBLOK WHICH GIVES AN ERROR MESSAGE
*
         USING FLCERR-FCODE,DB4   POINTER TO FFBLOK IS DB4
FLCERR   NOP   0                  DO NOTHING ON NORMAL ENTRY
         B     *+4                BRANCH TO RETAIN CONTROL ON EXECUTE
         XERR  01,023,S           A FIELD FUNCTION WAS APPLIED TO AN
*                                 INCORRECT PROGRAM DEFINED DATATYPE
*
*        THE FOLLOWING ENTRY POINTS ARE USED FOR EXECUTION ERRORS
*        9.001 - 9.012 (UNDEFINED FUNCTION AND OPERATOR CALLS)
*
XER09012 BCTR  DB2,0              9.012     UNDEFINED OPTR UNARY EXCLAM
XER09011 BCTR  DB2,0              9.011     UNDEFINED OPTR BINARY %
XER09010 BCTR  DB2,0              9.010     UNDEFINED OPTR UNARY %
XER09009 BCTR  DB2,0              9.009     UNDEFINED OPTR BINARY ?
XER09008 BCTR  DB2,0              9.008     UNDEFINED OPTR BINARY #
XER09007 BCTR  DB2,0              9.007     UNDEFINED OPTR UNARY #
XER09006 BCTR  DB2,0              9.006     UNDEFINED OPTR UNARY |
XER09005 BCTR  DB2,0              9.005     UNDEFINED OPTR BINARY @
XER09004 BCTR  DB2,0              9.004     UNDEFINED OPTR BINARY 
XER09003 BCTR  DB2,0              9.003     UNDEFINED OPTR BINARY &
XER09002 BCTR  DB2,0              9.002     UNDEFINED OPTR UNARY /
XER09001 BCTR  DB2,0              9.001     UNDEFINED FUNCTION CALL
*
*        COME HERE WITH (DB2) DECREMENTED BY AN AMOUNT CORRESPONDING
*        TO THE CORRECT MINOR CODE FOR THE ERROR MESSAGE
*
         ST    RETURN,RETLOC      SAVE RETURN POINT
         LCR   DB2,DB2            GET CODE - (DB2)
         A     DB2,$$BAS2         CALCULATE MINOR CODE
         STC   DB2,SYSERCOD+3     STORE MINOR CODE
         MVI   SYSERCOD+2,9       SET PROPER MAJOR CODE
         B     SYSERCOD           ISSUE ERROR (NOTE ERROR RESTORES DB2)
*
$$NOFN   EQU   XER09001           ALTERNATE NAME FOR UNDEF FUNCTION
         TITLE 'SPITBOLX -- DUMP,TRACE,EOJ ROUTINES'
*
*        ALL THESE ROUTINES ARE UNDER CONTROL OF THE FOLLOWING USING
*
         USING DTERTNS,DB4        BASE REG FOR DUMP/TRACE/EOJ ROUTINES
DTERTNS  EQU   *                  START OF DUMP/TRACE/EOJ ROUTINES
*
*        LINETERM -- DUMP OUT BUFFER FOR TRACE OR DUMP -- CALLED ON A2
*        LINETERM ALWAYS ENDS BY REINITIALIZING WITH LINEINIT
*
LINE$    EQU   DB4                REG FOR BALR CALL TO LINETERM
LINETERM STM   A1,A2+1,DTESAVE    SAVE REGISTERS NEEDED FOR WRITE
         LR    A1,FR              POINT TO OUTPUT BUFFER
         SR    DB3,A1             GET LINE LENGTH
         LR    A1+1,DB3           COPY LENGTH IN CASE ALL FITS ON LINE
         SH    DB3,=Y(TBUFSIZE)   GET LENGTH OF CHARS BEYOND BUFFER
         BNP   *+8                SKIP IF NO OVERFLOW
         LA    A1+1,TBUFSIZE      ELSE PRINT OUT FULL BUFFER
         SR    A2+1,A2+1          SET UNFORMATED OUTPUT
         L     R0,PRINTDCB        GET INTERFACE POINTER
         L     R2,=V(SYSWRITE)    LOAD INTERFACE ROUTNE ADDRESS
         BALR  R1,R2              CALL ROUTINE
         NOP   0                  IGNORE ERROR RETURN
         LM    A1,A2+1,DTESAVE    RESTORE WRITE REGISTERS
         LTR   DB3,DB3            CHECK FOR OVERFLOW ON LAST RECORD
         BM    LINEINIT           SET UP FOR NEXT LINE IF NO OVERFLOW
         EX    DB3,LINEMOVE       MOVE THE OVERFLOW INTO THE BUFFER
         MVI   0(FR),C' '         SET CONTROL CHARACTER
         LA    DB3,1(DB3,FR)      POINT TO NEXT EMPTY LOCATION
         BR    A2                 AND RETURN TO CALLER
*
*        LINEINIT -- INITIALIZE TRACE OR DUMP OUTPUT -- CALLED ON A2
*        LEAVES DB3 POINTING TO FIRST AVAILABLE LOC IN BUFFER
*
LINEINIT MVI   0(FR),C' '         SET FOR BLANK LINE (NO SKIP)
         LA    DB3,1(,FR)         POINT PAST CONTROL CHARACTER
         BR    A2                 AND RETURN TO CALLER
*
LINEMOVE MVC   1(*-*,FR),TBUFSIZE(FR)       MOVE BACK OVERFLOW RECORD
TBUFSIZE EQU   121                SIZE OF TRACE BUFFER INCL. CONT CHAR
         EJECT
*
*        ROUTINE TO INITIALIZE TRACE OUTPUT
*
*        BAL   A2,FTRCINIT
*
*        INITIALIZES THE TRACE BUFFER AND PLACES  ****NN*** ON THE
*        LINE WHERE NN IS THE STATEMENT NUMBER FROM RETLOC OR ALTLOC
*
FTRCINIT LR    A2+1,A2            SAVE LINKAGE
         BAL   A2,LINEINIT        INITIALIZE PRINT LINE
         MVC   0(10,DB3),TRCINIT  MOVE IN *** AND EDIT PATTERN
         BAL   A2,CALCSTNO        CALCULATE STATEMENT NUMBER
         CVD   A1+1,STOPSV        CONVERT TO DECIMAL
         ED    0(6,DB3),STOPSV+5  EDIT WITH LEADING *
         LA    DB3,10(,DB3)       BUMP PAST ****NN*** AND BLANK
         BR    A2+1               RETURN TO CALLER
*
*        EDIT PATTERN FOR TRACINIT
*
TRCINIT  DC    C'*'               FILL CHARACTER
         DC    X'2020202020'      EDIT PATTERN
         DC    C'*** '            TRAILING ASTERISKS
*
DMPRBBEB DC    C'>'               C'> = ' FOR ARRAY TABLE
DMPBEB   DC    C' = '             BLANK EQUALS BLANK FOR ASSIGNS
*
*        COME HERE JUST BEFORE TERMINATING A LINE TO WHICH EXTRA
*        CHARACTERS HAVE BEEN ADDED UNOFFICIALLY.  FIRST ENTRY ALSO
*        SKIPS OVER ONE CHARACTER ADDITION
*        BAL   A2,DMPCHK          CALL OF THIS ROUTINE
*        EXIT IS TO USER, POSSIBLY BY WAY OF LINETERM
*
DMPCHK1  LA    DB3,1(,DB3)        BUMP OVER ONE CHARACTER ADDITION
*
*        COME HERE TO CHECK FOR OVERFLOW
*
DMPCHK   LA    R2,TBUFSIZE(,FR)   POINT PAST LAST ALLOWED CHARACTER
         CR    DB3,R2             CHECK CURRENT POSITION
         BCR   NH,A2              EXIT TO CALLER IF NO OVERFLOW
         BR    LINE$              ELSE TERMINATE LINE FIRST
         EJECT
*
*        THIS ROUTINE IS ENTERED FROM WRITE IN SPITBOLX UPON NEED
*        FOR A VALUE TRACE TO BE PERFORMED.  REGISTERS ON ENTRY -
*        (A2)                     ADDRESS OF VARIABLE BLOCK
*        NOTE THAT A PROGRAMER DEFINED TRACE FUNCTION IS IN USE IF
*        A VIOPTR POINTS TO AN IOBLOK AND IOFUNC IS NON-ZERO
*        ON EXIT WRETLOC MUST BE RESTORED, AS MUST DB4 AND A2,A2+1
*        EXIT POINT DEPENDS UPON WHETHER A WRITE IS ALSO REQUESTED
*
VALTRACE LR    DB2,A2             POINT TO VAR BLOCK WITH SAFE REGISTER
         L     A2,V$TRACE         PICK UP &TRACE FOR PDTRC CALL
         SH    A2,H1              DECREMENT AND TEST VALUE OF &TRACE
         BM    VALTEXIT           SKIP TRACE IF &TRACE IS TURNED OFF
         CE    ZR,VIOPTR(,DB2)    DO WE POINT TO AN IOBLOK?
         BE    VALTSTD            SKIP IF NO IOBLOK (NO TRACE INFO)
         L     R1,VIOPTR(,DB2)    ELSE LOAD ADDRESS OF IOBLOK
         CE    ZR,IOFUNC(,R1)     IS THERE A PROG DEFINED TRACE FUNC
         BE    VALTSTD            SKIP IF NO FUNC DEFINED
*
*        COME HERE WITH R1 SET UP TO CALL PDTRC ROUTINE
*
         BAL   A2+1,PDTRCL        MAKE ENTRY FOR (R1) SETUP CASE
         NOP   0                  IMPOSSIBLE RETURN
         ST    RETURN,WRETLOC     RESTORE WRETLOC FOR WRITE
         B     VALTEXIT           AND EXIT FROM TRACE
*
*        COME HERE TO PRINT STD TRACE LINE WITH NAME = VALUE
*        NOTE THAT DUMPNVAL IS NOT USED SINCE IT REQUIRES FRETURN SAVE
*
VALTSTD  ST    A2,V$TRACE         SAVE UPDATED VALUE OF &TRACE
         BAL   A2,FTRCINIT        INITIALIZE LINE, SKIP &TRACE DECR
         LM    A1,A1+1,VNAME(DB2) LOAD STRING NAME FOR VARIABLE
         BAL   RETURN,LINESTR     ADD IT TO TRACE LINE
         LM    A1,A1+1,VALUE(DB2) LOAD VALUE ASSIGNED
         BAL   A2,LINEQVAL        PUT VALUE ON LINE AFTER C' = '
         BALR  A2,LINE$           AND PRINT THE LINE
*
*        COME HERE TO RETURN TO WRITE ROUTINE
*
VALTEXIT LR    A2,DB2             RESTORE VARIABLE BLOCK ADDRESS REG
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
         L     DB4,PSTRING+4(,PDR)          RESTORE DATA BASE ADDRESS
         L     A2+1,=A(WRITE)     LOAD BASE ADDRESS
         USING WRITE,A2+1         TELL ASSEMBLER
         TM    VFLAGS(A2),VOUA    IS A WRITE REQUESTED?
         BZ    WRITEX             OFF TO EXIT IF NOT
         LM    A1,A1+1,VALUE(A2)  ELSE RESTORE OUTPUT VALUE REGSITERS
         B     WRITE0             AND OFF TO GIVE OUTPUT REQUESTED
         DROP  A2+1               GET RID OF BASE REGISTER
         EJECT
*
*        LINEQVAL -- PRINT C' = ' FOLLOWED BY VALUE IN A1,A1+1 AT DB3
*
LINEQVAL MVC   0(3,DB3),DMPBEB    MOVE IN C' = '
         LA    DB3,3(,DB3)        PUSH BUFFER POINTER PAST IT AND MERGE
*
*        LINEVAL -- PRINT THE VALUE IN A1,A1+1 AT CURRENT DB3 LOC
*
LINEVAL  STM   A1,A2,LINESV       STORE ARGUMENT AND LINKAGE
         CLI   LINESV,NCODE       IS VALUE NULL
         BCR   E,A2               PRINT NOTHING IF NULL
         CLI   LINESV,SCODE       IS IT STRING?
         BNE   *+12               SKIP IF NOT
         MVI   0(DB3),C''''       MOVE IN INITIALI QUOTE IF STRING
         LA    DB3,1(,DB3)        ADJUST DB3 FOR QUOTE
         CLI   LINESV,MCODE       NAME?
         BNE   LINEVAL1           SKIP IF NOT
*
*        FOR NAMES REFERRING TO A SIMPLE VARIABLE, PRINT .NAME
*
         BAL   RETURN,GETSTGS     TRY TO CONVERT TO STRING
         B     LINEVAL1           NOT SIMPLE VAR IF NOT CONVERTIBLE
         MVI   0(DB3),C'.'        ELSE SET PERIOD ON TRACE LINE
         LA    DB3,1(,DB3)        BUMP PAST PERIOD AND MERGE
*
*        MERGE HERE TO CONVERT TO STRING OR GET DATATYPE
*
LINEVAL1 BAL   RETURN,GETSTGS     GET STRING FOR PRINTING
         BAL   RETURN,$$DTTP      GET DATATYPE IF UNCONVERTIBLE
         BAL   RETURN,LINESTR     GO PRINT STRING OUT
         LM    A1,A2,LINESV       RESTORE ARGUMENTS
         CLI   LINESV,SCODE       WAS IT A STRING?
         BNE   LINEVAL2           IF NOT, GO CHECK FOR ID PRINT
         MVI   0(DB3),C''''       ELSE MOVE TERMINAL QUOTE FOR STG
         B     DMPCHK1            BUMP PAST QUOTE, CHECK FOR OVERFLOW
*
*        COME HERE TO CHECK FOR CALL FROM DUMP REQUIRING ID NUMBER
*
LINEVAL2 CLI   LINESV,DCODE       IS IT PROG DEFINED DATATYPE?
         BE    LINEPDID           OFF TO DUMP ITS ID IF SO
         CLI   LINESV,TCODE       IS THIS A TABLE?
         BE    LINEVALT           OFF TO PRINT INFO IF TABLE
         CLI   LINESV,ACODE       IS THIS AN ARRAY?
         BCR   NE,A2              RETURN TO CALLER IF NOT
*
*        COME HERE IF OBJECT IS AN ARRAY TO GET SPECIFIER
*
         LM    A1,A1+1,ASPEC(A1)  LOAD PROTOTYPE
         B     LINEVAL3           AND MERGE WITH TABLE
         EJECT
*
*        COME HERE FOR TABLE VALUE
*
LINEVALT L     A1+1,TBDIVIDE(,A1) LOAD NUMBER OF SLOTS * 4
         SRL   A1+1,2             /4 EQUALS NUMBER OF SLOTS
         SR    A1,A1              INDICATE INTEGER TYPE CODE
*
*        TABLE AND ARRAY MERGE HERE WITH PROTOTYPES IN A1,A1+1
*
LINEVAL3 MVI   0(DB3),C'('        MOVE IN LEFT PARENTHESIS
         LA    DB3,1(,DB3)        AND BUMP PAST IT
         MVC   LINEIDSV(12),LINESV          SAVE ORIGINAL CALL INFO
         BAL   A2,LINEVAL         PUT VALUE ON LINE
         LM    A1,A2,LINEIDSV     RECOVER CALL REGISTERS
         MVC   0(3,DB3),DMPRPB#   MOVE IN C') #'
*
*        PROGRAMER DEFINED DATATYPE MERGES HERE
*
LINEVAL4 LH    A1+1,2(,A1)        PICK UP POSSIBLE ID NUMBER
         LTR   A1+1,A1+1          TEST FOR ID NUMBER
         BZ    DMPCHK1            BUMP PAST ) AND CHK FOR OVERFLOW IF
*                                 NO ID PRESENT
         LA    DB3,3(,DB3)        ELSE BUMP PAST # FOR ID
         SR    A1,A1              INDICATE INTEGER RESULT
         B     LINEVAL            OFF TO PRINT NUMBER AND RETURN
*
*        COME HERE FOR PROGRAMER DEFINED DATATYPE
*
*        THE DUMP FUNCTION MERGES HERE WITH (A1) POINTING TO THE BLOCK
*
LINEPDID MVC   0(2,DB3),DMPB#     MOVE C' #' ONTO LINE
         BCT   DB3,LINEVAL4       BACK UP DB3 FOR MERGE AND MERGE
*
DMPRPB#  DC    C')'               RIGHT PAREN FOR TABLE AND ARRAY
DMPB#    DC    C' #'              ' #' FOR ID NUMBER PRINTING
         EJECT
*
*        LINESTR -- PRINT STRING VALUE IN A1,A1+1 AT DB3 POINTER
*        CALLED ON RETURN
*
LINESTR  LR    R1,A1+1            COPY OFFSET/LENGTH
         SRL   R1,16              ISOLATE OFFSET
         AR    A1,R1              ADD OFFSET TO BASE
         N     A1+1,=X'00007FFF'  ISOLATE SLENGTH
*
*        LOOP GONE THROUGH MORE THAN ONCE IF WE DO NOT FIT ON ONE LINE
*
LINESTRL LA    R2,TBUFSIZE-1(,FR) END OF BUFFER-1 FOR 360 LENGTH CHECK
         SR    R2,DB3             CALCULATE NUMBER OF COLS LEFT ON LINE
         BM    LINESPRT           IF OVERFLOW, GO PRINT LINE
         CR    R2,A1+1            WILL STRING FIT ON THIS LINE
         BNL   LINESFIT           SKIP IF IT WILL
         EX    R2,LINESMV         ELSE MOVE IN WHATEVER WILL FIT
         LA    R2,1(,R2)          ADJUST FOR 360 LENGTH
         AR    A1,R2              PUSH STRING POINTER
         SR    A1+1,R2            DECREMENT COUNT
         LA    DB3,TBUFSIZE(,FR)  INDICATE FULL BUFFER
*
*        COME HERE TO PRINT A LINE
*
LINESPRT BALR  A2,LINE$           TERMINATE LINE
         B     LINESTRL           AND LOOP BACK
*
*        COME HERE WHEN WE CAN FIT ON THIS LINE
*
LINESFIT EX    A1+1,LINESMV       MOVE REST OF (OR ALL OF) STRING
         LA    DB3,1(DB3,A1+1)    BUMP PAST PART MOVED
         BR    RETURN             RETURN TO CALLER
*
LINESMV  MVC   0(*-*,DB3),SCHARS(A1)        MOVE CHARS TO BUFFER
         EJECT
*
*        TRACLABL -- ROUTINE TO PRINT TRACE OF TRANSFER TO LABEL
*
*        WHEN A TRACED LABEL IS TRANSFERED TO, THE TRANSFER IS MADE
*        TO A BLOCK IN FREE CORE.  THIS BLOCK CALLS LABTRAC, SETTING
*        DB2 TO AN ADDRESS WITHIN THE FREE CORE BLOCK
*        THE FREE CORE BLOCK CONTAINS THE REAL LABEL ADDRESS AND
*        THE ADDRESS OF THE VARIABLE BLOCK
*        NOTE THAT LABELS ARE ALSO TRACED ON FUNCTION CALL
*
LABTRACC L     A2,V$TRACE         LOAD VALUE OF &TRACE
         SH    A2,H1              DECREMENT AND TEST VALUE
         BM    LABTRACX           EXIT IF &TRACE NOT ON
         CE    ZR,LTFUNC-LTOFFSET(,DB2)     DO WE HAVE PDT FUNCTION?
         BNE   LABTFUNC           OFF TO HANDLE IT IF PRESENT
         ST    A2,V$TRACE         STORE UPDATED &TRACE VALUE
         ST    RETURN,RETLOC      STORE FOR USE BY CALCSTNO
         BAL   A2,FTRCINIT        INITIALIZE TRACE OUTPUT
         MVC   0(12,DB3),TRCLBMSG MOVE IN LABEL TRACE MESSAGE
         LA    DB3,12(,DB3)       BUMP PAST MESSAGE
         L     R1,LTBLOCK-LTOFFSET(,DB2)    LOAD VAR BLOCK ADDRESS
         LM    A1,A1+1,VNAME(R1)  LOAD VARIABLE BLOCK NAME
         BAL   RETURN,LINESTR     PUT NAME ON OUTPUT LINE
         BALR  A2,LINE$           PRINT LINE
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
*
*        COME HERE AT END OF TRACE OR IF &TRACE LE ZERO
*
LABTRACX L     R1,LTGOTO-LTOFFSET(,DB2)     LOAD TRANSFER ADDRESS
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
         BR    R1                 AND OFF TO STATEMENT
*
*        COME HERE IF WE HAVE A PROG TRACE FUNC TO INVOKE
*
LABTFUNC LA    R1,LTTAG-TRTAG-LTOFFSET(,DB2)          GET ADDR OF PSEUD
*                                 TRBLOK FOR PDTRC CALL
         BAL   A2+1,PDTRCL        CALL THE FUNCTION
         NOP   0                  IMPOSSIBLE TO RETURN HERE
         L     R1,VLABL(,DB2)     LOAD ADDRESS OF LTBLOK OR CODE
         L     DB2,$$BAS2         RESTORE DB2
         CLI   0(R1),LTBLOK       DID SOMEONE GET RID OF LTBLOK?
         BCR   NE,R1              OFF TO CODE IF THEY STOPTRED
         L     R1,LTGOTO(,R1)     ELSE LOAD CODE ADDR FROM LTBLOK
         BR    R1                 AND OFF TO IT
*
TRCLBMSG DC    C'TRANSFER TO '    MESSAGE LINE FOR LABEL TRACE
         EJECT
*
*        COME HERE IF THIS IS FAILURE CASE, NOGOTO, -FAIL SET
*
*        IN THIS SITUATION, THE GENERATED CODE SETS FRETURN TO DB1 TO
*        REDUCE THE LENGTH OF THE GENERATED CODE. THIS IS DONE ON THE
*        BASIS THAT A FAILURE IS UNLIKELY IN SUCH A STATEMENT. THIS
*        SECTION IS USED IF SUCH A FAILURE DOES OCCUR. THE FAILURE
*        BRANCH POINT IS THE FOLLOWING STATEMENT WHICH IS LOCATED BY
*        SCANNING TO THE NEXT AUR STATEMENT. NOTE THAT THIS PROCEDURE
*        IS USUALLY FAIRLY FAST SINCE THE CODE LOCATION POINTS
*        NEAR THE END OF THE STATEMENT IN MOST SIMPLE INSTANCES.
*        NOTE ALSO THAT IN THE CASE WHERE NO FAILURE OCCURS, THE
*        EXECUTION TIME IS REDUCED SINCE THE BALR, LA SEQUENCE
*        IS REPLACED BY A SINGLE LR INSTRUCTION.
*
READFAIL LA    R1,0(,RETURN)      COPY CALL ADDRESS
         SH    R1,H2              BACK OFF TWO BYTES FOR LOOP
         BALR  R2,0               SET START OF LOOP ADDRESS
         CLI   2(R1),X'3E'        AUR INSTRUCTION?
         LA    R1,2(,R1)          BUMP POINTER ANYWAY
         BCR   NE,R2              LOOP BACK IF NOT AUR
         BR    R1                 ELSE JUMP TO CODE (AT AUR INSTRUC)
         EJECT
*
*        COME HERE TO DO A GARBAGE COLLECTION BEFORE TRACING
*
FNCTGBG  BAL   RETURN,GBGCL0      CALL GARBAGE COLLECTOR
         L     RETURN,RETFLOC(,PDR)         RESTORE RETURN VALUE
*
*        COME HERE TO TEST FOR COLLECT NEEDED BEFORE TRACING
*
FNCTRC   CR    FR,PDR             DO WE NEED A COLLECT?
         BNL   FNCTGBG            OFF TO COLLECT IF SO
         SLR   A2,A2+1            FIX UP VALUE OF &TRACE AND TEST
         BZ    CFTRC              OFF TO TRY FTRACE IF &TRACE=0
*
*        COME HERE IF VALUE OF &TRACE NE ZERO
*
CTRC     TM    FFLAGS(DB3),VFTC   CHECK FOR POSSIBLE TRACE IN FBLOK
         BZ    CFTRC              OFF TO CHECK FOR FTRACE IF NO TRACE
         SH    A2,H1              DECREMENT AND TEST &TRACE
         BM    CFTRC              OFF TO TRY FTRACE IF NEGATIVE
         BAL   R1,FTRCNAME        SEARCE FOR NAME USED FOR CALL
         TM    VFLAGS(DB2),VFTC   IS THIS SPECIFIC FUNC TRACED?
         BZ    CFTRC              OFF TO TRY FTRACE IF NOT
         ST    A2,V$TRACE         STORE UPDATED &TRACE VALUE
         LA    R1,FCTRCCHN-TRCLINK          POINT TO START OF TRC CHAIN
         BAL   A2+1,PDTRC1        AND OFF TO SEARCH FOR PROG TRACE
         B     CFTRC1             DO OUR TRACE IF NO TRACE FUNC
         L     A2+1,V$FTRACE      LOAD &FTRACE IN (A2+1) FOR MERGE
         L     DB3,FBLOKLOC(,PDR) RESTORE BLOK ADDRESS
*
*        COME HERE TO TEST FOR MASTER FUNCTION TRACE (&FTRACE GT 0)
*
CFTRC    SH    A2+1,H1            DECREMENT AND TEST &FTRACE
         BM    CFLVTRC            OFF TO CHECK FOR FNCLEV TRC IF LE 0
         ST    A2+1,V$FTRACE      STORE UPDATED VALUE OF &FTRACE
         BAL   R1,FTRCNAME        FIND NAME USED IN CALL
*
*        AT THIS POINT (DB2) POINTS TO CALLING NAME
*
CFTRC1   ST    RETURN,RETLOC      STORE RETURN FOR CALCSTNO USE
         BAL   A2,FTRCINIT        SET UP TRACE LINE INFO
         MVC   0(24,DB3),FTCCMSG  MOVE IN MESSAGE
         L     R0,V$FNCLEV        LOAD FUNCTION LEVEL
         CVD   R0,STOPSV          CONVERT TO DECIMAL
         ED    16(4,DB3),STOPSV+6 EDIT IN FUNCTION LEVEL
         LA    DB3,24(,DB3)       BUMP BUFFER POINTER
         LM    A1,A1+1,VNAME(DB2) LOAD NAME OF CALLER
         BAL   RETURN,LINESTR     PLACE IT ON TRACE LINE
         MVI   0(DB3),C'('        MOVE IN LEFT PARENTHESIS
         LA    DB3,1(,DB3)        BUMP PAST IT
         L     DB2,FBLOKLOC(,PDR) LOAD FUNCTION BLOCK ADDRESS
         LH    FRETURN,FNARGS(,DB2)         LOAD NUMBER OF ARGUMENTS
         LTR   FRETURN,FRETURN    CHECK FOR NO ARGUMENT CASE
         BZ    CFTRC2             SKIP IF NO ARGUMENTS
         EJECT
*
*        LOOP TO DUMP OUT ARGUMENT VALUES
*
FTRACELP L     A1,FARGS(,DB2)     LOAD ADDRESS OF NEXT ARG NAME
         LM    A1,A1+1,VALUE(A1)  LOAD ARGUMENT VALUE
         BAL   A2,LINEVAL         PRINT VALUE
         MVI   0(DB3),C','        MOVE IN COMMA AFTER ARGUMENT
         LA    DB3,1(,DB3)        BUMP BUFFER POINTER
         LA    DB2,4(,DB2)        BUMP ARGUMENT NAME POINTER
         BCT   FRETURN,FTRACELP   LOOP BACK IF ARGUMENTS LEFT TO DUMP
         BCTR  DB3,0              DELETE LAST COMMA BY ADJUSTING PTR
*
*        COME HERE AFTER FINISHING ARGUMENTS
*
CFTRC2   MVI   0(DB3),C')'        PUT ON FINAL RIGHT PAREN
         BAL   A2,DMPCHK1         BUMP OVER ) AND CHECK FOR OVERFLOW
         BALR  A2,LINE$           TERMINATE LINE (PRINT IT)
         LM    FRETURN,RETURN,FRETFLOC(PDR) RESTORE RETURN AND FRETURN
*
*        AT THIS TIME WE MUST CHECK FOR &FNCLEVEL TRACE
*
CFLVTRC  L     R1,V$FNCLEV        LOAD VALUE OF &FNCLEVEL
         LA    R1,1(,R1)          INCREMENT IT
         ST    R1,V$FNCLEV        STORE UPDATED VALUE
         L     R1,FNCLTRC         LOAD POINTER TO TRACE INFORMATION
         BAL   DB2,KEYTRACE       OFF TO USE KEYWORD TRACING ROUTINE
         DC    Y(E$FNCLEV-INITVR1,8-1)      OFFSET, LENGTH FOR FNCLEVEL
         L     A1+1,V$FNCLEV      INSTRUCTION TO ACCESS VALUE
         L     DB4,FBLOKLOC(,PDR) RESTORE FBLOK ADDRESS
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
         B     FTRACECE           AND MERGE WITH FINAL CALL CODE
         EJECT
*
*        THIS ROUTINE IS CALLED TO DO FUNCTION RETURN TRACING
*        AS NECESSARY, DETERMINED BY THE SETTINGS OF &TRACE AND &FTRACE
*
RTRC     L     DB3,FBLOKLOC(,PDR) LOAD FUNCTION BLOCK ADDRESS
         TM    FFLAGS(DB3),VFTR   IS THERE AN INDIVIDUAL TRACE?
         BZ    RFTRC              CHECK FOR GLOBAL TRACE IF NOT SPECIAL
         SH    A2,H1              DECRECMENT &TRACE AND CHECK FOR ON
         BM    RFTRC              IF &TRACE IS OFF, CHECK &FTRACE
         BAL   R1,FTRCNAME        GET FUNCTION NAME USED IN CALL
         TM    VFLAGS(DB2),VFTR   SEE IF IT IS TRACED
         BZ    RFTRC              SKIP SPECIAL TRACE IF NOT
         ST    A2,V$TRACE         STORE UPDATED VALUE OF &TRACE
         LA    R1,FRTRCCHN-TRCLINK          POINT TO POTENTIAL CHAIN
*                                 OF PD TRACE FUNCTIONS
         SR    FRETURN,FRETURN    MAKE SURE THIS IS NOT RELOCATED
         IC    FRETURN,V$RETYPE   SAVE VALUE OF &RETYPE
         BAL   A2+1,PDTRC1        OFF TO CHECK FOR & DO PDTP
         B     RFTRC1             IF NO PROG DEF TRACE PROC, DO REG TRC
*                                 NOTE THAT &LASTNO=LAST STMT OF PDTP
         STC   FRETURN,V$RETYPE   RESTORE RETURN TYPE (? IS THIS OK?)
         L     A2+1,V$FTRACE      LOAD VALUE OF &FTRACE FOR MERGE
         L     DB3,FBLOKLOC(,PDR) RESTORE BLOK ADDRESS
*
*        COME HERE TO TEST FOR GLOBAL FUNCTION TRACING - CONTROLLED
*        BY THE SETTING OF &FTRACE
*
RFTRC    SH    A2+1,H1            DECREMENT AND TEST &FTRACE SETTING
         BM    RTRCFNCL           SKIP TRACE IF LE ZERO
         ST    A2+1,V$FTRACE      STORE UPDATED VALUE OF &FTRACE
         BAL   R1,FTRCNAME        GET NAME USED FOR FUNCTION CALL
*
*        COME HERE WITH DB2 POINTING TO NAME USED IN CALL
*        TO DO A SYSTEM TRACE - ALSO COME HERE IF NO 4TH ARG TO TRACE
*
RFTRC1   ST    RETURN,RETLOC      SAVE FOR STATEMENT NUMBER CALC
         BAL   A2,FTRCINIT        SET UP TRACE LINE FOR FUNCTION
         MVC   0(24,DB3),FTRCMSG  MOVE IN POTENTIAL TRACE MSG
         L     R0,V$FNCLEV        LOAD 'FROM' FUNCTION LEVEL
         BCTR  R0,0               CALCULATE 'TO' FUNCTION LEVEL
         CVD   R0,STOPSV          GET IN PACKED DECIMAL
         ED    16(4,DB3),STOPSV+6 PUT ON LINE IN READABLE FORM
         CLI   V$RETYPE,4         TEST TYPE OF RETURN
         BL    FTRACER1           SKIP IF TYPE = 'RETURN'
         MVC   1(6,DB3),FTRCMSG   SHIFT 'RETURN' ONE POSITION RIGHT
         MVI   0(DB3),C'F'        PROVISIONALLY INDICATE FRETURN
         BE    FTRACER1           DONE IF IT WAS FRETURN CASE
         MVI   0(DB3),C'N'        ELSE THIS WAS A NRETURN
         EJECT
*
*        COME HERE WITH RETURN TYPE SET UP IN MESSAGE
*
FTRACER1 LA    DB3,24(,DB3)       BUMP PAST MEESAGE
         LM    A1,A1+1,VNAME(DB2) LOAD FUNCTION NAME
         BAL   RETURN,LINESTR     ADD IT TO TRACE LINE
         CLI   V$RETYPE,4         CHECK FOR FAILURE RETURN
         BE    FTRACER2           MESSAGE COMPLETE IF FAILURE
         L     R1,FBLOKLOC(,PDR)  LOAD FUNCTION BLOCK ADDRESS
         L     R1,FNAME(,R1)      LOAD ADDRESS OF VARIABLE THAT
*                                 CONTAINS THE RETURNED VALUE
         LM    A1,A1+1,VALUE(R1)  LOAD THE RETUNED VALUE
         BAL   A2,LINEQVAL        PRINT RETURNED VALUE AFTER C' = '
*
*        COME HERE TO PRINT THE LINE OF TRACE OUTPUT
*
FTRACER2 BALR  A2,LINE$           TERMINATE THE LINE
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
*
*        COME HERE TO CHECK FOR AND GIVE &FNCLEVEL TRACE
*
RTRCFNCL L     R1,V$FNCLEV        LOAD &FNCLEVEL TO CHANGE VALUE
         BCTR  R1,0               DECREMENT IT
         ST    R1,V$FNCLEV        AND STORE UPDATED VALUE
         L     R1,FNCLTRC         LOAD TRACE INFORMATION FOR FNCLEVEL
         BAL   DB2,KEYTRACE       CALL STANDARD KEYWORD TRACE ROUTINE
         DC    Y(E$FNCLEV-INITVR1,8-1)      OFFSET,LENGTH FOR FNCLEVEL
         L     A1+1,V$FNCLEV      INSTRUCTION TO ACCESS & VALUE
*
*        COME HERE TO EXIT FROM RETURN TRACING PROCEDURE
*
RFTRCX   L     DB3,=A(RSTORE+2)   SET UP OLD BASE REGISTER
         L     DB2,$$BAS2         RESTORE DB2
         USING RSTORE+2,DB3       TELL ASSEMBLER
         B     FTRACERE           AND MERGE PAST FNCLEV STORE
         DROP  DB3
*
*        THIS ROUTINE SHOULD GIVE THE NAME ACTUALLY USED IN THE CALL
*        HOWEVER BECAUSE OF PROBLEMS WITH APPLY CALLS IT GIVES FNAME
*
FTRCNAME L     DB2,FNAME(,DB3)    LOAD NAME OF FUNCTION
         BR    R1                 AND RETURN TO CALLER
*
FTRCMSG  DC    C'RETURN  TO LEVEL '         START OF MESSAGE
         DC    X'202120'          EDIT PATTERN FOR LEVEL
         DC    C' OF '            REST OF MESSAGE
*
FTCCMSG  DC    C'CALL  FROM LEVEL '         START OF MESSAGE
         DC    X'202120'          EDIT PATTERN FOR LEVEL
         DC    C' OF '            REST OF MESSAGE
         EJECT
*
*        THIS ROUTINE IS CALLED TO TRACE CERTAIN KEYWORDS
*        INITIALLY A CHECK IS MADE TO DETERMINE IS TRACE NECESSARY
*
*        CONDITIONS ON ENTRY
*        (R1)                     CONTAINS ADDRESS OF TRBLOK IF 4 ARGS
*                                 NEGATIVE - NO FUNCTION ADDRESS GIVEN
*                                 ZERO - UNTRACED KEYWORD
*        BAL   DB2,KEYTRACE       STANDARD KEYTRACE CALL
*        DC    Y(NAME OFFSET,360 LENGTH)
*        (INSTRUCTION TO BE EXECUTED TO LOAD KEYWORD VALUE)
*
KEYTRACE L     A2,V$TRACE         PICK UP VALUE OF &TRACE TO TEST/DEC
         SH    A2,H1              TEST AND DECREMENT SWITCH VALUE
         BM    8(,DB2)            SKIP ALL TRACES IF NOT SET
         LTR   R1,R1              CHECK FOR SPECIFIC TRACE ON KEYWORD
         BZ    8(,DB2)            EXIT IF NOT TRACED
         LA    A2+1,4(,DB2)       SET UP EXIT ADDRESS FOR POTENTIAL
*                                 PROG DEF TRACE PROCEDURE
         BP    PDTRCL             INVOKE PROCEDURE IF REQUESTED
         ST    A2,V$TRACE         ELSE SAVE UPDATED &TRACE VALUE
         ST    RETURN,RETLOC      SAVE RETURN ADDR, MAY BE USED FOR STN
         BAL   A2,FTRCINIT        INITIALIZE TRACE
         MVI   0(DB3),C'&&'       SET UP INITIAL & ON TRACE LINE
         LA    DB3,1(,DB3)        AND BUMP PAST IT
         L     A1,INITVPTR        LOAD POINTER FOR INITV NAMES
         AH    A1,0(,DB2)         ADD IN KEYWORD NAME OFFSET
         LH    A1+1,2(,DB2)       LOAD LENGTH OF KEYWORD NAME
         BAL   RETURN,LINESTR     ADD KEYWORD NAME TO TRACE LINE
         MVC   0(3,DB3),DMPBEB    ADD C' = '
         LA    DB3,3(,DB3)        SKIP OVER IT
         EX    0,4(,DB2)          LOAD KEYWORD VALUE IN A1+1
         SR    A1,A1              INDICATE INTEGER VALUE
         BAL   A2,LINEVAL         PUT VALUE ON TRACE LINE
         BALR  A2,LINE$           AND OUTPUT THE LINE
         L     RETURN,RETLOC      RESTORE RETURN VALUE
         B     8(,DB2)            AND RETURN TO CALLER
         EJECT
*
*        THE FOLLOWING SUBROUTINE IS USED TO CHECK FOR AND PERFORM
*        A PROGRAM DEFINED TRACE FUNCTION --
*
*        (R1)                     POINTS TO HEAD OF CHAIN OF TRBLOK'S
*        (DB2)                    PTR TO VARIABLE BLOCK (WITH MCODE)
*        BAL   A2+1,PDTRC1
*        -->   RETURN HERE IF THERE IS NO BLOCK ON THE CHAIN
*        -->   RETURN HERE AFTER FINDING BLOCK AND PERFORMING TRACE
*
PDTRC1   L     R1,TRCLINK(,R1)    MOVE OUT ON LINK OF BLOCKS
         LTR   R1,R1              TEST FOR END OF CHAIN
         BCR   Z,A2+1             'NO TRACE' RETURN IF NAME NOT ON LIST
         C     DB2,TRVBLK(,R1)    DOES THIS TRC BLOCK REFER TO OUR VAR?
         BNE   PDTRC1             LOOP BACK TO TEST MORE IF NOT
*
*        CALL THIS POINT WITH (R1) POINTING TO LOCATED TRBLOK
*
PDTRCL   SH    PDR,=Y(STACKSIZ)   BUMP STACK FOR STANDARD STUFF
         L     R0,PDRLOC          LOAD PREVIOUD LEVEL
         ST    R0,PDRBPTR(,PDR)   SET BACK POINTER ON STACK
         ST    PDR,PDRLOC         SET CURRENT LEVEL
         ST    A2+1,TRLINK(,PDR)  SAVE OUR LINKAGE
         ST    A2,TRVTRC(,PDR)    SAVE VALUE OF &TRACE
         STE   ZR,V$TRACE         TURN OFF &TRACE TO AVOID INF LOOP
         STM   FRETURN,RETURN,FRETFLOC(PDR) SAVE RETURN POINTERS
         LM    A1,A2+1,TRTAG(R1)  LOAD TAG,NAME & FUNC ADDRESS
         ST    A2,TRVBLOCK(,PDR)  SAVE ON STACK FOR RESTORE AFTER CALL
         L     A2+1,VFUNC(,A2+1)  LOAD FUNCTION ADDRESS FROM VAR BLOCK
         ST    A2+1,FBLOKLOC(,PDR)          PUT FUNC ADDR ON STACK
         STE   ZR,PNAME(,PDR)     INDICATE PNAME NOT IN USE FOR COLLECT
         SR    A2+1,A2+1          CLEAR OUT POSSIBL NAME OFFSET
         STM   A1,A2+1,TEM#2(PDR) STORE NAME/TAG AS ARGUMENTS
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
         LA    FRETURN,PDTRET     SAVE US FROM FRETURN
*
*        NOTE THAT THE FOLLOWING CODE MUST BE STANDARD FUNC CALL CODE
*
         LA    R0,2               WE HAVE TWO ARGUMENTS
         L     DB4,FBLOKLOC(,PDR) LOAD FUNCTION ADDRESS
         BAL   RETURN,FCODE(,DB4) CALL THE FUNCTION
PDTRET   EQU   *                  BOTH SUCCESS AND FAILURE RETURN HERE
         L     DB4,=A(DTERTNS)    RESTORE OUR BASE REGISTER
         L     R0,TRVTRC(,PDR)    LOAD UPDATED &TRACE VALUE FROM STK
         ST    R0,V$TRACE         AND STORE IN PROPER PLACE
         L     A2+1,TRLINK(,PDR)  RESTORE CALLER'S ADDRESS
         L     DB2,TRVBLOCK(,PDR) RETURN VARIABLE BLOCK ADDR IN DB2
         LM    FRETURN,RETURN,FRETFLOC(PDR) RESTORE CODE ADDRESSES
         LA    PDR,STACKSIZ(,PDR) RESTORE PROPER PDR LOCATION
         ST    PDR,PDRLOC         RESET CURRENT LOCATION
         B     4(,A2+1)           AND GIVE SUCCESS RETURN
         AUR   SCNT,SINC          DUMMY FOR CALCSTNO
         B     CALCPDTF           BRANCH TO PROPER ROUTINE
         EJECT
*
*        CALCSTNO -- CALCULATE STATEMENT NUMBER
*
*        ALTLOC OR RETLOC         CODE LOCATION
*        BAL   A2,CALCSTNO
*        (A1,A1+1)                INTEGER VALUE OF STATEMENT NUMBER
*        NOTE -- THIS ROUTINE MUST NOT USE R1
*
*        EVERY FEW STATEMENTS, THE GENERATED CODE CONTAINS A NOP
*        INSTRUCTION WHOSE THIRD AND FOURTH BYTES CONTAIN THE CURRENT
*        STATEMENT NUMBER. NORMALLY, THIS NOP INSTRUCTION IMMEDIATELY
*        FOLLOWS THE AUR AT THE START OF THE STATEMENT. THE EXCEPTION
*        TO THIS RULE OCCURS IN CODE GENERATED AT EXECUTION TIME WHERE
*        ANOTHER NOP INSTRUCTION (CONTAINING AN OFFSET TO THE START
*        OF THE CODE BLOCK) PRECEDES THE STATEMENT NUMBER NOP.
*        IN CERTAIN CASES (E.G. TRACE FUNCTION CALLS), THE CODE ADDR IS
*        WRONG. IN THESE CASES, THE CALL POINT IS FOLLOWED BY A DUMMY
*        AUR FOLLOWED BY A BRANCH TO A SPECIAL ROUTINE WHICH LOCATES
*        THE REAL CODE LOCATION AND MERGES BACK.
*
*        ANOTHER SPECIAL CASE ARISES FROM EXECUTION OF EXPRESSION
*        CODE. THIS IS RECOGNIZED BY THE TERMINATING B $$EVLR INSTRUC
*
CALCSTNO LR    R0,PDR             SAVE ENTRY VALUE OF PDR
         L     A1,ALTLOC          LOAD ALTERNATE CODE LOCATION
         LTR   A1,A1              IS ONE IN USE?
         BNZ   *+8                SKIP IF ONE IS IN USE
         L     A1,RETLOC          ELSE LOAD STANDARD LOCATION
         SR    A1+1,A1+1          INITIALIZE STATEMENT NUMBER = 0
*
*        LOOP TO FIND AUR INSTRUCTIONS
*
         BALR  R2,0               SET START OF LOOP ADDRESS
         CLI   0(A1),X'47'        BRANCH INSTRUCTION?
         BE    CALCSTEX           JUMP TO TEST FOR END OF EXPR IF SO
         CLI   0(A1),X'3E'        IS THIS AN AUR INSTRUCTION?
*
*        MERGE BACK HERE FOR X'47' OPCODE NOT B $$EVLR
*
CALCSTMM LA    A1,2(,A1)          PUSH CODE POINTER
         BCR   NE,R2              LOOP BACK IF NOT AN AUR INSTRUCTION
*
*        COME HERE WHEN WE HAVE FOUND AN AUR INSTRUCTION
*
         BCTR  A1+1,0             COUNT DOWN STATEMENT NUMBER
         CLI   0(A1),X'47'        FOLLOWED BY NOP INSTRUCTION?
         BCR   NE,R2              LOOP BACK IF NOT
         CLI   4(A1),X'47'        TWO NOPS PRESENT (CODE CODE)?
         BNE   *+8                SKIP IF NOT
         LA    A1,4(,A1)          ELSE POINT TO THE NOP WE WANT
         EX    0,0(,A1)           EXECUTE POSSIBLE SPECIAL BRANCH
         AH    A1+1,2(,A1)        ELSE COMPUTE PROPER STATEMENT NUMBER
         SR    A1,A1              SET INTEGER TYPE CODE
         LR    PDR,R0             RESTORE ENTRY VALUE OF PDR
         BR    A2                 RETURN TO CALLER
         EJECT
*
*        CALCSTNO -- CONTINUED
*
*        WE COME HERE IF A X'47' (BRANCH) OPCODE IS DETECTED
*
*        THERE ARE THREE POSSIBLE CASES:
*
*        1)    THE B $$EVLR INSTRUCTION WHICH TERMINATES THE GENERATED
*              CODE FOR AN EXPRESSION. IN THIS CASE, THE SPECIAL
*              ROUTINE BELOW IS USED TO FIND THE 'REAL' CODE LOCATION.
*
*        2)    THE BRANCH USING INDEX REGISTER (2) WHICH BYPASSES
*              THE GENERATED CODE FOR AN EXPRESSION. IN THIS CASE, THE
*              SCAN LOCATION IS STEPPED PAST THE EXPRESSION CODE
*              AND THE CODE SCAN CONTINUES.
*
*        3)    ANY OTHER BRANCH INSTRUCTION. IN THIS CASE, WE MERELY
*              CONTINUE THE CODE SCAN.
*
CALCSTEX CLI   1(A1),X'F2'        UNCOND BRANCH WITH XREG (2)?
         BNE   CALCSTX1           SKIP IF NOT
*
*        HERE FOR BRANCH SKIPPING EXPRESSION CODE
*
         AH    A1,2(,A1)          STEP PAST EXPRESSION CODE
         BR    R2                 JUMP BACK TO CONTINUE SCAN
*
*        HERE IF NOT B ON XREG (2)
*
CALCSTX1 CLC   0(4,A1),BEVLR1     IS IT B $$EVLR?
         BNE   CALCSTMM           MERGE BACK IF NOT TO CONTINUE SCAN
*
*        HERE IF THE CODE POINTER POINTS TO THE TERMINATING BRANCH OF
*        AN UNEVALUATED EXPRESSION. THERE ARE SOME SITUATIONS IN WHICH
*        THE STACK IS PUSHED PAST THE UNEVALUATED EXPRESSION LEVEL
*        (E.G. LABEL TRACE) AND THE STACK MUST BE POPPED AN EXTRA TIME
*
         CE    ZR,FBLOKLOC(,PDR)  ARE WE DOWN TO THE PROPER LEVEL?
         BNZ   CALCPDTF           IF NOT, JUMP TO POP STACK EXTRA TIME
         SR    A1+1,A1+1          ELSE RESET STATEMENT NUMBER
         L     A1,RETFLOC(,PDR)   GET CODELOC IN CASE EVAL CALL
         TM    EVLINK(PDR),X'30'  CHECK CASES (PATTERN MATCH / EVAL)
         L     PDR,PDRBPTR(,PDR)  POP STACK TO PREVIOUS LEVEL
         BCR   NZ,R2              LOOP BACK (ALL SET) IF EVAL CASE
         L     A1,RETLOCP(,PDR)   ELSE LOAD PATTERN MATCH CODE LOC
         BR    R2                 AND LOOP BACK
*
*        SPECIAL CALCSTNO ROUTINE FOR PROGRAM TRACE FUNCTION CALL
*        ALSO USED TO POP BACK TO AN EXPRESSION LEVEL (SEE ABOVE)
*
CALCPDTF SR    A1+1,A1+1          RESET STATEMENT NUMBER COUNT
         L     A1,RETFLOC(,PDR)   LOAD ADDR OF CALLING CODE
         L     PDR,PDRBPTR(,PDR)  BACK UP TO NEXT LEVEL ON PDR
         BR    R2                 JUMP BACK TO MAIN SEARCH LOOP
         EJECT
*
*        THIS ROUTINE IS ENTERED FROM THE PROGRAM CHECK HANDLER
*        IF AN EXPONENT OVERFLOW OCCURS AS THE RESULT OF AN AUR
*        WHICH INCREMENTS THE STATEMENT COUNT REGISTER (SCNT)
*
*        THIS SITUATION CAN BE THE RESULT OF STLIMIT GREATER THAN
*        2**24, STCOUNT TRACING, A GENUINE STATEMENT COUNT (&STCOUNT)
*        OVERFLOW, OR IT CAN BE THE RESULT OF A TIMER OVERFLOW WHICH
*        IS SIGNALLED BY CAUSING A DUMMY STATEMENT COUNT OVERFLOW
*
STMOVER  L     DB4,=A(DTERTNS)    LOAD OUR BASE REGISTER
         STE   ZR,SCNTSAVE        STOP BAD PATTERN OPTIMIZATIONS ON
*                                 RETURN TO USER CODE
*
*        NOW DISTINGUISH BETWEEN REAL OVERFLOW AND TIMER OVERFLOW
*
         TM    STAGE,$OVERTIM     IS TIMER OVERFLOW FLAG SET?
         BO    $$TIME             OFF TO GIVE ERR MSG IF OVERTIME
*
*        COME HERE FOR STATEMENT COUNT OVERFLOW
*
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE
         L     R1,STCNTTRC        LOAD TRACE WORD FOR STCOUNT TRACE
         LTR   R1,R1              ARE WE BEING TRACED?
         BZ    AUROVER            NO TRACE IF SET TO ZERO
         L     R2,V$STCNT         ELSE LOAD AMOUNT COUNTED THUS FAR
         AH    R2,H1              INCREMENT IT
         C     R2,V$STLIM         HAVE WE EXCEEDED THE STATEMENT LIMIT?
         BH    AUROVER1           OFF TO GIVE ERROR MESSAGE IF SO
         ST    R2,V$STCNT         ELSE STORE UPDATED STCOUNT
         ST    RETURN,$$LAST      SAVE RETURN IN CASE LASTNO REFERENCE
         L     RETURN,SYSPSW+4    MAKE SURE AUR LOC IS RELOCATED
         BAL   DB2,KEYTRACE       PERFORM PROPER TRACE ACTION
         DC    Y(E$STCOUN-INITVR1,7-1)      STCOUNT OFFSET, LENGTH
         L     A1+1,V$STCNT       LOAD FOR TRACE ACCESS
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
*
*        NOW WE CAN RETURN TO THE CODE, NOTE THAT FRETURN IS PRESERVED
*
         LR    R1,RETURN          COPY LOCATION AFTER AUR
         L     RETURN,$$LAST      RESTORE RETURN FOR &LASTNO REF
         BR    R1                 JUMP TO CODE
         EJECT
*
*        COME HERE ON STATEMENT COUNT OVERFLOW WHEN STCOUNT IS
*        NOT BEING TRACED.
*
AUROVER  SU    SCNT,STSTART       CALCULATE HOW MANY STMTS EXECUTED
         STE   SCNT,STSTART       USE STSTART TO SAVE RESULT TEMP
         L     R2,STSTART         LOAD INTO GENERAL REGISTER
         LA    R2,0(,R2)          GET RID OF X'7F' EXPONENT
         A     R2,V$STCNT         ADD IN PREVIOUSLY COUNTED STMTS
         ST    R2,V$STCNT         SAVE NO. OF STMTS EXECUTED
         L     R1,SYSPSW+4        EXIT LOCATION = AUR ADDRESS
         S     R2,V$STLIM         GET NEGATIVE OF STMTS LEFT
         LCR   R2,R2              GET NO. STMTS LEFT TO EXECUTE
         BP    AUROVER2           SKIP IF WE HAVEN'T OVERFLOWED
*
*        COME HERE ON GENUINE STLIMIT OVERFLOW
*        WE WILL ALLOW 10 MORE STATEMENTS IN CASE OF SETEXIT
*
AUROVER1 LA    R2,10              ALLOW TEN MORE STATEMENTS
         L     R0,V$STLIM         LOAD STLIM TO FIX IT UP
         AR    R0,R2              INCREMENT IT BY TEN
         ST    R0,V$STLIM         AND STORE UPDATED VALUE
         MVC   RETLOC,SYSPSW+4    SAVE ERROR LOCATION FOR ERROR MSG
         LA    R1,AURERROR+2      LOAD PSEUDO EXIT ADDRESS=XERR CALL
*
*        COME HERE WITH NUMBER OF STATEMENTS LEFT TO EXECUTE IN R2
*
AUROVER2 LER   SCNT,SINC          START WITH 1 IF STILL TOO BIG
         C     R2,=X'00FFFFFF'    WILL WE FIT IN ONE SETTING
*                                 NOTE THAT WE CAN'T SET SCNT TO ZERO
         BNL   AUROVER3           SKIP IF TOO BIG FOR ONE SETTING
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE
         ST    R2,STSTART         USE STSTART AS TEMPORARY
         MVI   STSTART,X'7F'      SET UP EXPONENT
         SU    SCNT,STSTART       AND SET UP SCNT VALUE
*
*        COME HERE WITH SCNT SET UP TO RE-ENTER CODE
*        AT THE ADDRESS IN (R1) MINUS TWO
*
AUROVER3 STE   SCNT,STSTART       SAVE NEW INITIAL SCNT VALUE
         SH    R1,H2              BACK OFF TWO BYTES
         BR    R1                 OFF TO CODE
         EJECT
*
*        TRANSFER IS MADE TO THIS ERROR MESSAGE ON STCOUNT OVERFLOW
*
AURERROR L     FRETURN,SYSPSW+4   LOAD ADDRESS OF AUR INSTRUC + 2
         SH    FRETURN,H2         POINT TO AUR TO REEXECUTE ON CONTINUE
         XERR  11,006             STATEMENT LIMIT (&STLIMIT) EXCEEDED
*
*        COME HERE ON TRANSFER TO THE LABEL CONTINUE
*
L$CONTIN LM    FRETURN,RETURN,SETXTFRT      RESTORE TO/FROM REGISTERS
         STE   ZR,SETXTFRT        CLEAR TO SIGNAL ERROR PROCESSED
         TM    STAGE,$OVERTIM     CHECK OVERTIME IN CONTINUE LOOP
         BO    $$TIME             OFF TO SIGNAL IF OVERTIME
         LTR   FRETURN,FRETURN    TEST FOR PREVIOUSLY ISSUED ERROR
         BCR   NZ,FRETURN         FAIL IF ONE HAS BEEN ISSUED
         XERR  08,003,S           A TRANSFER TO THE LABEL CONTINUE
*                                 OCCURED, BUT NO PREVIOUS ERROR HAD
*                                 BEEN INTERCEPTED
*
*        COME HERE ON A TRANSFER TO THE LABEL ABORT
*
L$ABORT  L     DB4,=A(DTERTNS)    SET PROPER BASE REGISTER
         ST    RETURN,RETLOC      SAVE IN CASE OF NO PREVIOUS ERROR
         L     RETURN,SETXTRET    RESTORE ADDRESS OF STATEMENT IN ERR
         CE    ZR,V$ERRTYP        CHECK FOR PREVIOUS ERROR MESSAGE
         BNE   EXERRCS            IF ERR MSG STORE RETURN AND PRT ERROR
         XERR  08,004             A TRANSFER TO ABORT OCCURED, BUT NO
*                                 PREVIOUS ERROR HAD BEEN INTERCEPTED
*
*        COME HERE WHEN AN EXECUTION ERROR IS SIGNALLED
*
EXERR    LR    R1,RETURN          COPY CALL POINTER
         BCTR  R1,0               BACK OFF ONE BYTE
         CLI   0(R1),RETURN*16+SYS          CASE OF BALR RETURN,SYS?
         BE    EXERRCC            SKIP IF NORMAL ERROR CALL
*
*        COME HERE WHEN WE EXECUTE THE BR FRETURN WITH FRETURN SET TO
*        SYS WHICH OCCURS WHEN A STATEMENT HAVING NO S OR F GOTO FAILS
*        AND THE -NOFAIL OPTION WAS IN EFFECT
*
         XERR  02,001,S           FAILURE OF STATEMENT HAVING NO
*                                 CONDITIONAL GOTO WITH -NOFAIL
*                                 OPTION IN EFFECT
         EJECT
*
*        COME HERE FOR NORMAL ERROR PROCESSING
*
EXERRCC  SDR   ZR,ZR              FP ARITHMETIC MAY LEAVE GARBAGE IN ZR
         CLI   1(R1),6            CHECK FOR MEMORY OVERFLOW
         BE    *+10               IF SO, FATAL EVEN IF DURING CON EXPR
         LTER  SINC,SINC          ARE WE EVALUATING A CONSTANT EXPR?
         BZ    EXERRCN            SKIP (SPECIAL CASE) IF SO
         IC    A2+1,1(,R1)        PICK UP MAJOR ERROR CODE
         LA    A2,X'7F'           GET MASK VALUE (ALSO CLEAR FOR IC)
         NR    A2+1,A2            MASK OFF SPECIAL CONSTANT CODE BIT
         IC    A2,2(,R1)          PICK UP MINOR ERROR CODE
         MH    A2+1,=H'1000'      MAJOR CODE*1000
         AR    A2+1,A2            MAJOR CODE*1000 + MINOR CODE
         ST    A2+1,V$ERRTYP      SAVE FOR SETXIT USE, ETC.
*
*        MERGE HERE FROM KEYWORD CIRCUIT ON SETTING &ERRTYPE NON-ZERO
*
EXERRCM  L     R0,V$ERRLIM        LOAD LIMIT ON NUMBER OF ERRORS
         SH    R0,H1              DECREMENT IT FOR THIS ERROR
         BM    EXERRC             JUMP IF NO MORE ERRORS PERMITTED
*
*        HERE IF EXECUTION IS TO CONTINUE AFTER THE ERROR
*
         ST    R0,V$ERRLIM        SAVE NEW ERROR LIMIT
         MVI   ZTBL+C',',0        CLEAR POSSIBLE COMMA ENTRY
         MVI   ZTBL+C'(',0        CLEAR POSSIBLE LEFT PARENTHESIS ENTRY
         MVI   ZTBL+C')',0        CLEAR POSSIBLE RIGHT PAREN ENTRY
         MVI   ZTBL+C':',0        CLEAR POSSIBLE COLON ENTRY
         CE    ZR,FRETLOC         HAS FRETURN BEEN STORED?
         BE    *+8                SKIP IF NOT
         L     FRETURN,FRETLOC    ELSE LOAD PROPER FRETURN VALUE
         L     RETURN,ALTLOC      LOAD POSSIBLE ALTERNATE CODE LOC
         LTR   RETURN,RETURN      IS IT CORRECT?
         BNZ   *+8                SKIP IF WE ARE TO USE ALTERNATE LOC
         L     RETURN,RETLOC      ELSE LOAD STANDARD CODE LOC
         STE   ZR,FRETLOC         CLEAR POSSIBLE ALTERNATE FRETURN LOC
         STE   ZR,ALTLOC          CLEAR POSSIBLE ALTERNATE RETLOC
         L     PDR,PDRLOC         RESTORE PROPER PDR LOCATION
         L     R1,ETYPTRC         LOAD TRACE INFO FOR &ERRTYPE
         BAL   DB2,KEYTRACE       CALL KEYWORD TRACE ROUTINE
         DC    Y(E$ERRTYP-INITVR1,7-1)      ERRTYPE OFFSET, 360 LENGTH
         L     A1+1,V$ERRTYP      INSTRUCTION TO LOAD &ERRTYPE VALUE
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
         L     R2,EXITLOC         LOAD POSSIBLE SETEXIT ADDRESS
         STE   ZR,EXITLOC         DO NOT PERMIT ANOTHER INTERRUPT
         STM   FRETURN,RETURN,SETXTFRT      SAVE STATEMENT ADDRESSES
*                                 FOR ABORT AND CONTINUE
         LTR   R2,R2              DO WE HAVE A SETEXIT ADDRESS?
         BZ    L$CONTIN           DO AN AUTOMATIC CONTINUE IF NOT
         L     R1,VLABL(,R2)      LOAD LABEL TO TRANSFER TO
         BR    R1                 OFF TO IT LEAVING RETURN -> OLD STMNT
         EJECT
*
*        EXECUTION ERROR MESSAGE ROUTINE
*
*        ENTRY TO SAVE RETURN IN RETLOC (SEE ABORT)
*
EXERRCS  ST    RETURN,RETLOC      SAVE RETURN LOCATION
*
*        RETLOC                   CODE LOCATION
*        (R1)                     POINTS TO TWO BYTE MESG NUMBER
*
EXERRC   BAL   A2,CALCSTNO        GET STATEMENT NUMBER OF ERROR
         BAL   FRETURN,PRMSG      PRINT MESSAGE
         DC    AL2(30-1)          MESSAGE LENGTH + EDIT PATTERN FLAG
         DC    CL30'1EXECUTION ERROR IN STATEMENT '
         BALR  A2,LINE$           PRINT A BLANK LINE
*
*        NOW COMPUTE AND CONVERT ERROR CODE
*
         L     FRETURN,V$ERRTYP   LOAD ERROR MESSAGE CODE
         SR    R0,R0              CLEAR FOR DIVIDE
         LR    R1,FRETURN         COPY ERROR CODE FOR DIVIDE
         D     R0,=F'1000'        DIVIDE TO GET MAJOR CODE (/500!)
         LA    DB2,15*2           LOAD DEFAULT OFFSET TO ERR MSG
         AR    R1,R1              GET PROPOSED OFFSET TO ERROR MESSAGE
         BZ    EXERRC1            EXIT WITH DEFAULT IF NEW=0
         CR    R1,DB2             CHECK FOR MAJOR CODE OUT OF RANGE
         BNL   EXERRC1            EXIT WITH DEFAULT IF NOT IN RANGE
         LR    DB2,R1             ELSE USE ACTUAL ERROR CODE
*
*        NOW PRINT MESSAGE ITSELF
*
EXERRC1  LH    A1,EXERMA-2(DB2)   PICK UP MESSAGE OFFSET
         LA    A1,EXMSGS(A1)      POINT TO COUNT AND MESSAGE
         SR    A1+1,A1+1          CLEAR FOR IC
         IC    A1+1,0(,A1)        LOAD COUNT
         EX    A1+1,EXMSMV        MOVE MESSAGE INTO PLACE
         LA    DB3,1(A1+1,DB3)    BUMP OVER MESSAGE
         BALR  A2,LINE$           PRINT LINE
*
*        NOW PRINT CODE NUMBER (SAVED IN FRETURN)
*
         LR    A1+1,FRETURN       COPY CODE FOR PRMSG
         BAL   FRETURN,PRMSG      PRINT MESSAGE
         DC    AL2(0-11)          MESSAGE LENGTH + EDIT PATTERN FLAG
         DC    CL12'0ERROR CODE '
         B     XEQSTAT            JUMP TO PRINT EXECUTION STATISTICS
*
EXMSMV   MVC   0(*-*,DB3),1(A1)   MOVE ERROR MESSAGE TO BUFFER
         EJECT
*        EXECUTION ERROR MESSAGES
*        EACH MESSAGE IS GIVEN THE NAME XERRNN WHERE NN IS THE MSG NUMB
*        THE FIRST BYTE IS THE LENGTH - 1, THE REST IS THE MESSAGE
*
EXMSGS   EQU   *                  TABLE OF EXECUTION ERROR MESSAGES
1        XERM  'ILLEGAL DATATYPE'
2        XERM  'UNEXPECTED FAILURE'
3        XERM  'ERROR IN ARRAY REFERENCE'
4        XERM  'COMPILER DETECTED ERROR'
5        XERM  'ERROR IN KEYWORD REFERENCE'
6        XERM  'MEMORY OVERFLOW'
7        XERM  'EVALUATION OF GOTO FAILED'
8        XERM  'ERROR IN GOTO'
9        XERM  'CALL TO UNDEFINED FUNCTION OR OPERATOR'
10       XERM  'ERROR IN ARITHMETIC OPERATION'
11       XERM  'KEYWORD OR SYSTEM LIMIT EXCEEDED'
12       XERM  'INPUT/OUTPUT OR OTHER SYSTEM ERROR'
13       XERM  'INCORRECT VALUE FOR OPERATOR OR FUNCTION'
14       XERM  'VALUE RETURNED WHERE NAME IS REQUIRED'
15       XERM  'USER ISSUED ERROR MESSAGE'
*
*        THE XETB MACRO SETS UP A TABLE OF OFFSETS TO ERROR MESSAGES
*        THIS TABLE IS GIVEN THE ADDRESS EXERMA
*
         XETB
         EJECT
*
*        COME HERE IF AN ERROR OCCURS DURING EVALUATION OF A CONSTANT
*        EXPRESSION. IN THIS CASE, WE DO NOT WANT TO SIGNAL THE ERROR
*        AT THIS TIME, BUT RATHER WHEN THE CONSTANT EXPRESSION IS USED.
*
*        TO ACHIEVE THIS END, WE SEARCH AHEAD IN THE CONSTANT EXPR
*        CODE FOR THE AUR TERMINATING THIS EXPRESSION. JUST BEFORE IS
*        THE STM INTO THE CONSTANT EXPRESSION BLOCK. THUS WE CAN LOCATE
*        THIS BLOCK. THE SECOND WORD OF THE BLOCK CONTAINS A POINTER
*        TO THE CORRESPONDING LOAD SEQUENCE IN THE MAIN CODE. WE
*        THEN OVERWRITE THIS WITH AN APPROPRIATE XERR CALL.
*
*        (R1)                     POINTS 1 BYTE BEHIND XERR PARAMETERS
*        RETLOC                   CONTAINS LOC IN EXPR CODE
*
EXERRCN  L     RETURN,ALTLOC      RELOAD POSSIBLE CODELOC
         LTR   RETURN,RETURN      ALTERNATE LOCATION IN USE?
         BNZ   EXERRCNL           JUMP IF SO
         L     RETURN,RETLOC      ELSE CODELOC IS IN STANDARD LOCATION
*
*        LOOP TO SEARCH FOR AUR AT END OF EXPRESSION
*
EXERRCNL BALR  R2,0               SET START OF LOOP ADDRESS
         CLI   0(RETURN),X'3E'    AUR INSTRUCTION?
         LA    RETURN,2(,RETURN)  BUMP CODE POINTER ANYWAY
         BCR   NE,R2              LOOP BACK IF NOT AUR
*
*        HERE WE HAVE FOUND THE AUR INSTRUCTION
*
         SH    RETURN,H10         BACK OFF TO ADDRESS STM
         MVI   4(RETURN),X'41'    CHANGE LM A1,A1+1,
         MVI   5(RETURN),X'20'              INTO LA R2,
         CLI   0(RETURN),X'58'    STM PRECEDED BY A LOAD INSTRUCTION?
         BNE   *+8                SKIP IF NOT
         EX    0,0(,RETURN)       ELSE EXECUTE POSSIBLE LOAD OF DB4
         LM    DB2,DB3,$$BAS2     MAKE SURE DATA BASE REGS ARE SET
         EX    0,4(,RETURN)       NOW EXECUTE THE LA TO GET BLK ADDRESS
         L     R2,4(,R2)          LOAD ADDR OF LOAD IN MAIN CODE
         MVC   0(2,R2),SYSERCOD   SET XERR OPCODE
         MVC   2(2,R2),1(R1)      SET PROPER XERR PARAMETERS
         OI    2(R2),X'80'        SET FLAG TO ENSURE STORE OF RETURN
         L     PDR,PDRLOC         RESET PDR TO PROPER POINT IN CASE
         B     10(,RETURN)        AND GO COMPUTE NEXT EXPRESSION
         EJECT
*
*        COME HERE ON A TRANSFER TO THE LABEL END
*        NOTE THAT L$ SYMBOLS MUST BE IN SPITBOLX, SEE VARLOC
*
L$END    L     DB4,=A(DTERTNS)    SAME ACTION AS $$STOP FOR END TRANSFR
*
*        $$STOP MERGES HERE TO SAVE RETURN LOCATION FOR STNO DUMP
*
ENDLABEL ST    RETURN,ALTLOC      SAVE END STNO FOR POSSIBLE DUMP
         BAL   A2,CALCSTNO        GET NUMBER OF STATEMENT WE STOPPED IN
         BAL   FRETURN,PRMSG      PRINT MESSAGE
         DC    AL2(31)            MESSAGE LENGTH AND EDIT PATTERN FLAG
         DC    CL32'1NORMAL TERMINATION IN STATEMENT'
*
*        XEQSTAT                  PRINT EXECUTION STATISTICS
*
XEQSTAT  CE    ZR,ALTLOC          IS ALTLOC IN USE (= OK FOR DUMP)
         BNE   *+10               SKIP IF IN USE
         MVC   ALTLOC,RETLOC      ELSE MOVE IN COPY OF RETLOC
*
*        PRINT NUMBER OF STATEMENTS EXECUTED
*
         LTER  FA,SCNT            TEST AND COPY STATEMENT COUNTER REG
         BZ    *+8                SKIP SUBTRACT IF NO EXECUTION TRIED
         SU    FA,STSTART         SUBTRACT TO GET STATEMENT COUNT
         STE   FA,STOPSV          STORE COUNT
         MVI   STOPSV,0           CLEAR EXPONENT
         L     A1+1,STOPSV        LOAD TO GR
         A     A1+1,V$STCNT       ADD IN STATEMENTS ALREADY COUNTED
         LR    DB2,A1+1           COPY FOR USE LATER (MSEC/STATEMENT)
         BAL   FRETURN,PRMSG      PRINT MESSAGE
         DC    AL2(29)            LENGTH + EDIT PATTERN FLAG
         DC    CL30'0NUMBER OF STATEMENTS EXECUTED'
*
*        PRINT EXECUTION TIME
*
         L     R2,VSYSTIME        LOAD ADDR OF SYSTEM TIMER ROUTINE
         BALR  R1,R2              CALL SYSTEM TIMER ROUTINE
         NOP   0                  NO ERROR POSSIBLE
         S     R0,TIME            SUBTRACT TIME AT START OF EXECUTION
         LR    A1+1,R0            COPY FOR PRMSG
         BAL   FRETURN,PRMSG      PRINT MESSAGE
         DC    AL2(0-25)          LENGTH + EDIT PATTERN FLAG
         DC    CL26'0EXECUTION TIME (SECONDS)'
*
*        PRINT MSEC/STATEMENT
*
         LTR   DB2,DB2            TEST FOR NO STATEMENTS EXECUTED
         BZ    XEQSTAT1           SKIP THIS PRINT IF SO
         M     A1,=F'1000'        CONVERT XEQ TIME TO MICROSECS
         DR    A1,DB2             DIVIDE BY NUMBER OF STATEMENTS
         BAL   FRETURN,PRMSG      PRINT MESSAGE
         DC    AL2(0-15)          LENGTH + EDIT PATTERN FLAG
         DC    CL16'0MSEC/STATEMENT'
         EJECT
*
*        PRINT NUMBER OF STORAGE REGENERATIONS
*
XEQSTAT1 ZAP   STOPSV(8),GCOLCNT  SIMULATE CVD FOR PRMSG
         BAL   FRETURN,PRMSG+4    MERGE INTO PRMSG PAST CVD
         DC    AL2(31)            LENGTH OF MESSAGE + EDIT PATTERN
         DC    CL32'0NUMBER OF STORAGE REGENERATIONS'
*
*        NOW TEST FOR REQUESTED DUMP
*
         L     A1+1,V$DUMP        LOAD VALUE OF &DUMP
         LTR   A1+1,A1+1          DUMP REQUESTED?
         BZ    STOPRUN            SKIP IF NO DUMP REQUESTED
         L     DB4,=A(F$DUMP-FCODE)         POINT TO DUMP FUNCTION
         SR    A1,A1              SET INTEGER TYPE CODE
         STM   A1,A1+1,TEM#1(PDR) SET ARGUMENT FOR DUMP FUNCTION
         BAL   RETURN,FCODE(,DB4) CALL DUMP (NOTE DB4 IS RESET IN DUMP)
*
*        HERE WE RETURN TO THE SYSTEM MONITOR
*        WE RETURN NORMALLY OR BOMB DEPENDING ON SETTING OF &ABEND
*
STOPRUN  L     R0,V$CODE          LOAD VALUE OF &CODE (RETURN CODE)
         L     R2,=V(SYSEOJ)      GET ADDRESS OF EOJ ROUTINE
         CE    ZR,V$ABEND         SHOULD WE ABEND?
         BCR   E,R2               NORMAL END IF &ABEND = 0
         L     R0,V$ABEND         ELSE LOAD VALUE OF &ABEND
         L     R2,=V(SYSABEND)    LOAD ABEND ROUTINE ADDRESS
         BR    R2                 AND OFF TO IT
         EJECT
*
*        PRMSG -- ROUTINE TO PRINT MESSAGE AT END OF EXECUTION
*
*        (A1+1)                   BINARY VALUE OF PARAMETER TO EDIT
*        BAL   FRETURN,PRMSG
*        DC    AL2(LENGTH)        LENGTH OF MESSAGE (360 LENGTH)
*        DC    C'......MESSAGE.......'
*        -->   NORMAL RETURN
*
*        IF LENGTH IS POSITIVE, THE ARGUMENT IS EDITED AS AN INTEGER
*        IF LENGTH IS NEGATIVE, THREE DECIMAL PLACES ARE GIVEN
*
PRMSG    CVD   A1+1,STOPSV        EDIT ARGUMENT
         BAL   A2,LINEINIT        INITIALIZE BUFFER
         BCTR  DB3,0              BACK OFF TO POINT TO CTL CHAR
         MVC   1(34,DB3),0(DB3)   BLANK BUFFER
         LH    R1,0(,FRETURN)     LOAD MESSAGE LENGTH
         MVC   34(9,DB3),EDITP1   SET INTEGER EDIT PATTERN IN CASE
         LTR   R1,R1              TEST LENGTH
         BP    *+12               SKIP IF POSITIVE
         LPR   R1,R1              ELSE MAKE POSITIVE
         MVC   33(10,DB3),EDITP2  SET EDIT PATTERN FOR 3 DEC PLACES
         EX    R1,PRMSGM          MOVE MESSAGE
         ED    32(11,DB3),STOPSV+3          EDIT NINE DIGITS
         LA    DB3,43(,DB3)       BUMP PAST MESSAGE AND EDITED VALUE
         LA    A2,2+1(FRETURN,R1) POINT TO RETURN LOCATION
         BR    LINE$              PRINT LINE AND RETURN
*
EDITP1   DC    X'202020202020202120'        INTEGER EDIT PATTERN
EDITP2   DC    X'2020202021204B202020'      EDIT PATTERN WI 3 DEC PL
*
PRMSGM   MVC   0(*-*,DB3),2(FRETURN)        MOVE MESSAGE TO BUFFER
         TITLE 'SPITBOLX -- ROUTINE TO SET CODE INTERCEPTS FOR I/O'
*
*        IOASSOC IS A COMMON ROUTINE CALLED BY INPUT, OUTPUT AND TRACE
*        FOR INPUT ASSOCIATION  SEARCH OUT AND REPLACE:
*                                 LM    A1,A1+1,VALUE
*                                 LM    A2,A2+1,VALUE
*        FOR OUTPUT ASSOCIATION REPLACE:
*                                 STM   A1,A1+1,VALUE
*                                 MVI   NCODE,VALUE
*        FULLWORD INSTRUCTION FOUND IS REPLACED BY BALR DB1,DB1
*        FOLLOWED BY HALFWORD.  BITS 0 AND 1 ARE ALWAYS ON
*        BIT 2 IS ON IF THIS IS AN OUTPUT ASSOCIATION CASE
*        BIT 3 IS SET IF THE INSTRUCTION REFERENCES A1 AND A1+1
*        BITS 4-8 ARE USED TO INDICATE WHICH OF 32 BASE REGISTERS
*        BITS 9-15 INDICATE LOCATION OF VARIABLE BLOCK IN 32 BYTE INCR.
*
*        REGISTERS ON ENTRY:
*        A1    ADDRESS OF VARIABLE BLOCK
*        A1+1-A2+1  ARE SCRAP
*        DB2   SCRAP
*        DB3   X'80' FOR OUTPUT ASSOCIATION
*        DB3   X'70' FOR INPUT ASSOCIATION
*        DB4   A(IOASSOC)
*
*        REGISTERS IN PROGRAM:
*        R0    SCRAP
*        R1    POINTER TO NEXT BLOCK IN DYNAMIC MEMORY
*        R2    HALFWORD CODE ADDRESS, INITIALLY CODEADR
*        A1    ADDRESS OF VARIABLE BLOCK
*        A1+1  HALFWORD  L  DB4,0
*        A2    S ADDRESS OF DB4 TABLE ENTRY FOR THIS VARIABLE
*        A2+1  SWITCH FOR DB4 VALUE: 0 IF INCORRECT VALUE IN DB4
*              1 IF DB4 IS NOT USED OR IF CORRECT VALUE IS LOADED
*        DB2   S ADDRESS OF VARIABLE
*
*        REGISTERS ON EXIT:
*        A1    ADDRESS OF VARIABLE BLOCK
*        DB2-DB3                  RESTORED DATA BASE REGISTER VALUES
*
*        FLAGS USED BY IOASSOC ROUTINE
*
A1BIT    EQU   X'10'              SET ON IN PSEUDO CODE FOR LM A1,A1+1
STMBIT   EQU   X'10'              SET ON IN PSEUDO CODE FOR STM A1,A1+1
WRITEBIT EQU   X'20'              SET ON IN PSEUDO CODE FOR OUTPUT CASE
INFLAG   EQU   X'70'              FLAG FOR INPUT CALL (NE CC)
OUTFLAG  EQU   X'80'              FLAG FOR OUTPUT CALL (EQ CC)
         EJECT
*
*        ENTRY POINT
*
         USING IOASSOC,DB4        OUR BASE REGISTER
IOASSOC  LA    DB2,VALUE(,A1)     GET ADDRESS OF VALUE FIELD
         SR    R1,R1              INITIALIZE POINTER TO BASE TABLE
         LR    R2,DB1             POINT TO FIRST 4K BLOCK
         B     IOASSOCM           SKIP INTO LOOP
*
*        LOOP TO SEARCH FOR PROPER BASE TABLE ENTRY FOR VARIABLE
*
IOASSOC0 LA    R1,4(,R1)          BUMP TO NEXT TABLE ENTRY
         L     R2,$$BAS1(R1)      LOAD BASE VALUE
*
*        MERGE HERE FIRST TIME THROUGH LOOP WITH (R2) --> 1ST BLOCK
*
IOASSOCM CR    DB2,R2             COMPARE AGAINST VARIABLE ADDRESS
         BL    IOASSOC0           VAR BLK MUST BE GE, ELSE GET NEXT BAS
         LA    R0,4095(,R2)       GET END OF BLOCK (BASE REG) ADDRESS
         CR    DB2,R0             COMPARE AGAINST VARIABLE ADDRESS
         BH    IOASSOC0           VAR BLK MUST BE LE, ELSE LOOP BACK
*
*        FOUND THE ENTRY, INITIALIZE CODE SEARCH
*
         SR    DB2,R2             GET DISPLACEMENT VALUE
         LR    R0,R1              COPY BASE NUMBER*4
         SLL   R0,7-2             POSITION FOR IOASSOC CODE
         LR    R2,DB2             COPY DISPLACEMENT
         SRL   R2,5               /32 TO GET DBLWRD OFFSET FOR IO CODE
         ALR   R0,R2              GET IO CODE ADDRESS
         STH   R0,IOASSCOD+2      STORE FOR INSERTION IN CODE
         OI    IOASSCOD+2,X'C0'   SET ON BITS FOR CODE SEARCHES
         SR    A1+1,A1+1          DEFAULT PREVENTS L DB4 FROM BEING FND
         CH    R1,H12             IS THIS IN THE DB4 DOMAIN?
         BL    IOASSOC1           SKIP IF NOT
         LH    A1+1,IOLDB4        GET INSTRUCTION L  DB4,0 FOR CHECK
         LH    A2,DB4SAD          PREPARE SADR CALC FOR BASE TBL ENTRY
         ALR   A2,R1              GET BASE TABLE S ADDRESS
         LA    R1,(DB4-DB1)*4     SET UP TO GIVE DB4 AS BASE REGISTER
*
*        COME HERE TO CALCULATE VARIABLE BLOCK S ADDRESS
*
IOASSOC1 SLL   R1,12-2            POSITION BASE REGISTER NUMBER
         ALR   DB2,R1             ADD INTO DISPLACEMENT
         AH    DB2,VARBSAD        AND FINISH S ADDRESS CALCULATION
         CH    DB3,=Y(OUTFLAG)    IS THIS OUTPUT ASSOCIATION?
         BNE   *+8                SKIP IF NOT OUTPUT OR TRACE
         OI    IOASSCOD+2,WRITEBIT          SET TO INDICATE OUTPUT REF
         L     R1,DYNAMB          POINT TO START OF DYNAMIC MEMORY
         L     R2,CODEADR         POINT TO MAIN CODE BLOCK
*
*        LOOP THROUGH BLOCKS OF CODE (1ST MAIN BLOCK, THE CBLOK'S)
*
IOASSOCL LA    A2+1,IOASSVAR-IOASSRX        SET DB4 CORRECT SWITCH
         EJECT
*
*        LOOP TO EXAMINE CODE FOR REFS TO OUR VARIABLE OR DB4
*
IOASSOC2 TM    0(R2),X'C0'        TEST INSTRUCTION LENGTH
         BNM   IOASSRR            SKIP IF RR INSTRUCTION
         CH    DB2,2(,R2)         DOES RX REFER TO OURVARIABLE?
         BE    IOASSRX(A2+1)      TAKE ACTION DEPENDANT ON DB4 IF SO
*
*        COME HERE FOR RX INSTRUCTIONS TO CHECK FOR DB4 REFERENCES
*        NOTE THAT A1+1 IS ZERO UNLESS DB4 IS OUR BASE REGISTER
*        SO NO DB4 REFERENCES ARE FOUND UNLESS DB4 IS ACTUALLY NEEDED
*
IOASSRX  CH    A1+1,0(,R2)        IS THIS A L OF DB4? (ONLY IF DB4 USD)
         BNE   IOASSRX1           SKIP PAST IT IF NOT
         SR    A2+1,A2+1          INDICATE POTENTIAL INCORRECT DB4 VALU
         CH    A2,2(,R2)          CHECK FOR CORRECT LOAD OF DB4 FOR US
         BNE   IOASSRX1           SKIP PAST INSTRUCTION IF NOT
         LA    A2+1,IOASSVAR-IOASSRX        SET CORRECT DB4 VALUE IF OK
*
*        COME HERE TO SKIP OVER A FOUR BYTE INSTRUCTION
*
IOASSRX1 LA    R2,4(,R2)          BUMP PAST 4 BYTE INSTRUCTION
         B     IOASSOC2           LOOP BACK TO CONTINUE SEARCH
*
*        COME HERE ON 2 BYTE INSTRUCTION - CHECK FOR I/O CASE
*
IOASSRR  CLI   1(R2),DB3*16+DB1   CHECK FOR BALR DB3,DB1 (I/O CALL)
         BNE   IOASSRR1           OFF TO PUSH PAST 2 BYTES IF NOT
         B     IOASSRX1           ELSE TREAT AS 4 BYTES AND SKIP IT
*
*        COME HERE WHEN A REFERENCE TO OUR VARIABLE IS FOUND
*
IOASSVAR CLI   0(R2),X'98'        COM PARE OP CODE AGAINST LM
         EX    DB3,IOCHKBR        B IF NOT OP CODE FOR THIS CALL
         CLI   1(R2),A1*16+A1+1   IS THIS AN A1 REFERENCE?
         MVC   0(4,R2),IOASSCOD   MOVE IN CODE FOR IO CALL
         BNE   IOASSRX1           SKIP OVER CODE IF NOT A1 REFERENCE
         OI    2(R2),A1BIT        INDICATE A1,A1+1 REFERENCE
         B     IOASSRX1           AND OFF TO SKIP OVER CODE
         EJECT
*
*        COME HERE FOR TWO BYTE INSTRUCTION
*
IOASSRR1 CLI   0(R2),X'00'        IS IT X'0000' AT END OF CODE BLOCK?
         LA    R2,2(,R2)          BUMP POINTER ANYWAY
         BNE   IOASSOC2           LOOP BACK IF NOT TO CONTINUE SEARCH
*
*        HERE WE HAVE COMPLETED PROCESSING OF A CODE BLOCK
*        SEARCH DYNAMIC MEMORY FOR NEXT CBLOK TO PROCESS
*
IOASSBL  CR    R1,FR              ANY BLOCKS LEFT IN DYNAMIC MEMORY?
         BE    IOASSXT            JUMP IF NOT TO EXIT
         CLI   0(R1),CBLOK        ELSE IS NEXT BLOCK A CODE BLOCK?
         BNE   IOASSBM            SKIP IF NOT TO BUMP PAST BLOCK
         LA    R2,CODECODE(,R1)   ELSE POINT TO CODE TO BE PROCESSED
         A     R1,CODNLEN(,R1)    BUMP FREE CORE PTR PAST BLOCK
         B     IOASSOCL           AND LOOP BACK TO PROCESS CBLOK CODE
*
*        HERE TO BUMP PAST BLOCK IN FREE CORE NOT A CBLOK
*
IOASSBM  LR    R0,A1              SAVE VAR BLOCK POINTER
         LR    A1,R1              COPY BLOCK ADDRESS FOR BLOKLEN
         SR    R2,R2              CLEAR FOR IC
         IC    R2,DTYPE(,A1)      LOAD BLOCK CODE
         EX    0,BLOKLEN(R2)      GET LENGTH OF BLOCK
         AR    R1,R2              PUSH FREE CORE POINTER
         LR    A1,R0              RESTORE VARIABLE BLOCK POINTER
         B     IOASSBL            LOOP BACK TO LOOK FOR CBLOK'S
*
*        HERE AFTER PROCESSING ALL CBLOK'S IN DYNAMIC MEMORY
*
IOASSXT  LM    DB2,DB3,$$BAS2     RELOAD DATA BASE REGS
         BR    RETURN             RETURN TO CALLER
*
*        CONSTANTS FOR I/O ASSOCIATION ROUTINE
*
IOLDB4   L     DB4,0              INSTRUCTION FOR DB4 LOAD
         ORG   *-2                GET RID OF BASE AND DISPLACMENT
IOCHKBR  BC    *-*,IOASSRX1       EXECUTED TEST FOR PROPER VALUE REF
DB4SAD   DC    S($$BAS1)          S ADDRESS OF FIRST DATA BASE
VARBSAD  DC    S(0(DB1))          INDICATE DB1 AS A BASE REGISTER
*
         DROP  DB4                DROP IOASSOC BASE REG
         TITLE 'SPITBOLX -- EXECUTION INITIALIZATION ROUTINE'
*
*        HERE WE INITIATE EXECUTION PROPER. THERE ARE TWO CASES --
*
*        1)    COMPILE AND GO MODE. IN THIS CASE, WE COME HERE AFTER
*        COMPLETING THE COMPUTATION OF CONSTANT EXPRESSIONS
*
*        2)    LOAD MODE. IN THIS CASE, WE HAVE A PREVIOUSLY GENERATED
*        OBJECT MODULE AND CONTROL WAS PASSED FROM THE RELOAD ROUTINE
*
*        THE CODE FOR CASE 1 IS REQUIRED ONLY IN THE STANDARD MODULES,
*
         USING ECONC,FRETURN      BASE REG SET BY CALLER (EITHER CASE)
ECONC    DS    0H                 START OF ROUTINE
*
         AIF   (&LMOD NE 0).SKIPL10
*
*        HERE WE HAVE THE STANDARD CASE (CALLED FROM SPITBOLA)
*
         NI    HICINUSE+3,X'F8'   ALLIGN HIGH CORE TO DOUBLEWORD
         L     PDR,HICINUSE       LOAD NEW PDR (DELETE CONSTANT CODE)
         SH    PDR,=Y(STACKTOP)   ALLOW STANDARD PDR OFFSET
         MVI   CLLCTFL,X'FF'      SET SPECIAL COLLECT FLAG
         XC    LINKLOCS(ENDLINKS-LINKLOCS),LINKLOCS CLEAR LINKAGE LOCS
         STE   ZR,SRETSV          ZERO TABLE RETURN LOC
         BAL   RETURN,GBGCL0S     COLLECT SETTING VALID RETLOC ADDRESS
*                                 SO CODE SEARCH WORKS
         AUR   SCNT,SINC          DUMMY TO STOP CODE SEARCH (SINC=0)
*                                 NOTE: FRETURN MUST NOT BE RELOCATABLE
         MVI   CLLCTFL,0          RESET SPECIAL COLLECT FLAG
         BAL   RETURN,OBJGEN      CHECK FOR POSSIBLE OBJECT MOD GEN
         CLI   BYPASXEQ,0         TEST FOR -NOEXECUTE OPTION
         BZ    XEQGOGO            SKIP IF NOT (-EXECUTE)
         LA    A1,NOEXMSG         ELSE POINT TO MESSAGE
         LA    A1+1,L'NOEXMSG     SET LENGTH
         BAL   RETURN,XPRINTER    CALL ROUTINE TO PRINT ERROR MESSAGE
         SR    R0,R0              RETURN CODE = ZERO
         L     R2,=V(SYSEOJ)      POINT TO END OF JOB ROUTINE
         BALR  R1,R2              TERMINATE THIS RUN
*
NOEXMSG  DC    C'0EXECUTION SUPPRESSED'
.SKIPL10 ANOP
*
*        BOTH CASES MERGE HERE
*
XEQGOGO  ST    FR,DYNAMB          SET NEW START OF DYNAMIC MEMORY
         LE    SCNT,STSTART       LOAD INITIAL STATEMENT COUNT VALUE
         LE    SINC,=X'7F000001'  LOAD STATEMENT INCREMENT VALUE
         LCR   R0,PDR             GET NEGATIVE NON-ZERO VALUE = END STK
         ST    R0,FBLOKLOC(,PDR)  STORE AS END OF STACK MARKER
         ST    PDR,PDRLOC         INITIALIZE PDR LOCATION FOR THIS LEVL
         STE   ZR,PNAME(,PDR)     SET PNAME FLD NOT IN USE FOR GBGCLTR
         LM    DB2,DB3,$$BAS2     LOAD DATA BASE REGS
         EJECT
*
*        SET UP IOBLOKS FOR STANDARD FILES
*
         XC    0(3*IOBSIZE,FR),0(FR)        ZERO OUT 3 IOBLOKS
         MVI   0(FR),IOBLOK       SET PROPER BLOCK CODE
         ST    FR,B$OUTPUT+VIOPTR SET OUTPUT IOBLOK POINTER
         MVC   OFORMAT(4,FR),OUTFORMP       SET FORMAT = ONE BLANK
         MVC   OFILE(4,FR),PRINTDCB         SET SYSPRINT DCB POINTER
         LA    FR,IOBSIZE(,FR)    PUSH PAST FIRST IOBLOK
         MVI   0(FR),IOBLOK       SET PROPER BLOCK CODE
         ST    FR,B$INPUT+VIOPTR  STORE POINTER TO INPUT IOBLOK
         MVC   IFILE(4,FR),READDCB          SET POINTER TO SYSIN DCB
         LA    FR,IOBSIZE(,FR)    PUSH PAST THIS IOBLOK
         ST    FR,B$PUNCH+VIOPTR  STORE POINTER TO PUNCH IOBLOK
         MVI   0(FR),IOBLOK       SET PROPER BLOK CODE
         MVI   OFORMAT(FR),NCODE  SET FORMAT = NULL
         MVC   OFILE(4,FR),PUNCHDCB         COPY PTR TO SYSPUNCH DCB
         LA    FR,IOBSIZE(,FR)    PUSH PAST PUNCH IOBLOK
         LA    A1,NEWPAGE         POINT TO NEW PAGE CHARACTER
         LA    A1+1,1             LENGTH = ONE CHARACTER
         BAL   RETURN,XPRINTER    CALL ROUTINE TO PRINT TO GET EJECT
         MVI   CRELFLG,0          NO MORE NEED TO PROCESS CONSTANTS
         L     R2,=V(SYSTIME)     ADDRESS OF SYSTEM TIMER ROUTINE
         BALR  R1,R2              GET CURRENT TIME (START OF XEQ)
         NOP   0                  ERROR RETURN NOT POSSIBLE
         ST    R0,TIME            SAVE TIME AT START OF EXECUTION
*
*        NOW INITIATE EXECUTION UNLESS WE ARE OVERTIME
*
         L     R1,TRAADR          LOAD TRANSFER ADDRESS
         TM    STAGE,$OVERTIM     ARE WE OVERTIME?
         BO    $$TIME             SIGNAL OVERTIME IF SO
         CR    FR,PDR             ENOUGH ROOM TO START EXECUTION?
         BALR  RETURN,0           POINT RETURN FOR POSSIBLE &LASTNO REF
         BCR   L,R1               OFF TO CODE IF THERE IS ROOM
         B     GBGCL0S            COLLECT IF NOT ENOUGH ROOM
         AUR   SCNT,SINC          DUMMY AUR FOR CALCSTNO
         DC    X'47000001'        NOP 1 SO THAT &LASTNO = 0 FOR ABOVE
*
*        STANDARD FORMAT POINTER FOR OUTPUT IOBLOK (SYSPRINT)
*
OUTFORMP DC    AL1(SCODE)         STRING CODE
         DC    AL3(OUTFORM)       POINTER TO FORMAT
*
OUTFORM  EQU   *-SCHARS           START OF FORMAT - OFFSET
         DC    C' '               STANDARD OUTPUT FORMAT
*
NEWPAGE  DC    C'1'               CONTROL CHARACTER FOR NEW PAGE
         EJECT
*
*        SUBROUTINE TO PRINT A LINE ON SYSPRINT
*
*        (A1,A1+1)                ADDRESS/LENGTH OF MESSAGE
*        BAL   RETURN,XPRINTER
*        -->                      NORMAL RETURN
*
XPRINTER L     R0,PRINTDCB        POINT TO SYSPRINT DCB
         L     R2,XPRINTV         LOAD POINTER TO OUTPUT ROUTINE
         SR    A2+1,A2+1          SET UNFORMATTED MODE
         BALR  R1,R2              CALL SYSWRITE ROUTINE
         NOP   0                  IGNORE ERROR (PAGE LIMIT EXCEEDED)
         BR    RETURN             RETURN TO XPRINTER CALLER
         DROP  FRETURN            DONE WITH ECONC BASE REGISTER
*
XPRINTV  DC    V(SYSWRITE)        ADDRESS OF SYSTEM OUTPUT ROUTINE
         TITLE 'SPITBOLX -- OBJECT MODULE GENERATION'
*
*        THIS ROUTINE GENERATES AN OBJECT MODULE IF THE SYSOBJ FILE
*        HAS BEEN DEFINED. IT IS ONLY INCLUDED IN THE STANDARD MODULES
*
         AIF   (&LMOD EQ 1).SKIPS15
*
*        THE OBJECT MODULE GENERATED IS DESIGNED TO BE LINKED WITH THE
*        LIBRARY MODULES, AND CONSISTS OF TWO CONTROL SECTIONS --
*
*        SPITBOLL                 LOW SECTION OF ALLOCATED DATA AREA
*                                 UP TO THE NEW VALUE OF DYNAMB
*
*        SPITBOLH                 HIGH SECTION OF ALLOCATED DATA AREA
*                                 FROM HICINUSE ON
*
*        FIRST SEE IF WE SHOULD GENERATE AN OBJECT MODULE
*
         USING ECONC,FRETURN      BASE REG SET BY CALLER
OBJGEN   LA    A1,SYSOBJNM        POINT TO NAME = 'SYSOBJ'
         LA    A1+1,6             LENGTH = 6 CHARACTERS
         L     R2,VOPEN           LOAD ADDRESS OF SYSTEM ROUTINE
         BALR  R1,R2              CALL SYSTEM ROUTINE TO LOCATE DCB PTR
         B     0(,RETURN)         ALL DONE IF FILE NOT DEFINED
*
*        IF WE SHOULD, PERFORM APPROPRIATE INITIALIZATION
*
         ST    R0,OBJDCB          SAVE POINTER TO SYSOBJ DCB
         L     A2,HICINUSE        LOAD STARTING ADDRESS OF SPITBOLH
         SH    A2,H8              SUBTRACT MORE THAN SCHARS,VALUE SO
*                                 THAT ALL PTRS POINT WITHIN SPITBOLH
         ZAP   OBJSER,=P'0'       RESET SERIALIZATION COUNTER
         EJECT
*
*        FIRST GENERATE ESD CARD
*
*        THE FORMAT OF AN ESD CARD IS AS FOLLOWS --
*
*        COL 1                    12-2-9 MULTIPUNCH
*        COL 2-4                  ESD
*        COLS 11-12               NUMBER OF BYTES OF INFORMATION
*        COLS 15-16               ESID NUMBER OF FIRST SD ON THIS CARD
*        COLS 17-72               VARIABLE INFORMATION
*              8 POSITIONS        NAME
*              1 POSITION         TYPE (0=SD,1=LD,2=ER,3=PC,4=CM)
*              3 POSITIONS        ASSEMBLED ORIGIN
*              1 POSITION         BLANK
*              3 POSITIONS        CONTROL SECTION LENGTH
*        COLS 73-76               PROGRAM ID (= SPIT)
*        COLS 77-80               SEQUENCE NUMBER
*
         BAL   A1,OBJINIT         INITIALIZE BUFFER
         MVC   OBJBUFR(40),ESDMOD MOVE MODEL ESD CARD
         ST    DREG,OBJBUFR+24    STORE SPITBOLD ADDR + 0 = SD CODE
         LR    R0,FR              CURRENT END OF SPITBOLL
         SR    R0,DREG            - START = LENGTH
         ST    R0,OBJBUFR+28      STORE LENGTH OF SPITBOLL
         ST    DREG,SPITLAD       SET ADDRESS OF SPITBOLL
         MVI   OBJBUFR+28,C' '    BLANK UPPER BYTE
         ST    A2,OBJBUFR+40      STORE SPITBOLH ADDR + 0 = SD CODE
         LR    R2,DREG            START OF DATA AREA ADDR
         A     R2,DATASIZE        + TOTAL LENGTH
         SR    R2,A2              - SPITBOLH START = SPITBOLH LENGTH
         ST    R2,OBJBUFR+44      STORE LENGTH OF SPITBOLH
         ST    A2,SPITHAD         STORE ADDRESS OF SPITBOLH
         MVI   OBJBUFR+44,C' '    BLANK UPPER BYTE
         BAL   A1,OBJWRITE        WRITE ESD CARD
         EJECT
*
*        NOW WE GENERATE THE REQUIRED TEXT CARDS
*
*        THE FORMAT OF A TEXT CARD IS AS FOLLOWS
*
*        COL 1                    12-2-9 MULTI-PUNCH
*        COLS 2-4                 TXT
*        COLS 6-8                 ASSEMBLED ORIGIN
*        COLS 11-12               NUMBER OF BYTES OF TEXT
*        COLS 15-16               ESID NUMBER OF SD CONTAINING TEXT
*        COLS 17-72               UP TO 56 BYTES OF TEXT
*        COLS 73-76               PROGRAM ID (= 'SPIT')
*        COLS 77-80               SEQUENCE NUMBER
*
         LA    R0,2               SET SD NUMBER = 2 = NUMBER OF CSECTS
         LR    R1,A2              ADDR OF SPITBOLH (LENGTH IS IN R2)
*
*        LOOP TO GENERATE TEXT CARDS
*
TXTLOOP  BAL   A1,OBJINIT         INITIALIZE BUFFER
         MVC   OBJBUFR(4),TXTMOD  SET INITIAL BYTES
         ST    R1,OBJBUFR+4       STORE ADDR (= ASSEMBLED ORIGIN)
         MVI   OBJBUFR+4,C' '     BLANK UPPER BYTE
         STH   R0,OBJBUFR+14      STORE ESID NUMBER
         LA    A1,56              GET CONSTANT 56
         CR    R2,A1              CHECK NUMBER OF BYTES OF TEXT TO GO
         BNH   TXTPART            SKIP IF 56 BYTES OR LESS LEFT
         STH   A1,OBJBUFR+10      ELSE STORE TEXT LENGTH = 56
         MVC   OBJBUFR+16(56),0(R1)         MOVE 56 BYTES TO BUFFER
         SR    R2,A1              DECREMENT COUNT LEFT BY 56
         AR    R1,A1              PUSH TEXT POINTER
         BAL   A1,OBJWRITE        WRITE TXT CARD
         B     TXTLOOP            LOOP BACK FOR NEXT CARD
*
*        HERE TO GENERATE LAST TXT CARD OF A CONTROL SECTION
*
TXTPART  STH   R2,OBJBUFR+10      STORE ACTUAL NUMBER OF BYTES
         BCTR  R2,0               ADJUST FOR 360
         EX    R2,TXTMOVE         MOVE WHAT BYTES WE HAVE
         BAL   A1,OBJWRITE        WRITE LAST TXT CARD FOR CSECT
         LR    R1,DREG            POINT TO SPITBOLD
         LR    R2,FR              END OF SPITBOLD
         SR    R2,R1              - START = LENGTH
         BCT   R0,TXTLOOP         DECR ESID NUMBER & LOOP IF MORE TO GO
         EJECT
*
*        NOTE THAT WE DO NOT GENERATE ANY RLD CARDS. INSTEAD, WE DO
*        OUR OWN RELOCATION WHEN THE PROGRAM IS RELOADED. THIS
*        SIMPLIFIES THE CODING AND AVOIDS THE NECCESSITY OF
*        USING SOME OF THE MORE EXOTIC LINK EDITOR OPTIONS
*
*        NOW GENERATE THE END CARD, THE FORMAT IS SIMPLY
*
*        COL 1                    12-2-9 MULTI-PUNCH
*        COLS 2-4                 END
*        COLS 73-76               PROGRAM ID (= 'SPIT')
*        COLS 77-80               SEQUENCE NUMBER
*
         STE   ZR,SPITLAD         CLEAR SPECIAL ADDRESSES
         STE   ZR,SPITHAD         . . . .
         BAL   A1,OBJINIT         CLEAR BUFFER
         MVC   OBJBUFR(4),ENDMOD  MOVE FIRST FOUR BYTES
         BAL   A1,OBJWRITE        WRITE END CARD
         LA    A1,OBJOKM          POINT TO MESSAGE
         LA    A1+1,L'OBJOKM      LENGTH OF MESSAGE
         B     XPRINTER           EXIT VIA ROUTINE TO PRINT MESSAGE
         EJECT
*
*        SUBROUTINE TO INITIALIZE OUTPUT OF AN OBJECT MODULE CARD
*
*        BAL   A1,OBJINIT
*
OBJINIT  MVI   OBJBUFR,C' '       SET BLANK
         MVC   OBJBUFR+1(71),OBJBUFR        CLEAR TO BLANKS
         MVC   OBJBUFR+72(4),SYSOBJID       SET PROGRAM ID
         UNPK  OBJBUFR+76(4),OBJSER         SET SERIALIZATION
         OI    OBJBUFR+79,C'0'    SET PROPER ZONE ON LAST DIGIT
         AP    OBJSER,=P'1'       INCREMENT SERIALIZATION
         BR    A1                 RETURN TO CALLER
*
*        SUBROUTINE TO OUTPUT A COMPLETED IMAGE
*
*        BAL   A1,OBJWRITE
*
OBJWRITE STM   R0,A1+1,OBJWSAV    SAVE REGS
         LA    A1,OBJBUFR         POINT TO BUFFER
         LA    A1+1,80            LENGTH = 80 CHARS
         L     R0,OBJDCB          LOAD PTR TO FILE
         L     R2,XPRINTV         LOAD ROUTINE ADDRESS (SYSWRITE)
         SR    A2+1,A2+1          SIGNAL UNFORMATTED
         BALR  R1,R2              CALL ROUTINE
         B     OBJWRITX           SKIP IF THERE IS AN ERROR
         LM    R0,A1+1,OBJWSAV    ELSE RESTORE REGS
         BR    A1                 AND RETURN TO CALLER
*
*        COME HERE IF WE GET AN ERROR WRITING THE FILE
*
OBJWRITX LA    A1,OBJMERR         POINT TO MESSAGE
         LA    A1+1,L'OBJMERR     LENGTH OF MESSAGE
         B     XPRINTER           EXIT VIA ROUTINE TO PRINT ERROR MSG
         EJECT
*
*        CONSTANTS FOR OBJGEN
*
TXTMOVE  MVC   OBJBUFR+16(*-*),0(R1)        MOVE PARTIAL TXT INFO
OBJOKM   DC    C'0OBJECT MODULE SUCCESSFULLY WRITTEN TO SYSOBJ FILE'
OBJMERR  DC    C'0ERROR WRITING SYSOBJ FILE, MODULE NOT GENERATED'
TXTMOD   DC    C'TXT'            MODEL TXT CARD
ENDMOD   DC    C'END'            MODEL END CARD
ESDMOD   DC    C'ESD      '      MODEL ESD CARD
         DC    AL2(32)            # BYTES
         DC    C'  '
         DC    AL2(1)             FIRST ESID NUMBER
         DC    C'SPITBOLL'
         DC    C'XXXX XXX'        ADDR/LENGTH
SYSOBJID DC    C'SPITBOLH'        CSECT NAME + DECK NAME (=SPIT)
SYSOBJNM DC    C'SYSOBJ'          NAME OF OUTPUT FILE
         DROP  FRETURN            DROP BASE REG
.SKIPS15 ANOP
         TITLE 'SPITBOLX -- EXECUTION TIME SCAN ROUTINE'
*
*        SCAN ROUTINE FOR EXECUTION TIME ROUTINES
*
*        CONDITIONS ON ENTRY -
*        (A2)                     BASE REGISTER, ADDRESS OF FIRST CODE
*        BALR  RETURN,A2          CALL OF SCAN ROUTINE
*        ->    RETURN FOR NULL STRING SCANNED, A2+1 CONTAINS STOP CHR
*        ->    RETURN FOR RUNOUT
*        (A2+1)                   TRT STOP CHARACTER TBL ENTRY
*                                 ZERO IF RUNOUT WHICH IS IGNORED
*        NORMAL EXIT IS TO GETNAME, SO (A1) CONTAINS VAR BLK ADDR
*        FLAG FOR XSCAN CONTROL  --  ZEROED BY XSCANI
*        XSCANFLG                 XSIGNRO   IGNORE RUNOUT
*                                 XSIGNGN   DON'T DO GETNAME CALL
*        IF GETNAME DOES A COLLECT , IT IS A GBGCLF!
*        THIS ROUTINE DOES A TRT ON ZTBL, ASSUMING THAT IT HAS BEEN
*        SET UP BY CALLER.
*
         USING XSCAN,A2           TELL ASSEMBLER OF BASE REGISTER
XSCAN    LM    R0,R1,XSCANSV      LOAD LENGTH LEFT/ SCAN LOCATION
         SR    R2,R2              CLEAR TRT INSERT REGISTER
         BCTR  R0,0               GET 360 LENGTH LEFT
         LTR   A1+1,R0            COPY AND TEST LENGTH LEFT
         BM    XSRUNOUT           RUNOUT IF NO CHARACTERS LEFT
         LR    A1,R1              COPY CURRENT SCAN LOCATION
         AR    A1,A1+1            POINT TO LAST CHARACTER
         LA    R0,256             GET STANDARD CONSTANT
*
*        LOOP TO TRT OVER MORE THAN 256 CHARACTERS
*
XSTLP    CR    A1+1,R0            TEST FOR SIZE OF TRT NEEDED
         BL    XSSML              SKIP IF <= 256 CHARACTERS
         TRT   0(256,R1),ZTBL     SCAN OUT
         BNZ   XSFND              EXIT OF STOP CHARACTER FOUND
         AR    R1,R0              PUSH TRT SCAN LOCATION
         SR    A1+1,R0            DECREMENT LENGTH LEFT
         B     XSTLP              AND BACK TO TEST LENGTH LEFT
*
*        COME HERE IF <= 256 CHARACTERS LEFT IN ARGUMENT
*
XSSML    EX    A1+1,SCNTRT        DO FINAL TRT
         BZ    XSRUNOUT           SKIP IF NO STOP CHARACTER FOUND
         EJECT
*
*        COME HERE WHEN STOP CHARACTER FOUND
*
XSFND    L     A1+1,XSCANSV+4     LOAD INITIAL SCAN LOCATION
         LR    R0,A1+1            COPY IT FOR LATER
         SR    R0,R1              GET NEGATIVE LENGTH SCANED OUT
         LCR   R0,R0              GET POSITIVE LENGTH SCANED OUT
         BCTR  R0,0               GET 360 LENGTH
         SR    A1,R1              GET CHARACTERS LEFT IN STRING
         ST    A1,XSCANSV         SAVE FOR NEXT CALL
         L     A1,TEM#1(,PDR)     GET STRING BASE
         SR    A1+1,A1            GET OFFSET+SCHARS IN SCAN START
         SH    A1+1,=Y(SCHARS)    FUDGE FOR SCHARS
         SLL   A1+1,16            POSITION OFFSET ON LEFT
         ALR   A1+1,R0            AND ADD IN LENGTH
         LR    A2+1,R2            SAVE SCAN STOP CHARACTER
         AH    R1,H1              PUSH SCAN PAST STOP CHARACTER,SV TYPE
         ST    R1,XSCANSV+4       SAVE FOR NEXT SCAN CALL
         LTR   R0,R0              WAS STRING SCANNED OUT NULL?
         BCR   M,RETURN           GIVE APPROPRIATE RETURN IF SO
         TM    XSCANFLG,XSIGNGN   SHOULD WE DO GETNAME CALL?
         BO    8(,RETURN)         EXIT IF NOT
         LA    RETURN,4(,RETURN)  FUDGE FOR RETURN FROM GETNAME
         B     GETNAME            AND CALL GETNAME, RETURN TO CALLER
*
*        COME HERE ON RUNOUT
*
XSRUNOUT LA    A1+1,1(,A1+1)      GET REAL LENGTH LEFT IN STRING
         AR    R1,A1+1            POINT PAST LAST CHARACTER
         TM    XSCANFLG,XSIGNRO   SHOULD WE IGNORE RUNOUT?
         BO    XSFND              TREAT AS IF FOUND STOP CHAR IF SO
         B     4(,RETURN)         AND TAKE RUNOUT RETURN
*
SCNTRT   TRT   0(*-*,R1),ZTBL     DO VAR LENGTH TRT
         EJECT
*
*        INITIAL CALL TO SCAN COMES HERE
*
*        NOTE - IF CHARACTERS OTHER THAN (),: CAN BE LEFT IN ZTBL
*        ON AN ERROR CALL FIX ERROR ROUTINE APPROPRIATELY
*        GETNAME CALS MUST NOT BE PERMITTED FOR USERS WHO CAN'T GBGCLF!
*
*        TEM#1                    SCAN ARGUMENT
*        BAL   A2+1,XSCANI        CALL ROUTINE
*        ->    RETURN FOR NON STRING ARGUMENT
*        ->    RETURN FOR NULL STRING ARGUMENT
*        (A2)  POINTER TO XSCAN FOR NEXT CALLS
*
XSCANIC  CLI   TEM#1(PDR),NCODE   IS ARGUMENT NULL?
         BE    4(,A2+1)           TAKE NULL RETURN IF SO
         LM    A1,A1+1,TEM#1(PDR) LOAD SCAN ARGUMENT
         BAL   RETURN,GETSTG      CONVERT IT TO STRING
         BR    A2+1               TAKE ERROR RETURN IF NOT POSSIBLE
         NOPR  0                  FILLER FOR ERROR RETURN
         STM   A1,A1+1,TEM#1(PDR) RESTORE SCAN ARGUMENT AS STRING
         AH    A1,TEM#1+SOFFSET(,PDR)       ADD IN OFFSET
         AH    A1,=Y(SCHARS)      ADD IN SCHARS OFFSET, SAVE SCODE
         ST    A1,XSCANSV+4       SAVE FOR NEXT SCAN LOCATION
         LH    A1+1,TEM#1+SLENGTH(,PDR)     LOAD 360 LENGTH
         LA    A1+1,1(,A1+1)      GET REAL LENGTH LEFT
         ST    A1+1,XSCANSV       SAVE LENGTH LEFT
         MVI   XSCANFLG,0         INITIALIZE FLAG FOR SCAN ROUTINE
         B     8(,A2+1)           TAKE NORMAL EXIT
         DROP  A2                 DON'T NEED THIS BASE REGISTER ANYMORE
         TITLE 'SPITBOLX -- ROUTINE TO ORDER TABLE ELEMENTS'
*
*        THIS ROUTINE IS USED TO COUNT AND CHRONOLOGICALLY LINK THE
*        NON NULL ELEMENTS IN A TABLE
*
*        REGISTERS USED           R0,R1,R2,A1,A1+1,A2,RETURN
*        (A1)                     TABLE ADDRESS
*        BAL   RETURN,TBCHRON     CALL OF SYSTEM ENTRY POINT
*        ->    RETURN FOR NO NON-NULL ELEMENTS FOUND
*        (A1+1)                   COUNT OF NON-NULL ELEMENTS
*        TBCHRSV                  CHAIN OF TEBLOKS
*                                 GBG FIELD IS USED FOR CHAIN
*                                 THE BLOCK CODES HAVE BEEN CLEARED
*        (RETURN)                 POINTS TO A ROUTINE TO CLEAR THE GBG
*                                 FIELDS, RESTORE BLOCK CODES, AND EXIT
*                                 TO GBGCLF FOR RECALL OF USER
*                                 RETURN IS SET UP ONLY IF NON-NULL
*                                 ELEMENTS EXIST
*
*        THIS ROUTINE WORKS BY USING THE OBSERVATION THAT THE ORDER IN
*        WHICH THE ENTRIES WERE CREATED CORRESPONDS TO THE ORDER IN
*        WHICH THE TEBLOK'S APPEAR IN FREE CORE. THERE ARE TWO PASSES,
*
*        1)    MARK ALL NON-NULL TEBLOK'S IN THE TABLE BY SETTING
*              BYTE 2 OF THE GARBAGE COLLECTION FIELD TO X'80'
*
*        2)    SCAN THROUGH FREE CORE LINEARLY STARTING WITH THE
*              BLOCK JUST BEYOND THE TBLOK AND CHAINING TEBLOK'S UP
*              UNTIL THE CORRECT NUMBER (FOUND IN PASS 1) ARE LINKED.
*
         USING TBCHRONC,A2        TELL ASSEMBLER OF BASE REGISTER
TBCHRONC ST    A1,TBCHRSV         SAVE TABLE ADDRESS
         L     R1,TBDIVIDE(,A1)   LOAD NUMBER OF SLOTS * 4
         AR    R1,A1              GET BXLE END ADDRESS
         LA    R0,4               GET BXLE INCREMENT
         SR    A1+1,A1+1          INITIALIZE COUNT OF NON-NULL ELEMENTS
         B     TBCHRON3           AND MAKE INITIAL LOOP ENTRY
*
*        COME HERE TO CHECK FOR NULL VALUED ELEMENT
*
TBCHRON1 CLI   TEVALUE(R2),NCODE  IS THIS ELEMENT NULL?
         BE    *+10               SKIP COUNT AND MARK IF SO
         MVI   1(R2),X'80'        MARK THE BLOCK AS PART OF THIS TABLE
         BCTR  A1+1,0             AND COUNT THE ELEMENT
         L     R2,TLINK(,R2)      MOVE OUT ON THE LINK
*
*        COME HERE TO TEST FOR END OF LINK (ZERO)
*
TBCHRON2 LTR   R2,R2              IS THIS END OF LINK?
         BNZ   TBCHRON1           BACK TO CHECK VALUE IF NOT
         EJECT
*
*        COME HERE TO MOVE TO NEXT SLOT
*
TBCHRON3 L     R2,TBLPTRS(,A1)    LOAD NEXT SLOT POINTER
         BXLE  A1,R0,TBCHRON2     OFF TO CHECK FOR LINK END IF ONE
         LPR   A1+1,A1+1          GET POSITIVE ELEMENT COUNT,TEST
         BCR   Z,RETURN           OFF TO CALLER IF NO ELEMENTS
         L     A1,TBCHRSV         RESTORE TABLE ADDRESS
         LA    R1,TBCHRSV         INITIALIZE LINK POINTER
         LR    R0,A1+1            COPY COUNT OF NON-NULL ELEMENTS
*
*        COME HERE TO SKIP PAST UNMARKED BLOCK, AND INITIALLY THE TABLE
*
TBCHRON4 SR    R2,R2              CLEAR FOR IC
         IC    R2,DTYPE(,A1)      GET BLOK TYPE TO SLECT LENGTH ROUTINE
         EX    0,BLOKLEN(R2)      GET BLOCK LENGTH IN (R2)
         AR    A1,R2              SKIP OVER BLOCK
         CLI   1(A1),X'80'        IS THIS BLOCK MARKED?
         BNE   TBCHRON4           SKIP PAST IT IF NOT
         ST    A1,0(,R1)          ENTER THIS ELEMENT ON CHAIN
         LR    R1,A1              SET UP FOR NEXT CHAIN ENTRY
         BCT   R0,TBCHRON4        LOOP BACK IF MORE ELEMENTS LEFT
         STE   ZR,DTYPE(,R1)      CLEAR LINK OF LAST BLOCK FOR EASY
*                                 END OF LINK TEST
         BAL   RETURN,4(,RETURN)  RETURN PAST NULL TABLE EXIT
         DROP  A2                 DONE WITH THIS BASE REGISTER
         USING *,RETURN           BASE REGISTER SET BY CALLER
*
*        COME HERE TO CLEAR THE GBG FIELDS AND RESTORE TYPE CODES
*
         L     R1,TBCHRSV         LOAD LINK HEAD
         L     R0,TEBLOKBT        LOAD TEBLOK GBGFIELD
*
*        LOOP TO MOVE OUT ON CHAIN, AND ZERO GBG FIELD
*
TBCHRON5 L     R2,0(,R1)          LOAD ADDRESS OF NEXT ELEMENT
         ST    R0,0(,R1)          CLEAR GBG FIELD
         LTR   R1,R2              COPY POINTER AND TEST FOR END
         BNZ   TBCHRON5           LOOP BACK IF NOT AT LINK END
         B     GBGCLF             AND DO FUNCTION GBG CALL
         DROP  RETURN             DONE WITH THIS BASE REGISTER
         TITLE 'SPITBOLX -- SYSTEM OPSYN ROUTINE'
*
*        THIS ROUTINE IS CALLED WHENEVER A FUNCTION ADDRESS IS TO BE
*        INSERTED INTO A VARIABLE BLOCK IN ORDER TO HANDLE EXTERNAL
*        FUNCTIONS PROPERLY.
*
*        (A1)                     VARIABLE BLOCK ADDRESS
*        (A1+1)                   FUNCTION ADDRESS TO BE INSERTED
*        BAL   RETURN,OPSYN$      CALL ROUTINE
*        (A1)                     UNCHANGED
*        (A1+1)                   UNCHANGED
*        (A2)                     BASE REGISTER - POINTS TO ENTRY PT
*        (R2)                     OLD FUNCTION ADDRESS
*
         USING OPSYN$C,A2         TELL ASSEMBLER OF BASE REGISTER
OPSYN$C  L     R2,VFUNC(,A1)      SAVE OLD FUNCTION ADDRESS
         CLC   FCODE(4,R2),EFBLOKI          CHECK FOR EFBLOK
         BNE   OPSYN1             NO SPECIAL HANDLING IF NOT
         SR    R0,R0              CLEAR FOR IC
         IC    R0,EFUSE(,R2)      GET CURRENT USE COUNT
         BCT   R0,OPSYN2          SKIP IF NO UNLOAD NEEDED
*
*        THE FOLLOWING TEST AVOIDS UNLOADING AN EXTERNAL FUNCTION
*        WHOSE USE COUNT IS ONE ON A CALL OF THE TYPE OPSYN(.F,.F)
*
         LR    R0,R2              OLD FUNCTION ADDRESS
         SR    R0,A1+1            NEW FUNCTION ADDRESS
         N     R0,=X'00FFFFFF'    REMOVE UPPER BYTE
         BZ    OPSYN2             SKIP UNLOAD IF OLD FUNC = NEW FUNC
*
*        HERE WE UNLOAD AN EXTERNAL MODULE
*
         STM   A1,A1+1,OPSYNSV    SAVE REGS
         L     R2,EFNAME(,R2)     LOAD POINTER TO FUNCTION NAME BLOCK
         L     A1,VNAME(,R2)      LOAD NAME POINTER
         AH    A1,VNAME+SOFFSET(,R2)        ADD OFFSET
         LA    A1,SCHARS(,A1)     POINT TO ACTUAL NAME
         LH    A1+1,VNAME+SLENGTH(,R2)      LOAD 360 LENGTH OF NAME
         LA    A1+1,1(,A1+1)      GET REAL LENGTH
         L     R2,=V(SYSUNLOD)    POINT TO UNLOAD ROUTINE
         BALR  R1,R2              CALL UNLOAD ROUTINE
         B     SYSERROR           GIVE ERROR IF ONE IS SIGNALLED
         LM    A1,A1+1,OPSYNSV    ELSE RELOAD REGS
         L     R2,VFUNC(,A1)      RELOAD OLD FUNCTION ADDRESS
         EJECT
*
*        COME HERE TO STORE DECREMENTED USE COUNT, NOTE THAT NO HARM
*        IS DONE BY STORING A GARBAGE VALUE IN UNLOADED BLOCKS
*
OPSYN2   STC   R0,EFUSE(,R2)      SAVE NEW VALUE OF USE COUNT
*
*        COME HERE AFTER DEALING WITH POSSIBLE EXTERNAL FUNCTION
*
OPSYN1   IC    R0,VFUNC(,A1)      SAVE UPPER BYTE OF FUNCTION WORD
         ST    A1+1,VFUNC(,A1)    SAVE NEW FUNCTION ADDRESS
         STC   R0,VFUNC(,A1)      RESTORE UPPER BYTE
         CLC   FCODE(4,A1+1),EFBLOKI        IS NEW FUNCTION EXTERNAL?
         BCR   NE,RETURN          RETURN IF NOT
         IC    R1,EFUSE(,A1+1)    LOAD CURRENT USE COUNT
         LA    R1,1(,R1)          INCREASE IT BY ONE (HOPE ITS LE 254)
         STC   R1,EFUSE(,A1+1)    STORE NEW USE COUNT IN BLOCK
         BR    RETURN             AND RETURN TO CALLER
         DROP  A2                 GET RID OF BASE REGISTER
*
*        THE FOLLOWING INSTRUCTION IS THE FIRST INSTRUCTION (AT FCODE)
*        IN ALL EXTERNAL FUNCTION BLOCKS. NO OTHER FUNCTION BLOCKS
*        START WITH THIS CODE PERMITTING EASY IDENTIFICATION
*
EFBLOKI  B     $$LOAD             FIRST INSTRUCTION IN EFBLOK
         TITLE 'SPITBOLX -- FAILURE RETURN FOR EVAL'
*
*        THIS CODE IS CALLED ON A FAILURE RETURN FROM A DEFERRED EXPR
*
DEFFAIL  L     R1,EVLINK(,PDR)    RESTORE LINKAGE REGISTER
         L     R2,PDRBPTR(,PDR)   GET REAL PDR ABOVE US
         ST    R2,PDRLOC          AND SAVE IT FOR THIS LEVEL
         SPM   R1                 FIND OUT WHO CALLED US
         BCR   NE,R1              OFF TO CALLER IF NOT PAT MATCH
         ST    FR,FRSAVE          SAVE NEW FR
         L     R0,RETLOCP(,R2)    GET RETURN ADDRESS FOR MATCH ERRORS
         ST    R0,RETLOC          SAVE FOR ERR MSG ROUTINE
         LA    PDR,PATSPACE(,PDR) RESTORE STACK POINTER
         LM    BPS,PBASE,PSAVBPS(PDR)       RESTORE ALL REGS
         L     FSADR,PSTRING(,R2) RESTORE STRING ADDRESS
         AH    FSADR,PSTRING+SOFFSET(,R2)   ADD IN OFFSET
         AH    FSADR,PSTRING+SLENGTH(,R2)   ADD IN 360 LENGTH
         LA    FSADR,SCHARS+1(,FSADR)       POINT TO LAST CHARACTER
         BR    R1                 RETURN TO FAILURE POINT
*
*        THIS CODE IS FOR PAT MATCH WRITES - AUR IS SHARED WITH READ
*
EVALWRIT EQU   *                  START OF DUMMY EXPRESSION CODE
         L     A2,EVALVAR         RESTORE VARIABLE BLOCK ADDRESS
         LM    A1,A1+1,VALUE(A2)  RESTORE OUTPUT VALUE
         BAL   RETURN,WRIT        DO OUTPUT W/O ST IN RETLOC
         B     $$EVLR             AND RETURN SUCCESSFULLY
*
*        THIS CODE IS A DUMMY EXPRESSION FOR DEFFERED READS
*
EVALREAD EQU   *                  START OF DUMMY CODE
         L     A2,EVALVAR         RESTORE VARIABLE BLOCK ADDRESS
         BAL   RETURN,$$READ      DO THE READ
         B     $$EVLR             AND RETURN SUCCESSFULLY
         AUR   SCNT,SINC          END OF STATEMENT FOR GBG COLLECTOR
         TITLE 'SPITBOLA -- START OF CONTROL SECTION'
*
*        THIS CONTROL SECTION CONTAINS EXECUTION ROUTINES WHICH
*        ARE ADDRESSABLE UNDER THE SYS BASE REGISTER
*
         BEGIN A                  START OF SPITBOLA, SPITBLLA CSECT
         USING SPITBOLA,SYS       BASE REG USED THROUGHOUT
*
*        THE FOLLOWING ROUTINE TO CALL THE ERROR MESSAGE PRINTER MUST
*        BE AT THIS LOCATION, SINCE IT IS CALLED BY A BALR ON SYS
*
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE
         USING DTERTNS,DB4        TELL ASSEMBLER
         TM    0(RETURN),X'80'    CHECK SPECIAL FLAG BIT
         BNO   EXERR              JUMP IF NOT SET
*
*        COME HERE IF THE SIGN BIT IS SET. THIS FLAG IS SET IN THE
*        PARAMETERS OF THE XERR CALL WHICH IS SUBSTITUTED IN THE CODE
*        WHEN AN ERROR OCCURS DURING EVALUATION OF CONSTANT EXPRESSIONS
*        THIS BIT ENSURES THAT RETURN GETS STORED PROPERLY IN THIS CASE
*
         ST    RETURN,RETLOC      STORE RETURN POINT
         B     EXERR              AND THEN JUMP TO ERROR ROUTINE
*
*        THIS IS THE ENTRY TO THE EXECUTION ERROR MESSAGE ROUTINE
*        WHICH STORES THE RETURN LOCATION FIRST
*
EXERRS   ST    RETURN,RETLOC      STORE RETURN LOCATION
         L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REGISTER
         BCT   R1,EXERRCC         MERGE AS REAL ERROR, FIXING (R1)
         DROP  DB4                DROP BASE REGISTER
*
*        EXIT HERE ON ERRORS SIGNALLED BY SYSTEM INTERFACE
*        IN ALL CASES, (R0) CONTAINS THE ERROR CODE
*
SYSERROR STC   R0,SYSERCOD+3      SAVE MINOR ERROR CODE
         MVI   SYSERCOD+2,12      SET PROPER MAJOR CODE
         B     SYSERCOD           AND GO OFF TO ISSUE IT AS ERROR MSG
         TITLE 'SPITBOLA -- CODE BYTE CONSTANTS'
*
*        THESE CONSTANTS ARE USED TO SUPPLY THE UPPER BYTES OF DATA
*        ITEMS --
*
         CNOP  0,4                ALLIGN TO FULL WORD BOUNDARY
NCODEBT  DC    AL1(NCODE,0,0,0)             NULL
*
SCODEBT  DC    AL1(SCODE,0,0,0)             STRING
*
PCODEBT  DC    AL1(PCODE,0,0,0)             PATTERN
*
ACODEBT  DC    AL1(ACODE,0,0,0)             ARRAY
*
MCODEBT  DC    AL1(MCODE,0,0,0)             NAME
*
TCODEBT  DC    AL1(TCODE,0,0,0)             TABLE
*
RCODEBT  DC    AL1(RCODE,0,0,0)             REAL
*
ECODEBT  DC    AL1(ECODE,0,0,0)             EXPRESSION
*
VCODEBT  DC    AL1(VCODE,0,0,0)             *VARIABLE
*
DCODEBT  DC    AL1(DCODE,0,0,0)             PROG DEF DATATYPE
*
WCODEBT  DC    AL1(WCODE,0,0,0)             DREAL
*
*
$$NULL   EQU   NCODEBT            NULL CONSTANT FOR GENERATED CODE
$$MCOD   EQU   MCODEBT            MCODE CONSTANT FOR GENERATED CODE
*
*        POINTER TO GET SCODE TYPE NAMES FROM INITV TABLES
*
INITVPTR DC    AL1(SCODE)         TYPE CODE FOR STRINGS
         DC    AL3(INITVR1+1-SCHARS)        STG BASE PTR FOR INITV NAME
*
*        HEADER FOR TEBLOCK USED FOR CLEARING AFTER TBCHRON IS USED
*
TEBLOKBT DC    A(TEBLOK*256*256*256)        GBGCL FIELD FOR TEBLOK
         TITLE 'SPITBOLA -- CONCATENATION ENTRY POINT'
*
*        $$CNC2                   CONCATENATION ROUTINE
*
*        THIS ROUTINE IS CALLED FROM THE GENERATED CODE TO CONCATENATE
*        STRINGS AND/OR PATTERNS
*
*
*        (A1,A1+1)                LEFT ARG
*        (A2,A2+1)                RIGHT ARG
*        BAL   RETURN,$$CNC2
*        (A1,A1+1)                CONCATENATED RESULT
*
*        THE ALLOWABLE ARGUMENTS ARE AS FOLLOWS (WITH THEIR RESULTS)
*
*        INTEGER/INTEGER          STRING
*        INTEGER/REAL             STRING
*        INTEGER/STRING           STRING
*        INTEGER/PATTERN          PATTERN
*        INTEGER/EXPRESSION       PATTERN
*        REAL/REAL                STRING
*        REAL/STRING              STRING
*        REAL/PATTERN             PATTERN
*        REAL/EXPRESSION          PATTERN
*        STRING/STRING            STRING
*        STRING/PATTERN           PATTERN
*        STRING/EXPRESSION        PATTERN
*        PATTERN/PATTERN          PATTERN
*        PATTERN/EXPRESSION       PATTERN
*        EXPRESSION/EXPRESSION    PATTERN
*        ANYTHING/NULL            ANYTHING
         EJECT
$$CNC2   ST    RETURN,RETLOC      SAVE RETURN LOCATION
*
*        FIRST TEST FOR COMMON CASE OF BOTH ARGUMENTS STRINGS
*
         STM   FR,A2+1,CONCATSF   SAVE FR AND ARGS FOR TESTS
         CLI   CONCATSV,SCODE     CHECK FOR FIRST ARG STRING
         BNE   CONCAT2            SKIP IF FIRST ARG NOT STRING
         CLI   CONCATSV+8,SCODE   CHECK SECOND ARG FOR STRING
         BE    CONCATS            SKIP IF SECOND ARG IS A STRING
*
*        NOW TEST FOR CASES WHERE ONE ARGUMENT IS NULL
*
CONCAT2  CLI   CONCATSV+8,NCODE   IS SECOND ARG NULL?
         BCR   E,RETURN           IF SO, RETURN FIRST ARG AS RESULT
         CLI   CONCATSV,NCODE     IS FIRST ARGUMENT NULL?
         BNE   CONCAT3            SKIP IF NOT
         LR    A1,A2              IF FIRST ARG IS NULL, MOVE
         LR    A1+1,A2+1               2ND ARG TO A1 AS RESULT
         BR    RETURN             AND RETURN
*
*        NOW TEST FOR CASES WHERE ARGS CAN BE CONVERTED TO STRINGS
*
CONCAT3  ST    RETURN,CRETSAVE    STORE RETURN LOCATION
         BAL   RETURN,GETSTG      TRY TO CONVERT TO STRING
         B     CONCATP            GO TO PATTERN CASE ON CONVERT ERROR
         STM   A1,A1+1,CONCATSV   STORE FIRST ARGUMENT
         LR    A1,A2              LOAD SECOND ARGUMENT
         LR    A1+1,A2+1               INTO FIRST ACCUMULATOR
         BAL   RETURN,GETSTG      TRY TO CONVERT TO STRING
         B     CONCATP            SKIP TO PATTERN CASE ON CONVERT ERROR
         L     RETURN,CRETSAVE    RELOAD RETURN LOCATION
         LR    A2,A1              MOVE STRING POINTER
         LR    A2+1,A1+1          FINISH POSITIONING 2ND ARG
         LM    A1,A1+1,CONCATSV   RELOAD ARG 1 -- MERGE SCONC
         EJECT
*
*        SCONC IS THE ENTRY USED TO CONCATENATE STRINGS IN THE PATTERN
*        REPLACEMENT ROUTINE --
*
*        (A1,A1+1)                LEFT ARG
*        (A2,A2+1)                RIGHT ARG
*        BAL   RETURN,SCONC
*        (A1,A1+1)                SPECIFIER FOR CONCATENATED RESULT
*
SCONC    STM   FR,A2+1,CONCATSF   SAVE FR, ARGS -- MERGE CONCATS
*
*        AT THIS STAGE WE HAVE TO CONCATENATE TWO STRINGS
*        THE SPECIFIERS FOR THE STRINGS ARE IN CONCATSV AND A1,A2+1
*
*        NOTE THAT THIS CASE IS TESTED FOR FIRST TO SPEED IT UP
*        SINCE IT IS PROBABLY THE MOST COMMON
*
*
*        REENTER HERE WHEN WE HAD TO DO A GARBAGE COLLECTION
*
*
CONCATS  LH    A1+1,SLENGTH+CONCATSV        LOAD 1ST ARG LENGTH
         LH    A2+1,SLENGTH+CONCATSV+8      LOAD 2ND ARG LENGTH
         LA    R2,1(A1+1,A2+1)    CALCULATE NEW LENGTH
         AH    A2,CONCATSV+SOFFSET+8        PNT TO 1ST CHAR OF 2ND ARG
         LA    R0,256             CRANK CONSTANT FOR LONG STRINGS
         C     R2,V$MAXLN         CHECK AGAINST MAXIMUM LENGTH
         BL    CONCATS1           SKIP IF OK
         CLI   CONCATSV,PCODE     ELSE WAS THIS PATTERN CASE?
         BE    *+8                SKIP IF SO
         XERR  11,007             CONCATENATION RESULTED IN THE
*                                 FORMATION OF A STRING MORE THAN
*                                 &MAXLNGTH CHARACTERS LONG
         CH    R2,=X'7FFF'        FOR PATTERN, CHECK AGAINST 32K
         BL    CONCATS2           AND SKIP IF OK - NO OPT HERE
*
*        HERE FOR PATTERN > 32K (MERGE FROM OPTIMIZATION CIRCUIT)
*
PSIZERR  XERR  11,008             A PATTERN STRUCTURE HAS EXCEEDED THE
*                                 MAXIMUM PERMITTED SIZE (32K BYTES)
*
*        NOW TEST FOR CASE OF LEFT ARGUMENT THE SAME AS THE RESULT
*        WE GENERATED ON THE PREVIOUS CALL -- THIS IS SO THAT WE CAN
*        AVOID NEEDLESS COPIES BY USING THE SBLOK AS IT IS
*
CONCATS1 CLC   CONCATSF(4+8),CONCFRSV       CHECK FR,A1,A1+1 WI OLD VLS
         BNE   CONCATS2           SKIP IF NOT ALL EQUAL
         EJECT
*
*        STRING CONCATENATION (SCONC,CONCATS) -- CONTINUED
*
*
*        COME HERE FOR THE SPECIAL CASE OF THE LEFT ARGUMENT IDENTICAL
*        TO THE RESULT RETURNED LAST TIME -- IN THIS CASE -- JUST
*        ADD THE RIGHT ARGUMENT ON TO THE EXISTING BLOCK
*
         LA    R1,SCHARS+BOUND+1(A1,R2)     SEE WHERE FR WILL END UP
         LA    FR,0(A1,A1+1)      GET NEW LENGTH
         CR    R1,PDR             DO WE HAVE ENOUGH CORE?
         BL    CONCATLN           SKIP IF ROOM
         L     FR,CONCATSF        ELSE RESTORE FR AND MERGE
*
*        GARBAGE COLLECT HERE IF INSUFFICIENT CORE
*
CONCATLG LM    A1,A2+1,CONCATSV   RESTORE ARGUMENTS
         ST    RETURN,CRETSAVE    SAVE RETURN LOCATION
         BAL   RETURN,GBGCL2      COLLECT, SAVING BOTH ARGUMENTS
         STM   A1,A2+1,CONCATSV   STORE RELOCATED POINTERS
         L     RETURN,CRETSAVE    RELOAD RETURN LOCATION
         B     CONCATS            AND JUMP BACK TO TRY AGAIN
*
*        COME HERE FOR NORMAL CASE OF BOTH ARGUMENTS REQUIRE COPYING
*
CONCATS2 LA    R1,SCHARS+BOUND+1(FR,R2)     SEE WHERE FR WILL END UP
         CR    R1,PDR             CHECK IF WE HAVE ROOM
         BNL   CONCATLG           SKIP BACK IF NOT
*
*        AT THIS POINT WE ARE ALL SET FOR CONCATENATION AND CONSTRUC-
*        TION OF A NEW SBLOK.
*
CONCATL2 AH    A1,CONCATSV+SOFFSET          POINT TO FIRST CHAR
         LR    R1,FR              SAVE START OF NEW BLOCK
         CR    A1+1,R0            CHECK NUMBER OF CHARS LEFT IN 1ST ARG
         BL    CONCATL4           SKIP IF 256 OR LESS
*
*        THIS IS THE LOOP TO MOVE THE FIRST ARGUMENT IN 256 BYTE CHUNKS
*
CONCATL3 MVC   SCHARS(256,FR),SCHARS(A1)    ELSE MOVE NEXT 256 CHARS
         AR    A1,R0              BUMP SOURCE POINTER
         AR    FR,R0              BUMP DESTINATION POINTER
         SR    A1+1,R0            DECREMENT COUNT OF CHARS LEFT
         CR    A1+1,R0            STILL MORE THAN 256 CHARS TO GO?
         BNL   CONCATL3           LOOP BACK IF YES
         EJECT
*
*        STRING CONCATENATION (SCONC,CONCATS) -- CONTINUED
*
*
*        COME HERE TO MOVE REMAINING PIECE OF FIRST ARGUMENT
*
CONCATL4 EX    A1+1,CNCTSM1       MOVE REMAINING CHARS
         AR    FR,A1+1            BUMP FREE POINTER APPROPRIATELY
         LR    A1,R1              GET SBLOK START ADDRESS FOR RESULT
         A     A1,SCODEBT         SUPPLY CODE BYTE FOR STRING
         STE   ZR,GCOLPTR(,A1)    ZERO GCOL FLD, SET DTYPE=SBLOK=0
*
*        REENTER HERE FROM CASE OF LEFT ARG NOT RECOPIED
*
CONCATLN LR    A1+1,R2            GET NEW SLENGTH IN PROPER REG
         CR    A2+1,R0            HOW MANY CHARS LEFT?
         BL    CONCATSL           IF <257, SHORT STG CIRCUIT COMPLETES
*
*        LOOP TO MOVE 2ND ARG IN CHUNKS OF 256 BYTES
*
CONCATL5 MVC   SCHARS+1(256,FR),SCHARS(A2)  ELSE MOVE NEXT 256 CHARS
         AR    A2,R0              BUMP SOURCE POINTER
         AR    FR,R0              BUMP DESTINATION POINTER
         SR    A2+1,R0            DECREMENT COUNT OF CHARS REMAINING
         CR    A2+1,R0            CHECK FOR MORE THAN 256 CHARS LEFT
         BNL   CONCATL5           SKIP BACK IF SO
*
*        COME HERE TO MOVE REMAINING PIECE OF SECOND ARGUMENT
*
CONCATSL EX    A2+1,CNCTSM2       MOVE CHARS (REMAINING) OF 2ND ARG
         LA    R1,SCHARS+BOUND+1(,A1+1)     CALCULATE SBLOK LENGTH
         N     R1,FULLWRD         ADJUST TO PROPER BOUNDARY
         STH   R1,STLENGTH(,A1)   SET SBLOK LENGTH
         LA    FR,0(A1,R1)        CALCULATE NEW FR LOCATION
         STM   FR,A1+1,CONCFRSV   SAVE FR,A1,A1+1 FOR REENTRY CHECK
         BR    RETURN             RETURN TO CALLER
*
CNCTSM1  MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE CHARS OF FIRST ARG
CNCTSM2  MVC   SCHARS+1(*-*,FR),SCHARS(A2)  MOVE CHARS OF 2ND ARG
         EJECT
*
*        WE COME HERE WHEN THE RESULT IS A PATTERN -- SET FLAG AND
*        MERGE WITH ALTERNATION ENTRY POINT
*
*
CONCATP  L     RETURN,RETLOC      RELOAD RET LOC, MERGE PCONC
         LM    A1,A2+1,CONCATSV   RELOAD OPERANDS
*
*        PCONC ENTRY TO PATTERN CONCATENATION USED BY DOLLAR AND DOT
*
*
*        (A1)                     POINTER TO FIRST PATTERN
*        (A2)                     POINTER TO SECOND PATTERN
*        BAL   RETURN,PCONC
*        (A1)                     RESULTING PATTERN
*
PCONC    MVI   PATFLAG,X'FF'      SET FLAG FOR CONCATENATION
         B     CNCMR              JUMP TO MERGE
         TITLE 'SPITBOLA -- ALTERNATION ENTRY POINT'
*
*        $$ORP2                   ALTERNATION
*
*        (A1,A1+1)                LEFT ARGUMENT
*        (A2,A2+1)                RIGHT ARGUMENT
*        BAL   RETURN,$$ORP2
*        (A1)                     RESULTING PATTERN
*
*        THIS ROUTINE IS CALLED FROM THE GENERATED CODE TO GENERATE A
*        PATTERN WHICH IS THE ALTERNATION OF THE TWO ARGUMENTS
*
*        THE PERMISSIBLE ARGUMENTS ARE INTEGERS, REALS, STRINGS, NULL
*        PATTERNS AND EXPRESSIONS. BOTH ARGUMENTS ARE CONVERTED TO
*        PATTERNS IF NECCESSARY BEFORE ALTERNATION.
*
$$ORP2   ST    RETURN,RETLOC      SAVE RETURN
*
*        MERGE HERE FROM ARBNO TO BUILD ITS SPECIAL PATTERN
*
ORMAK    MVI   PATFLAG,X'00'      SET FLAG FOR ALTERNATION
*
*        PATTERN CONCATENATION MERGES HERE
*
CNCMR    ST    RETURN,PRETLOC     SAVE RETURN LOCATION
         BAL   RETURN,GETPAT      GET FIRST ARGUMENT AS PATTERN
         XERR  01,024             THE LEFT ARGUMENT FOR ALTERNATION
*                                 OR CONCATENATION IS NOT A STRING
*                                 OR PATTERN
         ST    A1,CONCATSV        SAVE FIRST PATTERN POINTER
         LR    A1,A2              MOVE SECOND ARGUMENT
         LR    A1+1,A2+1               TO A1
         BAL   RETURN,GETPAT      GET SECOND ARG AS PATTERN
         XERR  01,025             THE RIGHT ARGUMENT TO CONCATENATION
*                                 OR ALTERNATION IS NOT A STRING
*                                 OR PATTERN
         LR    A2,A1              MOVE 2ND ARG PATTERN PTR TO A2
         L     A1,CONCATSV        LOAD 1ST ARG PATTERN PTR TO A1
         L     RETURN,=A(PATSUB)  LOAD ROUTINE ADDRESS
         BR    RETURN             OFF TO IT SETTING BASE
         TITLE 'SPITBOLA -- UNARY DOLLAR ENTRY POINTS'
*
*        $$DL1V                   INDIRECT ADDRESSING BY VALUE
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,$$DL1V
*        (A1,A1+1)                INDIRECT VALUE
*
$$DL1V   MVI   DOLLFLG,$BYVAL     SET FLAG FOR BY VALUE
         L     R2,=A(DOLLC)       LOAD ROUTINE ADDRESS
         BR    R2                 OFF TO IT
*
*        $$DL1N                   INDIRECT ADDRESSING BY NAME
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,$$DL1N
*        (A1,A1+1)                NAME (ADDRESS) OF INDIRECT CONTENTS
*
$$DL1N   MVI   DOLLFLG,$BYNAM     SET FLAG FOR BY NAME
         L     R2,=A(DOLLC)       LOAD ROUTINE ADDRESS
         BR    R2                 OFF TO IT
         TITLE 'SPITBOLA -- MISCELLANEOUS CONTROL ENTRY POINTS'
*
*
*        $$GOTO                   EXECUTE COMPLEX GOTO
*
*        THE NAME IS IN (A1,A1+1). IT MUST BE A NATURAL VARIABLE TO BE
*        A LEGAL GOTO
*
$$GOTO   L     R1,VLABL(,A1)      LOAD LABEL ADDRESS IN CASE
         LA    A1,0(,A1)          CLEAR POSSIBLE UPPER BYTE (MCODE)
         CR    A1,FR              ARE WE ABOVE DYNAMIC CORE
         BCR   H,R1               MAKE TRANSFER IF SO (NATURAL VAR)
         C     A1,DYNAMB          ARE WE BELOW DYNAMIC CORE?
         BCR   L,R1               NATURAL VARIABLE IF SO, TRANSFER
         XERR  08,005,S           NAME USED AS A GOTO OPERAND IS NOT
*                                 A NATURAL VARIABLE
*
*        $$DGTO                   EXECUTE DIRECT GOTO
*
*        (A1,A1+1)                VALUE OF DIRECT GOTO OPERAND
*        BAL   RETURN,$$DGTO
*
$$DGTO   ST    A1,TEM#1(,PDR)     STORE CODE TO CHECK IT
         CLI   TEM#1(PDR),CCODE   IS THE OBJECT CODE?
         BE    CODECODE(,A1)      OFF TO EXECUTE THE CODE IF SO
         XERR  08,006,S           VALUE USED AS DIRECT GOTO OPERAND
*                                 IS NOT CODE
*
*        WE ENTER AT THIS POINT AFTER COMPLETION OF COMPUTATION
*        OF CONSTANT EXPRESSION VALUES. THE CONTINUATION ROUTINE
*        IS LOCATED IN SPITBOLX AT ECONC.
*
$$ECON   L     FRETURN,=A(ECONC)  LOAD BASE ADDRESS OF ROUTINE
         BR    FRETURN            OFF TO ROUTINE
*
*        THIS ROUTINE IS ENTERED ON A LABEL TRACE CALL
*        THE MAIN CODE FOR THIS ROUTINE IS IN SPITBOLX
*
LABTRAC  L     DB4,=A(DTERTNS)    LOAD PROPER BASE REGISTER
         USING DTERTNS,DB4        TELL ASSEMBLER
         B     LABTRACC           OFF TO REAL CODE FOR LABEL TRACE
         DROP  DB4                AND GET RID OF BASE REGISTER
         TITLE 'SPITBOLA -- INPUT-OUTPUT ENTRY POINTS'
*
*        $$DOIO                   ENTER FROM  BALRS IN CODE TO GET ADDR
*                                 OF VARIABLE BLOCK - ALSO INTERCEPT
*                                 LABEL TRACE CALLS
*
$$DOIO   LTR   DB3,DB3            CHECK REG USED FOR I/O BALR
         BP    DOIO1              JUMP IF I/O CASE (NOT FAILURE CASE)
         ST    DB4,TRCSVDB4       SAVE POSSIBLE BASE FOR LABEL TRACE
         L     DB4,=A(DTERTNS)    GET ADDR OF TRACE ROUTINES
         USING DTERTNS,DB4        TELL ASSEMBLER
         B     READFAIL           OFF TO FAILURE ROUTINE
         DROP  DB4                GET RID OF THIS BASE REGISTER
*
*        COME HERE FOR IO CALL
*
DOIO1    LR    RETURN,DB3         GET ADDR OF PSEUDO CODE AFTER BALR
         L     DB3,$$BAS3         RESTORE DB3
         LH    R0,0(,RETURN)      GET PSEUDO CODE
         N     R0,=X'00000FFF'    GET RID OF ALL BUT ADDRESS BITS
         SR    R1,R1              CLEAR FOR SHIFT INTO R1
         SRDL  R0,7               SHIFT VAR BLOCK OFFSET INTO (R1)
         SLL   R0,2               GET DATA BASE OFFSET
         SRL   R1,32-7-5          GET OFFSET IN BYTES NOT BLOCKS (32B)
         LR    R2,R0              GET BASE ADDRESS ADDRESSABLE
         A     R1,$$BAS1(R2)      ADD IN BASE REGISTER VALUE
         TM    0(RETURN),WRITEBIT WAS THIS AN OUTPUT CALL?
         BO    DOIOWRIT           B IF OUTPUT CALL
         TM    0(RETURN),A1BIT    WAS THIS LM A1,A1+1?
         LA    RETURN,2(,RETURN)  POINT TO NEXT INSTRUCTION
         BO    DOIORED1           B IF REFERS TO A1
         STM   A1,A1+1,READSAVE   ELSE SAVE A1,A1+1
         LR    A1,R1              GET VARIABLE BLOCK ADDR
         MVI   READFLG,2          SET TO RETURN VALUE IN A2,A2+1
         B     READMRG            AND MERGE WITH READ CALL
*
*        COME HERE IF VALUE TO BE RETURNED IN A1,A1+1
*
DOIORED1 STM   A2,A2+1,READSAVE   SAVE A2,A2+1
         LR    A1,R1              POINT TO VARIABLE BLCOK
*
*        $$READ                   NORMAL READ OPERATION
*
$$READ   MVI   READFLG,1          SET FOR VALUE TO BE RETURNED IN A1
*
*        MERGE HERE IF RESULT BELONGS IN A2
*
READMRG  L     A2+1,=A(READ)      GET ROUTINE ADDRESS
         ST    RETURN,RETLOC      STORE RETURN IN CASE OF ERRORS
         BR    A2+1               OFF TO IT
         EJECT
*
*        COME HERE FOR BALR CALL TO DO OUTPUT
*
DOIOWRIT LR    A2,R1              GET VARIABLE BLOCK ADDRESS
         SR    A2+1,A2+1          CLEAR OFFSET TO 0
         TM    0(RETURN),STMBIT   WAS THIS A STM A1,A1+1?
         LA    RETURN,2(,RETURN)  POINT TO NEXT INSTRUCTION
         BO    *+8                SKIP (VALUE LOADED) IF STM
         L     A1,NCODEBT         ELSE LOAD NULL IF MVI ..,NCODE
         ST    RETURN,RETLOC      STORE RETURN POINT, MERGE WRIT
*
*        WRIT -- INTERNAL ENTRY POINT USED BY EXECUTION ROUTINES TO
*        ASSIGN A VALUE WITH A CHECK FOR I/O ASSIGNMENT
*
*        (A1,A1+1)                VALUE TO BE ASSIGNED
*        (A2)                     VARIABLE ADDRESS (NAME+BASE)
*        (RETLOC)                 CODE PTR ALREADY STORED
*        BAL   RETURN,WRIT
*        ->  RETURN HERE WITH ASSIGNMENT (AND I/O) COMPLETE
*
WRIT     STM   A1,A1+1,VALUE(A2)  FIRST, MAKE THE ASSIGNMENT
         TM    VFLAGS(A2),VOUA+VTRC         CHECK FOR SOMETHING TO DO
         BCR   Z,RETURN           RETURN IF NOT ASSOCIATED
*
*        MERGE HERE FROM $$ASSN, $$RASN
*
WRIT1    L     A2+1,=A(WRITE)     GET ROUTINE BASE ADDRESS
         LA    A2,0(,A2)          CLEAR POSSIBLE UPPER BYTE
         CR    A2,PDR             ARE WE ABOVE DYNAMIC CORE?
         BCR   H,A2+1             OFF TO WRITE IF NATURAL VARIABLE
         C     A2,DYNAMB          ARE WE BELOW FREE CORE?
         BCR   NL,RETURN          NOT NATURAL VARIABLE IF NOT
         BR    A2+1               OFF TO IT
         TITLE 'SPITBOLA -- ASSIGNMENT ENTRY POINTS'
*
*        $$ASSN                   ASSIGN WITH CHECK FOR I/O ASSOCIATION
*
*        (A1,A1+1)                NAME OF VARIABLE TO ASSIGN TO
*        (A2,A2+1)                VALUE TO BE ASSIGNED
*        BAL   RETURN,$$ASSN
*
$$ASSN   AR    A1,A1+1            ADD NAME OFFSET TO BASE
         STM   A2,A2+1,VALUE(A1)  PERFORM ASSIGNMENT
         TM    VFLAGS(A1),VOUA+VTRC         POSSIBLE ASSOCIATED VBLOK
         BCR   Z,RETURN           RETURN (ALL DONE) IF NOT
         LR    A2,A1              ELSE COPY NAME POINTER
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE TO BE ASSIGNED
         ST    RETURN,RETLOC      STORE RETURN POINT
         B     WRIT1              MERGE BACK INTO WRIT ROUTINE
*
*        $$RASN                   LIKE $$ASSN BUT WITH ARGS REVERSED
*
*        (A1,A1+1)                VALUE TO BE ASSIGNED
*        (A2,A2+1)                NAME OF VARIABLE TO BE ASSIGNED
*        BAL   RETURN,$$RASN
*
$$RASN   AR    A2,A2+1            ADD VARIABLE OFFSET TO NAME BASE
         STM   A1,A1+1,VALUE(A2)  FIRST PERFORM ASSIGNMENT
         TM    VFLAGS(A2),VOUA+VTRC         POSSIBLE ASSOCIATED VBLOK?
         BCR   Z,RETURN           RETURN (ALL DONE) IF NOT?
         ST    RETURN,RETLOC      ELSE STORE RETURN LOCATION
         B     WRIT1              AND MERGE INTO WRIT ROUTINE
         TITLE 'SPITBOLA -- PATTERN MATCH ENTRY POINTS'
*
*        $$PTNL                   PATTERN BY NAME WITH NULL REPLACEMENT
*
*        SAME CALL AS $$PTN2
*
$$PTNL   O     A1,X80             SET SIGN BIT FLAG AND MERGE $$PTN2
*
*        $$PTN2                   PATTERN MATCH BY NAME
*
*        (A1,A1+1)                NAME OF VARIABLE CONTAINING STRING
*        (A2,A2+1)                PATTERN
*        BAL   RETURN,$$PTN2
*        THIS ENTRY IS CALLED WHEN THE STATEMENT CONTAINS A PATTERN
*        REPLACEMENT -- EVERYTHING IS LEFT SET UP FOR A $$PATA CALL
*
*        SEE THE PATTERN MATCHING ROUTINES FOR A BETTER UNDERSTANDING
*        OF WHAT THIS ROUTINE ACCOMPLISHES
*
$$PTN2   STM   A1,A1+1,PNAME(PDR) STORE NAME ON STACK
         AR    A1,A1+1            ADD OFFSET TO NAME
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE AND MERGE $$PTV2
*
*        $$PTV2                   PATTERN MATCH BY VALUE
*
*        (A1,A1+1)                SUBJECT STRING
*        (A2,A2+1)                PATTERN
*        BAL   RETURN,$$PTV2
*
*        PATTERN MATCH ROUTINE FOR CASE OF NO PATTERN REPLACEMENT
*
$$PTV2   L     DB2,=A(PTV2C)      LOAD ADDRESS OF CONTINUATION
         BR    DB2                AND OFF TO IT
         TITLE 'SPITBOLA -- PATTERN EXIT POINTS'
*
*        COME HERE TO ABORT (TERMINATE) PATTERN MATCH FOR ANY
*        OF A VARIETY OF REASONS --
*
PABORT   L     DB1,PSAVDB1(,PDR)  RESTORE PROPER DATA BASE ADDRESS
*
*        MERGE HERE WHEN DB1 WAS NOT SAVED (STRING MATCH CASE)
*
PABORTMM L     PDR,PDRLOC         RESTORE PDR
         LM    DB2,DB3,$$BAS2     RELOAD DB2,DB3
         L     FR,FRSAVE          RESTORE FREE POINTER
         STE   ZR,PNAME(,PDR)     CLEAR POSSIBLE NAME ON STACK
         LM    FRETURN,RETURN,FRETLOCP(PDR) LOAD FAILURE ADDR & RETURN
         BR    FRETURN            AND FAIL BACK TO CODE
*
*        PATTERN EXIT ON SUCCESSFUL MATCH
*
PATENDE  L     DB1,PSAVDB1(,PDR)  RESTORE PROPER DB1 VALUE
*
*        MERGE HERE WHEN DB1 HAS NOT BEEN SAVED (SIMPLE STRING CASE)
*
PATENDEM L     PDR,PDRLOC         RESTORE REAL TOP OF STACK ADDRESS
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3
         L     FR,FRSAVE          RELOAD FREE REGISTER
         LM    FRETURN,RETURN,FRETLOCP(PDR) LOAD RETURN REGS
         TM    PNAME(PDR),X'80'   TEST FOR $$PTNL FLAG
         BCR   NO,RETURN          LEAVE IF NOT SET
         L     A1,NCODEBT         ELSE LOAD A NULL AND MERGE $$PATA
         TITLE 'SPITBOLA -- PATTERN REPLACEMENT ENTRY POINT'
*
*        $$PATA                   PATTERN REPLACEMENT (ASSIGNMENT)
*
*        (A1,A1+1)                REPLACING ARGUMENT
*        BAL   RETURN,$$PATA
*
*        THE FOLLOWING RELEVANT VALUES HAVE BEEN LEFT SET UP BY THE
*        PATTERN MATCH ROUTINES --
*
*        PNAME(,PDR)              NAME (AND OFFSET) OF VARIABLE
*        PSTRING(,PDR)            STRING SPECIFIER OF SUBJECT STRING
*        MATCHPB(,PDR)            NUM CHARS LEFT AT START OF MATCH
*        MATCHPE(,PDR)            NUM CHARS LEFT AT END OF MATCH
*
*        BASICALLY, IT IS NECCESSARY TO CONCATENATE THREE SEPARATE
*        PARTS --
*
*        PART 1                   THE PART OF THE SUBJECT STRING NOT
*                                 MATCHED AT THE START
*
*        PART 2                   THE SUPPLIED ARGUMENT TO $$PATA
*
*        PART 3                   THE PART OF THE STRING NOT MATCHED
*                                 AT THEN END
*
*        THE RESULT OF THIS CONCATENATION IS THEN ASSIGNED TO THE
*        VARIABLE, CHECKING FOR I/O ASSOCIATION
*
$$PATA   L     DB2,=A(PATAC)      LOAD CONTINUATION ROUTINE ADDRESS
         BR    DB2                AND GO OFF TO IT
         TITLE 'SPITBOLA -- ENTRY POINTS FOR FUNCTION PROCESSING'
*
*        $$WNAG                   WRONG NUMBER OF ARGUMENTS ROUTINE
*
*        B     $$WNAG
*        (SUPPLIES ONE EXTRA NULL ARGUMENT AND RETURNS TO FCODE(DB4) )
*
$$WNAG   LR    R1,R0              COPY ARGUMENT COUNT
         LA    R0,1(R1)           BUMP ARGUMENT COUNT BY ONE
         SLL   R1,3               ARGUMENT COUNT * 8 TO INDEX TEMP LOCS
         LCR   R1,R1              NEGATE (BECAUSE STACK IS BUILT DOWN)
         AR    R1,PDR             ADD STACK POINTER
         MVI   TEM#1(R1),NCODE    SET NEXT ARGUMENT TO NULL
         B     FCODE(,DB4)        BACK TO SEE WHETHER THAT IS ENOUGH
*
*        $$FLCN                   CONTINUE PROCESSING FROM FFBLOK
*
*        THIS FUNCTION COMPLETES THE PROCESS OF REFERENCING A FIELD
*        OF A PROGRAMMER DEFINED DATATYPE THROUGH A CALL TO ITS
*        ASSOCIATED FIELD FUNCTION (SEE PDBLOK AND FFBLOK STRUCTURES)
*
$$FLCN   L     A1,TEM#1(,PDR)     PICK UP POINTER TO PDBLOK
         L     R0,PDFPTR(,A1)     PICK UP ASSOCIATED PDFBLOK POINTER
         C     R0,PDFPTR(,DB4)    CHECK FOR MATCH WITH FIELD FUNC DEF
         BE    FLCN1              SKIP IF THEY MATCH
*
*        COME HERE IF FFBLOK DOES NOT MATCH ARGUMENT TYPE
*
FLCN0    L     DB4,FFBLNEXT(,DB4) LINK TO NEXT FFBLOK WITH SAME NAME
         EX    0,FCODE+4(,DB4)    EXECUTE THE LA
         C     R0,PDFPTR(,DB4)    CHECK FOR MATCH WITH FIELD FUNC DEF
         BNE   FLCN0              LOOP BACK IF NO MATCH
*
*        COME HERE WHEN WE ARE FINALLY IN THE RIGHT FFBLOK
*
FLCN1    LA    A1,0(,A1)          CLEAR UPPER BYTE IN CASE BY NAME
         AL    A1,MCODEBT         TYPE CODE = MCODE
         CLC   0(4,RETURN),BFRVN  CHECK FOR CALL BY NAME (B $$FRVN)
         L     PDR,PDRLOC         RESTORE STACK POINTER
         BE    4(RETURN)          RETURN PAST IT WITH NAME IF SO
         AR    A1,A1+1            ELSE CALL BY VALUE, POINT TO CONTENTS
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE
         BR    RETURN             AND RETURN
*
*        CONSTANT TO CHECK FOR CALL BY NAME (B $$FRVN)
*
BFRVN    B     $$FRVN             FOUR BYTE CHECK CONSTANT
         EJECT
*
*        JUMP HERE FROM FFBLOK WHEN ARG IS NOT PRG DEF DATATYPE
*
$$FLE1   L     DB4,FFBLNEXT(,DB4)           POINT TO NEXT IN CHAIN
         C     DB4,=A(FLCERR-FCODE)         IS THIS END OF CHAIN?
         BNE   FCODE(,DB4)        OFF TO FUNCTION IF NOT END OF CHAIN
         XERR  01,026,S           THE ARGUMENT TO A FIELD FUNCTION IS
*                                 NOT A PROGRAM DEFINED DATATYPE
*
*        ENTRY POINT FROM EFBLOK TO CALL EXTERNAL FUNCTION
*
$$LOAD   L     DB3,=A(LOADC)      LOAD CONTINUATION ROUTINE ADDRESS
         BR    DB3                OFF TO ROUTINE
*
*        COME HERE TO SIGNAL A FAILURE RETURN
*
FAILRL   L     RETURN,RETLOC      RESTORE RETURN POINT
*
*        USE THIS ENTRY POINT IF RETURN ALREADY SET
*
FAILR    L     PDR,PDRLOC         RESTORE ACTUAL PDR LOCATION
         BR    FRETURN            AND FAIL
*
*        COME HERE FROM FUNCTION CALL TO RETURN NULL RESULT
*
EXITNULL L     A1,NCODEBT         LOAD NULL AS RESULT, MERGE
*
*        STANDARD EXIT POINT FOR FUNCTIONS (RESULT IS IN A1,A1+1)
*
EXIT     L     RETURN,RETLOC      RESTORE RETURN LOCATION
         L     PDR,PDRLOC         RESTORE STACK POINTER
         BR    RETURN             RETURN TO CALLER
         EJECT
*
*        ENTRY POINT FROM FBLOK ON FUNCTION CALL
*
$$FUNC   CH    R0,FNARGS(,DB4)    ARE THERE ENOUGH ARGS?
         BL    $$WNAG             GET NULLS IF NOT
         LR    DB3,DB4            COPY ADDRESS OF FBLOK FOR LOOPS
         LH    R2,FNARGS(,DB4)    GET NUMBER OF ARGS
         LR    R1,R2              COPY INTO REG 1
         AH    R2,FNLOCS(,DB4)    ADD NUMBER OF LOCALS
         SLL   R2,3               *8 EQUALS NUMBER OF BYTES ON STACK
         LCR   R2,R2              GET NEGATIVE FOR STACK CALC
         AR    R2,PDR             PUSH DOWN BY NUMBER OF TEMPORARIES
         L     A2,FNAME(,DB4)     GET VAR BLOCK POINTER
         LM    A1,A1+1,VALUE(A2)  GET PRESENT VALUE
         STM   A1,A1+1,TEM#1(R2)  STORE AT TEM#N+1, N=AGS+LOCS
         MVI   VALUE(A2),NCODE    NULL NAME
         BCTR  R1,0               NUMBER OF ARGUMENTS - 1
         SLL   R1,2               *4 = SPACE FOR ARGUMENT ADDRESSES
         AR    R1,DB4             ADDRESS OF LAST ARG PTR (DON'T DO LA)
         LA    R0,4               GET THE CORRECT INCREMENT
         LA    DB2,8              GET STACK CONSTANT
         CR    R1,DB4             WERE THERE ANY ARGUMENTS?
         BL    FUNCNXT            SKIP IF NOT
*
*        LOOP TO SAVE OLD ARGUMENT VALUES & SET NEW VALUES
*
FUNCLP1  L     R2,FARGS(,DB3)     GET VAR BLOCK ADDRESS
         LM    A1,A1+1,TEM#1(PDR) PICK UP ARG VALUE
         LM    A2,A2+1,VALUE(R2)  PICK UP VALUE TO BE SAVED
         STM   A1,A1+1,VALUE(R2)  STORE THE ARGUMENT VALUE
         STM   A2,A2+1,TEM#1(PDR) SAVE OLD VALUE
         SR    PDR,DB2            BACK UP ON STACK
         BXLE  DB3,R0,FUNCLP1     PUSH UP FARGS PTR, TEST AND LOOP
         EJECT
*
*        COME HERE WHEN ALL ARGUMENTS HAVE BEEN PROCESSED
*
FUNCNXT  LH    A1,FNLOCS(,DB4)    PICK UP NUMBER OF LOCALS
         AR    A1,A1              *2
         BZ    FUNCEND            SKIP IF NO LOCALS
         AR    A1,A1              *4
         AR    R1,A1              GET NEW END ADDRESS
*
*        LOOP TO SAVE OLD LOCAL VALUES AND SET NULL
*
FUNCLP2  L     R2,FARGS(,DB3)     GET VAR BLOCK ADDRESS
         LM    A1,A1+1,VALUE(R2)  GET VALUE TO BE SAVED
         STM   A1,A1+1,TEM#1(PDR) SAVE IT
         MVI   VALUE(R2),NCODE    MAKE LOCAL VALUE NULL
         SR    PDR,DB2            BACK UP 1 TEMP
         BXLE  DB3,R0,FUNCLP2     PUSH UP FARGS PTR, TEST AND LOOP
*
*        COME HERE WITH ALL ARGUMENTS AND LOCALS PROCESSED
*
FUNCEND  LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
         SH    PDR,=Y(STACKTOP-TEM#1)       PUSH DOWN STACK MIN AMOUNT
         STE   ZR,PNAME(,PDR)     TO PLEASE THE GBGCOLLECTOR
         STM   FRETURN,RETURN,FRETFLOC(PDR) SAVE RETURN POINTS
         ST    DB4,FBLOKLOC(,PDR) SAVE THIS FUNCTION ADDRESS
         L     R1,PDRLOC          GET CURRENT PDR LOCATION ABOVE US
         ST    R1,PDRBPTR(,PDR)   SAVE IT ON STACK
         ST    PDR,PDRLOC         AND STORE THIS LEVEL'S PDR
         LM    A1+1,A2+1,V$FNCLEV LOAD FNCLEVEL,TRACE, AND FTRACE
         ALR   A2,A2+1            TEST TRACE AND FTRACE
         BNZ   FUNCTRC            SKIP TO TRY TRACE UNLESS BOTH ZERO
         LA    A1+1,1(,A1+1)      INCREMENT &FNCLEVEL
         ST    A1+1,V$FNCLEV      AND STORE UPDATED VALUE
         EJECT
*
*        RE-ENTER HERE AFTER TRACE -- NOTE DB4 HAS BEEN RESTORED
*
FTRACECE L     A1,FLABEL(,DB4)    LOAD ADDRESS OF LABEL VBLOK
*
*        CHECK TO MAKE SURE NO COLLECT NEEDED
*
FUNCRENT L     R1,VLABL(,A1)      LOAD LABEL ADDRESS FOR FUNCTION
         CR    FR,PDR             CHECK FOR COLLECT NEEDED
         BCR   L,R1               OFF TO FUNCTION CODE IF SAFE
         ST    RETURN,$$LAST      SAVE RETURN LOC IN COLLECTABLE LOC
         ST    R1,RETLOC          SAVE TARGET ADDR AS GBGCL3 CODE LOC
         BAL   RETURN,GBGCL0      DO COLLECT
         L     RETURN,$$LAST      RELOAD RETURN POINT FOR &LASTNO
         B     FUNCRENT           AND BACK TO DO ANOTHER FREE CORE TEST
*
*        COME HERE IF BOTH &TRACE AND &FTRACE ARE NOT ZERO
*
FUNCTRC  LR    DB3,DB4            SAVE FUNCTION BLOCK ADDRESS
         L     DB4,=A(DTERTNS)    GET TRACE ROUTINES BASE REGISTER
         USING DTERTNS,DB4        TELL ASSEMBLER
         B     FNCTRC             OFF TO TRACE ROUTINES
         DROP  DB4
         TITLE 'SPITBOLA -- KEYWORD ACCESS ENTRY POINTS'
*
*        $$KGET                   ACCESS VALUE OF A KEYWORD
*
*        (A1,A1+1)                NAME OF ARGUMENT
*        BAL   RETURN,$$KGET
*        (A1,A1+1)                VALUE OF KEYWORD
*
$$KGET   L     R2,=A(KGETC)       LOAD ROUTINE ADDRESS
         BR    R2                 AND GO OFF TO IT
*
*        $$KPUT                   STORE VALUE OF KEYWORD
*
*        (A1,A1+1)                NAME OF KEYWORD ARGUMENT
*        (A2,A2+1)                VALUE TO BE STORED
*        BAL   RETURN,$$KPUT
*        ->  NORMAL RETURN WITH VALUE STORED
*
$$KPUT   L     DB3,=A(KPUTC)      LOAD ROUTINE ADDRESS
         BR    DB3                AND GO OFF TO IT
         TITLE 'SPITBOLA -- ROUTINES USED IN PATTERN MATCHING'
*
*        GBAL                     ROUTINE TO SCAN OUT A BALANCED STRING
*
*
*        USED BY BAL PATTERN ROUTINE AND ITS EXTEND ROUTINES
*
*        (NCP)                    CURRENT SCAN LOC (NUM CHARS LEFT)
*        BAL   RETURN,GBAL
*        (NCP)                    SCAN LOC AFTER SCANNING OUT BAL STRIN
*
         USING QPATSUBS,PBASE     MAKE FAIL,LFAIL ADDRESSABLE
GBAL     LTR   NCP,NCP            TEST NUMBER OF CHARACTERS REMAINING
         BZ    FAIL               NORMAL FAILURE IF NO CHARACTERS LEFT
         BAL   R2,PTIMTST         TEST FOR OVERTIME
         LR    R1,FSADR           POINT R1 TO END OF STRING
         SR    R1,NCP             MINUS NUM CHARS LEFT = CURRENT LOC
         SR    R2,R2              ZERO PARENTHESES COUNT
BALEXT1  CLI   0(R1),C')'         IS NEXT CHAR A RIGHT PAREN?
         BH    BALEXT3            SKIP IF NEITHER ( NOR )
         BE    BALEXT2            SKIP IF )
         CLI   0(R1),C'('         IS CHAR A LEFT PAREN?
         BNE   BALEXT3            SKIP IF NOT A PAREN
         LA    R2,1(,R2)          FOR LEFT PAREN -- BUMP PAREN COUNT
BALEXT1A LA    R1,1(R1)           BUMP CHARACTER POINTER
         BCT   NCP,BALEXT1        BACK TO TEST NEXT CHARACTER
         B     FAIL               FAIL IF NO MORE CHARS TO TEST
BALEXT2  BCTR  R2,0               FOR RIGHT PAREN, DECREASE PAREN COUNT
BALEXT3  LTR   R2,R2              TEST PAREN COUNT
         BM    FAIL               FAIL IF IT HAS GONE NEGATIVE
         BP    BALEXT1A           KEEP GOING IF GREATER THAN ZERO
         BCTR  NCP,RETURN         MINUS ONE MORE FOR LAST CHAR, RETURN
         BR    RETURN             RETURN EVEN IF BCTR FALLS THROUGH
         DROP  PBASE              DROP QPATSUBS BASE REG
         EJECT
*
*        ROUTINES CALLED FROM PATTERN MATCH ROUTINES TO GET UNEVALUATED
*        ARGUMENTS EVALUATED (SPAN,BREAK,ANY,NOTANY,(R)POS,(R)TAB,LEN)
*
*
*        ENTRY TO GET A DEFERRED INTEGER
*
*
*        BAL   NCP,DEFEXPI
*        ->  ERROR RETURN IF UNCONVERTIBLE TO INTEGER
*        ->  ERROR RETURN IF NON-POSITIVE
*        ->  NORMAL RETURN -- INTEGER STORED IN PARAM1 FIELD OF NODE
*
DEFEXPI  L     RETURN,PARAM2(PB,PO)         LOAD EXPR OR VAR POINTER
         CR    R0,R0              SET CC FOR PAT MATCH CALL
         BAL   R1,$EVAL           EVALUATE
         USING QPATSUBS,PBASE     BASE REG FOR NEXT INSTRUC
         B     FAIL               ON CODE FAILURE -- FAIL
         DROP  PBASE              DROP BASE REG
         BAL   RETURN,GETINT      CONVERT RESULT TO INTEGER
         B     DEFEXPE1           ERROR RETURN FOR UNCONVERTABLE
         LTR   A1+1,A1+1          TEST INTEGER
         BM    DEFEXPE2           GIVE ERROR RETURN IF NON-POSITIVE
         L     PO,PSAVPO(,PDR)    RESTORE PO TO CONTINUE MATCH
         ST    A1+1,PARAM1(PB,PO) STORE INTEGER IN PARAM1
         LM    A1,A1+1,PSAVBPS(PDR)         RELOAD A1,A1+1 (BPS,PS2)
         B     10(,NCP)           GIVE NORMAL RETURN
         EJECT
*
*        ENTRY TO GET A DEFERRED STRING
*
*        (PB,PO)                  POINTS TO PATTERN NODE
*        BAL   NCP,DEFEXPS
*        ->  ERROR RETURN IF UNCONVERTIBLE TO STRING
*        ->  ERROR RETURN IF NULL
*        ->  NORMAL RETURN
*        (RETURN)                 START OF STRING
*        (R2)                     ACTUAL LENGTH OF STRING
*
*        DEFEXPS ALSO DOES AN ANY/NOTANY TEST ON THE NEXT CHARACTER AND
*        LEAVES THE CC SET NONZERO IF THE CHAR WAS FOUND (ANY SUCCEEDS)
*        AND ZERO IF IT WAS NOT FOUND (NOTANY SUCCEEDS)
*
DEFEXPS  L     RETURN,PARAM2(PB,PO)         LOAD EXPR OR VAR POINTER
         CR    R0,R0              SET CC FOR CALL BY PAT MATCH
         BAL   R1,$EVAL           EVALUATE
         USING QPATSUBS,PBASE     BASE REG FOR NEXT INSTRUC
         B     FAIL               ON FAIL RETURN FROM CODE -- FAIL
         DROP  PBASE              DROP BASE REG
         BAL   RETURN,GETSTGS     GET STRING FROM RESULT
         B     DEFEXPE1           ERROR RETURN IF UNCONVERTABLE
         LR    RETURN,A1          SAVE STRING POINTER
         LTR   R2,A1+1            MOVE AND TEST LENGTH
         BM    DEFEXPE2           ERROR RETURN IF NULL
         LCR   R1,CP              MINUS NUM CHARS LEFT
         SR    A1,A1              CLEAR IC REG
         IC    A1,0(R1,FSADR)     LOAD CHARACTER TO TEST
         LA    R1,1               GET PLUG CHAR
         STC   R1,ZTBL(A1)        PLUG CHARACTER IN ZEROS TABLE
         EX    R2,CHARTRT         DO TRT TO TEST FOR AMONG GIVEN CHARS
         LA    R1,0               CLEAR R1 WITHOUT CLOBBERING CC
         STC   R1,ZTBL(A1)        RESTORE ALTERED LOCATION IN ZTBL
         LA    R2,1(,A1+1)        CONVERT 360 LENGTH TO ACTUAL LENGTH
         LM    BPS,PS2,PSAVBPS(PDR)         RELOAD BPS,PS2 (A1,A1+1)
         L     PO,PSAVPO(,PDR)    RESTORE PO TO CONTINUE MATCH
         B     8(,NCP)            RETURN TO CALLER
*
CHARTRT  TRT   SCHARS(*-*,RETURN),ZTBL      TRT TO TEST CHARACTER
         EJECT
*
*        COME HERE IF ARGUMENT UNCONVERTABLE AS REQUESTED
*
DEFEXPE1 LR    RETURN,NCP         COPY RETURN ADDRESS FOR ERROR MSG
         B     $EVALERR           OFF TO GIVE RECURSIVE ERROR CALL
*
*        COME HERE IF RESULT NOT VALID
*
DEFEXPE2 LA    RETURN,4(,NCP)     GET ERROR MESSAGE ADDRESS AS RETURN
*
*        COME HERE TO RESTORE R1 FROM PREVIOUS EVAL CALL, FOR ERROR
*
         USING QPATSUBS,PBASE     INDICATE PAT MATCH BASE REGISTER
$EVALERR LA    R1,FAIL            SET RETURN ADDRESS TO FAIL
         STM   PS1,PB,PSAVPS1(PDR)          SAVE PS1,PB (A2,A2+1)
         B     $EVAL1A            AND SAVE PAT STACK FOR SETEXIT (FAIL)
         DROP  PBASE              GET RID OF BASE REGISTER
         EJECT
*        $EVAL ENTRY TO EVALUATE EXPRESSION
*
*        CONDITION CODE IS EQ IF CALLED FROM PAT MATCH ROUTINE
*
*        (RETURN)                 EXPRESSION OR VARIABLE POINTER
*        BAL   R1,$EVAL
*        -> ERROR EXIT FOR CODE FAILURE -- ALL REGS RESTORED
*        -> (A1,A1+1) (BPS,PS2) RESULT -- ALL OTHER REGS RESTORED
*        EXCEPT DB1/PO WHICH POINTS TO DATA AREA (IS DB1 VALUE)
*
$EVAL    ST    PO,PSAVPO(,PDR)    SAVE CURRENT PATTERN OFFSET
         L     DB1,PSAVDB1(,PDR)  AND GET DATA AREA ADDRESS
         C     RETURN,ECODEBT     TEST FOR SIMPLE VARIABLE CASE
         BNL   $EVAL1             SKIP IF NOT
         TM    VFLAGS(RETURN),VINP+VINA     IS IT READ ASSOCIATED?
         BO    $EVALRR            SKIP IF SO
         STM   A1,A1+1,PSAVBPS(PDR)         SAVE A1,A1+1
         LM    A1,A1+1,VALUE(RETURN)        LOAD VARIABLE VALUE
         B     4(,R1)             TAKE SUCCESS EXIT
*
*        HERE FOR REFERENCE TO A VCODE FOR A READ ASSOCIATED VALUE
*        IN THIS CASE, WE OBTAIN A DUMMY EXPRESSION POINTER AND GO
*        THROUGH THE FULL ECODE LOGIC (I.E. A DEFFERED CALL)
*
$EVALRR  ST    RETURN,EVALVAR     SAVE VAR BLOCK ADDR FOR CALL
         L     RETURN,EVALRCON    GET ADDRESS OF DUMMY CODE
*
*        COME HERE FOR EXPRESSION CASE (READ ASSOC VARIABLE MERGES)
*
$EVAL1   STM   BPS,PB,PSAVBPS(PDR)          SAVE REGISTERS BELOW PO
*
*        COME HERE TO ISSUE AN ERROR MESSAGE DURING PATTERN MATCHING
*        (RETURN)                 POINTS TO ERROR MESSAGE
*        ALL REGISTERS ARE ON THE STACK, DB1 IS CORRECT
*        THE PURPOSE OF THIS RECURSIVE CALL IS TO SAVE THE PATTERN
*        STACK SO THAT A SETEXIT/CONTINUE HAS THE EFFECT OF ELEMENT
*        FAILURE IN THE MATCH
*        NOTE THAT (R1) MUST BE AS ON ORIGINAL CALL FOR SETEXIT
*
$EVAL1A  STM   CP,PBASE,PSAVCP(PDR)         SAVE REGS ABOVE PO
         L     FR,FRSAVE          RESTORE FREE CORE POINTER
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3
         SH    PDR,=Y(PATSPACE)   PUSH STACK PROPER AMOUNT
         STD   ZR,FRETFLOC(,PDR)  CLEAR POSSIBLE GARBAGE RETURN LOCS
         EJECT
*
*        EVAL FUNCTION MERGES HERE
*
$EVAL2   STE   ZR,PNAME(,PDR)     SET NAME FIELD UNUSED
         STE   ZR,FBLOKLOC(,PDR)  SAY THIS IS DEFFERED EXPRESSION
         ST    R1,EVLINK(,PDR)    SAVE LINKAGE WITH CONDITION CODE
         L     FRETURN,=A(DEFFAIL)          GET ADDRESS IN CASE OF FAIL
         L     R0,PDRLOC          GET CURRENT PDR BACK POINTER
         ST    R0,PDRBPTR(,PDR)   PUT IT ON STACK
         ST    PDR,PDRLOC         AND SET BACK POINTER FOR THIS LEVEL
         CR    FR,PDR             DO WE NEED A COLLECT?
         BCR   L,RETURN           OFF TO CODE IF NOT
         B     GBGCL0S            SAVE NOTHING, STORE RETURN FOR GBGCOL
*
*        COME HERE FOR SUCCESSFUL RETURN FROM CODE
*
$$EVLR   L     R1,EVLINK(,PDR)    RESTORE CALLERS CC AND ADDRESS
         SPM   R1                 RESTORE CONDITION CODE
         BNE   EVLR1              NO RE-EVALUATE FOR EXPRESSION CALL
         ST    A1,EVALSV          STORE RESULT TO TEST TYPE CODE
         TM    EVALSV,EXPRBIT     TEST FOR EXPRESSION RETURNED
         BNO   EVLR1              SKIP IF NOT EXPRESSION
         TM    STAGE,$OVERTIM     CHECK FOR UNCAUGHT OVERTIME
         BO    $$TIME             OFF TO GIVE ERROR MESSAGE IF OVERTIME
         LR    RETURN,A1          COPY EXPRESSION POINTER
         CLI   EVALSV,ECODE       IS IT COMPLEX VAR CASE?
         BCR   E,RETURN           OFF TO CODE IF SO
*
*        COME HERE FOR SIMPLE VARIABLE EXPRESSION RETURNED AS VALUE
*
         LM    A1,A1+1,VALUE(RETURN)        LOAD VALUE
         TM    VFLAGS(RETURN),VINP+VINA     IS IT READ ASSOCIATED?
         BNO   EVLR1              OFF TO RESTORE REGS IF NOT
         ST    RETURN,EVALVAR     SAVE VAR BLOCK ADDRESS FOR READ
         L     RETURN,EVALRCON    GET ADDRESS OF DUMMY CODE
         BR    RETURN             OFF TO CODE
*
*        COME HERE WITH VALUE TO RETURN TO CALLER
*
EVLR1    L     R2,PDRBPTR(,PDR)   RESTORE ACTUAL PDR IN CODE ABOVE US
         ST    R2,PDRLOC          SET IN CASE OF ERROR OR FAIL
         SPM   R1                 SEE WHO CALLED US
         BNE   4(,R1)             RETURN TO CALLER FOR EVAL CASE
         LA    PDR,PATSPACE(,PDR) PUSH UP STACK
         LM    PS1,PB,PSAVPS1(PDR)          RESTORE REGISTERS BELOW PO
         LM    CP,PBASE,PSAVCP(PDR)         RESTORE REGISTERS ABOVE PO
         ST    FR,FRSAVE          SAVE NEW FREE CORE ADDRESS
         L     R0,RETLOCP(,R2)    GET RETURN ADDR FOR PAT MATCH ERRORS
         ST    R0,RETLOC          AND STORE FOR ERROR MESSAGE ROUTINE
         L     FSADR,PSTRING(,R2) GET START OF STRING ADDRESS
         AH    FSADR,PSTRING+SOFFSET(,R2)   ADD IN OFFSET
         AH    FSADR,PSTRING+SLENGTH(,R2)   ADD IN 360 LENGTH
         LA    FSADR,SCHARS+1(,FSADR)       POINT PAST LAST CHARACTER
         B     4(,R1)             RETURN PAST FAIL RETURN
         TITLE 'SPITBOLA -- ARITHMETIC OPERATOR ROUTINES'
*
*        $$INCR                   INCREMENT (BY ONE)
*
*        (A1,A1+1)                ARG TO BE INCREMENTED
*        BAL   RETURN,$$INCR
*        (A1,A1+1)                INCREMENTED RESULT
*
$$INCR   LA    A2+1,1             GET A ONE
         LTR   A1,A1              WAS ARGUMENT AN INTEGER?
         BZ    ADDI               IF SO, JUMP TO ADD ONE
         SR    A2,A2              ELSE MAKE INTEGER 1 AND MERGE $$ADD2
*
*        $$ADD2                   SUM
*
*        (A1,A1+1)                LEFT ARG
*        (A2,A2+1)                RIGHT ARG
*        BAL   RETURN,$$ADD2
*        (A1,A1+1)                SUM
*
$$ADD2   ALR   A1,A2              ADD TYPE CODES
         BZ    ADDI               IF SUM=0, BOTH ARGS ARE INTEGERS
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES
         XERR  01,027             OPERAND OF BINARY + IS NON-NUMERIC
*
*        INSTRUCTIONS EXECUTED IN REAL,DREAL CASES
*
         AD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE
         AE    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE
*
*        CASE OF ADDITION OF TWO INTEGERS
*
ADDI     AR    A1+1,A2+1          PUT SUM IN A1+1 (A1 IS SET OK)
         BCR   NO,RETURN          RETURN IF NO OVERFLOW
         XERR  10,007,S           INTEGER ADDITION OVERFLOW
         EJECT
*
*        $$DECR                   DECREMENT (BY ONE)
*
*        (A1,A1+1)                ARGUMENT TO BE DECREMENTED
*        BAL   RETURN,$$DECR
*        (A1,A1+1)                DECREMENTED RESULT
*
$$DECR   LA    A2+1,1             GET A ONE
         LTR   A1,A1              WAS ARGUMENT AN INTEGER?
         BZ    SUBI               IF SO, JUMP TO SUBTRACT ONE
         SR    A2,A2              ELSE MAKE INTEGER 1 AND MERGE $$SUB2
*
*        $$SUB2                   SUBTRACTION
*
*        (A1,A1+1)                LEFT ARGUMENT
*        (A2,A2+1)                RIGHT ARGUMENT
*        BAL   RETURN,$$SUB2
*        (A1,A1+1)                DIFFERENCE
*
$$SUB2   ALR   A1,A2              ADD TYPE CODES
         BZ    SUBI               SUM=0 IF BOTH ARGS INTEGERS
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES
         XERR  01,028             OPERAND OF BINARY - IS NON-NUMERIC
*
*        INSTRUCTIONS EXECUTE IN REAL,DREAL CASES
*
         SD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE
         SE    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE
*
*        CASE OF SUBTRACTION OF TWO INTEGERS
*
SUBI     SR    A1+1,A2+1          DO SUBTRACTION
         BCR   NO,RETURN          RETURN TO CODE IF NO OVERFLOW
         XERR  10,008,S           INTEGER SUBTRACTION OVERFLOW
         EJECT
*
*        $$MLT2                   MULTIPLICATION
*
*        (A1,A1+1)                LEFT ARGUMENT
*        (A2,A2+1)                RIGHT ARGUMENT
*        BAL   RETURN,$$MLT2
*        (A1,A1+1)                PRODUCT
*
$$MLT2   ALR   A1,A2              ADD TYPE CODES
         BZ    MLTI               RESULT IS ZERO IF BOTH INTEGERS
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES
         XERR  01,029             OPERAND OF BINARY * IS NON-NUMERIC
*
*        INSTRUCTIONS EXECUTED FOR REAL,DREAL CASES
*
         MD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE
         ME    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE
*
*        MULTIPLICATION OF TWO INTEGERS
*
MLTI     MR    A1,A2+1            DO MULTIPLICATION
         LTR   A1+1,A1+1          TEST SIGN OF RESULT
         BNM   *+8                SKIP IF POSITIVE
         X     A1,=X'FFFFFFFF'    ELSE COMPLEMENT UPPER REG (SIGN BITS)
         LTR   A1,A1              UPPER REG SHOULD BE ALL ZEROS
         BCR   Z,RETURN           RETURN TO CODE IF SO
         XERR  10,009,S           INTEGER MULTIPLICATION OVERFLOW
         EJECT
*
*        $$DVD2                   DIVISION
*
*        (A1,A1+1)                LEFT ARGUMENT
*        (A2,A2+1)                RIGHT ARGUMENT
*        BAL   RETURN,$$DVD2
*        (A1,A1+1)                QUOTIENT
*
$$DVD2   ALR   A1,A2              ADD TYPE CODES
         BZ    DVDI               IF ZERO, BOTH INTEGERS
         BAL   R2,ARITH           CALL COMMON ROUTINE IN OTHER CASES
         XERR  01,030             OPERAND OF BINARY / IS NON-NUMERIC
*
*        INSTRUCTIONS EXECUTED IN REAL,DREAL CASES
*
         DD    FA,ARITHSV+8       INSTRUCTION FOR DREAL CASE
         DE    FA,ARITHSV+12      INSTRUCTION FOR REAL CASE
*
*        CASE OF DIVISION OF TWO INTEGERS
*
DVDI     LTR   A1+1,A1+1          TEST SIGN OF DIVIDEND
         BNM   *+6                SKIP IF ZERO OR POSITIVE
         BCTR  A1,0               ELSE PROPOGATE MINUS SIGN IN A1
         DR    A1,A2+1            DO DIVISION
*
*        NOTE -- INTERRUPT LOCATION -- ERROR EXIT DVDIZ
*
DVDII    BR    0                  ENSURE PRECISE INTERRUPT
         SR    A1,A1              IF OK, CLEAR TYPE CODE TO INTEGER
         BR    RETURN             RETURN TO CODE
         EJECT
*
*        $$CMPR                   COMPARISON
*
*        (A1,A1+1)                LEFT ARGUMENT
*        (A2,A2+1)                RIGHT ARGUMENT
*        BAL   RETURN,$$CMPR
*        (CONDITION CODE IS LEFT SET CORRECTLY)
*
$$CMPR   ALR   A1,A2              ADD TYPE CODES
         BZ    CMPI               SKIP ON CASE OF BOTH INTEGERS
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES
         XERR  01,031             ARGUMENT TO NE,EQ,LE,GE,LT OR GT
*                                 IS NON-NUMERIC
*
*        INSTRUCTIONS EXECUTED IN REAL AND DREAL CASES
*
         B     CMPD               JUMP ON DREAL CASE
         B     CMPR               JUMP ON REAL CASE
*
*        CASE OF COMPARISON OF TWO INTEGERS
*
CMPI     CR    A1+1,A2+1          COMPARE INTEGER VALUES
         BR    RETURN             RETURN TO CODE
*
*        CASE OF COMPARISON OF DREALS
*
CMPD     CD    FA,ARITHSV+8       DO COMPARISON
         BR    RETURN             LEAVE WITH CC SET
*
*        CASE OF COMPARISON OF REALS
*
CMPR     CE    FA,ARITHSV+12      DO REAL COMPARISON
         BR    RETURN             RETURN WITH CC SET
         EJECT
*
*        $$EXP2                   EXPONENTIATION
*
*        (A1,A1+1)                LEFT ARGUMENT
*        (A2,A2+1)                RIGHT ARGUMENT
*        BAL   RETURN,$$EXP2
*        (A1,A1+1)                RESULT
*
$$EXP2   ALR   A1,A2              ADD TYPE CODES
         BZ    EXPI               SKIP IF BOTH INTEGERS
         BAL   R2,ARITH           COMMON ROUTINE IN OTHER CASES
         XERR  01,032             OPERAND OF BINARY ** IS NON-NUMERIC
*
*        INSTRUCTIONS EXECUTED IN DREAL,REAL CASES
*
         BAL   R0,EXPDD           JUMP TO        (SEE TEST AT ARITH1
         BAL   R0,EXPRR            GIVE ERROR     TO EXPLAIN BAL)
*
*        CASE OF EXPONENTIATION OF TWO INTEGERS
*
EXPI     LTR   A2+1,A2+1          TEST EXPONENT
         BP    EXPOS              SKIP IF EXPONENT > 0
         LA    A1+1,1             PREPARE RESULT OF 1 FOR N ** 0
         BCR   Z,RETURN           AND RETURN FOR THIS CASE (EXPONENT=0)
         XERR  10,010,S           NEGATIVE EXPONENT FOR
*                                 INTEGER ** INTEGER
*
*        CASE OF EXPONENT > 0
*
EXPOS    LR    R1,A1+1            COPY BASE
         B     EXPOS2             JUMP TO END OF LOOP
*
*        LOOP TO MULTIPLY BY BASE (EXPONENT - 1) TIMES
*
EXPOSL   MR    A1,R1              MULTIPLY BY BASE
         SLDA  A1,32              TEST FOR OVERFLOW
         BNO   *+10               SKIP IF NONE
         XERR  10,011,S           OVERFLOW IN INTEGER EXPONENTIATION
         SRDA  A1,32              REPOSITION RESULT
*
*        JUMP TO THIS POINT IN LOOP FIRST TIME
*
EXPOS2   BCT   A2+1,EXPOSL        BACK TO MULTIPLY AGAIN
         SR    A1,A1              WHEN ALL DONE, SET CODE = 0 (ICODE)
         BR    RETURN             AND RETURN TO CODE
*
*        ERROR EXITS FOR DREAL AND REAL CASES
*
EXPDD    XERR  10,012             DREAL ** DREAL IS NOT PERMITTED
EXPRR    XERR  10,013             REAL ** REAL IS NOT PERMITTED
         EJECT
*
*        SPECIAL EXPONENTIATION ROUTINE FOR DREAL ** INTEGER
*
EXPWTOI  LR    A2+1,A1+1          SAVE EXPONENT
         BAL   FRETURN,ARITHWM    MERGE INTO ARITHSV TO LOAD DREAL
         MDR   ZR,FA              + EXP INSTRUC (R2 => HERE ON RETURN)
         DDR   ZR,FA              - EXP INSTRUCTION
         B     EXPWRI             ARITH EXECUTES THIS INSTRUCTION
*
*        SPECIAL ROUTINE FOR REAL ** INTEGER
*
EXPRTOI  BAL   FRETURN,ARITHIM    USE ARITH TO LOAD REAL ARGUMENT
         MER   ZR,FA              + EXPONENT INSTRUCTION
         DER   ZR,FA              MINUS EXPONENT INSTRUCTION
         NOP   0                  4 EXTRA BYTES (EXECUTE IS OF 8(R2))
         B     EXPWRI             ARITH EXECUTES THIS INSTRUCTION
*
*        COMMON ROUTINE FOR DREAL ** INTEGER AND REAL ** INTEGER
*
EXPWRI   LE    ZR,=E'1.0'         LOAD INITIAL VALUE OF ONE
         LTR   A2+1,A2+1          TEST EXPONENT
         BP    EXPWRI1            SKIP IF EXPONENT IS POSITIVE
         BZ    EXPWRI2            SKIP IF EXPONENT IS ZERO
*
*        HERE FOR NEGATIVE EXPONENT
*
         LPR   A2+1,A2+1          FORCE EXPONENT POSITIVE
         LA    R2,2(,R2)          POINT TO DIVIDE INSTEAD OF MULTIPLY
*
*        COME HERE TO DO EXPONENTIATION
*
EXPWRI1  BALR  R1,0               SET START OF LOOP ADDRESS
         EX    0,0(,R2)           EXECUTE MDR,MER,DDR,DER
*
*        THIS IS AN INTERRUPT LOCATION -- EXIT TO EXPWRO ON FPT OVERFLO
*
EXPWRE   BR    0                  ENSURE PRECISE INTERRUPT
         BCTR  A2+1,R1            IF NO OVERFLOW, LOOP TILL DONE
*
*        COME HERE TO STORE RESULT
*
EXPWRI2  LDR   FA,ZR              PUT RESULT IN PROPER REG
         SDR   ZR,ZR              CLEAR ZR BACK TO ZERO
         TM    0(R2),X'10'        CHECK FOR BIT INDICATING SHORT-FORM
         BNO   DREALIL            SKIP BACK TO RETURN DREAL
         STE   FA,ARITHSV+4       ELSE STORE REAL RESULT
         LM    A1,A1+1,ARITHSV    LOAD INTO RESULT REGS
         BR    RETURN             RETURN TO CALLER
         EJECT
*        ARITH ROUTINE -- CALLED BY BINARY ARITHMETIC ROUTINES TO DO
*        TYPE ANALYSIS AND CONVERSION IN ALL BUT SIMPLE CASES
*
*        (A1)                     SUM OF TYPE CODES
*        (A1+1)                   SECOND WORD OF LEFT ARG
*        (A2,A2+1)                RIGHT ARG
*        BAL   R1,ARITH
*        ->  ERROR EXIT FOR ARGUMENTS NOT CONVERTIBLE
*        -> INSTRUCTION EXECUTED IN DREAL/DREAL CASE
*        -> INSTRUCTION EXECUTED IN REAL/REAL CASE
*        -> EXIT POINT FOR INTEGER/INTEGER CASE
*        (A1,A1+1)                CONVERTED LEFT ARGUMENT
*        (A2,A2+1)                CONVERTED RIGHT ARGUMENT
*
*        NORMALLY BOTH ARGUMENTS ARE CONVERTED TO THE HIGHER TYPE --
*        THE ONE EXCEPTION TO THIS CASE IS FOR EXPONENTIATION
*        (RECOGNIZED BY THE XERR FOR DREAL/DREAL CASE). HERE THE CASES
*        DREAL ** INTEGER, REAL ** INTEGER RETURN TO THE SPECIAL
*        ROUTINES EXPWTOI AND EXPRTOI RESPECTIVELY
*
ARITH    BC    CZ,ARITHRR         IMMEDIATE SKIP ON REAL/REAL CASE
         STM   FRETURN,RETURN,FRETLOC       SAVE RETURN REGISTERS
         SR    A1,A2              RESTORE TYPE CODES
         LR    FRETURN,R2         SAVE ARITH LINKAGE
         BAL   RETURN,GETNUM      CONVERT FIRST ARG TO NUMERIC
         BR    FRETURN            ERROR RETURN IF UNCONVERTIBLE
         NOPR  0                  SPACE TO FILL ERROR RETURN TO 4 BYTES
         STM   A1,A1+1,ARITHSV    SAVE CONVERTED FIRST ARGUMENT
         LR    A1,A2              COPY SECOND ARGUMENT
         LR    A1+1,A2+1          ...
         BAL   RETURN,GETNUM      CONVERT SECOND ARGUMENT TO NUMERIC
         BR    FRETURN            ERROR RETURN IF UNCONVERTIBLE
         NOPR  0                  FILL ERROR RETURN TO 4 BYTES
         BNP   ARITH1             SKIP IF SECOND ARG REAL OR INTEGER
*
*        COME HERE WITH SECOND ARGUMENT DREAL
*
ARITHWW  SLDL  A1,8               POSITION DREAL FOR ARITHMETIC
         STM   A1,A1+1,ARITHSV+8  SAVE DREAL SECOND ARGUMENT
*
*        EXPWI MERGES HERE TO LOAD ITS ARGUMENT
*
ARITHWM  LM    A1,A1+1,ARITHSV    LOAD FIRST ARGUMENT
         BAL   RETURN,GETDREAL    CONVERT FIRST ARG TO DREAL
         NOP   0                  NO ERROR IS POSSIBLE
         SLDL  A1,8               POSITION FIRST ARG FOR ARITHMETIC
         STM   A1,A1+1,ARITHSV    SAVE DREAL FIRST ARG
         LD    FA,ARITHSV         LOAD FIRST ARGUMENT
         LR    R2,FRETURN         RESTORE LINKAGE TO ARITHSV
         LM    FRETURN,RETURN,FRETLOC       RESTORE RETURN REGS
         STE   ZR,FRETLOC         INDICATE FRETLOC NOT IN USE
         EX    0,4(,R2)           EXECUTE ARITHMETIC INSTRUCTION
         EJECT
*
*        ARITH -- CONTINUED
*
*
*        THIS IS AN INTERRUPT LOCATION, ON FLOATING OVERFLOW, THE EXIT
*        IS TO DREALO, ON FLOATING DIVIDE, THE EXIT IS TO DREALDZ
*
DREALIL  BR    0                  ENSURE PRECISE INTERRUPT
         STD   FA,ARITHSV         IF OK, STORE RESULT
         LM    A1,A1+1,ARITHSV    LOAD INTO PROPER REG
         SRDL  A1,8               POSITION
         AL    A1,WCODEBT         SUPPLY TYPE CODE
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE IF SECOND ARGUMENT IS INTEGER OR REAL
*
ARITH1   CLI   ARITHSV,WCODE      IS FIRST ARG DREAL?
         BNE   ARITH2             SKIP IF NOT
         LTR   A1,A1              IS SECOND ARG INTEGER?
         BNZ   ARITH1A            SKIP IF NOT
         CLI   4(FRETURN),X'45'   IS THIS EXPONENTIATION CASE? (BAL R0)
         BE    EXPWTOI            SKIP IF SO TO GET DREAL ** INTEGER
*
*        COME HERE IF BOTH ARGS TO BE CONVERTED TO DREAL
*
ARITH1A  BAL   RETURN,GETDREAL    CONVERT SECOND ARGUMENT TO DREAL
         NOP   0                  NO ERROR RETURN IS POSSIBLE
         B     ARITHWW            MERGE BACK FOR DREAL/DREAL CASE
*
*        COME HERE IF NEITHER ARGUMENT IS A DREAL
*
ARITH2   LTR   A1,A1              TEST SECOND ARGUMENT
         BZ    ARITH3             SKIP IF SECOND ARGUMENT INTEGER
         LR    A2+1,A1+1          MOVE REAL SECOND ARGUMENT
         LR    A2,A1              ...
         LM    A1,A1+1,ARITHSV    LOAD FIRST ARGUMENT
         BAL   RETURN,GETREAL     CONVERT FIRST ARGUMENT TO REAL
         NOP   0                  NO ERROR RETURN IS POSSIBLE
*
*        REENTER HERE FOR REAL/INTEGER CONVERTED TO REAL/REAL
*
ARITH2A  LR    R2,FRETURN         RELOAD ARITH LINKAGE
         LM    FRETURN,RETURN,FRETLOC       RELOAD RETURN REGS
         STE   ZR,FRETLOC         INDICATE FRETLOC NOT IN USE
*
*        COME HERE IF BOTH ARGUMENTS ARE REAL
*
ARITHRR  STM   A1+1,A2+1,ARITHSV+4          STORE REAL ARGS
         LE    FA,ARITHSV+4       LOAD LEFT ARGUMENT
         EX    0,8(,R2)           EXECUTE PROPER ARITHMETIC INSTRUC
         EJECT
*
*        THIS IS AN INTERRUPT LOCATION -- ON FLOATING OVERFLOW, THE
*        EXIT IS TO REALO, ON FLOATING DIVIDE, THE EXIT IS TO REALDZ
*
REALIL   BR    0                  ENSURE PRECISE INTERRUPT
         STE   FA,ARITHSV+12      STORE RESULT
         LM    A1,A1+1,ARITHSV+8  LOAD RESULT INTO PROPER REG
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE IS SECOND ARG IS INTEGER, FIRST ARG REAL OR INTEGER
*
ARITH3   CLI   ARITHSV,ICODE      IS FIRST ARG INTEGER?
         BE    ARITH4             SKIP IF SO (BOTH INTEGERS)
         CLI   4(FRETURN),X'45'   IS THIS EXPONENTIATION CASE? (BAL R0)
         BE    EXPRTOI            IF SO, JUMP TO COMPUTE REAL**INTEGER
         BAL   RETURN,GETREAL     ELSE CONVERT SECOND ARG TO REAL
         NOP   0                  NO ERROR IS POSSIBLE
*
*        EXPRI MERGES HERE TO LOAD ITS ARGUMENT
*
ARITHIM  LR    A2+1,A1+1          MOVE SECOND ARGUMENT
         LR    A2,A1              ...
         LM    A1,A1+1,ARITHSV    LOAD REAL FIRST ARGUMENT
         B     ARITH2A            AND JUMP BACK FOR REAL/REAL CASE
*
*        COME HERE FOR INTEGER/INTEGER CASE
*
ARITH4   LR    A2,A1              MOVE FIRST ARG TO A2,A2+1
         LR    A2+1,A1+1
         LM    A1,A1+1,ARITHSV    RELOAD FIRST ARGUMENT
         LR    R2,FRETURN         RELOAD ARITH LINKAGE
         LM    FRETURN,RETURN,FRETLOC       RESTORE RETURN REGS
         STE   ZR,FRETLOC         INDICATE FRETLOC NOT IN USE
         B     12(,R2)            JUMP TO INTEGER/INTEGER CODE
         EJECT
*
*        $$ADD1                   AFFIRMATION
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,$$ADD1
*        (A1,A1+1)                RESULT
*
$$ADD1   ST    RETURN,RETLOC      STORE RETURN LOCATION (FOR XERR)
         LR    A2,RETURN          SAVE RETURN LOCATION
         BAL   RETURN,GETNUM      CONVERT TO NUMERIC
         XERR  01,033             OPERAND OF UNARY + IS NON-NUMERIC
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         BR    A2                 RETURN TO CODE
*
*        $$SUB1                   NEGATION
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,$$SUB1
*        (A1,A1+1)                NEGATIVE
*
$$SUB1   ST    RETURN,RETLOC      SAVE RETURN LOCATION
         BAL   RETURN,GETNUM      CONVERT TO NUMERIC
         XERR  01,034             OPERAND OF UNARY - IS NON-NUMERIC
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         BZ    SUB1I              SKIP ON INTEGER CASE
         BO    SUB1R              SKIP ON REAL CASE
*
*        HERE FOR DREAL
*
         X     A1,=X'00800000'    INVERT SIGN BIT
         BR    RETURN             RETURN TO CODE
*
*        HERE FOR INTEGER CASE
*
SUB1I    LCR   A1+1,A1+1          NEGATE INTEGER
         BCR   NO,RETURN          RETURN IF NO OVERFLOW
         XERR  10,014             INTEGER OVERFLOW FOR UNARY MINUS
*                                 (HAPPENS ONLY WITH LARGEST NEG NUM)
*
*        HERE FOR REAL CASE
*
SUB1R    X     A1+1,X80           INVERT SIGN BIT
         BR    RETURN             RETURN TO CODE
         TITLE 'SPITBOLA -- ARRAY ENTRY POINTS'
*
*        THESE FUNCTIONS ARE CALLED TO CALCULATE ARRAY NAMES AND VALUES
*        THE ACTUAL ROUTINES ARE IN THE UNADDRESSABLE REGION
*        THIS CODING IS REPEATED IN THE ITEM FUNCTION
*
*
*        $$AR1N                   SINGLE SUBSCRIPTED ARRAY BY NAME
*
$$AR1N   MVI   NAMEFL,0           SET BY NAME FLAG AND MERGE $$AR1V
         L     R2,SUBSC1AD        GET ADDRESS OF ROUTINE
         BR    R2                 AND GO TO IT
*
*        $$AR1V                   SINGLE SUBSCRIPTED ARRAY BY VALUE
*
$$AR1V   MVI   NAMEFL,X'FF'       SET CALL BY VALUE
         L     R2,SUBSC1AD        GET ADDRESS OF ROUTINE
         BR    R2                 AND GO TO IT
*
SUBSC1AD DC    A(SUBSC1)          ADDRESS OF ROUTINE
*
*        $$ARMN                   MULTIPLE SUBSCRIPT ARRAY BY NAME
*
$$ARMN   MVI   NAMEFL,0           SET BY NAME FLAG AND MERGE $$ARMV
         L     A2,SUBSCMAD        GET ADDRESS OF ROUTINE
         BR    A2                 AND OFF TO IT
*
$$ARMV   MVI   NAMEFL,X'FF'       SET FOR CALL BY VALUE
         L     A2,SUBSCMAD        GET ADDRESS OF ROUTIEN
         BR    A2                 AND OFF TO IT
*
SUBSCMAD DC    A(SUBSCM)          ADDRESS OF ROUTINE
         TITLE 'SPITBOLA -- MISCELLANEOUS OPERATOR ENTRY POINTS'
*
*        $$DTTP                             DATATYPE FUNCTION
*
$$DTTP   L     R2,=A(DATATPP)     LOAD ROUTINE ADDRESS
         BR    R2                 OFF TO IT
*
*        SYSTEM ENTRY POINT FOR OPSYN ROUTINE
*
OPSYN$   L     A2,=A(OPSYN$C)     GET BASE REGISTER
         BR    A2                 AND OFF TO ROUTINE
*
*        SYSTEM ENTRY POINT FOR XSCAN INITIALIZATION
*
XSCANI   L     A2,=A(XSCAN)       LOAD BASE REGISTER
         USING XSCAN,A2           TELL ASSEMBLER
         B     XSCANIC            OFF TO INITIALIZATION CODE
         DROP  A2                 GET RID OF BASE REGISTER
*
*        SYSTEM ENTRY POINT FOR ROUTINE TO ORDER TABLE ELEMENTS
*
TBCHRON  L     A2,=A(TBCHRONC)    LOAD ROUTINE ADDRESS
         BR    A2                 AND OFF TO IT
         EJECT
*
*        $$LCMP                   LEXICAL COMPARISON
*
*        (A1,A1+1)                FIRST ARGUMENT
*        (A2,A2+1)                SECOND ARGUMENT
*        BAL   RETURN,$$LCMP
*        (RETURN WITH CONDITION CODE SET CORRECTLY)
*
*        THIS ROUTINE IS USED BY LEQ,LNE,LGT,LLT,LLE,LGE
*
$$LCMP   ST    RETURN,RETLOC      SAVE RETURN LOCATION
         BAL   RETURN,GETSTGT     CONVERT LEFT ARG TO STRING
         XERR  01,035             ARGUMENT FOR LEQ,LNE,LGT,LLT,
*                                 LGE OR LLE IS NOT A STRING
         LR    RETURN,A1          SWITCH ARGUMENTS
         LR    A1,A2              ...
         LR    A2,RETURN          ...
         LR    RETURN,A1+1        ...
         LR    A1+1,A2+1          ...
         LR    A2+1,RETURN        ...
         BAL   RETURN,GETSTGS     CONVERT TO STRING
         XERN  01,035             ARGUMENT FOR LEQ,LNE,LGT,LLT,
*                                 LGE OR LLE IS NOT A STRING
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
*
*        THE DUMP FUNCTION ENTERS HERE TO COMPARE TWO STRINGS AND IT
*        IS IMPORTANT THAT ONLY A1,A1+1,A2,A2+1,R1 ARE USED FROM NOW ON
*
LCMPM    CR    A2+1,A1+1          COMPARE LENGTHS
         BALR  R1,0               SAVE RESULT OF THIS COMPARISON
         BNL   *+6                SKIP IF A1+1 HAS SHORTER LENGTH
         LR    A1+1,A2+1          ELSE GET THE SHORTER LENGTH
         LTR   A1+1,A1+1          IS EITHER OR BOTH ARGS NULL?
         BM    LCMP3              SKIP IF SO TO SET CC BY LENGTHS
*
*        HERE WE ARE READY TO COMPARE TWO STRINGS
*
         LA    A2+1,256           GET CRANK CONSTANT
         CR    A1+1,A2+1          256 CHARACTERS OR LESS?
         BL    LCMP2              SKIP IF SO
         EJECT
*
*        $$LCMP -- CONTINUED
*
*
*        LOOP TO CHECK 256 CHARACTERS AT A TIME
*
LCMP1    CLC   SCHARS(256,A2),SCHARS(A1)    CHECK 256 CHARS
         BCR   NE,RETURN          ALL DONE IF NO MATCH
         AR    A1,A2+1            ELSE BUMP ARG ONE POINTER
         AR    A2,A2+1            BUMP ARG TWO POINTER
         SR    A1+1,A2+1          DECREMENT CHARS LEFT
         CR    A1+1,A2+1          STILL MORE THAN 256 CHARACTERS?
         BNL   LCMP1              LOOP BACK IF SO
*
*        COME HERE TO CHECK FINAL CHARACTERS
*
LCMP2    EX    A1+1,LCMPC         CHECK LAST CHARS
         BCR   NE,RETURN          ALL SET IF THEY DO NOT MATCH
*
*        COME HERE IF ALL CHARS MATCH -- SET CC BY LENGTHS
*
LCMP3    SPM   R1                 RECALL CC FROM LENGTH COMPARISON
         BR    RETURN             RETURN TO CALLER
*
LCMPC    CLC   SCHARS(*-*,A2),SCHARS(A1)    CHECK REMAINING CHARS
         EJECT
*        $$IDNT                   IDENT
*
*        (A1,A1+1)                LEFT ARG
*        (A2,A2+1)                RIGHT ARG
*        BAL   RETURN,$$IDNT
*        (CC SET EQUAL OR UNEQUAL DEPENDING ON RESULT)
*
*        NOTE -- THIS ROUTINE MUST NOT USE R0,R1,R2 SINCE IT IS CALLED
*        FROM WITHIN THE SYSTEM (SEE $ ROUTINES AND TABLE LOOK UP)
*
$$IDNT   CR    A1,A2              COMPARE FIRST WORDS
         BNE   IDENTN             SKIP IF FIRST WORDS UNEQUAL
         CR    A1+1,A2+1          ELSE CHECK SECOND WORDS
         BCR   E,RETURN           DEFINITELY IDENT IF BOTH MATCH
*
*        HERE WE HAVE THE SITUATION WHERE THE FIRST WORDS MATCH BUT
*        THE SECOND WORD DOES NOT. THE ARGUMENTS ARE STILL IDENT
*        EXCEPT FOR NUMERIC DATATYPES AND NAMES WHICH ARE DIFFER,
*        AND STRINGS WHICH MUST BE COMPARED TO GET THE RESULT
*
         STM   A1,A2+1,IDNTSV     STORE ARGS IN CASE STRING
         C     A1,ACODEBT         CHECK FOR NUMERIC,STRING,NAME
         BL    IDENTT             JUMP IF ANY OF THESE
         CR    R0,R0              ELSE SET CONDITION CODE FOR IDENT
         BR    RETURN             RETURN TO CALLER
*
*        COME HERE IF THE FIRST WORDS ARE UNEQUAL. CAN STILL BE
*        IDENT FOR STRINGS AND NULLS
*
IDENTN   STM   A1,A2+1,IDNTSV     SAVE ARGUMENTS
         CLC   IDNTSV(1),IDNTSV+8 ARE DATATYPES THE SAME?
         BCR   NE,RETURN          DEFINITELY DIFFER IF NOT
         CLI   IDNTSV,NCODE       ELSE ARE THEY NULLS?
         BCR   E,RETURN           IDENT IF SO
*
*        MERGE HERE TO TEST FOR STRING (DIFFER IF ANYTHING ELSE)
*
IDENTT   CLI   IDNTSV,SCODE       ARE ARGUMENTS STRINGS?
         BCR   NE,RETURN          RETURN (DIFFER) IF NOT
         EJECT
*
*        IDENT -- CONTINUED
*
*        CASE OF STRING ARGUMENTS
*
IDENTS   LH    A1+1,IDNTSV+SLENGTH          GET 360 LENGTH OF 1ST ARG
         CH    A1+1,IDNTSV+SLENGTH+8        COMPARE WITH 2ND ARG LENGTH
         BCR   NE,RETURN          DIFFER IF LENGTHS UNEQUAL
         AH    A1,IDNTSV+SOFFSET            ELSE ADD LEFT ARG OFFSET
         AH    A2,IDNTSV+SOFFSET+8          ADD RIGHT ARG OFFSET
*
*        SPECIAL ENTRY USED BY $ TO COMPARE STRINGS
*
IDENTM   LA    A2+1,256           GET CRANK CONSTANT
         CR    A1+1,A2+1          TEST FOR 256 CHARS OR LESS
         BL    IDENTSE            SKIP IF 256 CHARS OR LESS
*
*        LOOP TO COMPARE 256 CHARACTER CHUNKS
*
IDENTSL  EX    0,LCMP1            COMPARE 256 CHARACTERS
         BCR   NE,RETURN          DIFFER IF NOT THE SAME
         AR    A1,A2+1            PUSH LEFT ARG STRING POINTER
         AR    A2,A2+1            PUSH RIGHT ARG STRING POINTER
         SR    A1+1,A2+1          DECREMENT LENGTH
         CR    A1+1,A2+1          MORE THAN 256 CHARS TO GO?
         BNL   IDENTSL            SKIP BACK IF SO
*
*        COME HERE TO COMPARE 256 CHARS OR LESS AT END
*
IDENTSE  EX    A1+1,IDENTC        COMPARE REMAINING CHARACTERS
         BR    RETURN             LEAVE WITH CC CORRECTLY SET
*
IDENTC   EQU   LCMPC              COMPARE LAST CHARACTERS
         EJECT
*
*        THIS ROUTINE IS PASSED THE CORRECT ADDRESS -- IT MERELY
*        SUPPLIES THE UPPER BYTE (TYPE CODE) AND RETURNS
*
*        $$AST1                   UNARY * (DEFERRED EXPRESSION)
*
*        (R2)                     4 BYTES BEHIND CODE (FROM BALR)
*        BAL   RETURN,$$AST1
*        (A1,A1+1)                EXPRESSION SPECIFIER
*
$$AST1   LA    A1,4(,R2)          POINT TO CODE & CLEAR UPPER BYTE
         A     A1,ECODEBT         SUPPLY TYPE CODE
         BR    RETURN             AND RETURN
*
*        $$INTG                   INTEGER
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,$$INTG
*        -->   0(FRETURN) IF NOT AN INTEGER
*        -->   0(RETURN)  IF AN INEGER
*
$$INTG   LR    A2,RETURN          SAVE RETURN POINT
         BAL   RETURN,GETNUM      CONVERT TO NUMERIC
*
*        HERE IF CONVERSION ATTEMPT FAILS
*
         LR    RETURN,A2          RESTORE RETURN POINT
         BR    FRETURN            GIVE FAILURE RETURN
*
*        HERE IF CONVERSION ATTEMPT SUCCEEDS
*
         LR    RETURN,A2          RESTORE RETURN POINT
         LTR   A1,A1              IS RESULT AN INTEGER?
         BCR   NZ,FRETURN         FAILURE RETURN IF NOT AN INTEGER
         BR    RETURN             AND RETURN TO CALLER
         TITLE 'SPITBOLA -- GARBAGE COLLECTION ENTRY POINTS'
*
*        THE GARBAGE COLLECTOR NEEDS THREE PARAMETERS --
*
*        1)    THE CODE LOCATION
*                                 A)        IN RETURN (S ENTRY POINTS)
*                                 B)        AT RETLOC (NORMAL ENTRIES)
*
*        2)    RETURN POINT                 IN RETURN
*
*        3)    NUMBER OF ACCUMULATORS TO RELOCATE (DEPENDS ON ENTRY)
*
*
*        STORE CODE LOCATION -- RELOCATE NO REGISTERS
*
GBGCL0S  ST    RETURN,RETLOC      STORE RETURN, MERGE GBGCL0
*
*        NO CODE LOC STORE, NO REGISTER RELOCATION
*
GBGCL0   MVI   GCOLNRG,0          SET FOR NO REGS TO RELOCATE
         B     GCOLC              JUMP TO COMMON CALL POINT
*
*        STORE CODE LOCATION -- RELOCATE CONTENTS OF (A1,A1+1)
*
GBGCL1S  ST    RETURN,RETLOC      STORE CODE LOCATION, MERGE GBGCL1
*
*        NO CODE LOC SAVE -- RELOCATE (A1,A1+1)
*
GBGCL1   MVI   GCOLNRG,GRELOC1    SET TO SAVE ONE REG
         B     GCOLC              JUMP TO COMMON CALL POINT
*
*        STORE CODE LOCATION -- RELOCATE (A1,A1+1) , (A2,A2+1)
*
GBGCL2S  ST    RETURN,RETLOC      SAVE CODE LOCATION
*
*        NO CODE LOC SAVE -- RELOCATE (A1,A1+1) , (A2,A2+1)
*
GBGCL2   MVI   GCOLNRG,GRELOC1+GRELOC2      SET TO RELOCATE A1 & A2
*
*        COMMON CALL POINT
*
GCOLC    L     R1,=A(GCOL)        LOAD ROUTINE ADDRESS
         BR    R1                 OFF TO IT
*
*        SPECIAL ENTRY FROM THE MIDDLE OF A FUNCTION CALL
*
GBGCLF   MVI   GCOLNRG,GGBGCLF    SET SPECIAL FLAG
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3
         B     GCOLC              JUMP TO COMMON CALL POINT
         TITLE 'SPITBOLA -- END OF RUN ENTRY POINT'
*
*        $$STOP                   COME HERE ON FLOW INTO END LABEL
*
$$STOP   L     DB4,=A(DTERTNS)    LOAD DUMP/TRACE/EOJ BASE REG
         USING DTERTNS,DB4        TELL ASSEMBLER
         B     ENDLABEL           AND MERGE WITH END LABEL TRANSFER
         DROP  DB4                DROP BASE REG
         TITLE 'SPITBOLA -- MISCELLANEOUS ERROR EXITS'
*
*        ENTER HERE FROM STATEMENT WITH COMPILATION ERROR
*
$$SERR   XERR  04,001,S           ATTEMPTED EXECUTION OF A STATEMENT
*                                 FOUND ERRONEOUS BY THE COMPILER
*
*        ENTER HERE ON FAILURE WITHIN GOTO
*
$$FING   XERR  07,001,S           THE EVALUATION OF A COMPLEX GOTO
*                                 ITSELF FAILED
*
*        ENTER HERE WHEN FUNCTION CALLED BY NAME RETURNS VALUE
*
$$FRVN   XERR  14,001,S           A FUNCTION CALLED BY NAME RETURNED
*                                 A VALUE
*
*        HERE FOR OTHER VALUE WHERE NAME REQUIRED CASES
*
$$NMVL   XERR  14,002,S           AN EXPRESSION OTHER THAN A FUNCTION
*                                 CALL RETURNED A VALUE WHERE A NAME
*                                 WAS REQUIRED
*
*        HERE TO TEST FOR OVERTIME DURING PATTERN MATCHING. ANY
*        PATTERN EXTENSION ROUTINE WHICH IS LIKELY TO LEAD TO LONG
*        OR INFINITE PATTERN MATCH LOOPS USES THIS OVERTIME CHECK
*
*        CALLED BY:
*
*        BAL   R2,PTIMTST
*        -->                      RETURN IF OK (R1,R2) DESTROYED
*
PTIMTST  L     R1,PSAVDB1(,PDR)   GET DATA AREA POINTER
         TM    STAGE-SPITBOLD(R1),$OVERTIM  ARE WE OVERTIME?
         BCR   NO,R2              RETURN IF NOT OVERTIME
         LR    DB1,R1             ELSE RESTORE DATA AREA PTR AND MERGE
*
*        HERE FOR OVERTIME TRAP
*
$$TIME   LE    SCNT,SCNTTSAV      RESTORE PROPER VALUE OF SCNT
         NI    STAGE,X'FF'-$OVERTIM         TURN OFF OVERTIME FLAG
         XERR  11,009             TIME LIMIT EXCEEDED
         TITLE 'SPITBOLA -- PATTERN CONTRUCTION ROUTINES'
*
*        THE FOLLOWING ROUTINES IMPLEMENT THE OPERATORS AND FUNCTIONS
*        WHICH RETURN PATTERNS WHEN CALLED
*
*
*        MPBLOK                   MAKE A PATTERN BLOCK
*
*        THIS IS THE UTILITY ROUTINE USED TO CREATE PATTERN BLOCKS
*
*        (R2)                     MINMATCH FIELD CONTENTS
*        (A1,A1+1)                PARAMS (AS NEEDED)
*        BAL   R1,MPBLOK
*        DC    YL1(FLAGS)         CONTENTS TO BE PLACED IN PFLAGS FIELD
*        DC    YL1(PTLENG)        LENGTH (28,32,36 -- 0,1,2 PARAMS)
*
*        FOLLOWED BY EITHER --
*
*        DC    Y(CODELOC-PATSUBS)           FOR CASE WITH NO EXTEND
*
*        OR
*
*        DC    YL2(CODELOC-PATSUBS+X'8000') FOR CASE WITH EXTEND
*        DC    YL2(EXTEND-QPATSUBS)         OFFSET TO QUICKSCAN ROUTINE
*
*
*        MPBLOK RETURNS WITH THE PATTERN POINTER IN A1 (NO GCOL TEST)
*
*        MPBLOKX                  IS CALLED IN THE SAME WAY, BUT
*                                 RETURNS TO THE GENERATED CODE VIA
*                                 (RETURN) AFTER TESTING FOR GCOL
*
*        MPBLOKXR                 ALSO RESTORES DB2
*
MPBLOKXR L     DB2,$$BAS2         RESTORE DB2 BEFORE CALL
*
*        MPBLOKX ENTRY POINT
*
MPBLOKX  MVI   PBLOKSW,X'00'      SET SWITCH, MERGE MPBLOK
         B     *+8                MERGE PAST SWITCH SET
*
*        MPBLOK ENTRY POINT
*
MPBLOK   MVI   PBLOKSW,X'FF'      SET X FLAG OFF
         L     DB3,=A(MPBLOKC)    LOAD ADDRESS OF CONTINUATION
         BR    DB3                JUMP TO IT
         EJECT
*
*        BINARY DOT/DOLLAR ROUTINES
*
*        $$DOTD                   DOT WITH DEFERRED NAME
*        $$DOT2                   DOT -- NORMAL CASE
*        $$DOLD                   DOLLAR WITH DEFERRED NAME
*        $$DOL2                   DOLLAR -- NORMAL CASE
*
*        FOR $$DOLD,$$DOTD
*
*        (A2,A2+1)                EXPRESSION
*        (A1,A1+1)                PATTERN (MAY NEED CONVERTING)
*        BAL   RETURN,$$DOLD      ($$DOTD)
*        (A1,A1+1)                RESULTING PATTERN
*
*        FOR $$DOL2,$$DOT2
*
*        (A1,A1+1)                PATTERN (MAY NEED CONVERTING)
*        (A2,A2+1)                NAME AND OFFSET
*        BAL   RETURN,$$DOL2      ($$DOT2)
*        (A1,A1+1)                RESULTING PATTERN
*
*
*
*        THESE FOUR OPERATORS GENERATE A STRUCTURE AS FOLLOWS
*
*        +------------+         +------------+         +------------+
*        |            |  THEN   |            |  THEN   |            |
*        |    MARK    |-------->|   PATTERN  |-------->|   DOLDOT   |
*        |            |         |            |         |            |
*        +------------+         +------------+         +------------+
*
*        MARK IS A SPECIAL PATTERN WHICH SAVES THE CURRENT CURSOR LOC
*        PATTERN IS THE LEFT ARGUMENT TO THE $ OR . OPERATOR
*        DOLDOT IS THE PATTERN NODE FOR THE APPROPRIATE CASE
*
*        THE FOLLOWING PATTERN MATCH ROUTINES ARE INVOLVED --
*
*        DOL,DOT,DOLD,DOTD,MARK,DOTEXT,DOLEXT,MARKEXT
*
*        PCONC IS USED TO PERFORM THE NECCESSARY PATTERN CONCATENATIONS
*
         EJECT
*
*        DOLLAR/DOT ROUTINES -- CONTINUED
*
*
*        DOTD ENTRY POINT (DEFERRED DOT CASE)
*
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   DOTEXT
*
$$DOTD   BAL   R2,DOLDOTD         GO TO COMMON ROUTINE
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) 2ND PARAM IS RELOC
         DC    AL2(PN$DOTD-PATSUBS+X'8000')
         DC    AL2(DOTEXT-QPATSUBS)
*
*        $$DOLD                   DOLLAR (DEFERRED CASE)
*
*        PARAM1                   NOT USED
*        PARAM2                   EXPRESSION POINTER
*        EXTEND                   DOLEXT
*
$$DLRD   BAL   R2,DOLDOTD         GO TO COMMON ROUTINE
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) 2ND PARAM IS RELOC
         DC    AL2(PN$DOLD-PATSUBS+X'8000')
         DC    AL2(DOLEXT-QPATSUBS)
*
*        $$DOT2                   DOT NORMAL CASE
*
*        PARAM1                   NAME BASE
*        PARAM2                   NAME OFFSET
*        EXTEND                   DOTEXT
*
$$DOT2   BAL   R2,DOLDOT          OFF TO COMMON ROUTINE
         DC    YL1(PARM1+PARM2+QF+PRELOC1,LPRM2)
         DC    AL2(PN$DOT-PATSUBS+X'8000')
         DC    AL2(DOTEXT-QPATSUBS)
*
*        $$DLR2                   DOLLAR NORMAL CASE
*
*        PARAM1                   NAME BASE
*        PARAM2                   NAME OFFSET
*        EXTEND                   DOLEXT
*
$$DLR2   BAL   R2,DOLDOT          CALL COMMON ROUTINE
         DC    YL1(PARM1+PARM2+QF+PRELOC1,LPRM2)
         DC    AL2(PN$DOL-PATSUBS+X'8000')
         DC    AL2(DOLEXT-QPATSUBS)
         EJECT
*
*        DOLLAR/DOT ROUTINES -- CONTINUED
*
*
*        COMMON ROUTINE FOR DEFERRED CASE
*
DOLDOTD  LR    A2+1,A2            MOVE EXPR PTR TO PARAM2 POSITION
         C     A2,ECODEBT         CHECK FOR COMPLEX EXPRESSION
         BNL   DOLDOT             BRANCH IF COMPLEX EXPRESSION
         SR    A2+1,A2+1          ELSE CLEAR OFFSET FOR SIMPLE VARIABLE
         LA    R2,$$DOT2-$$DOTD(R2)         POINT TO NON-DEFERRED CASE
*
*        COMMON ROUTINE FOR NORMAL CASE
*
DOLDOT   MVC   DOLDOTX(14),DOLDOTXX         MOVE CODE TO EXECUTE IT
         MVC   DOLDOTX+4(6),0(R2) MOVE PARAMS INTO OUT OF LINE CODE
         ST    RETURN,RETLOC      SAVE RETURN LOCATION
         BAL   RETURN,GETPAT      CONVERT LEFT ARG TO PATTERN
         XERR  01,038             LEFT ARGUMENT OF BINARY $ OR . IS NOT
*                                 A PATTERN
         LR    A1+1,A2+1          MOVE SECOND PARAM INTO PLACE
         LR    A2+1,A1            SAVE PATTERN POINTER
         LR    A1,A2              MOVE FIRST PARAM INTO PLACE
         SR    R2,R2              MINMATCH=0 FOR ALL TYPES
         B     DOLDOTX            JUMP TO OUT OF LINE CODE
*
*        RETURN HERE AFTER CALL TO MPBLOK
*
DOLDOTR  LR    A2,A1              MOVE DOL/DOT PATTERN PTR TO ACCUM 2
         LR    A1,A2+1            MOVE LEFT ARGUMENT PATTERN PTR TO A1
         BAL   RETURN,PCONC       CONCATENATE PATTERNS
         LR    A2,A1              PUT RESULT IN A2
         L     A1,MARKPTR         LOAD POINTER TO MARK PATTERN
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         B     PCONC              CONCATENATE AND LEAVE
*
*        THE FOLLOWING CODE IS MOVED INTO THE DATA AREA SINCE IT HAS
*        TO BE MODIFIED BY FILLING IN PARAMETERS
*
DOLDOTXX BAL   R1,MPBLOK          CALL ROUTINE TO BUILD PATTERN
         DC    6X'00'             6 BYTE PARAMETER FILLED IN
         B     DOLDOTR            RETURN TO MAINLINE CODE
         EJECT
*
*        @ PATTERN CONSTRUCTION ROUTINES
*
*        $$ATSP                   @ OPERATOR (ARGUMENT IS NAME)
*
*        (A1,A1+1)                ARGUMENT (NAME BASE/OFFSET)
*        BAL   RETURN,$$ATSP
*        (A1,A1+1)                RESULTING PATTERN
*
*
*        COME HERE FROM EXPRESSION CASE WHERE EXPRESSION WAS VCODE
*        SINCE A VCODE IS EQUIVALENT TO A SIMPLE VARIABLE WE TREAT IT
*        AS A SIMPLE VARIABLE
*
ATSPM    SR    A1+1,A1+1          SET NAME OFFSET FOR SIMPLE VAR = 0
$$ATSP   SR    R2,R2              SET MINMATCH = 0
         BAL   R1,MPBLOKX         MAKE BLOCK AND EXIT
         DC    YL1(PARM1+PARM2+QF+PRELOC1,LPRM2) FLAGS AND LENGTH
         DC    YL2(PN$@-PATSUBS)  CODELOC OFFSET
*
*        $$ATSD                   @ OPERATOR (ARGUMENT IS EXPRESSION)
*
*        (A1,A1+1)                EXPRESSION ARGUMENT
*        BAL   RETURN,$$ATSD
*        (A1,A1+1)                RESULTING PATTERN
*
$$ATSD   C     A1,ECODEBT         CHECK FOR VCODE AS EXPRESSION
         BL    ATSPM              TREAT AS NORMAL IF VCODE
         SR    R2,R2              SET MINMATCH = 0
         LR    A1+1,A1            MOVE EXPR PTR TO STORE AS PARAM2
         BAL   R1,MPBLOKX         MAKE PATTERN BLOCK AND EXIT
         DC    YL1(PARM1+PARM2+QF+PRELOC2,LPRM2) FLAGS AND LENGTH
         DC    YL2(PN$@D-PATSUBS) CODELOC OFFSET
         EJECT
*
*        $$LENP                   LEN FUNCTION
*        $$POSP                   POS FUNCTION
*        $$TABP                   TAB FUNCTION
*        $$RPSP                   RPOS FUNCTION
*        $$RTBP                   RTAB FUNCTION
*
*        (A1,A1+1)                ARGUMENT (EXPRESSION OR INTEGER)
*        BAL   RETURN,$$....
*        (A1,A1+1)                RESULTING PATTERN
*
$$LENP   BAL   A2,PATSET          CALL COMMON ROUTINE
         DC    AL2(PN$LEN-PATSUBS)          MINMATCH=ARG
         XERR  01,039             ARGUMENT TO LEN IS NOT AN INTEGER
         XERR  13,012             ARGUMENT TO LEN IS NEGATIVE
*
*        $$POSP                   POS
*
$$POSP   BAL   A2,PATSET          CALL COMMON ROUTINE
         DC    AL2(PN$POS-PATSUBS+X'8000')  MINMATCH=0
         XERR  01,040             ARGUMENT TO POS IS NOT AN INTEGER
         XERR  13,013             ARGUMENT TO POS IS NEGATIVE
*
*        $$TABP                   TAB
*
$$TABP   BAL   A2,PATSET          CALL COMMON ROUTINE
         DC    AL2(PN$TAB-PATSUBS+X'8000')  MINMATCH=0
         XERR  01,041             ARGUMENT TO TAB IS NOT AN INTEGER
         XERR  13,014             ARGUMENT TO TAB IS NEGATIVE
*
*        $$RPSP                   RPOS
*
$$RPSP   BAL   A2,PATSET          CALL COMMON ROUTINE
         DC    AL2(PN$RPOS-PATSUBS+X'8000') MINMATCH=0
         XERR  01,042             ARGUMENT TO RPOS IS NOT AN INTEGER
         XERR  13,015             ARGUMENT TO RPOS IS NEGATIVE
*
*        $$RTBP                   RTAB
*
$$RTBP   BAL   A2,PATSET          CALL COMMON ROUTINE
         DC    AL2(PN$RTAB-PATSUBS+X'8000') MINMATCH=0
         XERR  01,043             ARGUMENT TO RTAB IS NOT AN INTEGER
         XERR  13,016             ARGUMENT TO RTAB IS NEGATIVE
*
*        PATSET -- COMMON ROUTINE FOR ABOVE
*
PATSET   L     A2+1,=A(PATSETC)   LOAD ADDRESS OF ROUTINE
         BR    A2+1               OFF TO IT
         EJECT
*
*        ETEST                    COMMON ROUTINE USED BY SPAN,BREAK ETC
*
*        (A1,A1+1)                ARGUMENT
*        BAL   DB3,ETEST          CALLED ON DB3
*        ->  ERROR EXIT IF NEITHER STRING NOR EXPRESSION
*        ->  ERROR EXIT FOR NULL STRING ARGUMENT
*        ->  A(EXIT ADDRESS IF NON-NULL STRING)
*        MPBLOK PARAMETERS FOR USE IF IT IS EXPRESSION CASE
*
*        IF THE ARGUMENT IS AN EXPRESSION -- ETEST BUILDS THE BLOCK
*        AND RETURNS CONTROL TO THE CODE
*
*        ENTER HERE FOR MINMATCH=1 CASES
*
ETEST1   LA    R2,1               SET MINMATCH VALUE TO 1
         B     *+6                ENTER WITH PROPER MINMATCH VALUE
*
*        COME HERE FOR MINMATCH = 0 CASES
*
ETEST    SR    R2,R2              SET MINMATCH VALUE TO 0
         ST    A1,ETESTSV         SAVE ARGUMENT TO TEST CODE
         TM    ETESTSV,EXPRBIT    TEST FOR EXPRESSION
         BNO   ETESTS             SKIP IF NOT EXPRESSION
*
*        COME HERE FOR EXPRESSION CASE
*
         LR    A1+1,A1            COPY TO SET EXPR PTR IN PARAM2
         LA    R1,12(,DB3)        POINT TO MPBLOK PARAMETERS
         B     MPBLOKXR           RESTORE DBS&BUILD EXPRESSION PATTERN
*
*        COME HERE IF NOT EXPRESSION
*
ETESTS   ST    RETURN,RETLOC      SAVE RETURN REG
         BAL   RETURN,GETSTGS     CONVERT ARGUMENT TO STRING
         BR    DB3                ERROR EXIT IF UNCONVERTABLE
         NOPR  0                  FILL UP 4 BYTE ERROR RETURN
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         LTR   A1+1,A1+1          TEST FOR NULL
         BM    4(,DB3)            TAKE ERROR EXIT IF NULL STRING
         L     DB3,8(,DB3)        ELSE LOAD CONTINUATION ROUTINE ADDR
         BR    DB3                AND GO OFF TO IT
         EJECT
*
*        $$SPNP                   SPAN FUNCTION
*        $$BRKP                   BREAK FUNCTION
*        $$BRKX                   BREAKX FUNCTION
*
*        (A1,A1+1)                ARGUMENT -- STRING OR EXPRESSION
*        BAL   RETURN,$$....
*        (A1,A1+1)                RESULTING PATTERN
*
*        ALL THESE FUNCTIONS BUILD TRANSLATE AND TEST TABLES
*
*        FOR SPAN, THE TABLE IS NON-ZERO EXCEPT FOR SELECTED CHARS
*        FOR BREAK,BREAKX, THE TABLE IS ZERO EXCEPT FOR SELECTED CHARS
*
*
*        $$SPNP                   SPAN
*
*        PARAM1                   TBLOK OR CODE POINTER (STR OR EXPR)
*        EXTEND                   NONE
*
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORD BDRY
$$SPNP   BAL   DB3,ETEST1         TEST FOR EXPRESSION, MINMATCH = 1
         XERR  01,044             SPAN ARG NOT STRING OR EXPR
         XERR  13,017             ARGUMENT TO SPAN IS NULL
         DC    A(SPANPP)          STRING CASE ROUTINE ADDRESS
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC
         DC    Y(PN$SPAND-PATSUBS)          CODELOC FOR EXPR CASE
*
*        $$BRKX                   BREAKX
*
*        PARAM1                   TBLOK OR CODE POINTER (STR OR EXPR)
*        EXTEND                   BRKXEXT
*
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORDBOUND
$$BRKX   BAL   DB3,ETEST          TEST FOR EXPRESSION, MINMATCH = 0
         XERR  01,045             ARGUMENT TO BREAKX NOT STRING OR EXPR
         XERR  13,018             ARGUMENT TO BREAKX IS NULL
         DC    X'FF'              SET ADCON NEGATIVE TO SIGNAL BREAKX
         DC    AL3(BREAKPP)       ADDR OF ROUTINE FOR STRING CASE
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC
         DC    AL2(PN$BRKXD-PATSUBS+X'8000')
         DC    AL2(BRKXDEXT-QPATSUBS)       EXTENT FOR EXPR CASE
         EJECT
*
*        $$BRKP                   BREAK
*
*        PARAM1                   TBLOK OR CODE POINTER (STR OR EXPR)
*        EXTEND                   NONE
*
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORD BOUND
$$BRKP   BAL   DB3,ETEST          TEST FOR EXPRESSION, MINMATCH = 0
         XERR  01,046             ARGUMENT TO BREAK NOT STRING OR EXPR
         XERR  13,019             ARGUMENT FOR BREAK IS NULL
         DC    A(BREAKPP)         ADDR OF ROUTINE FOR STRING CASE
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC
         DC    Y(PN$BRKD-PATSUBS) ..
         EJECT
*
*        $$ANYP                   ANY FUNCTION
*        $$NTNP                   NOTANY FUNCTION
*
*        (A1,A1+1)                ARGUMENT INTEGER OR EXPRESSIONS
*        BAL   RETURN,$$....
*        (A1,A1+1)                RESULTING PATTERN
*
*        EACH ANY PATTERN USES ONE BIT POSITION OUT OF EIGHT IN A TBLOK
*        FOR THE SELECTED CHARACTERS, THE BITS ARE SET ON
*
*        NOTANY IS TREATED AS ANY OF ITS COMPLEMENT
*
*        ANYTPTR                  POINTER TO CURRENT TBLOK
*        ANYMASK                  LAST BIT USED (LEFT MOST USED FIRST)
*
*        FOR STRING CASE --
*        PARAM1                   TBLOK POINTER
*        PARAM2                   TM    CTCHARS(R2),BITMASK
*        EXTEND                   NONE
*
*        FOR EXPRESSION CASE --
*        PARAM1                   CODE POINTER
*        EXTEND                   NONE
*
*
*        $$NTNP                   NOTANY
*
         CNOP  2,4                MAKE SURE ADCON IS ON FULLWORD BOUND
$$NTNP   SR    DB2,DB2            SET FLAG FOR NOTANY CASE
         BAL   DB3,ETEST1         TEST FOR EXPRESSION, MINMATCH = 1
         XERR  01,047             ARGUMENT TO NOTANY NOT STRING OR EXPR
         XERR  13,020             ARGUMENT TO NOTANY IS NULL
         DC    A(NTNANY)          ROUTINE ADDRESS FOR STRING CASE
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC
         DC    AL2(PN$NANYD-PATSUBS)        CODELOC FOR EXPR CASE
*
*        $$ANYP                   ANY
*
         CNOP  0,4                MAKE SURE ADCON IS ON FULLWORD BOUND
$$ANYP   LA    DB2,NTNANYA-NTNANYN          SET FOR ANY CASE
         BAL   DB3,ETEST1         TEST FOR EXPRESSION, MINMATCH = 1
         XERR  01,048             ARGUMENT TO ANY NOT STRING OR EXPR
         XERR  13,021             ARGUMENT TO ANY IS NULL
         DC    A(NTNANY)          ROUTINE ADDRESS FOR STRING ARGUMENT
         DC    YL1(QF+PARM1+PARM2+PRELOC2,LPRM2) EXPR CASE PARAM2 RELOC
         DC    AL2(PN$ANYD-PATSUBS)         CODELOC FOR EXPR CASE
         TITLE 'SPITBOLA -- TYPE CONVERSION ROUTINES'
*
*        GETPAT -- CONVERT TO PATTERN ROUTINE
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,GETPAT
*        (ERROR RETURN -- CONVERSION NOT POSSIBLE)
*        RETURNS TO 4(RETURN) WITH PATTERN POINTER IN A1
*
*
GETPAT   STM   DB2,DB3,GETPATSV   SAVE REGS
         L     DB2,=A(GETPATC)    LOAD ADDRESS OF CONTINUATION
         BR    DB2                JUMP TO IT
         EJECT
*
*        GETREAL                  CONVERT TO REAL
*
*        (A1,A1+1)                ARGUMENT TO BE CONVERTED
*        BAL   RETURN,GETREAL
*        => ERROR RETURN IF UNCONVERTIBLE
*        => NORMAL RETURN
*        (A1,A1+1)                CONVERTED REAL RESULT
*
GETREAL  BAL   R2,CVNUM           CONVERT ARGUMENT TO NUMERIC
         BO    4(,RETURN)         RETURN IF WE HAVE A REAL
         BZ    GETRLI             JUMP TO COMMON ROUTINE IF INTEGER
         SLDL  A1,8               POSITION FOR MERGE
*
*        RETURN HERE FROM GETRLI
*
         LR    A1+1,A1            POSITION CORRECTLY
         L     A1,RCODEBT         SET TYPE CODE FOR REAL
         B     4(,RETURN)         RETURN TO CALLER
*
*        GETDREAL                 CONVERT TO DREAL
*
*        (A1,A1+1)                ARGUMENT TO BE CONVERTED
*        BAL   RETURN,GETDREAL
*        => ERROR RETURN IF UNCONVERTIBLE
*        => NORMAL RETURN
*        (A1,A1+1)                CONVERTED DREAL RESULT
*
GETDREAL BAL   R2,CVNUM           CONVERT ARGUMENT TO NUMERIC
         BP    4(,RETURN)         RETURN IF WE HAVE A DREAL
         BZ    GETRLI             USE COMMON ROUTINE FOR INTEGER CASE
         LR    A1,A1+1            POSITION REAL FOR MERGE
         SR    A1+1,A1+1          CLEAR LOW ORDER
*
*        RETURN HERE FROM GETRLI
*
         SRDL  A1,8               POSITION FOR DREAL
         AL    A1,WCODEBT         SUPPLY TYPE CODE
         B     4(,RETURN)         RETURN TO CALLER
         EJECT
*
*        COMMON ROUTINE USED TO CONVERT INTEGER TO DREAL
*
*        USED BY GETREAL,GETDREAL
*
GETRLI   L     R0,=X'4E00000000000000'      LOAD 4E EXPONENT
         LPR   R1,A1+1            FORCE INTEGER + (OK EVEN ON OVERFLOW)
         STM   R0,R1,GETSVV       STORE PREPARED UNNORMALIZED REAL
         LD    FA,GETSVV          LOAD INTO FLOATING REG
         ADR   FA,ZR              NORMALIZE THE NUMBER
         LTR   A1+1,A1+1          TEST ORIGINAL SIGN
         BNM   *+6                SKIP IF POSITIVE
         LCDR  FA,FA              IF NEGATIVE, MAKE RESULT NEGATIVE
         STD   FA,GETSVV          STORE CONVERTED RESULT
         LM    A1,A1+1,GETSVV     LOAD CONVERTED LONG REAL
         B     12(,R2)            RETURN TO PROPER ROUTINE
         EJECT
*
*        GETINT                   CONVERT TO INTEGER
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,GETINT
*        ->  ERROR RETURN IF UNCONVERTIBLE
*        ->  NORMAL RETURN
*        (A1,A1+1)                CONVERTED INTEGER
*
GETINT   BAL   R2,CVNUM           CONVERT ARGUMENT TO NUMERIC
         BZ    4(,RETURN)         IMMEDIATE RETURN IF WE HAVE INTEGER
*
*        COME HERE TO CONVERT REAL OR DREAL TO INTEGER
*
         SLDL  A1,8               POSITION POSSIBLE DREAL LEFT IN A1
         BP    *+8                SKIP IF DREAL
         SLDL  A1,24              ELSE COMPLETE POSITIONING FOR REAL
         STM   A1,A1+1,GETSVV     STORE THE REAL
         LD    FA,GETSVV          LOAD INTO FLOATING REG
         LPDR  FA,FA              SET SIGN POSITIVE
         CD    FA,=X'4E0000007FFFFFFF'      CHECK AGAINST MAXIMUM
         BCR   H,RETURN           ERROR IF TOO LARGE
         AW    FA,=X'4E00000000000000'      RIGHT POSITION BINARY POINT
         TM    GETSVV,X'80'       TEST ORIGINAL SIGN
         STD   FA,GETSVV          STORE UNNORMALIZED RESULT
         L     A1+1,GETSVV+4      LOAD INTEGER INTO PROPER REG
         LA    A1,0               SET TYPE CODE FOR INTEGER (LEAVE CC)
         BNO   4(,RETURN)         ALL DONE IF ORIGINAL SIGN +
         LCR   A1+1,A1+1          ELSE NEGATE
         B     4(,RETURN)         AND RETURN
         EJECT
*
*        GETNUM                   CONVERT TO NUMERIC (REAL OR INTEGER)
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,GETNUM
*        ->  ERROR RETURN IF UNCONVERTIBLE
*        ->  NORMAL RETURN
*        (A1,A1+1)                CONVERTED REAL OR INTEGER
*        CC = Z(INTEGER), O(REAL), P(DREAL)
*
GETNUM   LA    R2,4(,RETURN)      ADJUST (R2) TO MERGE INTO CVNUM
*
*        CVNUM -- UTILITY ROUTINE USED BY GETINT,GETREAL,GETNUM TO
*        CONVERT ARGUMENTS TO NUMERIC (REAL OR INTEGER)
*
*        (A1,A1+1)                ARGUMENT
*        BAL   R2,CVNUM
*        (RETURNS TO (RETURN) IF ARGUMENT CANNOT BE CONVERTED)
*        ->  NORMAL RETURN  (TO 0(R2))
*        (A1,A1+1)                CONVERTED RESULT
*        CC = Z(INTEGER), O(REAL), P(DREAL)
*
CVNUM    LCR   R0,A1              TEST TYPE
         BCR   NM,R2              RETURN WITH CC SET IF NUMERIC
         STM   A1,A1+1,GETSV      ELSE STORE ARGUMENT
         CLI   GETSV,SCODE        IS IT A STRING?
         BE    CVNUMS             SKIP IF IT IS
         SR    A1,A1              ELSE PREPARE AN INTEGER
         SR    A1+1,A1+1          WITH VALUE = ZERO
         CLI   GETSV,NCODE        IS ARGUMENT NULL?
         BCR   E,R2               RETURN NORMALLY WITH INTEGER 0 IF SO
         EJECT
*
*        GETNUM -- CONTINUED
*
*        HERE THE ONLY VALID POSSIBLITY IS A NAME
*
         CLI   GETSV,MCODE        IS IT A NAME?
         BCR   NE,RETURN          CONVERSION ERROR IF ANYTHING ELSE
         L     A1,GETSV           RESTORE NAME BLOCK POINTER
         LA    A1,0(,A1)          STRIP OFF UPPER BYTE (MCODE)
         CR    A1,FR              ARE WE ABOVE FREE CORE = NAT VAR?
         BH    *+10               SKIP IF NATURAL VARIABLE
         C     A1,DYNAMB          ARE WE BELOW FREE CORE?
         BCR   NL,RETURN          GIVE ERROR RETURN IF NOT
         LM    A1,A1+1,VNAME(A1)  LOAD NAME OF VARIABLE
         B     CVNUM              AND RE-ENTER
*
*        COME HERE TO CONVERT A STRING TO NUMERIC
*
CVNUMS   ST    R2,GETSV           SAVE LINKAGE
         AH    A1,GETSV+SOFFSET   ADD OFFSET TO POINT TO START OF STG
         LH    A1+1,GETSV+SLENGTH           LOAD 360 LENGTH OF STRING
         L     R2,=A(STGTONUM)    LOAD ADDRESS OF CONVERT ROUTINE
         BALR  R1,R2              CALL CONVERSION ROUTINE
         B     0(,RETURN)         GIVE ERROR RETURN ON CONVERT ERROR
         LCR   R0,A1              SET CC TO SHOW TYPE
         L     R2,GETSV           RELOAD CVNUM LINKAGE
         BR    R2                 RETURN TO CALLER
         EJECT
*
*        GETSTG                   CONVERT TO STRING
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,GETSTG
*        ->  ERROR RETURN IF UNCONVERTIBLE
*        ->  NORMAL RETURN
*        (A1,A1+1)                SPECIFIER FOR CONVERTED STRING
*
*        NOTE THAT THIS ROUTINE (UNLIKE GETSTGS) CONSTRUCTS A NEW SBLOK
*        IN FREE CORE WHERE NEEDED (HOWEVER, NO GCOL TEST IS MADE)
*
*        NOTE THAT THE NULL STRING IS RETURNED UNCHANGED
*
GETSTG   STM   A1,A1+1,GETSV      STORE ARGUMENT
         CLI   GETSV,SCODE        TEST FOR STRING
         BE    4(,RETURN)         NORMAL RETURN IF STRING
         CLI   GETSV,NCODE        IS ARG  NULL?
         BE    4(,RETURN)         NORMAL RETURN IF NULL
         LTR   A1,A1              TEST CODE FOR REMAINING CASES
         BP    GETSTGNN           SKIP IF NON-NUMERIC
         L     R0,GETSTGC         ELSE LOAD CONVERSION PARAMETERS
         L     R2,=A(NUMTOSTG)    LOAD POINTER TO CONVERT ROUTINE
         BALR  R1,R2              CALL ROUTINE TO CONVERT TO STRING
         BZ    GETSTGL1           SKIP IF NO NEED TO COPY TO FREE CORE
*
*        NOW MOVE THE STRING TO FREE CORE AND MAKE A NEW SBLOK
*        THIS ENTRY POINT IS ALSO USED BY STG TO BUILD A NEW SBLOK
*
GETSTGL  STE   ZR,0(,FR)          SET DTYPE=SBLOK=0, GCOLPTR=0
         LA    R0,SCHARS+BOUND+1(,A1+1)     NEW SBLOK LENGTH WITH FUDGE
         N     R0,FULLWRD         ADJUST TO PROPER BOUNDARY
         STH   R0,STLENGTH(,FR)   STORE IN SBLOK LENGTH FIELD
         EX    A1+1,GETSTGMM      MOVE CHARACTERS TO SBLOK
         LR    A1,FR              SET ADDRESS OF SBLOK
         AR    FR,R0              BUMP FREE POINTER
*
*        HERE TO EXIT, SKIP HERE FOR CASE OF NO NEED TO COPY TO FREECOR
*
GETSTGL1 O     A1,SCODEBT         SUPPLY TYPE CODE
         B     4(,RETURN)         GIVE SUCCESS RETURN
         EJECT
*
*        GETSTG -- CONTINUED
*
*
*        HERE THE ONLY REMAINING POSSIBILITY IS A NAME
*
GETSTGNN CLI   GETSV,MCODE        IS IT A NAME?
         BCR   NE,RETURN          CONVERSION ERROR IF ANYTHING ELSE
         LA    R1,0(,A1)          IF A NAME, COPY & STRIP UPPER BYTE
         CR    R1,FR              ARE WE ABOVE FREE CORE?
         BH    GETSTGN1           SKIP IF SO=NATURAL VARIABLE
         C     R1,DYNAMB          ARE EW BELOW FREE CORE?
         BCR   NL,RETURN          GIVE ERROR RETURN IF NOT
*
*        COME HERE FOR NATURAL VARIABLE TO LOAD STRING NAME
*
GETSTGN1 LM    A1,A1+1,VNAME(A1)  LOAD NAME OF VARIABLE
         B     4(,RETURN)         AND GIVE SUCCESS RETURN
*
GETSTGMM MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE CHARS TO FREE CORE
         CNOP  0,4                ALLIGN CONVERSION PARAMETERS
GETSTGC  DC    AL1(0,14,0,7)      FORMAT=0(GZ), DIGS=7(REAL),14(DREAL)
         EJECT
*
*        GETSTGS                  CONVERT TO STRING SPECIFICATION
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,GETSTGS
*        ->  ERROR RETURN IF UNCONVERTIBLE
*        ->  NORMAL RETURN
*        (A1)                     FIRST ADDRESS OF CONVERTED STRING
*        (A1+1)                   360 LENGTH OF CONVERTED STRING
*
*        UNLIKE GETSTG, THIS ROUTINE DOES NOT BUILD A NEW SBLOK IN
*        FREE CORE -- IT IS USED IN SITUATIONS WHERE THE USE OF THE
*        CONVERTED STRING IS EPHEMERAL
*
*        THE NULL STRING RETURNS WITH A 360 LENGTH OF -1
*
GETSTGS  STM   A1,A1+1,GETSV      STORE ARGUMENT
         CLI   GETSV,SCODE        CHECK FOR STRING
         BNE   GETSTGS1           SKIP IF NOT STRING
*
*        REENTER HERE AFTER CONVERTING A NAME TO A STRING
*
GETSTGS0 AH    A1,GETSV+SOFFSET   ADD STRING OFFSET
         LH    A1+1,GETSV+SLENGTH           LOAD 360 LENGTH
         B     4(,RETURN)         GIVE NORMAL RETURN
*
*        COME HERE TO TEST FOR NULL CASE
*
GETSTGS1 CLI   GETSV,NCODE        IS ARGUMENT NULL?
         BNE   GETSTGS2           SKIP IF NOT
         SR    A1+1,A1+1          ELSE SET 360 LENGTH = 0
         BCT   A1+1,4(,RETURN)    NORMAL RETURN SETTING 360 LEN TO -1
*
*        COME HERE TO TEST REMAINING CASES
*
GETSTGS2 LTR   A1,A1              TEST TYPE
         BP    GETSTGS3           SKIP IF NON-NUMERIC
         L     R0,GETSTGC         ELSE LOAD CONVERSION PARAMETERS
         L     R2,=A(NUMTOSTG)    LOAD ADDRESS OF CONVERT ROUTINE
         BALR  R1,R2              CALL CONVERT ROUTINE
         B     4(,RETURN)         AND RETURN TO CALLER
*
*        AT THIS POINT, THE ONLY LEGAL REMAINING POSSIBILITY IS A NAME
*
GETSTGS3 CLI   GETSV,MCODE        IS IT A NAME?
         BCR   NE,RETURN          ERROR RETURN IF NOT
         LA    R1,0(,A1)          IF IT IS A NAME, COPY AND STRIP
         CR    R1,FR              ARE WE ABOVE FREE CORE?
         BH    *+10               SKIP IF SO - NATURAL VARIABLE
         C     R1,DYNAMB          ARE WE BELOW FREE CORE?
         BCR   NL,RETURN          ERROR IF NOT NATURAL VARIABLE
         L     A1,VNAME(,R1)      IF SO, LOAD STRING NAME POINTER
         AH    A1,VNAME+SOFFSET(,R1)        ADD STRING OFFSET
         LH    A1+1,VNAME+SLENGTH(,R1)      LOAD STRING LENGTH
         B     4(,RETURN)         GIVE SUCCESSFUL CONVERSION EXIT
         EJECT
*
*        GETSTGT                  CONVERT TO STRING (TEMPORARY)
*
*        (A1,A1+1)                ARGUMENT TO BE CONVERTED
*        BAL   RETURN,GETSTGT
*        => ERROR RETURN IF UNCONVERTIBLE
*        => NORMAL RETURN
*        (A1,A1+1)                STRING IN ADDRESS,LENGTH FORM
*
*        THIS STRING CONVERSION ROUTINE IS LIKE GETSTGS IN THAT THE
*        STRING IS IN ADDRESS/LENGTH FORMAT AND IS ONLY FOR TEMPORARY
*        USE -- HOWEVER, THE CONVERTED RESULT FROM A NUMERIC IS MOVED
*        TO FREE CORE (FR IS NOT MOVED PAST IT)
*
GETSTGT  LTR   R0,A1              TEST TYPES
         BP    GETSTGS            MERGE WITH GETSTGS IF NON-NUMERIC
*
*        HERE FOR ALL NUMERIC CASES
*
         L     R0,GETSTGC         LOAD CONVERSION PARAMETERS
         L     R2,=A(NUMTOSTG)    ADDRESS OF CONVERT ROUTINE
         BALR  R1,R2              CONVERT NUMERIC TO STRING
         BZ    4(,RETURN)         RETURN IF NO NEED TO COPY
         EX    A1+1,GETSTGMM      MOVE CHARACTERS TO FREE CORE
         LR    A1,FR              SET ADDRESS OF CHARACTERS
         B     4(,RETURN)         RETURN TO CALLER
*
*        USE OF THE THREE ROUTINES GETSTG,GETSTGS,GETSTGT
*
*        GETSTG IS USED IF THE RESULT IS TO BE KEPT AROUND OR
*        SUBJECTED TO A GARBAGE COLLECTION -- THE SCODE BYTE IS ALWAYS
*        SUPPLIED AND THE SOFFSET MAY BE NON-ZERO -- NULL IS RETURNED
*        AS A NULL WITH NCODE
*
*        GETSTGS IS USED IF THE RESULT IS TO BE IMMEDIATELY USED AND
*        DISCARDED. SCODE IS NOT NECCESSARILY SUPPLIED. SOFFSET IS
*        ALWAYS ZERO. NULL IS RETURNED WITH A LENGTH OF -1.
*
*        GETSTGT IS USED WHEN TWO TEMPORARY STRINGS ARE NEEDED, TWO
*        SUCCESSIVE CALLS TO GETSTGS MAY CAUSE OVERWRITING OF CONVERTED
*        STRINGS -- IN THIS SITUATION, THE FIRST CALL SHOULD BE TO
*        GETSTGT -- IN OTHER RESPECTS, GETSTGS AND GETSTGT ARE IDENTICL
         EJECT
*
*        GETNAME                  CONVERT TO NAME
*
*        (A1,A1+1)                ARGUMENT
*        BAL   RETURN,GETNAME
*        ->  ERROR RETURN IF UNCONVERTIBLE
*        ->  NORMAL RETURN
*        (A1)                     ADDRESS OF VARIABLE BLOCK
*
GETNAME  MVI   DOLLFLG,$BYNAM+$GETNM        SET GETNAME, BY NAME FLGS
         L     R2,=A(DOLLC)       LOAD ROUTINE ADDRESS
         USING DOLLC,R2           TEMP BASE REGISTER FOR JUMP
         B     DOLLC1             JUMP TO ROUTINE PAST ST IN RETLOC
         DROP  R2                 GET RID OF BASE REGISTER
         TITLE 'SPITBOLA -- CONSTANT POOL'
*
*        EQUATE FOR BOUNDARY ALIGNMENT FUDGE
*
BOUND    EQU   3                  BOUNDARY ALIGNMENT FUDGE
*
*
*        THE CONSTANTS HERE ARE USED BY ALL THE EXECUTION ROUTINES
*
         CNOP  0,4                FULLWORD ALLIGNMENT FOR POOL
X80      EQU   RCODEBT            RCODEBT IS A X'80000000'
*
*        PATTERN POINTERS
*
NULLPTR  DC    AL1(PCODE)         TYPE CODE FOR PATTERN
         DC    AL3(NULLPAT)       POINTER TO NULL PATTERN
*
MARKPTR  DC    AL1(PCODE)         CODE FOR PATTERN
         DC    AL3(MARKPAT)       POINTER TO MARK PATTERN
*
*        MISCELLANEOUS CONSTANTS
*
BEVLR1   B     $$EVLR             CONSTANT TO CHECK END OF EXPR CODE
FBLOKI   B     $$FUNC             1ST INSTRUC IN FBLOK (TO CHECK FBLOK)
SPINMX   DC    X'7FFFFFFF'        MAXIMUM VALUE OF STATEMENT COUNTER
FULLWRD  DC    X'FFFFFFFC'        USED TO MASK TO FULL WORD BOUNDARY
VCLOSE   DC    V(SYSCLOSE)        ADDRESS OF INTERFACE ROUTINE
VOPEN    DC    V(SYSDCB)          ADDRESS OF INTERFACE ROUTINE
VSYSTIME DC    V(SYSTIME)         ADDRESS OF INTERFACE GETTIME
AIOASSOC DC    A(IOASSOC)         ADDR OF ROUTINE TO PLUG CODE FOR IO
CODXEQAD DC    A(COMPILER)        EXECUTE TIME COMPILER LOAD ROUTINE
H1       DC    H'1'               HALF WORD 1
H2       DC    H'2'               HALF WORD 2
H3       DC    H'3'               HALF WORD 3
H4       DC    H'4'               HALF WORD 4
H6       DC    H'6'               HALF WORD 6
H8       DC    H'8'               HALF WORD 8
H10      DC    H'10'              HALF WORD 10
H12      DC    H'12'              HALF WORD 12
H16      DC    H'16'              HALF WORD 16
H256     DC    H'256'             HALF WORD 256
*
*        DUMMY EXPRESSION VALUES USED DURING PATTERN MATCHING & EVAL
*
         DS    0F                 ALLIGN
EVALWCON DC    AL1(ECODE)         EXPRESSION TYPE CODE
         DC    AL3(EVALWRIT)      DEFERRED WRITE CALL
EVALRCON DC    AL1(ECODE)         EXPRESSION TYPE CODE
         DC    AL3(EVALREAD)      DEFERRED READ CALL
EVALGCOL EQU   BEVLR1             JUST DEFERRED CALL TAKES CARE OF GCOL
         EJECT
*
*        LITERALS FOR SPITBOLP, SPITBOLX, SPITBOLA
*
         LTORG ,                  ADDRESSABLE UNDER SYS BASE REG
*
         TITLE 'SPITBOLA -- PATCH SPACE'
*
         DC    S(*)               S ADDRESS FOR FIRST PATCH
         DC    30AL4(0)           PATCH SPACE, INITIALIZE TO ZEROS
*
         ORG   SPITBOLA+4096-2-2  ORIGIN TO END OF ADDRESSABLE AREA - 2
         DC    S(*)               S ADDRESS FOR LAST PATCH
         TITLE 'SPITBOLA -- GET FREE CORE BLOCK LENGTH ROUTINE'
*
*        BLOKLEN                  GET LENGTH OF BLOCK IN FREE CORE
*
*        USED IN GARBAGE COLLECTOR, COPY, CONVERT, DUMP, IOASSOC
*
*        (OLD) OR (A1)            POINTS TO BLOCK
*        (R2)                     MUST HAVE UPPER THREE BYTES ZERO
*        EX    0,BLOKLEN(REGISTER WITH DTYPE BLOK CODE)
*        (R2)                     NUMBER OF BYTES IN BLOCK
*
*        TABLE OF INSTRUCTIONS EXECUTED TO GET LENGTH OF BLOCKS
*
         ORG   SPITBOLA+4096-2    ORIGIN TO LAST ADDRESSABLE LOCATION
BLOKLEN  EQU   *                  START OF INSTRUCTIONS
*
         LH    R2,STLENGTH(,OLD)            SBLOK
*
         LA    R2,CTCHARS+256               TBLOK
*
         LH    R2,FNLENG(,OLD)              FBLOK
*
         LH    R2,EFLENG(,OLD)              EFBLOK
*
         LA    R2,IOBSIZE                   IOBLOK
*
         L     R2,NBYTESA(,OLD)             ABLOK
*
         IC    R2,NBYTESD(,OLD)             PDBLOK
*
         LA    R2,FFBSIZE                   FFBLOK
*
         LH    R2,NBYTESDF(,OLD)            PDFBLOK
*
         LH    R2,PTLENG(,OLD)
*
         L     R2,TBLENGTH(,OLD)            TBBLOK
*
         LA    R2,TESIZE                    TEBLOK
*
         L     R2,CODNLEN(,OLD)             CBLOK
*
         LA    R2,TRBSIZE                   TRBLOK
*
*        LAST ENTRY -- OFFSET MUST BE LTBLOK
*
         ORG   BLOKLEN+LTBLOK     POSITION FOLLOWING ENTRY CORRECTLY
         LA    R2,LTSIZE                    LTBLOK
         TITLE 'SPITBOLF -- START OF SECTION'
*
*        THIS CSECT CONTAINS THE STANDARD SYSTEM FUNCTION DEFINITIONS
*
         BEGIN F                  START OF SPITBOLF, SPITBLLF CSECT
         TITLE 'SPITBOLF -- INTRINSIC FUNCTIONS'
*        THE FOLLOWING FUNCTIONS ARE USUALLY INTRINSIC -- THAT IS, CODE
*        IS GENERATED IN LINE, USUALLY A DIRECT CALL TO AN ENTRY
*        POINT IN THE ADDRESSABLE REGION. THESE ENTRY POINTS ARE USED
*        WHEN THE FUNCTION IS APPLIED OR AS A RESULT OF AN OPSYN OR
*        THE COMPILATION OF THE CALL OCCURED IN -NOOPTIMIZE MODE.
*
*        ENTRY FOR IDENT FUNCTION
*
         USING F$IDENT-FCODE,DB4  FUNCTION BASE REGISTER
F$IDENT  BAL   R2,IDDIFR          JUMP TO COMMON IDENT/DIFFER ROUTINE
         BCR   E,RETURN           SUCCESS RETURN IF ARGS IDENT
         B     FAILR              ELSE FAIL RETURN
*
*        ENTRY FOR DIFFER FUNCTION
*
         USING F$DIFFER-FCODE,DB4 FUNCTION BASE REGISTER
F$DIFFER BAL   R2,IDDIFR          JUMP TO COMMON IDENT/DIFFER ROUTINE
         BCR   NE,RETURN          SUCCESS RETURN IF DIFFER
         B     FAILR              ELSE FAIL RETURN
         DROP  DB4                DROP FUNCTION BASE
*
*        IDDIFR -- COMMON ROUTINE USED BY IDENT AND DIFFER
*
IDDIFR   CH    R0,H2              MUST HAVE TWO ARGUMENTS
         BL    $$WNAG             USE $$WNAG TO SUPPLY MISSING ONES
         LM    A1,A2+1,TEM#2(PDR) LOAD ARGS (WRONG WAY ROUND IS OK)
         L     PDR,PDRLOC         RESET STACK POINTER
         ST    RETURN,RETLOC      SAVE RETURN LOCATION
         BAL   RETURN,$$IDNT      CALL IDENT ROUTINE WHICH SETS CC
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         L     A1,NCODEBT         LOAD NULL RESULT
         BR    R2                 RETURN TO IDDIFR CALLER
         EJECT
*
*        ENTRY POINT FOR ANY
*
         USING F$ANY-FCODE,DB4    FUNCTION BASE REGISTER
F$ANY    BAL   R2,LOADARG         CALL COMMON ARGUMENT LOAD ROUTINE
         DC    Y($$ANYP-SPITBOLA) SYS OFFSET OF STANDARD ROUTINE
*
*        THE ENTRY POINTS FOR THE REMAINING ONE ARGUMENT INTRINSICS ARE
*        GENERATED WITH THE FUNC MACRO WHICH GENERATES ANALOGOUS
*        CODE TO THE ANY FUNCTION ABOVE
*
BREAK    FUNC  $$BRKP             BREAK
BREAKX   FUNC  $$BRKX             BREAKX
LEN      FUNC  $$LENP             LEN
NOTANY   FUNC  $$NTNP             NOTANY
POS      FUNC  $$POSP             POS
RPOS     FUNC  $$RPSP             RPOS
RTAB     FUNC  $$RTBP             RTAB
SPAN     FUNC  $$SPNP             SPAN
TAB      FUNC  $$TABP             TAB
*
*        LOADARG -- COMMON ROUTINE USED BY ALL THE ABOVE
*        NOTE THAT THERE IS ALWAYS ONE ARGUMENT ON STACK ALREADY
*
         DROP  DB4                THIS ROUTINE NEEDS NO BASE REG
LOADARG  LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         L     PDR,PDRLOC         RESET STACK POINTER
         LH    R2,0(,R2)          LOAD OFFSET TO STANDARD ROUTINE
         B     0(R2,SYS)          AND JUMP TO IT
*
*        ENTRY POINT FOR INTEGER
*
F$INTEGE LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         L     PDR,PDRLOC         RESET STACK POINTER
         ST    RETURN,RETLOC      SAVE RETURN POINT
         BAL   RETURN,GETNUM      CONVERT ARGUMENT TO NUMERIC
         B     FAILRL             NOT INTEGER IF CONVERT ERROR
         LTR   A1,A1              IF OK CONVERT, IS RESULT INTEGER
         BCR   NZ,RETURN          BACK TO GIVE FAILURE IF NOT
         B     EXITNULL           ELSE RETURN NULL
         EJECT
*
*        NOTE THAT FOR CALLS TO THE LOGICAL FUNCTIONS DB4 IS ACTUALLY
*        SET 2 BYTES LOWER THAN USING AT MERGE POINT INDICATES
*        THIS ONLY MEANS THAT CALLS TO CMPRFUNC ENTER 2 BYTES BEFORE
*        CMPRFUNC.  TO GET AROUND THIS WE NEED ONLY PUT A NOPR BEFORE
*        CMPRFUNC, SINCE DB4 IS NOT THE BASE REGISTER FOR IT
*
*        ENTRY POINT FOR LEQ
*
F$LEQ    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE EQ
*
*        ENTRY POINT FOR EQ
*
         USING F$EQ-FCODE,DB4     FUNCTION BASE REGISTER
F$EQ     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE
         BCR   E,RETURN           SUCCESS RETURN IF EQUAL
*
*        ENTRY POINT FOR LNE
*
F$LNE    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE NE
*
*        ENTRY POINT FOR NE
*
         USING F$NE-FCODE,DB4     FUNCTION BASE REGISTER
F$NE     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE
         BCR   NE,RETURN          SUCCESS RETURN IF UNEQUAL
*
*        ENTRY POINT FOR LGE
*
F$LGE    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE GE
*
*        ENTRY POINT FOR GE
*
         USING F$GE-FCODE,DB4     FUNCTION BASE REGISTER
F$GE     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE
         BCR   NH,RETURN          SUCCESS RETURN IF 2ND ARG <= 1ST ARG
*
*        ENTRY POINT FOR LGT
*
F$LGT    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE GT
*
*        ENTRY POINT FOR GT
*
         USING F$GT-FCODE,DB4     FUNCTION BASE REGISTER
F$GT     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE
         BCR   L,RETURN           SUCCESS RETURN IF 2ND ARG < 1ST ARG
         EJECT
*
*        ENTRY POINT FOR LLE
*
F$LLE    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE LE
*
*        ENTRY POINT FOR LE
*
         USING F$LE-FCODE,DB4     FUNCTION BASE REGISTER
F$LE     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE
         BCR   NL,RETURN          SUCCESS RETURN IF 2ND ARG >= 1ST ARG
*
*        ENTRY POINT FOR LLT
*
F$LLT    LR    DB3,DB1            FLAG LEXICAL COMPARE -- MERGE LT
*
*        ENTRY POINT FOR LT
*
         USING F$LT-FCODE,DB4     FUNCTION BASE REGISTER
F$LT     BAL   R2,CMPRFUNC        JUMP TO COMMON ROUTINE
         BCR   H,RETURN           SUCCESS RETURN IF 2ND ARG > 1ST ARG
*
*        CMPRFUNC -- COMMON FUNCTION USED BY ABOVE ENTRY POINTS
*
         DROP  DB4                THIS ROUTINE DOES NOT USE A BASE REG
*
*        THIS NOPR IS SO CALLS FOR LOGICAL FUNCTIONS DON'T HAVE
*        TROUBLE WITH MIS-SET BASE REG DB4
*
         NOPR  0                  DO NOTHING IF WE ENTER EARLY
CMPRFUNC ST    R2,CMPRSAVE        SAVE R2 (LINKAGE)
         ST    RETURN,ALTLOC      SAVE RETURN FOR POSSIBLE ERROR
         CH    R0,H2              MAKE SURE WE HAVE AT LEAST TWO ARGS
         BL    $$WNAG             USE $$WNAG TO SUPPLY ANY MISSING ARGS
         LM    A1,A2+1,TEM#2(PDR) LOAD ARGUMENTS WRONG WAY ROUND
         L     PDR,PDRLOC         RESET STACK POINTER
         LA    RETURN,$$CMPR      TENTATIVELY SET ADDRESS OF ARITH CMPR
         CR    DB3,DB1            TEST CASES (ARITH/LEXICAL)
         BALR  DB3,0              GET A BASE REGISTER
         USING *,DB3              TELL ASSEMBLER
         BNE   *+8                SKIP IF THIS IS WHAT WE WANT
         DROP  DB3                DROP SILLY BASE REGISTER
         LA    RETURN,$$LCMP      ELSE POINT TO LEXICAL COMPARE
         L     DB3,$$BAS3         RESTORE DB3
         BALR  RETURN,RETURN      CALL PROPER ROUTINE
         L     R2,CMPRSAVE        RELOAD LINKAGE REG
         L     RETURN,ALTLOC      RELOAD CODE RETURN LOC
         STE   ZR,ALTLOC          CLEAR ALTERNATE RETURN LOC
         L     A1,NCODEBT         LOAD NULL AS RETURNED RESULT
         EX    0,0(,R2)           EXECUTE CONDITIONAL SUCCESS BRANCH
         B     FAILR              FAIL IF IT DOES NOT BRANCH
         LTORG ,                  LITERALS FOR INTRINSIC FUNCTIONS
         TITLE 'SPITBOLF -- APPLY FUNCTION'
APPLY    FUNCTION  2              ENTRY POINT -- AT LEAST 2 ARGS
         LR    DB4,R0             SAVE NUMBER OF ARGUMENTS
         LM    A1,A1+1,TEM#1(PDR) LOAD FUNCTION SPECIFIER
         SH    PDR,H8             ADJUST STACK TO POINT TO ARGS
         BAL   RETURN,GETNAME     GET VARBLOCK FOR FUNCTION
         XERR  01,051             1ST ARG TO APPLY NOT A FUNCTION
         LR    R0,DB4             IF OK, RECALL ARGUMENT COUNT
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         L     DB4,VFUNC(,A1)     POINT TO FUNCTION TO BE APPLIED
         BCT   R0,FCODE(,DB4)     ADJUST ARG COUNT, OFF TO FUNCTION
*
*        NOTE THAT THE ABOVE BCT CANNOT FALL THROUGH SINCE WE REQUIRED
*        TWO ARGUMENTS IN THE FUNCTION HEADER FOR APPLY
         TITLE 'SPITBOLF -- ARBNO FUNCTION'
ARBNO    FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED
*
*        ARBNO(PATTERN) IS THE FOLLOWING PATTERN STRUCTURE --
*
*        +------------+
*        |            |
*        |    NULL    |
*        |            |
*        +------------+
*              |
*              | OR
*              |
*              V
*        +------------+         +------------+         +------------+
*        |            |  THEN   |            |  THEN   |            |
*    +-->|    MARK    |-------->|   PATTERN  |-------->|    ARBNO   |
*    |   |            |         |            |         |            |
*    |   +------------+         +------------+         +------------+
*    |                                                       |
*    |                                           PARAM1      |
*    +-------------------------------------------------------+
*
*        NOTE THAT THIS DEVIATES FROM GBGCLF RULE
*
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT FOR CONVERT
         L     PDR,PDRLOC         RESET STACK POINTER
         BAL   RETURN,GETPAT      CONVERT ARGUMENT TO PATTERN
         XERR  01,050             ARGUMENT TO ARBNO IS NOT A PATTERN
         LR    A2+1,A1            SAVE POINTER
         LH    A1,PTLENG(,A2+1)   PICK UP LENGTH OF ARBNO ARGUMENT
         SH    A1,H4              ADJUST TO GET PARAMETER VALUE
         SR    R2,R2              MINMATCH = 0 FOR ARBNO
         BAL   R1,MPBLOK          MAKE BLOCK FOR ARBNO
         DC    YL1(QF+PARM1,LPRM1)          ONE PARAM, NOT RELOCATABLE
         DC    AL2(PN$ARBNO-PATSUBS+X'8000')
         DC    AL2(ARBNOEXT-QPATSUBS)
         LR    A2,A1              PUT ARBNO POINTER IN A2
         LR    A1,A2+1            RECALL ARG POINTER TO A1
         BAL   RETURN,PCONC       CONCATENATE PATTERN, ARBNO BLOCK
         LR    A2,A1              PUT RESULT IN A2
         L     A1,MARKPTR         LOAD POINTER TO MARK PATTERN
         BAL   RETURN,PCONC       WE HAVE WHOLE LOWER PART NOW
         LR    A2,A1              MOVE TO A2
         L     A1,NULLPTR         LOAD POINTER TO NULL PATTERN
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         B     ORMAK              JUMP TO OR THEM AND RETURN
ARBNO    ENDFUNC ,                END OF ARBNO FUNCTION
         TITLE 'SPITBOLF -- ARG FUNCTION'
ARG      FUNCTION  2              ENTRY POINT -- TWO ARGS REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     FIND VARIABLE BLOCK
ARGERR   XERR  01,052             FIRST ARG TO ARG NOT FUNCTION NAME
         LR    A2,A1              ELSE IF OK, SAVE POINTER
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         XERR  01,053             SECOND ARGUMENT TO ARG NOT AN INTEGER
         L     A2+1,VFUNC(,A2)    LOAD FUNCTION POINTER
         CLC   FCODE(4,A2+1),FBLOKI         TEST FOR PROG DEF FUNCTION
         BNE   ARGERR             ERROR IF NOT
         CH    A1+1,FNARGS(,A2+1)           IS COUNT TOO LARGE?
         BH    FAILRL             FAIL IF SO
         SLA   A1+1,2             MULTIPLY COUNT BY FOUR
         BNP   FAILRL             FAIL IF ZERO OR NEGATIVE
         L     A1,FARGS-4(A2+1,A1+1)        LOAD ARGUMENT POINTER
         LM    A1,A1+1,VNAME(A1)  LOAD NAME OF ARGUMENT
         B     EXIT               RETURN TO CALLER
ARG      ENDFUNC   ,              END OF ARG FUNCTION
         TITLE 'SPITBOLF -- ARRAY FUNCTION'
ARRAY    FUNCTION  2              ENTRY POINT -- 2 ARGUMENTS NEEDED
         STE   ZR,0(,FR)          ZERO THE GARBAGE COLLECTION FIELD
         MVI   0(FR),ABLOK        SET BLOCK CODE
         MVC   ASPEC(8,FR),TEM#1(PDR)       SAVE PROTOTYPE IN ARRAY
         LR    DB2,FR             COPY ARRAY POINTER
         LA    DB3,8              INITIAL SUBFAC IS 8
         STE   ZR,SUBLBD(,FR)     INITIALIZE 1ST LBD/DIMENSION
         MVI   SUBLBD+1(FR),1     SET LOW BOUND DEFAULT = 1
         CLI   TEM#1(PDR),ICODE   CHECK FOR INTEGER SUBSCRIPT CASE
         BE    ARRAYI             SKIP FOR SPEEDY HANDLING IF INTEGER
         BAL   A2+1,XSCANI        INITIALIZE SCAN ROUTINE
         XERR  01,054             FIRST ARG TO ARRAY IS NOT A STRING
         XERR  13,022             THE FIRST ARGUMENT IN A CALL TO THE
*                                 ARRAY FUNCTION IS NULL
         OI    XSCANFLG,XSIGNRO+XSIGNGN     IGNORE RUNOUT, NO GETNAME
         MVI   ZTBL+C':',LOWBND-ARRAYRO     SET TO STOP ON :
         MVI   ZTBL+C',',HIBND-ARRAYRO      SET TO STOP ON ,
*
*        COME HERE TO SCAN OUT NEXT ELEMENT IN PROTOTYPE
*
ARRAYSCN BALR  RETURN,A2          SCAN OUT AN ELEMENT
         XERR  13,023             AN ARRAY BOUND IN A CALL TO THE ARRAY
*                                 FUNCTION IS NULL
*
*        SINCE THE RUNOUT ERROR IS IMPOSSIBLE, WE CAN USE THIS WORD
*
AMAXVAL  DC    X'7FFF'            MAXIMUM VALUE FOR SUB OR DIM
         NOPR  0                  PAD OUT THE WORD
         BAL   RETURN,GETINT      CONVERT THE BOUND TO INTEGER
         XERR  13,024             AN ARRAY BOUND IN A CALL TO THE ARRAY
*                                 FUNCTION IS NON-NUMERIC
         B     ARRAYRO(A2+1)      TAKE ACTION PROPER FOR LOW OR HIBND
*
*        COME HERE ON RUNOUT RETURN
*
ARRAYRO  NOPR  0                  DO NOTHING, MERGE WITH HIBND
         EJECT
*
*        COME HERE WHEN AN UPPER BOUND SCANNED OUT
*
HIBND    ST    DB3,SUBFAC(,DB2)   SAVE THE SUBFACTOR
         SH    A1+1,SUBLBD(,DB2)  - LOWER BOUND = DIMENSION-1
         BM    ADIMERR            ERROR IF LE ZERO ELEMENTS
         CH    A1+1,AMAXVAL       CHECK FOR HALFWORD DIMENSION
         BNL   ADIMERR            ERRONEOUS DIMENSION IF NOT HALFWORD
         LA    A1+1,1(,A1+1)      ADD ONE TO GET DIMENSION
         STH   A1+1,SUBDIM(,DB2)  SAVE DIMENSION IN BLOCK
         MH    DB3,SUBDIM(,DB2)   CALC NEXT FACTOR IGNORE OVERFLOW
         LA    DB2,8(,DB2)        POINT TO NEXT SUBSCRIPT INFO
         STE   ZR,SUBLBD(,DB2)    INITIALIZE LOWBND/DIM FIELD
         MVI   SUBLBD+1(DB2),1    DEFAULT LOW BOUND IS ONE
         LTR   A2+1,A2+1          ARE WE AT END OF STRING?
         BNZ   ARRAYSCN           SCAN NEXT ELEMENT IF NOT AT END
*
*        COME HERE WHEN ENTIRE PROTOTYPE PROCESSED
*
         MVI   ZTBL+C':',0        CLEAR ZEROS TABLE
         MVI   ZTBL+C',',0        CLEAR ZEROS TABLE
         LA    R2,AVALS-8(DB3,DB2)          FIND NEW FREE CORE ADDRESS
         CR    R2,PDR             WILL WE NEED A COLLECT?
         BNL   GBGCLF             COLLECT AND RE-ENTER IF SO
         SR    R2,FR              GET BLOCK LENGTH
         ST    R2,NBYTESA(,FR)    STORE IN BLOCK
         LR    R0,DB2             COPY END OF SUBSCRIPTS ADDR
         SR    R0,FR              GET ROOM USED FOR SUBSCRIPTS
         SRL   R0,3               CALCULATE NUMBER OF SUBSCRIPTS
         STC   R0,NSUBS(,FR)      AND SAVE IN BLOCK
         LA    R0,16              GET ROOM NEEDED BY TWO ELEMENTS
         LA    R1,AVALS-16(DB3,DB2)         GET END ADDR FOR BXLE
         LM    A1,A1+1,TEM#2(PDR) LOAD INITIALIZE VALUE
         LM    A2,A2+1,TEM#2(PDR) LOAD INITIALIZE VALUE
         STM   A1,A2+1,AVALS-8(DB2)         STORE TWO ELEMENTS
         BXLE  DB2,R0,*-4         LOOP UNTIL ALL ELEMENTS FILLED
         LR    A1,FR              COPY ARRAY ADDRESS
         AL    A1,ACODEBT         ADD IN TYPE CODE
         AR    FR,R2              PUSH FR PAST BLOCK
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
         B     EXIT               RETURN TO CALLER
         EJECT
*
*        COME HERE TO PROCESS A LOWER BOUND
*
LOWBND   CLI   SUBDIM(DB2),0      TEST FOR TWO LOW BOUNDS
         BE    *+8                SKIP IF THIS IS ONLY FOR SUBSCRIPT
         XERR  13,025             A SUBSCRIPT BOUND HAS TWO COLONS
*                                 IN A CALL TO THE ARRAY FUNCTION
         STH   A1+1,SUBLBD(,DB2)  SAVE NEW LOW BOUNDS
         MVI   SUBDIM(DB2),1      SET FLAG FOR LOW BOUND FOUND
*
*        COME HERE TO MAKE SURE THE BOUND VALUE IS REASONABLE
*
         LPR   R0,A1+1            GET MAGNITUDE OF LOW BOUND
         CH    R0,AMAXVAL         CHECK AGAINST MAXIMUM ABS VALUE
         BNH   ARRAYSCN           SCAN OUT NEXT ELEMENT IF IN RANGE
         XERR  13,026             AN ARRAY LOWER BOUND IS NOT IN THE
*                                 RANGE -32767 TO 32767 IN A CALL TO
*                                 THE ARRAY FUNCTION
*
*        COME HERE IF THE ARRAY PROTOTYPE IS AN INTEGER
*
ARRAYI   LM    A1,A1+1,TEM#1(PDR) LOAD INTEGER RESULT
         SR    A2+1,A2+1          INDICATE END OF PROTOTYPE
         B     HIBND              AND PROCESS AS A HIGH BOUND
*
*        COME HERE WHEN THE DIMENSION IS IN ERROR
*
ADIMERR  XERR  13,027             THE DIMENSION FOR AN ARRAY BOUND
*                                 IS NOT IN THE RANGE 1 TO 32767
ARRAY    ENDFUNC                  END OF ARRAY FUNCTION
         TITLE 'SPITBOLF -- CLEAR FUNCTION'
CLEAR    FUNCTION  2              ENTRY POINT -- TWO ARGUMENTS REQUIRED
         BAL   A2+1,XSCANI        INITIALIZE EXECUTION SCAN ROUTINE
         XERR  01,055             FIRST ARGUMENT TO CLEAR NOT A STRING
         B     CLEARS             SKIP MARKING PHASE IN NULL FIRST ARG
         OI    XSCANFLG,XSIGNRO   SET TO IGNORE RUNOUT
         MVI   ZTBL+C',',1        SET TO STOP ON COMMAS
         OI    STAGE,$CLEARFG     TELL VARLOC NOT TO ADD 4K BLOCK
*
*        LOOP TO FIND AND MARK NOCLEAR BLOCKS IN FIRST ARGUMENT
*
CLEARSCN BALR  RETURN,A2          SCAN OUT A NAME
         NI    STAGE,X'FF'-$CLEARFG         ON ULL, 1ST KILL SPCL FLAG!
         XERR  13,028             NAME IN FIRST ARGUMENT TO THE CLEAR
*                                 FUNCTION IS NULL
         LTR   A1,A1              CHECK FOR NOTHING AS RESULT OF HASH
*                                 WHICH WOULD OCCUR IF VARLOC WAS
*                                 ASKED TO CREATE A NEW 4K DATAAREA BLK
         BZ    *+8                SKIP IF NO BLCOK ADDRESS RETURNED
         OI    VCLEAR(A1),CLEARSW INDICATE THIS VAR VALUE TO BE SAVED
         LTR   A2+1,A2+1          TEST END OF ARGUMENTS
         BNZ   CLEARSCN           LOOP BACK IF NOT AT END OF STRING
         MVI   ZTBL+C',',0        CLEAR ZTBL FOR LATER REUSE
         NI    STAGE,X'FF'-$CLEARFG         TURN OFF SPECIAL VARLOC FLG
*
*        COME HERE TO GO DOWN HASH CHAINS CLEARING VARIABLE BLOCKS
*
CLEARS   SR    R2,R2              SET SWITCH VALUE FORPATTERN CLEAR
         CLI   TEM#2(PDR),NCODE   IS SECOND CLEAR ARG NULL?
         BE    *+8                DON'T SAVE PATTERNS IF NULL
         LA    R2,4               ELSE SET TO NOT NULL PATTERNS
         LA    A1,4               GET BXLE INCREMENT
         L     A2,HASHTBAD        LOAD START OF HASH TABLE ADDRESS
         LA    A1+1,HASHTBNS*4(,A2)         LOAD END OF HASH TB ADDRESS
         L     R0,=X'00FFFFFF'    LOAD MASK TO TEST FOR LINK END
         B     CLEARE             MAKE INITIAL LOOP ENTRY
         EJECT
*
*        LOOP TO CLEAR VARIABLE BLOCKS AS FOUND IF NTO MARKED
*
CLEARL   TM    VCLEAR(R1),CLEARSW ARE WE TO SAVE THIS BLOCKS VALUE?
         BO    CLEARSV            SKIP IF SO
         CLI   VALUE(R1),PCODE    IS THIS VALUE A PATTERN?
         BE    *+4(R2)            IF PAT, TAKE ACTION SPEC BY 2ND CLEAR
*                                 ARGUMENT (R2 SET UP AT CLEARS)
         MVI   VALUE(R1),NCODE    SET VARIABLE BLOCK VALUE TO NULL
*
*        COME HERE WHEN BLOCK MARKED NOT TO BE CLEARED
*
CLEARSV  NI    VCLEAR(R1),X'FF'-CLEARSW     TURN OFF CLEAR SWITCH
*
*        COME HERE TO MOVE OUT ON LINK OR GET HASH SLOT VALUE
*
CLEART   L     R1,VLINK(,R1)      MOVE OUT ON LINK
         NR    R1,R0              MAKE CHECK FOR 0 LINK ADDRESS
         BNZ   CLEARL             LOOP TO CLEAR BLOCK IF NOT LINK END
*
*        COME HERE TO MOVE TO NEXT HASH SLOT
*
CLEARE   LR    R1,A2              COPY SLOT ADDRESS-VLINK
         BXLE  A2,A1,CLEART       LOOP BACK AFTER CHECK FOR DONE
         B     EXITNULL           RETURN NULL AS RESULT
CLEARSW  EQU   X'01'              USE RIGHTMOST BIT AS FLAG
VCLEAR   EQU   VFUNC+3            USE VFUNC FIELD (COLLECT IMPOSSIBLE
*                                 BECAUSE OF CLEARFG FUGE TO VARLOC)
CLEAR    ENDFUNC   ,              END OF CLEAR FUNCTION
         TITLE 'SPITBOLF -- CODE FUNCTION'
CODE     FUNCTION  1              ONE ARGUMENT REQUIRED
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         CLI   TEM#1(PDR),CCODE   IS ARGUMENT ALREADY CODE?
         BE    EXIT               RETURN ARG AS RESULT IF SO
         BAL   RETURN,GETSTG      CONVERT ARGUMENT TO STRING
         B     FAILRL             FAIL IF NOT A STRING
         L     R1,CODXEQAD        ELSE LOAD ADDR OF COMPILER ROUTINE
         MVI   CODXSW,CCODE       SET TYPE CODE
         BALR  RETURN,R1          CALL COMPILER
         B     FAILRL             SIGNAL FAILURE IF SYNTAX ERROR
         B     EXIT               RETURN TO CALLER
CODE     ENDFUNC   ,              END OF CODE FUNCTION
         TITLE 'SPITBOLF -- COLLECT FUNCTION'
*
*        THE COLLECT FUNCTION EXPECTS 0 OR 1 ARGUMENTS ON THE STACK
*        IF AN ARGUMENT IS PRESENT, IT SPECIFIES THE NUMBER OF BYTES
*        NEEDED AFTER A COLLECT FOR THIS FUNCTION TO SUCCEED
*
COLLECT  FUNCTION  1              ENTRY POINT -- ONE ARG REQUIRED
         MVI   GCOLNRG,GGBGCLF+GCMPRSS      SET FOR SUPER COMPRESS GCOL
         TS    CLLCTFL            TEST COLLECT FLAG AND SET IT
         BZ    GCOLC              COLLECT IF NOT DONE ALREADY
*
*        WE COME HERE ON THE SECOND ENTRY (AFTER COLLECTION)
*
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         BAL   RETURN,GETINT      GET AN INTEGER VALUE
         XERR  01,057             ARGUMENT TO COLLECT IS NOT AN INTEGER
         LR    A2,A1+1            GET ARGUMENT LENGTH
         LR    A1+1,PDR           INTEGER RESULT = PDR
         SR    A1+1,FR                 MINUS FR = STORAGE FREE
         MVI   CLLCTFL,0          RESET COLLECT FLAG
         CR    A1+1,A2            CHECK RESULT AGAINST ARGUMENT
         BNL   EXIT               EXIT IF OK
         B     FAILRL             ELSE FAIL
COLLECT  ENDFUNC   ,              END OF COLLECT FUNCTION
         TITLE 'SPITBOLF -- CONVERT FUNCTION'
CONVERT  FUNCTION  2              ENTRY POINT -- 2 ARGS REQUIRED
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT
         BAL   RETURN,GETSTGS     GET STRING SPECIFIER FOR SECOND ARG
         XERR  01,058             CONVERT SECOND ARGUMENT NOT A STRING
         LR    A2,A1              MOVE TO SECOND ACCUMULATOR
         LR    A2+1,A1+1          ...
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         LA    R0,CVTSTD          SET TO TRY STANDARD TYPES
         LA    R1,CVTABL          POINT TO FIRST ENTRY
         LR    R2,PDR             SAVE ENTRY STACK POINTER
         L     PDR,PDRLOC         AND THEN RESET STACK POINTER
*
*        THIS LOOP DEALS WITH THE CASES IN WHICH CONVERSION IS
*        ACTUALLY POSSIBLE (STRING,NUMERIC,PATTERN,ARRAY,TABLE)
*
CNVRTL   CH    A2+1,0(,R1)        CHECK LENGTHS
         BNE   CNVTRE             SKIP TO END OF LOOP IF UNEQUAL
         EX    0,2(,R1)           EXECUTE CHARACTER COMPARISON
         BNE   CNVTRE             SKIP TO END OF LOOP IF NOT EQUAL
         EX    0,8(,R1)           EXECUTE CALL TO CONVERT ROUTINE
         B     FAILRL             FAIL IF UNCONVERTIBLE
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         CR    FR,PDR             DO WE NEED A COLLECT?
         BCR   L,RETURN           RETURN IF NO COLLECT NEEDED
         B     GBGCL1             ELSE COLLECT AND RETURN SAVING A1
*
*        COME HERE AT END OF LOOP
*
CNVTRE   LA    R1,12(,R1)         POINT TO NEXT ENTRY
         BCT   R0,CNVRTL          SKIP BACK IF MORE TO GO
*
*        COME HERE FOR ALL OTHER CASES -- CONVERT ONLY SUCCEEDS IF
*        THE DATATYPES MATCH (I.E. NULL CONVERSION)
*
         BAL   RETURN,$$DTTP      GET DATATYPE OF FIRST ARGUMENT
         LM    A2,A2+1,TEM#2(R2)  LOAD SECOND ARGUMENT
         BAL   RETURN,$$IDNT      COMPARE ARGUMENTS
         LM    A1,A1+1,TEM#1(R2)  RELOAD FIRST ARG AS RESULT
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         BCR   E,RETURN           ALL OK IF DATATYPES MATCH
         BR    FRETURN            ELSE FAIL
         EJECT
*
*        TABLE FOR CONVERTABLE TYPES
*
CVTABL   DC    Y(4-1)             360 LENGTH OF 'REAL'
         CLC   SCHARS(4,A2),=C'REAL'        CHECK CHARS FOR 'REAL'
         BAL   RETURN,GETREAL     CALL TO CONVERT TO REAL
*
         DC    Y(7-1)             360 LENGTH OF 'INTEGER'
         CLC   SCHARS(7,A2),=C'INTEGER'     CHECK CHARS FOR 'INTEGER'
         BAL   RETURN,GETINT      CALL TO CONVERT TO INTEGER
*
         DC    Y(6-1)             360 LENGTH OF 'STRING'
         CLC   SCHARS(6,A2),=C'STRING'      CHECK CHARS FOR 'STRING'
         BAL   RETURN,CVTSTG      CALL CONVERT TO STRING ROUTINE
*
         DC    Y(7-1)             360 LENGTH OF 'PATTERN'
         CLC   SCHARS(7,A2),=C'PATTERN'     CHECK CHARS FOR 'PATTERN'
         BAL   RETURN,GETPAT      CALL TO CONVERT TO PATTERN
*
         DC    Y(5-1)             360 LENGTH OF 'DREAL'
         CLC   SCHARS(5,A2),=C'DREAL'       CHECK CHARS FOR 'DREAL'
         BAL   RETURN,GETDREAL    CALL TO CONVERT TO DREAL
*
         DC    Y(7-1)             360 LENGTH OF 'NUMERIC'
         CLC   SCHARS(7,A2),=C'NUMERIC'     CHECK CHARS FOR 'NUMERIC'
         BAL   RETURN,GETNUM      CALL TO CONVERT TO NUMERIC
*
         DC    Y(5-1)             360 LENGTH OF 'ARRAY'
         CLC   SCHARS(5,A2),=C'ARRAY'       CHECK CHARS FOR 'ARRAY'
         BAL   RETURN,CVTARR      CALL TO CONVERT TO ARRAY
*
         DC    Y(5-1)             360 LENGTH OF 'TABLE'
         CLC   SCHARS(5,A2),=C'TABLE'       CHECK CHARS FOR 'TABLE'
         BAL   RETURN,CVTTAB      CALL TO CONVERT TO TABLE
*
         DC    Y(4-1)             360 LENGTH OF 'NAME'
         CLC   SCHARS(4,A2),=C'NAME'        CHECK CHARS FOR 'NAME'
         BAL   RETURN,CVTNAME     OFF TO GETNAME CODE
*
         DC    Y(4-1)             360 LENGTH OF 'CODE'
         CLC   SCHARS(4,A2),=C'CODE'        CHECK CHARS FOR 'CODE'
         BAL   RETURN,CVTCODE     OFF TO CODE TO CONVERT TO CODE
*
         DC    Y(10-1)            360 LENGTH OF 'EXPRESSION'
         CLC   SCHARS(10,A2),=C'EXPRESSION'
         BAL   RETURN,CVTEXPR     OFF TO SPECIAL EXPR CONVERT ROUTINE
*
CVTSTD   EQU   (*-CVTABL)/12      NUMBER OF ITEMS IN CVT LIST
         EJECT
*
*        SPECIAL ROUTINE FOR CONVERT TO STRING
*
CVTSTG   BAL   RETURN,GETSTG      CONVERT TO STRING
         BAL   RETURN,$$DTTP      GET DATATYPE IF NOT CONVERTIBLE
         L     RETURN,RETLOC      RESTORE RETURN POINT
         CR    FR,PDR             CHECK FOR GCOL REQUIRED
         BCR   L,RETURN           RETURN IF NOT
         B     GBGCL1             ELSE RETURN VIA GARBAGE COLLECTOR
*
*        SPECIAL ROUTINE FOR CONVERT TO NAME
*
CVTNAME  CLI   TEM#1(R2),MCODE    ALREADY A NAME?
         BNE   GETNAME            USE STANDARD VBLK GETNAME IF NOT
         B     4(,RETURN)         ELSE SIGNAL OK CONVERT IF ALREADY NM
*
*        SPECIAL ROUTINE FOR CONVERT TO CODE
*
CVTCODE  MVI   CODXSW,CCODE       SET TYPE CODE
         B     CVTEXPRM           MERGE WITH EXPRESSION CASE
*
*        SPECIAL ROUTINE FOR CONVERT TO EXPRESSION
*
CVTEXPR  MVI   CODXSW,ECODE       SET TYPE CODE
*
*        CONVERT TO CODE MERGES HERE
*
CVTEXPRM CLC   TEM#1(1,R2),CODXSW IS CONVERSION REQUIRED?
         L     RETURN,RETLOC      RELOAD RETURN IN CASE
         BCR   E,RETURN           RETURN IF ALREADY CONVERTED
         BAL   RETURN,GETSTG      ELSE CONVERT TO STRING
         B     FAILRL             FAIL, LOAD RETURN IF CAN'T CONVERT
         L     R1,CODXEQAD        LOAD ADDRESS OF COMPILER
         BALR  RETURN,R1          CALL COMPILER
         B     FAILRL             FAIL IF CANNOT COMPILE
         L     RETURN,RETLOC      ELSE LOAD RETURN POINT
         BR    RETURN             AND RETURN TO CALLER
         EJECT
*
*        COME HERE TO CONVERT ARGUMENT TO AN ARRAY
*        THIS FAILS UNLESS THE ARGUMENT IS AN ARRAY OR TABLE
*
CVTARR   CLI   TEM#1(R2),ACODE    IS IT ALREADY AN ARRAY?
         BE    4(,RETURN)         SUCCEED IF SO
         CLI   TEM#1(R2),TCODE    ELSE IS IT A TABLE?
         BCR   NE,RETURN          FAIL IF NOT
         BAL   RETURN,TBCHRON     COUNT AND CHRONOLOGICALLY ORDER ELEMS
         B     FAILRL             FAIL WITH RELOAD IF NO NON-NULL ELEMS
         LR    A2,A1+1            COPY ELEMENT COUNT
         LR    R1,A1+1            COPY COUNT FOR COLLECT CHECK
         SLL   R1,4               *(8*2) IS ROOM FOR ARRAY ELEMENTS
         LA    R1,AVALS+8+SCHARS+10+BOUND(FR,R1)      GET NEW FREE CORE
         CR    R1,PDR             WILL WE OVERFLOW AFTER STRING&ARRAY?
         BCR   NL,RETURN          OFF TO TBCHRON TO FIX UP AND GBGCLF
         SR    A1,A1              INDICATE INTEGER
         BAL   RETURN,GETSTGS     CONVERT DIM1 TO STRING FOR ASPEC
         NOP   0                  ERROR NOT POSSIBLE
         MVC   SCHARS(7,FR),SCHARS(A1)      COPY STRING TO FREE CORE
         LR    A1,FR              COPY POINTER TO NEW SBLOK
         STE   ZR,0(,FR)          SET DTYPE = SBLOK = 0, GCOLPTR = 0
         LA    R1,1(A1,A1+1)      POINT PAST STRING
         MVC   SCHARS(2,R1),=C',2'          COMPLETE SPECIFIER
         LA    R1,SCHARS+3+BOUND(,A1+1)     GET LENGTH OF SBLOK + FUDGE
         N     R1,FULLWRD         PUT ON BOUNDARY
         STH   R1,STLENGTH(,FR)   STORE LENGTH IN SBLOK
         AR    FR,R1              PUSH FR PAST SBLOK
         LA    A1+1,2(,A1+1)      GET NEW LENGTH
         STM   A1,A1+1,ASPEC(FR)  STORE SPECIFIER
         MVI   ASPEC(FR),SCODE    MAKE IT A STRING
         EJECT
*
*        HERE WE COMPLETE THE CONSTRUCTION OF THE ARRAY DV
*
         STE   ZR,0(,FR)          CLEAR GBGCOL FIELD
         MVI   0(FR),ABLOK        MAKE THIS AN ARRAY
         LR    R1,A2              COPY ELEMENT COUNT TO GET ARRAY SIZE
         SLL   R1,4               *(8*2) IS ROOM NEEDED IN ARRAY
         LA    R1,AVALS+8(,R1)    GET ARRAY LENGTH
         ST    R1,NBYTESA(,FR)    SAVE IN PROPER FIELD
         MVI   NSUBS(FR),2        SET NUMBER OF SUBSCRIPTS
         LA    A1,8               FIRST SUBFACTOR=8
         LR    A1+1,A2            COPY NUM OF ELEMENTS = SUBDIM 1
         SLL   A2,3               ELEMENTS*8 IS 2ND SUBFACTOR
         LA    A2+1,2             SECOND DIMENSION IS TWO
         STM   A1,A2+1,SUBFAC(FR) NON-SYMBOLIC SETUP OF ARRAY INFO
         MVI   SUBLBD+1(FR),1     SET LOW BOUND OF SUB 1 TO 1
         MVI   SUBLBD+1+8(FR),1   SET LOW BOUND OF SUBSC 2 TO 1
         LA    A2+1,AVALS+8(,FR)  POINT TO FIRST ARRAY ELEMENT VALUE
         L     R2,TEBLOKBT        LOAD GBGFLD OF A TEBLOK FOR CLEAR
         L     A1+1,TBCHRSV       LOAD HEAD OF CHRONOLOGICAL LIST
*
*        LOOP TO MOVE DOWN LINK COPYING ELEMENTS INTO ARRAY, CLEARING
*                                 TEBLOKS AS THEY ARE USED
*
CVTARR1  L     A1,0(,A1+1)        MOVE OUT ON CHAIN
         ST    R2,0(,A1+1)        RESET GBG FIELD
         LM    R0,R1,TENAME(A1+1) LOAD NAME FIELD
         STM   R0,R1,0(A2+1)      SAVE IN FIRST ARRAY FIELD
         LM    R0,R1,TEVALUE(A1+1)          LOAD ELEMENT VALUE
         ST    R0,0(A2,A2+1)      STORE 1ST WORD OF 2ND ARRAY FIELD
         ST    R1,4(A2,A2+1)      STORE 2ND WORD OF 2ND ARRAY FIELD
         LA    A2+1,8(,A2+1)      PUSH ARRAY SUBSCRIPT
         LTR   A1+1,A1            COPY AND TEST FOR END OF LINK
         BNZ   CVTARR1            LOOP BACK IF NOT END OF CHAIN
         LR    A1,FR              COPY ARRAY ADDRESS
         LA    FR,0(A2,A2+1)      POSITION FR CORRECTLY
         AL    A1,ACODEBT         MAKE AN ARRAY TYPE
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS
         BR    RETURN             RETURN TO CALLER
         EJECT
*
*        COME HERE TO CONVERT A TABLE OR ARRAY TO TABLE
*
CVTTAB   CLI   TEM#1(R2),TCODE    ALREADY A TABLE?
         BE    4(,RETURN)         SUCCEED IF SO
         CLI   TEM#1(R2),ACODE    ELSE IS IT AN ARRAY?
         BCR   NE,RETURN          FAIL IF NOT
         CLI   NSUBS(A1),2        IS IT RECTANGULAR?
         BNE   FAILRL             FAIL IF NOT
         LH    R1,SUBDIM(,A1)     GET NUMBER OF NAMES IN ARRAY
         MH    R1,=Y(TESIZE)      * SIZE REQUIRED PER NAME
         LA    R1,TBLPTRS+40(R1,FR)         + TBL SIZE + FREE CORE PTR
         CR    R1,PDR             WILL WE OVERFLOW?
         BNL   GBGCLF             IF SO, COLLECT AND RE-ENTER
         ST    FR,CVTSAVE         SAVE ADDRESS OF TABLE
         MVI   CVTSAVE,TCODE      AND MAKE IT LOOK LIKE A TABLE
         STE   ZR,0(,FR)          CLEAR START OF HASH TABLE
         MVI   0(FR),TBBLOK       MAKE IT A TABLE
         LA    R0,4*10            GET TABLE SIZE (10 SLOTS)
         ST    R0,TBDIVIDE(,FR)   STORE AS NUMBE OF SLOTS*4
         LA    R0,4*10+TBLPTRS    GET TABLE LENGTH
         ST    R0,TBLENGTH(,FR)   STORE IN CORRECT LOCATION
         XC    TBLPTRS(40,FR),TBLPTRS(FR)   CLEAR HASH TABLE
         AR    FR,R0              CORRECTLY POSITION FR PAST TABL)
         LA    DB3,AVALS+8(,A1)   POINT TO FIRST VALUE LOCATION
         L     DB2,SUBFAC+8(,A1)  GET DIFFERENCE BETWEEN NAME & VALUE
         AR    DB2,DB3            POINT TO FIRST VALUE FIELD
         ST    DB2,CVTEND         SAVE POINTER PAST LAS NAME FIELD
         L     R2,SUBSC1AD        GET BASE REGISTER FOR ROUTINE
*
*        LOOP TO PICK UP ARRAY VALUES AND CALL TABLE ROUTINE
*
CVTTAB1  CLI   0(DB2),NCODE       IS NEXT ELEMENT VALUE NULL?
         BE    CVTTAB2            SKIP CALL IF SO
         LM    A1,A1+1,0(DB3)     GET NAME OF ELEMENT
         L     A2,CVTSAVE         GET ADDRESS OF TABLE
         MVI   NAMEFL,0           SET CALL BY NAME
         USING SUBSC1,R2          TELL ASSEMBLER
         BAL   RETURN,TBLOOK      HASH THE TABLE ELEMENT
         DROP  R2                 DON'T NEED THIS BASE REG ANYMORE
         LM    R0,R1,0(DB2)       GET VALUE
         STM   R0,R1,TEVALUE(A1)  STORE IT IN VALUE FIELD
         EJECT
*
*        COME HERE TO PUSH TO NEXT ELEMENT IN ARRAY
*
CVTTAB2  LA    DB3,8(,DB3)        INCREMENT OFFSET
         LA    DB2,8(,DB2)        PUSH POINTER TO VALUES
         C     DB3,CVTEND         HAVE WE FINISHED?
         BL    CVTTAB1            LOOP IF NOT
         L     A1,CVTSAVE         GET TABLE POINTER
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3
         L     RETURN,RETLOC      RESTORE RETURN ADDRESS
         BR    RETURN             BACK TO CALLER
CONVERT  ENDFUNC                  END OF CONVERT FUNCTION
         TITLE 'SPITBOLF -- COPY FUNCTION'
COPY     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT
         TM    TEM#1(PDR),RELOCBIT          IS ARGUMENT RELOCATABLE
         BNO   EXIT               RETURN ARG AS COPY IF NOT
         CLI   TEM#1(PDR),MCODE   IS IT A NAME?
         BE    EXIT               IF SO, RETURN ARG AS COPY
         CLI   TEM#1(PDR),ECODE   IS IT AN EXPRESSION?
         BE    EXIT               IF SO, RETURN ARGUMENT AS COPY
*
*        AT THIS POINT WE HAVE FOUND SOMETHING WHICH REALLY NEEDS
*        TO BE COPIED -- SO FIND ITS LENGTH
*
         LR    A2+1,A1            COPY POINTER
         LA    A2,0(,A1)          COPY ALL BUT TYPE CODE
         SR    A2+1,A2            SUBTRACT TO ISOLATE TYPE CODE
         SR    R2,R2              CLEAR FOR IC
         IC    R2,DTYPE(,A1)      LOAD CODE FOR BLOCK TYPE
         EX    0,BLOKLEN(R2)      GET LENGTH OF BLOCK
         LR    R0,R2              COPY LENGTH TO (R0)
*
*        THE LENGTH IS NOW IN (R0) -- SO PERFORM COPY
*
         LR    R1,R0              SAVE LENGTH
         AR    R0,FR              SEE WHERE FR WILL END UP
         CR    R0,PDR             WILL WE HAVE ROOM?
         BH    GBGCLF             GARBAGE COLLECT IF NOT
         LA    R2,256             GET CRANK CONSTANT FOR LOOP
         LR    A2,FR              COPY START OF BLOCK
         CR    R1,R2              IS BLOCK SHORT OR LONG
         BL    COPY2              SKIP IF 256 CHARS OR LESS
*
*        LOOP TO MOVE 256 CHARACTERS AT A TIME
*
COPY1    MVC   0(256,A2),0(A1)    MOVE 256 CHARACTERS
         AR    A1,R2              BUMP SOURCE POINTER
         AR    A2,R2              BUMP DESTINATION POINTER
         SR    R1,R2              DECREMENT COUNT LEFT
         CR    R1,R2              MORE THAN 256 CHARS LEFT?
         BNL   COPY1              LOOP BACK IF SO
*
*        COME HERE TO MOVE LAST CHUNK OF 256 CHARS OR LESS
*
COPY2    EX    R1,COPYM           MOVE REMAINING CHARS (+1 GARBAGE CHR)
         CLI   DTYPE(FR),TBBLOK   WAS THIS A TABLE?
         BE    COPYT              SKIP ON SPECIAL CASE OF A TABLE
         LR    A1,FR              ELSE GET LOCATION OF NEW BLOCK
         ALR   A1,A2+1            SUPPLY TYPE BYTE
         LR    FR,R0              SET NEW FR LOCATION
         B     EXIT               RETURN
*
COPYM    MVC   0(*-*,A2),0(A1)    MOVE LAST CHUNK IN MAIN COPY
         EJECT
*
*        IN THE SPECIAL CASE OF A TABLE -- WE MUST COPY ALL TEBLOKS
*
COPYT    LR    A2+1,R0            GET FREE CORE PTR PAST NEW TABLE
         L     A1,TEM#1(,PDR)     GET OLD TABLE ADDRESS FOR TBCHRON
         BAL   RETURN,TBCHRON     CHRONOLLOGICALLY ORDER NON-NULL ELEMT
         B     COPYTNUL           SKIP ELEMENT COPY IF NONE TO COPY
         MH    A1+1,=Y(TESIZE)    CALCULATE ROOM NEEDED FOR TEBLOKS
         AR    A1+1,A2+1          ADD IN CURRENT FREE CORE ADDR
         CR    A1+1,PDR           CHECK FOR COLLECT NEEDED
         BCR   NL,RETURN          OFF TO CLEAN UP CORE IF NEED GBGCLT
         L     A1+1,TBCHRSV       LOAD POINTER TO CHAIN OF TEBLOKS
         L     R2,TEBLOKBT        LOAD GBG WRD FOR TEBLOKS TO FIX UP
*
*        LOOP HERE COPYING NON-NULL TEBLOKS TO FREE CORE
*        AFTER COPYING, OLD COPIES HAVE PTR TO NEW COPIES IN GBG FIELD
*
COPYTL   L     A1,0(,A1+1)        MOVE OUT ON TEBLOK CHAIN
         ST    A2+1,0(,A1+1)      STORE ADDR OF NEW COPY
         MVC   4(TESIZE-4,A2+1),4(A1+1)     COPY ALL BUT GBGFLD
         ST    R2,0(,A2+1)        FIX UP GBG FLD IN NEW BLOCK
         LA    A2+1,TESIZE(,A2+1) PUSH FREE CORE POINTER PAST BLOK
         LTR   A1+1,A1            COPY AND TEST LINK TO NEXT BLOK
         BNZ   COPYTL             LOOP BACK FOR MORE IF NOT CHN END
*
*        COME HERE AFTER ALL TEBLOKS COPIED (OR IF NONE TO COPY)
*
COPYTNUL LA    R0,4               GET BXLE CONSTANT FOR TBL LOOP
         L     R1,TBDIVIDE(,FR)   LOAD SIZE OF TBL PTRS
         ST    FR,TBCHRSV         SAVE ADDRESS OF NEW TABLE
         MVI   TBCHRSV,TCODE      SET DATATYPE TO TABLE
         SH    FR,=Y(TLINK-TBLPTRS)         GIVE PTRS A 'TLINK' OFFSET
         AR    R1,FR              CALCULATE BXLE END OF LOOP ADDRESS
         B     COPYTL3            AND MAKE INITIAL LOOP ENTRY
         EJECT
*
*        COME HERE WITH POINTER TO TEBLOK IN (A1)
*        IF VALUE IS NULL, THEN NO COPY MADE AND GBG FLD IS EMPTY
*        IF IT IS NOT EMPTY, THEN ADDR IS THAT OF NEW TEBLOK AND IS NEW
*        LINK FIELD FOR HASH CHAIN
*
COPYTL1  CLI   TEVALUE(A1),NCODE  WAS THIS ELEMENT COPIED?
         BE    COPYTL2            SKIP LINK FIXUP IF NOT COPIED
         L     A2,0(,A1)          LOAD ADDRESS OF NEW BLOCK
         ST    A2,TLINK(,A1+1)    STORE LINK TO NEW BLOCK
         LR    A1+1,A2            AND NEW BLOCK NOW NEEDS LINKING
         ST    R2,0(,A1)          FIX UP GBG FLD IN OLD BLOCK
*
*        COME HERE TO MOVE OUT ON HASH CHAIN
*
COPYTL2  L     A1,TLINK(,A1)      LOAD BLOCK'S LINK FIELD
         LTR   A1,A1              TEST FOR END OF CHIN
         BNZ   COPYTL1            LOOP BACK IF NOT CHAIN END
         STE   ZR,TLINK(,A1+1)    SET END OF CHAIN IN NEW TBL CHAIN
*
*        COME HERE TO MOVE TO NEXT HASH TABLE SLOT
*
COPYTL3  LR    A1,FR              PRETEND SLOT IS A TABLE ELEMENT
         LR    A1+1,FR            SAVE LINK ADDRESS FOR NEW CHAIN
         BXLE  FR,R0,COPYTL2      TEST FOR TBL END, LOOP BACK IF NOT
         LR    FR,A2+1            SET PROPER FREE CORE POINTER
         L     A1,TBCHRSV         LOAD POINTER TO NEW TABLE
         B     EXIT               RETURN
COPY     ENDFUNC   ,              END OF COPY FUNCTION
         TITLE 'SPITBOLF -- DATA FUNCTION'
DATA     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED
         BAL   A2+1,XSCANI        INITIALIZE SCAN, SET SCAN BASE REG
         XERR  01,059             ARGUMENT TO DATA IS NOT A STRING
         XERR  13,030             ARGUMENT TO DATA IS NULL
         STE   ZR,0(,FR)          CLEAR GBG FIELD FOR PDF
         MVI   0(FR),PDFBLOK      SET PROPER BLOCK CODE
         MVC   8(PDMODL+4-8,FR),DATAMODL    MOVE IN STD CODE
         MVI   ZTBL+C'(',1        SET TO SCAN OUT LEFT PAREN
         BALR  RETURN,A2          GET FIRST NAME ADDRESS
         XERR  13,031             DATATYPE NAME IN ARGUMENT TO DATA
*                                 FUNCTION IS NULL
         XERR  13,032             ARGUMENT TO DATA FUNCTION DOES NOT
*                                 CONTAIN A LEFT PARENTHESIS
         ST    A1,PDFNPTR(,FR)    SAVE ADDRESS OF FUNCTION NAME
         MVI   ZTBL+C'(',0        NO LONGER STOP ON (
         MVI   ZTBL+C',',DATASCCM-DATASCAN  SET JUMP AMOUNT FOR COMMA
         MVI   ZTBL+C')',DATASCRP-DATASCAN  SET JUMP AOUNT FOR RT PAREN
         LR    DB2,FR             COPY ADDRESS FOR STORING FIELD NAMES
*
*        THIS IS THE BASE FOR INDEXED JUMPS AFTER FIELD PROCESSED
*
DATASCAN EQU   *-4                BASE FOR JUMPS (MUST BE LT DATASCNM)
*
*        COME HERE TO PROCESS ANOTHER FIELD ENTRY
*
DATASCCM BALR  RETURN,A2          CALL THE SCAN ROUTINE
         XERR  13,033             FIELD NAME IN ARGUMENT TO DATA
*                                 FUNCTION IS NULL
*
*        BRANCH TO HERE IF CHARACTERS FOUND AFTER THE RIGHT PARENTHESIS
*
DATAERR1 XERR  13,034             ARGUMENT TO DATA FUNCTION DOES NOT
*                                 END WITH A RIGHT PARENTHESIS
         ST    A1,FLDNPTR(,DB2)   SAVE FIELD NAME IN NEXT LOCATION
         LA    DB2,4(,DB2)        POINT PAST USED LOCATION
         B     DATASCAN(A2+1)     TAKE PROPER ACTION FOR COMA OR RT PAR
         EJECT
*
*        COME HERE IF STOP CHARACTER WAS A RIGHT PARENTHESIS
*
DATASCRP MVI   ZTBL+C',',0        CLEAR OUT TABLE
         MVI   ZTBL+C')',0        OF ZEROS FOR NEXT USE
         CE    ZR,XSCANSV         CHECK NUMBER OF CHARS LEFT IN ARG
         BNE   DATAERR1           ISSUE ERROR IF ANY CHARACTERS LEFT
         SR    DB2,FR             GET # OF FIELDS * 4 IN DB2
         LR    A2+1,DB2           SAVE FOR LATER USE
         SRL   DB2,2              /4 = NUMBER OF FIELDS
         CH    DB2,=H'30'         CHECK AGAINST FIELD LIMIT
         BNH   *+8                SKIP IF WITHIN LIMIT
         XERR  13,035             ARGUMENT TO DATA FUNCTION CONTAINS
*                                 MORE THAN 30 FIELDS
         STH   DB2,NFLDSDF(,FR)   SAVE NUMBER OF FIELDS IN BLOCK
         LA    R0,FLDNPTR(,A2+1)  GET TOTAL BLOCK SIZE
         STH   R0,NBYTESDF(,FR)   AND SAVE IT IN THE BLOCK
         ST    FR,PDMODL+PDFPTR(,FR)        SAVE POINTER TO THIS BLOCK
         LA    A2,0(A2+1,A2+1)    GET NO. OF ARGS * 8
         LA    R1,TEM#1+8         GET OFFSET TO ZEROITH TEMPORARY LOC
         SR    R1,A2              AND CALCULATE OFFSET TO 1ST TEM FOR
*                                 THE MVC IN BUILDING A DATA BLOCK
         STH   R1,DATAMVC+4(,FR)  SAVE OFSET IN MVC INSTRUCTION
         OI    DATAMVC+4(FR),PDR*16         USE PDR AS BASE REGISTER
         LA    R1,PDFLDS(,A2)     GET SIZE OF A PDBLOK
         STC   R1,PDMODL+PDFPTR(,FR)        SAVE LENGTH OF PDBLOK W/PTR
         STH   R1,DATAFRMV+2(,FR) AND SAVE AS PUSH FOR FR IN BLOCK
         BCTR  A2,0               GET 360 LENGTH OF ARGS ON STACK
         STC   A2,DATAMVC+1(,FR)  AND SAVE IN MVC IN PDFBLOK
         L     A1,PDFNPTR(,FR)    LOAD ADDRESS OF NAME BLOCK
         LR    A1+1,FR            SET ADDRESS OF NEW FUNCTION
         BAL   RETURN,OPSYN$      DO FUNC ADDR ASSGN, SET UP BASE REG
         LR    DB2,FR             SAVE ADDRESS OF PDFBLOK
         AH    FR,NBYTESDF(,FR)   PUSH PAST PDFBLOK
         LA    DB3,PDFLDS-VALUE   LOAD OFFSET FOR LAST FIELD
         EJECT
*
*        LOOP TO BUILD FFBLOKS BACKWARDS (STARTING WITH LAST FIELD
*                                 FUNCTION)
*
FFBUILD  MVC   1(7,FR),PDMODL+1(DB2)        MOVE IN PDFPTR, CLR GBGFLD
         MVI   0(FR),FFBLOK       SET BLOCK TYPE CODE
         MVC   FCODE(FFBSIZE,FR),DARGCODE   MOVE IN REST OF BLOCK
         STH   DB3,FFBLA+2(,FR)   SAVE OFFSET TO PROPER FIELD
         LA    DB3,8(,DB3)        PREPARE OFFSET FOR NEXT FIELD
         L     A1,FLDNPTR-4(A2+1,DB2)       GET NAME PTR FOR THIS FLD
         LR    A1+1,FR            GET FUNCTION ADDRESS
         LTR   FR,FR              SET CC NZ FOR DYNAMIC FUNCTION
         BALR  RETURN,A2          CALL OPSYN FUNCTION (BASE STILL SET)
         CLC   FCODE(4,R2),DARGCODE         IS OLD FUNC A FIELD FUNC?
         BNE   DATANDF            SKIP IF NOT
         ST    R2,FFBLNEXT(,FR)   ESLE CAHIN REFERENCE ON THIS BLOCK
*
*        COME HERE AFTER DEALING WITH POSSIBLE OLD FFBLOK POINTER
*
DATANDF  LA    FR,FFBSIZE(,FR)    PUSH FR PAST THIS BLOCK
         SH    A2+1,H4            DECREMENT AND TEST FIELD NAME OFFSET
         BP    FFBUILD            LOOP BACK IF MORE FIELDS TO BUILD
         LM    DB2,DB3,$$BAS2     RESTORE DB2,DB3
         L     PDR,PDRLOC         RESET STACK POINTER
         L     A1,NCODEBT         LOAD NULL AS RETURNED RESULT
         L     RETURN,RETLOC      RESTORE RETURN LOCATION
         CR    FR,PDR             DO WE NEED A COLLECT?
         BCR   L,RETURN           EXIT IF NOT
         B     GBGCL0             ELSE COLLECT (DO PROCESS NULL VALUE)
         EJECT
*
*        STANDARD BLOCK INFORMATION FOR DATA
*
*        MODEL FOR PDFBLOK
*
DATAMODL CH    R0,NFLDSDF(DB4)    ENOUGH ARGS? (DB4 MUST BE INDEX)
         BL    $$WNAG             SUPPLY NULLS IF NOT
         LM    R0,R1,PDMODL(DB4)  PICK UP PDMODL
         STM   R0,R1,0(FR)        STORE AS START OF PDBLOK
DATAMVC  EQU   *-(DATAMODL-FCODE) OFFSET TO MVC INSTRUCTION IN BLOCK
         MVC   PDFLDS(*-*,FR),*-* PICK UP N ARGS FROM TEM#N
         LR    A1,FR              POINT TO NEW PDBLOK
         A     A1,DCODEBT         ADD PROPER DATATYPE CODE
DATAFRMV EQU   *-(DATAMODL-FCODE) OFFSET TO LA OF FR IN PDFBLOK
         LA    FR,*-*(FR)         PUSH UP FREE CORE POINTER
         L     PDR,PDRLOC         RESTORE STACK ADDRESS
         CR    FR,PDR             DO WE NEED A CLOOECT?
         BCR   L,RETURN           RETURN TO CODE IF NOT
         B     GBGCL1S            ELSE COLLECT SAVING VALUE
         DC    AL4(0)             PDFNPTR
         DC    AL1(PDBLOK,0,0,0)  DTYPE, GCOLPTR FOR PDBLOK
*
*        MODEL FOR FFBLOK
*
DARGCODE CLI   TEM#1(PDR),DCODE   IS ARGUMENT A DATA ITEM?
         LA    A1+1,PDFLDS-VALUE  OFFSET TO FIELD FOR LAST ITEM
         BE    $$FLCN             IF DATA ITEM, GO LOAD IT
         B     $$FLE1             ELSE GIVE ERROR
         DC    AL4(FLCERR-FCODE)  FFBLNEXT DOES NOT EXIST
FFBLA    EQU   DARGCODE+4-(DARGCODE-FCODE)  OFFSET TO LA IN FFBLOK
DATA     ENDFUNC                  END OF DATA FUNCTION
         TITLE 'SPITBOLF -- DATATYPE FUNCTION'
DATATYPE FUNCTION  1,N            ENTRY POINT -- ONE ARGUMENT
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         L     PDR,PDRLOC         RESET STACK POINTER
         B     $$DTTP             JUMP TO STANDARD SYSTEM ROUTINE
DATATYPE ENDFUNC ,                END OF DATATYPE FUNCTION
         TITLE 'SPITBOLF -- DATE FUNCTION'
DATE     FUNCTION  0,N            ENTRY POINT -- NO ARGS
         L     PDR,PDRLOC         RESET STACK POINTER
         L     R2,DATEV           LOAD ADDRESS OF INTERFACE ROUTINE
         BALR  R1,R2              CALL IT
         B     SYSERROR           ERROR RETURN (IMPOSSIBLE)
         LR    A1,R0              LOAD POINTER TO PROPER REG
         SH    A1,H6              SET OFFSET (SCHARS)
         A     A1,SCODEBT         ADD CODE FOR STRING
         LA    A1+1,8-1           INDICATE OFFSET = 0, LENGTH = 7
         BR    RETURN             RETURN TO CALLER
DATEV    DC    V(SYSDATE)         ADDRESS OF ROUTINE
DATE     ENDFUNC   ,              END OF DATE FUNCTION
         TITLE 'SPITBOLF -- DEFINE FUNCTION'
DEFINE   FUNCTION  2              ENTRY POINT -- TWO ARGUMENTS REQUIRED
         BAL   A2+1,XSCANI        INITIALIZE THE SCAN ROUTINE
         XERR  01,060             FIRST ARGUMENT TO DEFINE FUNCTION
*                                 IS NOT A STRING
         XERR  13,036             FIRST ARGUMENT TO DEFINE FUNCTION
*                                 IS NULL
         MVC   0(12,FR),FBLKMOD   MOVE IN START OF FBLOK
         MVI   ZTBL+C'(',1        SET TO STOP ON LEFT PARENTHESIS
         BALR  RETURN,A2          SCAN OUT A NAME
         XERR  13,037             FUNCTION NAME IN DEFINE FIRST
*                                 ARGUMENT IS NULL
         XERR  13,038             FIRST ARGUMENT TO DEFINE FUNCTION
*                                 IS MISSING A LEFT PARENTHESIS
         MVI   ZTBL+C'(',0        DON'T STOP ON ( ANYMORE
         ST    A1,FNAME(,FR)      SAVE FUNCTION NAME BLOCK ADDRESS
         LR    DB2,FR             COPY POINT TO FARGS LOCATION
         MVI   ZTBL+C',',DEFARGL-DEFARG     MARK TO STOP ON ,
         LM    A1,A1+1,XSCANSV    PICK UP SCAN POINTERS TO CHECK FOR
*                                 CASE OF NO ARGUMENTS
         CLI   0(A1+1),C')'       IS NEXT CHARACTER A )?
         BE    DEFNOARG           SKIP FOR NO ARGS IF SO
         MVI   ZTBL+C')',DEFARGDN-DEFARG    SET FOR STOP ON )
*
*        THIS IS THE BASE FOR INDEXED JUMPS AFTER FIELD PROCESSING
*
DEFARG   EQU   *-4                MUST AVOID OFFSET OF ZERO
*
*        COME HERE TO PROCESS AN ARGUMENT NAME
*
DEFARGL  BALR  RETURN,A2          SCAN OUT A NAME
*
*        COME HERE TO GIVE ERROR MESSAGE IF NO CHARACTERS FOUND
*        AFTER INITIAL LEFT PARENTHESIS
*
DEFNULER XERR  13,039             FIRST ARGUMENT TO DEFINE FUNCTION
*                                 CONTAINS A NULL ARGUMENT NAME
         XERR  13,040             FIRST ARGUMENT TO DEFINE FUNCTION
*                                 IS MISSING A RIGHT PARENTHESIS
         ST    A1,FARGS(,DB2)     SAVE VAR BLOCK ADDR OF ARG NAME
         LA    DB2,4(,DB2)        BUMP OVER THIS ARGUMENT ENTRY
         B     DEFARG(A2+1)       AND TAKE PROPER STOP CHAR ACTION
*
*        COME HERE WHEN THERE ARE NO ARGUMENTS FOR FUNCTION
*
DEFNOARG SH    A1,H1              DECREMENT AND TEST LENGTH LEFT
         BM    DEFNULER           ERROR IF END OF STRING
         AH    A1+1,H1            BUMP OVER ), SAVE TYPE CODE
         STM   A1,A1+1,XSCANSV    STORE NEW SCAN POINTERS
         EJECT
*
*        COME HERE AFTER LAST ARGUMENT PROCESSED
*
DEFARGDN MVI   ZTBL+C')',0        NO LONGER STOP ON )
         LR    R0,DB2             COPY POINTER TO FARGS
         SR    R0,FR              GET NO. OF ARGS * 4
         SRL   R0,2               /4 = NUMBER OF ARGUMENT FIELDS
         STH   R0,FNARGS(,FR)     SAVE IN BLOCK
         CE    ZR,XSCANSV         HAVE WE EXHAUSTED THE STRING?
         BE    DLOCDONE           LOCALS DONE IF NO CHARS LEFT
         OI    XSCANFLG,XSIGNRO   SET TO IGNORE RUNOUT CONDITION
*
*        LOOP TO PROCESS LOCAL FIELDS
*
DEFLOCL  BALR  RETURN,A2          SCAN OUT A LOCAL
         XERR  13,041             FIRST ARGUMENT TO THE DEFINE FUNCTION
*                                 CONTAINS A NULL LOCAL NAME
         NOP   0                  IMPOSSIBLE RETURN LOCATION
         ST    A1,FARGS(,DB2)     SAVE LOCAL ADDRESS
         LA    DB2,4(,DB2)        PUSH OVER LOCAL ADDRESS
         LTR   A2+1,A2+1          TEST FOR RUNOUT
         BNZ   DEFLOCL            LOOP BACK FOR MORE IF NOT
*
*        COME HERE WHEN ALL LOCALS PROCESSED
*
DLOCDONE LR    R0,DB2             COPY FARGS POSITION FOR # CALC
         SR    R0,FR              GET NUMBER OF ARGS+LOCS*4
         SRL   R0,2               /4 = NUMBER OF ARGS+LOCS
         SH    R0,FNARGS(,FR)     MINUS NUMBER OF ARGS=NUMBER OF LOCS
         STH   R0,FNLOCS(,FR)     SAVE IN BLOCK
         MVI   ZTBL+C',',0        CLEAR ZTBL
         LA    DB2,FARGS(,DB2)    POINT PAST TBLOK
         CR    DB2,PDR            HAVE WE OVERFLOWED CORE?
         BNL   GBGCLF             COLLECT IF SO
         SR    DB2,FR             GET LENGTH OF BLOCK
         STH   DB2,FNLENG(,FR)    SAVE IN BLOCK
         L     A1,FNAME(,FR)      LOAD DEFAULT LABEL ADDRESS
*
*        COME HERE TO PROCESS THE ENTRY POINT ARGUMENT
*
         CLI   TEM#2(PDR),NCODE   IS SECOND ARGUMENT NULL?
         BE    DEFLABEL           OFF WITH LABEL IF NULL 2ND ARG
         LM    A1,A1+1,TEM#2(PDR) LOAD LABEL ADDRESS
         BAL   RETURN,GETNAME     GET VARIABLE BLOCK ADDR FOR LABEL
         XERR  01,061             SECOND ARGUMENT TO DEFINE FUNCTION
*                                 IS NOT A VALID LABEL NAME
         EJECT
*
*        COME HERE WITH A1 POINTING TO ENTRY POINT VARIABLE BLOCK
*
DEFLABEL ST    A1,FLABEL(,FR)     SAVE IN FUNCTION BLOCK
         L     A1,FNAME(,FR)      LOAD ADDRESS OF FUNCTION NAME
         MVC   FFLAGS(1,FR),VFLAGS(A1)      SET CURRENT FUNCTION FLGS
         LR    A1+1,FR            SET NEW FUNCTION ADDRESS
         BAL   RETURN,OPSYN$      MOVE IN FUNCTION ADDRESS
         AR    FR,DB2             BUMP PAST FUNCTION BLOCK
         L     DB2,$$BAS2         RESTORE DATA BASE REGISTER
         B     EXITNULL           RETURN NULL AS RESULT
*
*        MODEL BLOCK FOR FBLOK CONSTRUCTION
*
         DS    0H                 ALLIGN TO HALFWORD
FBLKMOD  DC    AL1(FBLOK)         DTYPE IS FBLOK
         DC    AL3(0)             GCOLPTR=0
         DC    AL2(0)             LENGTH OF BLOCK
         DC    AL1(0,0)           FLAGS AND UNUSED BYTE
         B     $$FUNC             CALL FUNCTION ENTRY ROUTINE
DEFINE   ENDFUNC                  END OF DEFINE FUNCTION
         TITLE 'SPITBOLF -- DETACH FUNCTION'
DETACH   FUNCTION  1              ENTRY POINT -- 1 ARG REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT
         BAL   RETURN,GETNAME     GET VARIABLE BLOCK
         XERR  01,062             ARGUMENT TO DETACH IS NOT THE NAME
*                                 OF A NATURAL VARIABLE
         LA    RETURN,EXITNULL    SET TO RETURN NULL AS RESULT
         LR    A1+1,A1            COPY VARIABLE BLOCK ADDRESS
         CE    ZR,VIOPTR(,A1+1)   DO WE HAVE AN IOBLOK?
         BCR   E,RETURN           ALL DONE IF NO IOBLOK
         NI    VFLAGS(A1+1),X'FF'-VINA-VOUA SET TO NO IO ASSOCIATIONS
         L     R1,VIOPTR(,A1+1)   LOAD IOBLOK ADDRESS
         CE    ZR,IOFUNC(,R1)     IS THERE ACTIVE TRACE INFORMATION?
         BCR   NE,RETURN          ALL DONE IF TRACE IS ACTIVE
         XC    VIOPTR+1(3,A1+1),VIOPTR+1(A1+1)        CLEAR OUT ADDR
         BR    RETURN             AND RETURN TO CALLER
DETACH   ENDFUNC                  END OF DETACH FUNCTION
         TITLE 'SPITBOLF -- DUMP FUNCTION'
*
*        THIS ROUTINE CAN BE CALLED FROM THE GENERATED CODE AND
*        AND AT THE END OF THE RUN IF A DUMP IS REQUESTED
*
DUMP     FUNCTION  1,N            ENTRY POINT -- ONE ARGUMENT REQUIRED
         STM   FRETURN,RETURN,FRETLOC       SAVE RETURN REGISTERS
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         LA    A1+1,1             ASSUME VALUE OF 1 IF ERROR
         LTR   A1+1,A1+1          TEST VALUE OF ARGUMENT
         BNP   DUMPOUT            EXIT IF NOT POSITIVE
         STC   A1+1,DMPARG        SAVE FOR LATER TEST
*
*        HERE WE CHECK FOR ARGUMENT = 3 (SYSTEM MEMORY DUMP)
*
         CLI   DMPARG,3           IS IT DUMP(3)?
         BNE   DUMPD              SKIP IF NOT
         L     R2,=V(SYSDUMP)     POINT TO SYSTEM DUMP ROUTINE
         BALR  R1,R2              CALL SYSTEM DUMP ROUTINE
         NOP   0                  UNUSED ERROR RETURN
         B     DUMPOUT            JUMP TO EXIT
*
*        GENERAL INITIALIZATION
*
*        IF ARGUMENT IS TWO, WE MUST SET ID NUMBERS IN DYNAMIC BLOCKS
*
DUMPD    CLI   DMPARG,2           IS ARGUMENT TWO? DUMP(2) CASE?
         BNE   DMPINIT            GO INITIALIZE DUMP IF NOT
         L     A1,DYNAMB          LOAD START OF DYNAMIC CORE
         CR    FR,A1              IS FREE CORE EMPTY?
         BCR   E,RETURN           BACK TO GETINT ERROR RETURN IF SO
         SR    DB3,DB3            INITIALIZE COUNTER TO ZERO
*
*        LOOP THROUGH BLOCKS IN DYNAMIC CORE SETTING ID NUMBERS
*
DMPSIDL  CLI   0(A1),ABLOK        IS IT ARRAY?
         BE    DMPSID             JUMP TO SET ID IF SO
         CLI   0(A1),PDBLOK       IS IT PROGRAM DEFINED DATATYPE?
         BE    DMPSID             JUMP TO SET ID IF SO
         CLI   0(A1),TBBLOK       IS IT TABLE?
         BNE   DMPSIDX            JUMP TO END OF LOOP IF NOT
*
*        COME HERE TO SET ID NUMBER
*
DMPSID   LA    DB3,1(,DB3)        BUMP ID NUMBER
         STH   DB3,2(,A1)         STORE ID NUMBER IN PLACE
*
*        COME HERE TO BUMP PAST THIS BLOCK
*
DMPSIDX  SR    R2,R2              CLEAR FOR IC
         IC    R2,DTYPE(,A1)      LOAD BLOCK TYPE AS TABLE OFFSET
         EX    0,BLOKLEN(R2)      LOAD LENGTH OF BLOCK IN R2
         AR    A1,R2              PUSH POINTER PAST BLOCK
         CR    A1,FR              ARE WE AT FREE CORE END?
         BL    DMPSIDL            LOOP BACK IF MORE TO GO
         EJECT
*
*        COME HERE TO INITIALIZE VARIABLE BLOCK SORT
*
*        THE NON-NULL VARIABLE BLOCK ARE CHAINED TOGETHER IN SORTED
*        ORDER USING THE VIOPTR FIELD TO HOLD THE FORWARD LINK.  IF
*        THE BLOCK WAS USING ITS VIOPTR FIELD THE BLOCKS ADDRESS IS
*        SAVED IN THE GBGCOL FIELD OF THE CONCERNED IOBLOK.  AFTER THE
*        DUMP IS COMPLETE, DURING THE FINAL SCAN THROUGH DYNAMIC CORE
*        THE VIOPTRS ARE RESTORED
*
DMPINIT  L     DB3,HASHTBAD       GET ADDRESS OF MAIN HASH TABLE
         L     R0,=X'00FFFFFF'    LOAD MASK TO CHECK FOR LINK )N:
         STE   ZR,VARCHAIN        INITIALIZE CHAIN TO NO VARIB6)S
         B     DMPHSSKP           MAKE LOOP ENTRY TO GET HASH SLOT
*
*        COME HERE TO CHECK VALUE FOR NULL
*
DMPNVL   CLI   VALUE(DB2),NCODE   IS THIS VALUE NULL?
         BE    DMPNVS             SKIP IT IF NULL
         CE    ZR,VIOPTR(,DB2)    DOES IT USE ITS IOPTR SLOT?
         BE    DMPNVCHN           NO PREPARATION IF NOT USED
         L     R1,VIOPTR(,DB2)    LOAD IOBLOK ADDRESS
         ST    DB2,0(,R1)         SAVE VARBLOK BACKPTR IN IOBLOK
         MVI   0(R1),IOBLOK       PUT BACK TYPE CODE FOR BLOKLEN
*
*        COME HERE WHEN VIOPTR HAS BEEN FREED FOR LINK USAGE
*
DMPNVCHN LA    R2,VARCHAIN-VIOPTR SET UP DUMMY CHAIN START
*
*        COME HERE TO SEARCH FOR SPOT ON CHAIN
*
DMPNVCN  LR    FRETURN,R2         SAVE BACK POINTER FOR INSERT
         L     R2,VIOPTR(,FRETURN)          MOVE OUT ON CHAIN
         NR    R2,R0              TEST FOR END OF CHAIN
         BZ    DMPNVINS           OFF TO INSERT HERE IF END OF CHAIN
         L     A1,VNAME(,DB2)     LOAD NAME BASE POINTER
         AH    A1,VNAME+SOFFSET(,DB2)       ADD IN NAME OFFSET
         LH    A1+1,VNAME+SLENGTH(,DB2)     LOAD NAME LENGTH
         L     A2,VNAME(,R2)      LOAD NAME OF ELEMENT ON CHAIN
         AH    A2,VNAME+SOFFSET(,R2)        ADD IN NAME OFFSET
         LH    A2+1,VNAME+SLENGTH(,R2)      LOAD NAME LENGTH
         BAL   RETURN,LCMPM       COMPARE THE NAMES
         BL    DMPNVCN            IF NEW NAME LOW, KEEP LOOKING
         EJECT
*
*        COME HERE TO INSERT A BLOCK ON THE LIST
*
DMPNVINS MVC   VIOPTR+1(3,DB2),VIOPTR+1(FRETURN)      LINK NEW BLOCK
*                                 IN FRONT OF HIGHER OR NON-EXISTANT
*                                 BLOCK ON OLD CHAIN
         IC    R1,VIOPTR(,FRETURN)          SAVE UPPER BYTE FOR LINK
         ST    DB2,VIOPTR(,FRETURN)         POINT LAST LOW BLOCK TO NEW
         STC   R1,VIOPTR(,FRETURN)          AND RESTORE UPPER BYTE
*
*        COME HERE TO MOVE OUT ON MAIN HASH CHAIN
*
DMPNVS   L     DB2,VLINK(,DB2)    MOVE OUT ON HASH CHAIN
         NR    DB2,R0             TEST FOR LINK END
         BNZ   DMPNVL             OFF TO CHECK VALUE IF NOT LINK END
*
*        COME HERE TO MOVE TO NEXT HASH SLOT
*
DMPHSSKP LR    DB2,DB3            PRETEND HASH SLOT VLINK FIELD
         LA    DB3,4(,DB3)        PUSH TO NEXT SLOT
         C     DB3,HASHTBEN       CHECK FOR PAST END OF HASH TABLE
         BNH   DMPNVS             OFF TO GET LINK IF NOT END OF TBL
         LA    FRETURN,DMPBASRG   POINT TO BASE REGISTER LOCATION
         DROP  DB4                GET RID OF OLD BASE REGISTER
         USING DMPBASRG,FRETURN   TELL ASSEMBLER OF NEW BASE REGISTER
         L     DB4,=A(DTERTNS)    LOAD TRACE ROUTINES BASE
         USING DTERTNS,DB4        TELL ASSEMBLER
         BAL   A2,LINEINIT        INITIALIZE OUTPUT
         BCTR  DB3,0              BACK UP TO CONTROL CHARACTER
         MVC   0(26,DB3),=C'1DUMP OF NATURAL VARIABLES'         MV MSSG
         LA    DB3,26(,DB3)       BUMP OVER IT
         BAL   A2+1,DMPUND        UNDERLINE IT AND PRINT BLANK LINE
         L     R0,VARCHAIN        POINT TO FIRST NON-NULL VARIABLE BLOK
         BAL   R1,DMPNVPT1        MAKE LOOP ENTRY SETTING (R1)
*
*        COME HERE TO DUMP A NAME AND VALUE
*
DMPNVPT  LM    A1,A1+1,VNAME(DB2) LOAD NAME
         BAL   RETURN,LINESTR     PRINT NAME
         LM    A1,A1+1,VALUE(DB2) LOAD VALUE
         BAL   A2,LINEQVAL        PRINT VALUE AFTER ' = '
         BALR  A2,LINE$           TERMINATE LINE
*
*        BASE REGISTER FRETURN POINTS HERE FOR REST OF ROUTINE
*
DMPBASRG L     R1,VIOPTR(,DB2)    MOVE OUT ON CHAIN
         LA    R0,0(,R1)          GET LINK WITHOUT UPPER BYTE
         SR    R1,R0              LEAVE ONLY UPPER BYTE IN R1
         ST    R1,VIOPTR(,DB2)    STORE BACK ZEROS AND UPPER BYTE
         L     R1,=A(DMPNVPT)     GET LOOP START ADDRESS
*
*        COME HERE TO POINT DB2 TO NEXT BLOCK AND TEST FOR LINK END
*
DMPNVPT1 LTR   DB2,R0             COPY AND TEST LINK FOR END
         BCR   NZ,R1              LOOP BACK IF NOT AT LINK END
         EJECT
*
*        INITIALIZE DUMP OF KEYWORDS
*
         BCTR  DB3,0              POINT TO CONTROL CHARACTER POSITION
         MVC   0(17,DB3),=C'0DUMP OF KEYWORDS'        MOVE IN TITLE
         LA    DB3,17(,DB3)       BUMP PAST IT
         BAL   A2+1,DMPUND        UNDERLINE IT AND PRINT BLANK LINE
         LA    DB2,DMPKYLST-DMPKYTBL        GET OFFSET TO LAST(FIRST)
*                                 KEYWORD TABLE ENTRY
*
*        COME HERE TO PRINT OUT A KEYWORD NAME AND VALUE
*
DMPKWL   LH    A1,DMPKYTBL(DB2)   LOAD CURRENT KEYWORD INITV LOC&LENGTH
         SR    A1+1,A1+1          CLEAR TO PREPARE FOR SHIFT
         SRDL  A1,12              SEPARATE LENGTH/ADDRESS OFFSET
         SRL   A1+1,32-12-16      POSITION OFFSET IN SOFFSET FIELD
         ALR   A1+1,A1            MOVE LENGTH INTO SLENGTH FIELD
         L     A1,INITVPTR        SUPPLY BASE ADDRESS + SCODE
         MVI   0(DB3),C'&&'       PUT AN & IN THE BUFFER
         LA    DB3,1(,DB3)        BUMP OVER IT (NO OVERFLOW POSSIBLE)
         BAL   RETURN,LINESTR     PUT KEYWORD NAME ON THE LINE
*
*        WHEN LINESTR RETURNS A1 POINTS TO NAME CHARACTERS, A1+1=360 LN
*        THERE FORE ADDING THE REAL LENGTH OF NAME TO A1 WILL POINT
*        TO THE FLAG BYTE.  JUST BEYOND FLAG IS THE KEYWORD NUMBER
*
         SR    R1,R1              CLEAR FOR IC
         IC    R1,SCHARS+1+1(A1,A1+1)       PICK UP CHAR PAST FLG & LEN
         L     R2,=A(KGETC)       LOAD KEYWORD BASE ADDRESS
         USING KGETC,R2           TELL ASSEMBLER OF BASE REGISTER
         BAL   RETURN,KGETC2      MERGE AT PROPER POINT
         DROP  R2                 GET RID OF BASE REGISTER
         BAL   A2,LINEQVAL        PUT VALUE ON LINE PAST C' = '
         BALR  A2,LINE$           PRINT THE LINE
         SH    DB2,H2             DECREMENT TBL OFFSET, PT TO NXT ENTRY
         BNM   DMPKWL             LOOP BACK IF NOT FINISHED
         EJECT
*
*        COME HERE TO CHECK FOR CASE 2 DUMP
*
         CLI   DMPARG,2           IS THIS A CASE 2 DUMP?
         BNE   DMPEXIT            OFF TO FIX UP IOBLOKS IF NOT
*
*        COME HERE FOR A CASE 2 DUMP TO DUMP DYNAMIC BLOKS
*
         BALR  A2,LINE$           PRINT A BLANK LINE
         L     A1,DYNAMB          POINT TO START OF DYNAMIC CORE
*
*        LOOP TO FIND USED BLOCKS AND DUMP THEM (USED BLOCKS HAVE MARK)
*
DMPDNL   ST    A1,DMPBSAV         SAVE BLOCK ADDRESS FOR DUMP ROUTINES
         CLI   0(A1),ABLOK        IS THIS AN ARRAY BLOCK?
         BE    DMPAR              OFF TO DUMP IT IF SO
         CLI   0(A1),TBBLOK       IS THIS A TABLE?
         BE    DMPTB              OFF TO DUMP IT IF TABLE
         CLI   0(A1),PDBLOK       IS THIS A PROGRAMER DEFINED DATATYPE?
         BNE   DMPSK              SKIP OVER IT IF NOT
*
*        COME HERE TO DUMP A PROGRAMER DEFINED DATATYPE
*
         L     DB2,PDFPTR(,A1)    LOAD POINTER TO PDFBLOK
         L     R1,PDFNPTR(,DB2)   LOAD POINTER TO DATATYPE NAME
         LM    A1,A1+1,VNAME(R1)  LOAD NAME
         BAL   RETURN,LINESTR     PRINT STRING NAME
         L     A1,DMPBSAV         RESTORE POINTER TO BLOCK
         BAL   A2,LINEPDID        GET PDBLOK ID ON LINE
         BAL   A2+1,DMPUND        UNDERLINE AND PRINT MESSAGE
         LH    A2+1,NFLDSDF(,DB2) LOAD NUMBER OF FIELDS
         SLL   A2+1,3             * 8 IS OFFSET TO FIRST (LAST) FIELD
         A     A2+1,DMPBSAV       POINT TO LAST FIELD
*
*        LOOP TO DUMP FIELD VALUES
*
DMPPDL   L     R1,FLDNPTR(,DB2)   LOAD POINTER TO NAME BLOCK
         LA    DB2,4(,DB2)        BUMP POINTER
         LM    A1,A1+1,VNAME(R1)  LOAD FIELD NAME
         BAL   RETURN,LINESTR     PRINT STRING NAME
         LM    A1,A1+1,PDFLDS-8(A2+1)       LOAD FIELD VALUE
         BAL   A2,LINEQVAL        OUTPUT FIELD VALUE AFTER C' = '
         BALR  A2,LINE$           AND PRINT THE LINE
         SH    A2+1,H8            POINT TO NEXT FIELD
         C     A2+1,DMPBSAV       ARE WE AT BLOCK END?
         BH    DMPPDL             KEEP LOOPING IF NOT
*
*        RETURN HERE FROM BLOCK DUMP ROUTINES
*
DMPRTN   BALR  A2,LINE$           PRINT A BLANK LINE
         L     A1,DMPBSAV         RESTORE BLOCK POINTER
         EJECT
*
*        COME HERE TO BUMP PAST A FREE CORE BLOCK
*
DMPSK    SR    R2,R2              CLEAR FOR IC
         IC    R2,DTYPE(,A1)      GET BLOCK TYPE
         EX    0,BLOKLEN(R2)      GET BLOCK LENGTH IN R2
         AR    A1,R2              BUMP BLOCK POINTER
         CR    A1,FR              ARE WE DONE?
         BL    DMPDNL             LOOP BACK IF NOT
*
*        COME HERE TO RESTORE IOB PTRS AND CLEAR OUT ID NUMBERS
*
DMPEXIT  L     A1,DYNAMB          POINT TO START OF DYNAMIC CORE
         B     DMPCLRL2           OFF TO CHECK FOR EMPTY FREE CORE
*
*        LOOP THROUGH BLOCKS
*
DMPCLRL  CLI   0(A1),IOBLOK       IS THIS AN IOBLOK?
         BNE   DMPCLRL1           OFF TO CLEAR OUT ID IF NOT
         CE    ZR,0(,A1)          WAS THIS BLOCK POINTED TO?
         BE    DMPCLRL1           NO MORE TO DO IF NOT USED
         L     R1,0(,A1)          GET VARIABLE BLOCK ADDRESS
         IC    R0,VIOPTR(,R1)     SAVE LEFT BYTE
         ST    A1,VIOPTR(,R1)     STORE IOBLOK ADDRESS
         STC   R0,VIOPTR(,R1)     RESTORE LEFT BYTE
*
*        COME HERE TO CLEAR A BLOCKS GARBAGE COLLECTOR FIELD
*
DMPCLRL1 SR    R2,R2              CLEAR FOR IC
         IC    R2,DTYPE(,A1)      GET BLOCK TYPE
         STE   ZR,0(,A1)          CLEAR COLLECT FIELD
         STC   R2,DTYPE(,A1)      RESTORE BLOCK CODE
         EX    0,BLOKLEN(R2)      GET BLOCK LENGTH IN R2
         AR    A1,R2              BUMP PAST BLOCK
*
*        COME HERE TO CHECK FOR FREE CORE END
*
DMPCLRL2 CR    A1,FR              ARE WE AT END OF FREE CORE?
         BL    DMPCLRL            BACK TO CLEAR MORE IF NOT
*
*        COME HERE WITH EVERYTHING CLEANED UP
*
         MVI   0(FR),C'1'         THIS IS CHEATING, SET FOR NEW PAGE
         BALR  A2,LINE$           SKIP TO NEW PAGE
         LM    DB2,DB3,$$BAS2     RESTORE DATA BASE REGISTERS
*
*        COME HERE TO EXIT BEFORE DBS USED
*
DUMPOUT  L     FRETURN,FRETLOC    RESTORE FRETURN
         STE   ZR,FRETLOC         AND CLEAR SAVED FRETURN AS REQUIRED
         B     EXITNULL           RETURN NULL AS RESULT
         EJECT
*
*        COME HERE TO DUMP AN ARRAY
*
DMPAR    AL    A1,ACODEBT         MAKE A VALUE POINTER FOR NM & ID, ETC
         BAL   A2+1,DMPNMFN       FIND NAME, PRINT ID INFORMATION
         L     A2+1,DMPBSAV       LOAD ARRAY ADDRESS
         SR    R1,R1              CLEAR FOR IC
         IC    R1,NSUBS(,A2+1)    AND LOAD NUMBER OF SUBSCRIPTS
*
*        DURING THE DUMP WE USE THE SUBFAC FIELDS TO KEEP THE CURRENT
*        SUBSCRIPTS -- THIS LOOP INITIALIZES THEM TO THE LBD VALUES
*
DMPARL   LH    R0,SUBLBD(,A2+1)   LOAD LOW BOUND
         ST    R0,SUBFAC(,A2+1)   STORE AS INITIAL SUBSCRIPT
         LA    A2+1,8(,A2+1)      BUMP TO NEXT SUBSCRIPT SET
         BCT   R1,DMPARL          LOOP BACK IF MORE SUBSCRIPTS TO GO
         ST    A2+1,DMPSV1        SAVE END OF SUBSCRIPT INFO FOR LATER
*
*        THIS LOOP DUMPS THE NON-NULL ARRAY ELEMENTS
*
DMPARL1  L     DB2,DMPBSAV        LOAD THE ARRAY ADDRESS
         CLI   AVALS-8(A2+1),NCODE          IS THE NEXT VALUE NULL?
         BE    DMPARL3            SKIP ITS PRINT IF NULL
         BAL   RETURN,DMNAMPRT    PRINT A NAME IF POSSIBLE
         MVI   0(DB3),C'<'        SET LEFT BRACKET AND MERGE
*
*        LOOP TO PRINT SUBSCRIPT VALUES
*
DMPARL2  LA    DB3,1(,DB3)        BUMP PAST < OR ,
         SR    A1,A1              SET INTEGER TYPE CODE
         L     A1+1,SUBFAC(,DB2)  LOAD SUBSCRIPT
         BAL   A2,LINEVAL         PRINT SUBSCRIPT VALUE
         LA    DB2,8(,DB2)        POINT TO NEXT SUBSCRIPT
         MVI   0(DB3),C','        MOVE IN A COMMA
         C     DB2,DMPSV1         ARE WE THROUGH WITH SUBSCRIPTS?
         BL    DMPARL2            LOOP BACK IF NOT
*
*        COME HERE WITH ALL SUBSCRIPTS PRINTED
*
         MVC   0(4,DB3),DMPRBBEB  OVERWRITE , WITH '> = '
         LA    DB3,4(,DB3)        BUMP PAST IT
         LM    A1,A1+1,AVALS-8(A2+1)        LOAD VALUE OF ELEMENT
         BAL   A2,LINEVAL         PRINT OUT VALUE OF ELEMENT
         BALR  A2,LINE$           PRINT OUT LINE
         EJECT
*
*        COME HERE TO SKIP A VALUE
*
DMPARL3  LA    A2+1,8(,A2+1)      POINT TO NEXT ELEMENT
         L     DB2,DMPBSAV        LOAD ARRAY ADDRESS
*
*        THIS LOOP INCREMENTS THE SUBSCRIPTS BY ONE
*
DMPARL4  L     R1,SUBFAC(,DB2)    LOAD CURRENT SUBSCRIPT VALUE
         AH    R1,H1              INCREMENT BY ONE
         ST    R1,SUBFAC(,DB2)    STORE AS NEW SUBSCRIPT
         SH    R1,SUBLBD(,DB2)    SUBTRACT LOW BOUND
         CH    R1,SUBDIM(,DB2)    CHECK FOR HIGH BOUND EXCEEDED
         BL    DMPARL1            LOOP BACK TO DUMP NEXT ELEMENT IF NOT
         LH    R1,SUBLBD(,DB2)    ELSE LOAD LOW BOUND
         ST    R1,SUBFAC(,DB2)    AND STORE AS NEW SUBSCRIPT VALUE
         LA    DB2,8(,DB2)        BUMP TO NEXT SUBSCRIPT
         C     DB2,DMPSV1         HAVE WE EXCEEDED BOUNDS?
         BL    DMPARL4            IF NOT, BACK TO INCREMENT NEXT SUBSCR
*
*        COME HERE WHEN ALL ELEMENTS HAVE BEEN DUMPED
*
         LA    R0,8               LOAD INITIAL MULTIPLIER OF 8
         L     DB2,DMPBSAV        LOAD ARRAY ADDRESS
*
*        LOOP TO RESTORE FACTORS
*
DMPARL5  ST    R0,SUBFAC(,DB2)    STORE VALUE OF THIS MULTIPLIER
         MH    R0,SUBDIM(,DB2)    MULTIPLY BY THIS DIMENSION
         LA    DB2,8(,DB2)        BUMP TO NEXT BOUNDS
         C     DB2,DMPSV1         HAVE WE DONE ALL BOUNDS
         BL    DMPARL5            LOOP BACK IF MORE TO GO
         B     DMPRTN             ELSE GO BACK FOR NEXT BLOCK
         EJECT
*
*        COME HERE TO DUMP A TABLE
*
DMPTB    AL    A1,TCODEBT         MAKE A TABLE VALUE TO GET HEADING
         BAL   A2+1,DMPNMFN       FIND A NAME IF POSSIBLE, GETID ETC.
         L     A1,DMPBSAV         RESTORE TABLE POINTER
         BAL   RETURN,TBCHRON     GET A CHRONOLOGICAL LIST, KIPIF NULL
         B     DMPRTN             NO MORE TO PRINT IF NO ELEMENTS
         LR    A2+1,A1+1          COPY NON-NULL ELEMENT COUNT
         L     DB2,TBCHRSV        LOAD POINTER TO FIRST ELEMENT
*
*        THIS LOOP DUMPS A TABLE ELEMENT
*
DMPTBL   BAL   RETURN,DMNAMPRT    PRINT A NAME IF POSSIBLE
         MVI   0(DB3),C'<'        MOVE IN LEFT BRACKET
         LA    DB3,1(,DB3)        PUSH OVER IT
         LM    A1,A1+1,TENAME(DB2)          PICK UP ELEMENT NAME
         BAL   A2,LINEVAL         PRINT IT AS A VALUE
         MVC   0(4,DB3),DMPRBBEB  MOVE IN C'> = '
         LA    DB3,4(,DB3)        PUSH OVER IT
         LM    A1,A1+1,TEVALUE(DB2)         PICK UP ELEMENT VALUE
         BAL   A2,LINEVAL         PRINT IT AS VALUE
         BALR  A2,LINE$           PRINT THE LINE
         MVI   0(DB2),TEBLOK      SET TYPE CODE FOR EXIT ROUTINE, ETC.
*                                 GBGFLDS ARE CLEARED AT EXIT
         L     DB2,0(,DB2)        MOVE OUT ON CHAIN
         BCT   A2+1,DMPTBL        LOOP BACK IF NOT OUT OF ELEMENTS
         B     DMPRTN             ALL DONE, RETURN TO GET NEXT BLOCK
*
*        TABLE OF KEYWORDS TO BE DUMPED - MUST BE IN REVERSE ORDER
*
DMPKYTBL KEYOFF TRIM              &TRIM LAST TO BE DUMPED
         KEYOFF TRACE             &TRACE
         KEYOFF STNO              &STNO
         KEYOFF STLIMIT           &STLIMIT
         KEYOFF STCOUNT           &STCOUNT
         KEYOFF RTNTYPE           &RTNTYPE
         KEYOFF OUTPUT            &OUTPUT
         KEYOFF MAXLNGTH          &MAXLNGTH
         KEYOFF INPUT             &INPUT
         KEYOFF FULLSCAN          &FULLSCAN
         KEYOFF FTRACE            &FTRACE
         KEYOFF FNCLEVEL          &FNCLEVEL
         KEYOFF ERRTYPE           &ERRTYPE
         KEYOFF ERRLIMIT          &ERRLIMIT
         KEYOFF DUMP              &DUMP
         KEYOFF CODE              &CODE
         KEYOFF ANCHOR            &ANCHOR
DMPKYLST KEYOFF ABEND             &ABEND IS END OF LIST, FIRST DUMPED
         EJECT
*
*        ROUTINE TO FIND POSSIBLE NAME FOR ARRAY OR TABLE
*        I.E. A NATURAL VARIABLE CONTAINING THE OBJECT AS VALUE
*        MERGES WITH ID PRINT AND UNDERLINE ROUTINES
*
*        (A1)                     POINTER TO OBJECT WITH TYPE CODE
*        BAL   A2+1,DMPNMFN       CALL OF THIS ROUTINE
*        DMNAMSV                  ON EXIT, PTR TO VAR BLOCK OR ZERO
*        USES R0,R1,R2,A1,A1+1,A2,A2+1
*
DMPNMFN  LA    R0,4               GET BXLE INCREMENT
         L     R2,HASHTBAD        LOAD POINTER TO MAIN HASH TABLE
         LA    R1,HASHTBNS*4(,R2) GET BXLE END ADDRESS
         L     A2,=X'00FFFFFF'    GET MASK TO TEST FOR CHAIN END
         B     DMPNMBG            MAKE INITIAL LOOP ENTRY
*
*        COME HERE TO TEST FOR CORRECT VALUE
*
DMPNMLP  C     A1,VALUE(,A1+1)    IS THIS THE CORRECT VALUE?
         BE    DMPNMND            END OF SEARCH IF FND CORRECT PTR
         L     A1+1,VLINK(,A1+1)  MOVE OUT ON LINK
*
*        COME HERE TO CHECK FOR END OF LINK
*
DMPNMCK  NR    A1+1,A2            TEST FOR ZERO ADDRESS FIELD
         BNZ   DMPNMLP            LOOP BACK IF NOT END OF LINK
*
*        COME HERE TO MOVE TO ANOTHER HASH SLOT
*
DMPNMBG  L     A1+1,VLINK(,R2)    PICK UP CONTENTS OF POTENTIAL SLOT
         BXLE  R2,R0,DMPNMCK      OFF TO CHECK FOR END OF LINK
         SR    A1+1,A1+1          INDICATE NO NAME FOUND
*
*        COME HERE TO STORE NAME BLOCK ADDRESS OR ZERO FOR LATER USE
*
DMPNMND  ST    A1+1,DMNAMSV       SAVE BLK PTR OR ZERO
*
*        COME HERE TO PUT DATATYPE, PROTOTYPE, AND ID # ON LINE
*
         BAL   A2,LINEVAL         GET ABOVE INFORMATION ON LINE
*                                 MERGE WITH DMPUND
         EJECT
*
*        ENTRY TO UNDERLINE COMPLETED MESSAGE
*
*        BAL   A2+1,DMPUND        CALL TO THIS ROUTINE
*
DMPUND   ST    DB3,DMPSV1         SAVE CURRENT BUFFER POINTER
         BALR  A2,LINE$           PRINT LINE
         BCTR  DB3,0              BACK UP TO CONTROL CHARACTER
         MVC   0(2,DB3),=C'+_'    SET FOR OVERPRINT + UNDERLINE CHAR
         L     R2,DMPSV1          RESTORE OLD END OF LINE BUFR POINTER
         SR    R2,DB3             GET NUMBER OF CHARACTERS TO UNDERLINE
         SH    R2,H3              ADJUST TO PROPER VALUE
         EX    R2,DMPIDM          PROPAGATE UNDERLINE CHARACTER
         LA    DB3,3(R2,DB3)      PUSH PAST UNDERLINE CHARACTERS
         BALR  A2,LINE$           PRINT LINE OF UNDERLINE CHARACTERS
         BALR  A2,LINE$           PRINT BLANK LINE
         BR    A2+1               RETURN TO CALLER
*
DMPIDM   MVC   2(*-*,DB3),1(DB3)  PROPAGATE UNDERLINE CHARACTER
*
*        ROUTINE TO PRINT ARRAY OR TABLE NAME FOUND BY DMPNMFN
*
*        (DB3)                    BUFFER POINTER (SET FOR LINESTR)
         BAL   RETURN,DMNAMPRT    CALL TO PRINT NAME
*        USES A1,A1+1
*
DMNAMPRT L     A1,DMNAMSV         LOAD POSSIBLE NAME POINTER
         LTR   A1,A1              WAS A NAME FOUND?
         BCR   Z,RETURN           IMMEDIATE RETURN IF NO NAME FOUND
         LM    A1,A1+1,VNAME(A1)  ELSE LOAD NAME TO BE PRINTED
         B     LINESTR            AND EXIT VIA STRING DUMP ROUTINE
         DROP  FRETURN,DB4        GET RID OF BASE REGISTERS
DUMP     ENDFUNC   ,              END OF DUMP FUNCTION
         TITLE 'SPITBOLF -- DUPL FUNCTION'
DUPL     FUNCTION 2               FUNCTION ENTRY POINT
         LM    A1,A1+1,TEM#2(PDR) PICK UP SECOND ARG TO DUPL
         BAL   RETURN,GETINT      MUST BE INTEGER
         XERR  01,063             SECOND ARGUMENT TO DUPL FUNCTION IS
*                                 NOT AN INTEGER
         LTR   A2,A1+1            COPY DUP FACTOR AND TEST
         BM    FAILRL             FAIL IF LENGTH NEGATIVE
         BZ    EXITNULL           RETURN NULL IF ZERO DUP FACTOR
         LM    A1,A1+1,TEM#1(PDR) LOAD STRING ARGUMENT
         BAL   RETURN,GETSTGT     GET A STRING IF POSSIBLE
         XERR  01,064             FIRST ARGUMENT TO DUPL FUNCTION IS
*                                 NOT A STRING
         LA    R1,1(,A1+1)        GET REAL STRING LENGTH
         MR    R0,A2              GET FINAL STRING SIZE
         C     R1,V$MAXLN         RESULT TOO LONG?
         BNH   *+8                SKIP IF OK
         XERR  11,010             STRING FORMED BY CALL TO DUPL
*                                 FUNCTION IS LONGER THAN &MAXLNGTH
         LA    R0,SCHARS+BOUND(,R1)         GET MAX BLOCK SIZE
         N     R0,FULLWRD         PUT ON PROPER BOUNDARY
         STH   R0,STLENGTH(,FR)   STORE AS BLOCK LENGTH
         AR    R0,FR              CALCULATE FINAL CORE POINTER
         CR    R0,PDR             WILL THERE BE ROOM?
         BNL   GBGCLF             COLLECT AND REENTER IF NOT
         STE   ZR,0(,FR)          MAKE FIRST WORD OF SBLOK
         LR    A2+1,FR            COPY NEW STRING ADDR
         LTR   A1+1,A1+1          CHECK FOR NULL STRING
         BP    DUPL1              BRANCH IF MORE THAN 1 CHAR TO DUPL
         BM    EXITNULL           RETURN NULL IF NULL ARG
         IC    R0,SCHARS(,A1)     GET ONLY CHAR IN ARG
         STC   R0,SCHARS(,FR)     STORE IN NEW BLOCK
         LR    A1+1,R1            COPY REAL RESULT LENGTH
         SH    A1+1,H2            GET 360 PROPAGATE LENGTH
         BM    DUPLOUT            ALL DONE IF 1CAR STG 1 TIME
         LA    A2+1,1(,FR)        DUMMY 'TO' LOCATION
         LR    A1,FR              DUMMY FROM ADDRESS
         LA    A2,1               ONLY ONE COPY
*
*        COME HERE IF GT 1 CHAR STG TO DUPL - MERGE IF 1 CHARACTER
*
DUPL1    LA    R0,256             GET SPECIAL CONSTANT
         CR    A1+1,R0            IS IT SMALL OR LARGE?
         BL    DUPLS              SKIP TO SPECIAL ROUTINE IF SHORT
         STM   A1,A1+1,DUPLSAV    SAVE INFO ON STRING TO BE DUPLICATED
         EJECT
*
*        LOOP TO MOVE ONE COPY OF A LONG STRING
*
DUPLB    MVC   SCHARS(256,A2+1),SCHARS(A1)  MOVE 256 BYTE CHUNK
         AR    A1,R0              PUSH FROM POINTER
         AR    A2+1,R0            PUSH TO POINTER
         SR    A1+1,R0            DECREMENT LENGTH REMAINING
         CR    A1+1,R0            IS IT STILL TO BIG FOR ONE MOVE?
         BNL   DUPLB              B IF TOO BIG
         EX    A1+1,DUPLMV        MOVE IN LAST PIECE
         LA    A2+1,1(A2+1,A1+1)  POINT PAST LAST CHARACTER
         LM    A1,A1+1,DUPLSAV    RELOAD STRING POINTER AND SIZE
         BCT   A2,DUPLB           AND MOVE IF MORE DUPS TO FINISH
         B     DUPLOUT            AND MERGE WITH SHORT STRING ROUTINE
*
*        COME HERE IF STRING LE 256 BYTES LONG
*
DUPLS    EX    A1+1,DUPLMV        MOVE IN ONE COPY
         LA    A2+1,1(A2+1,A1+1)  POINT PAST LAST CHARACTER
         BCT   A2,DUPLS           LOOP UNTIL ALL COPIES MADE
*
*        LONG STRING DUPL MERGES HERE
*
DUPLOUT  LR    A1+1,R1            GET REAL LENGTH OF RESULT
         BCTR  A1+1,0             GET 360 LENGTH
         LR    A1,FR              COPY RESULT ADDRESS
         AL    A1,SCODEBT         AND ADD IN TYPE CODE
         AH    FR,STLENGTH(,FR)   PUSH CORE POINTER
         B     EXIT               RETURN TO CALLER
*
DUPLMV   MVC   SCHARS(*-*,A2+1),SCHARS(A1)  MOVE IN SMALL STG
DUPL     ENDFUNC ,                END OF DUPL FUNCTION
         TITLE 'SPITBOLF -- ENDFILE FUNCTION'
ENDFILE  FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         BAL   RETURN,GETSTGS     CONVERT TO STRING
         XERR  01,065             ARGUMENT TO ENDFILE IS NOT A STRING
         LA    A1,SCHARS(,A1)     POINT TO ACTUAL FILENAME
         AH    A1+1,H1            GET REAL LENGTH
         BP    *+8                SKIP IF NAME IS NON-NULL
         XERR  13,042             ARGUMENT TO ENDFILE IS NULL
         L     R2,=V(SYSDCB)      POINT TO DCB LOCATE ROUTINE
         BALR  R1,R2              LOCATE DCB
         B     SYSERROR           SIGNAL ERROR IF ONE OCCURS
         L     R2,=V(SYSCLOSE)    ELSE POINT TO CLOSE ROUTINE
         BALR  R1,R2              CLOSE FILE
         B     SYSERROR           GIVE ERROR IF ONE OCCURS
         B     EXITNULL           ELSE RETURN NULL AS RESULT
ENDFILE  ENDFUNC                  END OF ENDFILE FUNCTION
         TITLE 'SPITBOLF -- EVAL FUNCTION'
EVAL     FUNCTION  1              NEED ONE ARGUMENT
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         LCR   R0,A1              TEST TYPE
         BNM   EXIT               IMMEDIATE RETURN OF ARG IF NUMERIC
         CLI   TEM#1(PDR),NCODE   IS IT NULL?
         BE    EXIT               SUCCEED RETURNING NULL IF NULL ARG
         CLI   TEM#1(PDR),VCODE   IS IT SIMPLE VARIABLE?
         BE    EVAL2              JUMP TO TREAT AS READ CALL IF SO
         CLI   TEM#1(PDR),ECODE   IS IT AN EXPRESSION?
         BE    EVAL1              SKIP IF ALREADY AN EXPRESSION
         BAL   RETURN,GETSTG      ELSE CONVERT ARGUMENT TO STRING
         B     FAILRL             FAIL IF EVAL ARG NOT AN EXPRESSION
         L     R1,CODXEQAD        GET ADDRESS OF COMPILER
         MVI   CODXSW,ECODE       SET TYPE CODE
         BALR  RETURN,R1          CALL COMPILER
         B     FAILRL             FAIL IF EVAL ARG NOT AN EXPRESSION
         L     RETURN,RETLOC      RELOAD RETURN POINT IF COMPILED OK
*
*        MERGE HERE WITH EXPRESSION POINTER IN A1
*
EVAL1    SH    PDR,=Y(STACKSIZ)   PUSH DOWN STACK
         STM   FRETURN,RETURN,FRETFLOC(PDR) SAVE RETURN REGISTERS
         LR    RETURN,A1          SET CODE ARGUMENT FOR $EVAL2
         CR    DB1,DB2            SET CONDITION CODE NE (EVAL CASE)
         BAL   R1,$EVAL2          SPECIAL ENTRY IN DEF EXP ROUTINE
         SR    R1,R1              SET IN CASE OF FAILURE
         NOPR  R1                 DO NOTHING
         LM    FRETURN,RETURN,FRETFLOC(PDR) RESTORE RETURN REGISTERS
         L     PDR,PDRLOC         POP STACK POINTER AND RESET TO BASE
         LTR   R1,R1              DID WE FAIL?
         BCR   NZ,RETURN          SUCCEED IF NOT
         BR    FRETURN            ELSE FAIL
*
*        COME HERE TO TREAT EVAL(*VARIABLE) AS READ CALL
*
EVAL2    L     PDR,PDRLOC         RESET STACK POINTER
         B     $$READ             AND JOIN READ ROUTINE
EVAL     ENDFUNC ,                END OF EVAL FUNCTION
         TITLE 'SPITBOLF -- FIELD FUNCTION'
FIELD    FUNCTION  2              ENTRY POINT -- TWO ARGUMENTS
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK
         XERR  01,067             FIRST ARGUMENT TO FIELD IS NOT A NAME
         LR    A2,A1              IF OK, SAVE POINTER TO VARIABLE BLOCK
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         XERR  01,068             SECOND ARG TO FIELD IS NOT AN INTEGER
         L     A2+1,VFUNC(,A2)    LOAD FUNCTION POINTER
         CLC   FCODE(2,A2+1),PDFBLOKI       IS FUNC FOR PROG DATATYPE?
         BNE   FAILRL             FAIL IF NOT
         CH    A1+1,NFLDSDF(,A2+1)          CHECK FOR NUMBER TOO LARGE
         BH    FAILRL             FAIL IF SO
         SLA   A1+1,2             ELSE MULTIPLY BY FOUR TO INDEX
         BNP   FAILRL             FAIL IF ZERO OR NEGATIVE
         L     A1,FLDNPTR-4(A1+1,A2+1)      LOAD NAME POINTER
         LM    A1,A1+1,VNAME(A1)            LOAD NAME
         B     EXIT               RETURN TO CALLER
*
*        INSTRUCTION TO CHECK FOR PDFBLOK
*
PDFBLOKI CH    R0,*-*(DB4)        FIRST INSTRUC ON ANY PDFBLOK
         ORG   *-2                LAST TWO BYTES NOT USED
*
FIELD    ENDFUNC   ,              END OF FIELD FUNCTION
         TITLE 'SPITBOLF -- INPUT FUNCTION'
INPUT    FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     LOCATE NAME BLOCK
         XERR  01,069             FIRST ARG TO INPUT IS NOT THE NAME
*                                 OF A NATURAL VARIABLE
         NI    VFLAGS(A1),X'FF'-VINA        RESET IN CASE ERROR
         TM    VFLAGS(A1),VINP    HAVE THE BALRS ALREADY BEEN SET?
         BO    INPUT2             SKIP IF YES
         L     DB4,AIOASSOC       GET ADDR OF ROUTINE TO INSERT THEM
         LA    DB3,INFLAG         SET FLAG FOR INPUT CALL
         BALR  RETURN,DB4         AND CALL IT
*
*        COME HERE WHEN INTERCEPTS HAVE BEEN SET FOR THIS VARIABLE
*
INPUT2   BALR  DB4,0              SET UP BASE REGISTER
         USING *,DB4              TELL ASSEMBLER
         CE    ZR,VIOPTR(,A1)     DO WE ALREADY HAVE AN IOBLOK?
         BNE   INPUT3             SKIP IF YES
         LA    R1,IOBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP
         CR    R1,PDR             DO WE NEED A COLLECT?
         BNL   GBGCLF             EXIT IF COLLECT NEEDED
         IC    R0,VIOPTR(,A1)     SAVE POSSIBLE FLAG BYTE
         ST    FR,VIOPTR(,A1)     AND SAVE ADDR OF NEW BLOCK
         STC   R0,VIOPTR(,A1)     RESTORE FLAG BYTE
         XC    0(IOBSIZE,FR),0(FR)          CLEAR OUT AREA FOR IOBLOCK
         MVI   0(FR),IOBLOK       SET DTYPE
         LR    FR,R1              UPDATE FREE CORE ADDRESS
         EJECT
*
*        COME HERE WITH IO BLOCK SET UP
*
INPUT3   L     A2,VIOPTR(,A1)     GET POINTER TO IOBLOK
         LR    A2+1,A1            SAVE VARIABLE BLOCK ADDRESS
         LM    A1,A1+1,TEM#2(PDR) GET SECOND ARG TO INPUT
         BAL   RETURN,GETSTGS     AND GET A STRING FOR THE FILE NAME
         XERR  01,070             FILE NAME (SECOND ARGUMENT) FOR
*                                 INPUT CALL IS NOT A STRING
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER IN NAME
         AH    A1+1,H1            GET REAL LENGTH AND TEST FOR NULL
         L     R0,READDCB         POINT TO STANDARD INPUT FILE IN CASE
         BZ    INPUT4             SKIP IF NULL TO USE STANDARD INPUT
*
*        HERE WE CALL SYSDCB TO GET THE PTR FOR A NON-NULL FILENAME
*
         L     R2,VOPEN           GET ADDR OF OPEN ROUTINE
         BALR  R1,R2              CALL IT
         B     SYSERROR           ERROR RETURN IF COME HERE
*
*        MERGE HERE WITH DCB POINTER IN (R0)
*
INPUT4   ST    R0,IFILE(,A2)      SAVE POINTER TO FILE
         LM    A1,A1+1,TEM#3(PDR) GET FORMAT ARGUMENT
         BAL   RETURN,GETINT      CONVERT IT TO AN INTEGER
         XERR  01,071             FORMAT SPECIFICATION (THIRD ARGUMENT)
*                                 FOR INPUT FUNCTION IS NOT AN INTEGER
         STM   A1,A1+1,IFORMAT(A2)          SAVE THE FORMAT
         OI    VFLAGS(A2+1),VINA+VINP       SET INPUT ACTIVE FLAGS
         B     EXITNULL           RETURN NULL AS RESULT
*
INPUT    ENDFUNC   ,              END OF INPUT FUNCTION
         TITLE 'SPITBOLF -- ITEM FUNCTION'
*
*        NOTE -- THIS FUNCTION IS REALLY REDUNDANT IN SPITBOL SINCE
*
*        ITEM(EXPR,A,B,C...
*
*        CAN ALWAYS BE REPLACED WITH --
*
*        EXPR<A,B,C...
*
*        FOR EXAMPLE --           A<B><C>
*
*        ITEM IS INCLUDED SOLELY FOR COMPATABILITY
*
ITEM     FUNCTION  2,N            ENTRY POINT -- AT LEAST TWO ARGS
         MVI   NAMEFL,X'FF'       TENTATIVELY SET FOR CALL BY VALUE
         CLC   0(4,RETURN),BFRVN  CHECK FOR B $$FRVN (CALL BY NAME)
         BNE   ITEM1              SKIP IF BY VALUE
         LA    RETURN,4(,RETURN)  ELSE BUMP RETURN PAST BRANCH
         MVI   NAMEFL,0           AND SET FLAG FOR BY NAME
*
*        NAME, VALUE CASES MERGE HERE
*
ITEM1    CH    R0,H2              CHECK NUMBER OF ARGUMENTS
         BH    ITEMM              SKIP ON MULTI-DIMENSIONAL CASE
*
*        HERE FOR ONE DIMENSIONAL CASE
*
         LM    A1,A2+1,TEM#2(PDR) LOAD ARRAY AND SUBSCRIPT VALUES
         L     PDR,PDRLOC         RESTORE PDR (NOT DONE IN 1-D ROUTINE)
         L     R2,SUBSC1AD        LOAD ADDRESS OF 1-D ARRAY ROUTINE
         BR    R2                 AND JUMP TO IT
*
*        HERE FOR MULTI-DIMENSIONAL CASE
*
ITEMM    LM    A1,A1+1,TEM#1(PDR) LOAD ARRAY VALUE
         SH    PDR,H8             POINT TO SUBSCRIPTS (PUSH STACK)
         L     A2,SUBSCMAD        LOAD MULTI-DIM ARRAY ROUTINE ADDRESS
         BCTR  R0,A2              GET COUNT OF SUBS, JUMP TO ROUTINE
*
ITEM     ENDFUNC   ,              END OF ITEM FUNCTION
         TITLE 'SPITBOLF -- LOAD FUNCTION'
LOAD     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED
         BAL   A2+1,XSCANI        INITIALIZE SCAN, SET SCAN BASE REG
         XERR  01,072             ARGUMENT TO LOAD IS NOT A STRING
         XERR  13,043             ARGUMENT TO LOAD IS NULL
         MVC   0(12,FR),LFBKMOD   MOVE EFBLOK MODEL TO FREE CORE
         MVI   ZTBL+C'(',1        SET FOR STOP ON LEFT PARENTHESIS
         BALR  RETURN,A2          SCAN OUT LOAD FUNCTION NAME
         XERR  13,044             FUNCTION NAME IN ARGUMENT TO LOAD
*                                 IS NULL
         XERR  13,045             MISSING ( IN ARGUMENT TO LOAD
         MVI   ZTBL+C'(',0        NO LONGER STOP ON LEFT PAREN
         ST    A1,EFNAME(,FR)     SAVE VBLOK ADDRESS IN EFBLOK
         MVI   ZTBL+C',',LDARG-F$LOAD       STOP ON COMMA, PROPER BR
         MVI   ZTBL+C')',LDARGEND-F$LOAD    STOP ON RP, PROPER BRANCH
         OI    XSCANFLG,XSIGNGN   STOP GETNAME CALLS
         LR    DB3,FR             INITIALIZE TO START OF CONVERT CHARS
*
*        THIS LOCATION IS ENTERED TO SCAN OUT AN ARGUMENT TYPE
*
LDARG    BALR  RETURN,A2          SCAN OUT NEXT ENTRY
         B     LDNOCVT            IF NULL ENTRY, NO CONVERT
         XERR  13,046             MISSING ) IN ARGUMENT TO LOAD
*
*        COME HERE WITH STRING SPECIFIER FOR ARGUMENT TYPE
*
         BAL   RETURN,GETSTGS     CONVERT TO ACTUAL NAME/ 360 LENGTH
         NOP   0                  IMPOSSIBLE RETURN
         LA    RETURN,4           SET TO NUMBER OF TABLE ENTRIES
         LA    DB2,LOADSTBL       POINT TO START OF TABLE
*
*        LOOP THROUGH POSSIBLE ENTRIES
*
LOADARGL CH    A1+1,0(,DB2)       DOES LENGTH MATCH?
         BNE   LOADARGE           SKIP IF NOT
         EX    A1+1,LOADARGC      CHECK FOR MATCH OF CHARS IF SO
         BE    LOADARGF           JUMP IF ENTRY FOUND
*
*        HERE TO MOVE TO NEXT TABLE ENTRY
*
LOADARGE LA    DB2,12(,DB2)       BUMP TO NEXT ENTRY
         BCT   RETURN,LOADARGL    LOOP BACK IF MORE ENTRIES TO CHECK
*
*        HERE IF NO CONVERSION REQUIRED
*
LDNOCVT  LA    DB2,LDNOCVTA-2     POINT TO TABLE ENTRY FOR NO CONVERT
*
*        MERGE HERE WITH (DB2) POINTING TO APPROPRIATE TABLE ENTRY
*
LOADARGF TM    XSCANFLG,XSIGNRO   ARE WE SCANNING RESULT OR ARG?
         BO    LOADARGR           JUMP IF SCANNING RESULT
         EJECT
*
*        COME HERE IF WE JUST SCANNED AN ARGUMENT
*
         MVC   EFTARGS(1,DB3),2(DB2)        SET ARG CONVERT BYTE
         LA    DB3,1(,DB3)        INCREMENT ARGUMENT BYTE POINTER
         B     F$LOAD(A2+1)       JUMP (LDARG IF , LDARGEND IF )  )
*
*        HERE AFTER ENCOUNTERING ) ENDING LAST ARGUMENT TYPE
*
LDARGEND OI    XSCANFLG,XSIGNRO   SET TO ALLOW RUNOUT FOR RESULT TYPE
         MVI   ZTBL+C')',0        CLEAR SCAN TABLE ENTRIES
         MVI   ZTBL+C',',0        . . . .
         B     LDARG              LOOP BACK TO SCAN RESULT TYPE
*
*        HERE AFTER SCANNING OUT RESULT TYPE
*
LOADARGR MVC   EFTRSL(1,FR),3(DB2)          SET RESULT CONVERT BYTE
         SR    DB3,FR             GET NUMBER OF ARGUMENTS
         STH   DB3,EFNARGS(,FR)   STORE NUMBER OF ARGUMENTS
         CH    DB3,=H'64'         TOO MANY ARGUMENTS?
         BNH   *+8                SKIP IF OK (64 OR FEWER ARGS)
         XERR  13,047             TOO MANY ARGUMENTS (MORE THAN 64)
*                                 IN FUNCTION TO BE LOADED
         LA    DB3,EFTARGS+BOUND(,DB3)      GET BLOCK LENGTH FUDGED UP
         N     DB3,FULLWRD        ADJUST TO FULLWORD
         STH   DB3,EFLENG(,FR)    STORE LENGTH OF EFBLOK
         AR    DB3,FR             FIND HWERE FR WILL END UP
         CR    DB3,PDR            WILL THERE BE ROOM?
         BNL   GBGCLF             GARBAGE COLLECT IF NOT
         L     A1,EFNAME(,FR)     LOAD POINTER TO VAR BLOCK FOR FUNC
         L     A1+1,=A($$NOFN-FCODE)        POINT TO UNDEFINED FUNC
         BAL   RETURN,OPSYN$      UNDEFINE FUNC (POSSIBLE UNLOAD)
         LR    A2,A1              AND COPY VAR BLOCK ADDRESS
         L     A1,VNAME(,A2)      LOAD NAME POINTER
         AH    A1,VNAME+SOFFSET(,A2)        ADD OFFSET
         LA    A1,SCHARS(,A1)     ADJUST FOR STANDARD OFFSET
         LH    A1+1,VNAME+SLENGTH(,A2)      LOAD 360 LENGTH OF NAME
         LA    A1+1,1(,A1+1)      ADJUST TO PROPER LENGTH
         L     R2,=V(SYSLOAD)     POINT TO SYSTEM LOAD ROUTINE
         BALR  R1,R2              CALL SYSTEM LOAD ROUTINE
         B     SYSERROR           SIGNAL ERROR IF WE GET ONE
         ST    R0,EFCODE(,FR)     IF LOAD OK, STORE CODE ADDRESS
         MVI   EFUSE(FR),0        SET USE COUNT = 0 (OPSYN SETS TO 1)
         LR    A1,A2              COPY VARIABLE BLOCK ADDRESS
         LR    A1+1,FR            COPY FUNCTION BLOCK ADDRESS
         BAL   RETURN,OPSYN$      CALL SYSTEM OPSYN ROUTINE
         LR    FR,DB3             SET NEW FREE REG PAST EFBLOK
         LM    DB2,DB3,$$BAS2     RELOAD STANDARD DATA BASE REGS
         B     EXITNULL           LOAD NULL AS RETURNED RESULT
*
LOADARGC CLC   SCHARS(*-*,A1),4(DB2)        CHECK FOR MATCH ON NAME
         EJECT
*
*        MODEL BLOCK FOR CONSTRUCTION OF EFBLOK
*
LFBKMOD  DC    AL1(EFBLOK)        TYPE CODE
         DC    AL3(0)             GARBAGE COLLECTOR FIELD
         DC    Y(0,0)             EFNARGS, EFLENG
         B     $$LOAD             INITIAL INSTRUCTION
*
*        TABLE TO SCAN DATATYPE NAMES
*
*        THE FORMAT IS AS FOLLOWS --
*
*        BYTES 1,2                360 LENGTH OF NAME
*        BYTE 3                   CONVERT BYTE FOR ARGUMENT
*        BYTE 4                   CONVERT BYTE FOR RESULT
*        BYTES 5-12               CHARACTERS OF NAME (LEFT JUSTIFIED)
*
LOADSTBL DC    Y(4-1)             360 LENGTH OF 'REAL'
         DC    AL1(LOADRL-LOADCL,LOADRRL-LOADRTNS)
         DC    CL8'REAL'
*
         DC    Y(5-1)             360 LENGTH OF 'DREAL'
         DC    AL1(LOADDR-LOADCL,LOADRDR-LOADRTNS)
         DC    CL8'DREAL'
*
         DC    Y(7-1)             360 LENGTH OF 'INTEGER'
         DC    AL1(LOADIN-LOADCL,LOADRIN-LOADRTNS)
         DC    CL8'INTEGER'
*
         DC    Y(6-1)             360 LENGTH OF 'STRING'
         DC    AL1(LOADST-LOADCL,LOADRST-LOADRTNS)
         DC    CL8'STRING'
*
*        TABLE ENTRY FOR NO CONVERT (ONLY NEED TYPE BYTES)
*
LDNOCVTA DC    AL1(LOADCNC-LOADCL,LOADRNC-LOADRTNS)
*
LOAD     ENDFUNC ,                END OF LOAD FUNCTION
         TITLE 'SPITBOLF -- LOCAL FUNCTION'
LOCAL    FUNCTION  2              ENTRY POINT -- TWO ARGS REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK
         XERR  01,073             FIRST ARGUMENT TO LOC IS NOT A NAME
         LR    A2,A1              IF OK, SAVE VARIABLE BLOCK POINTER
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         XERR  01,074             SECOND ARGUMENT TO LOC NOT AN INTEGER
         L     A2+1,VFUNC(,A2)    LOAD FUNCTION POINTER
         CLC   FCODE(4,A2+1),FBLOKI         IS FUNC PROGRAM DEFINED?
         BNE   FAILRL             FAIL IF NOT
         CH    A1+1,FNLOCS(,A2+1)           IS COUNT TOO LARGE?
         BH    FAILRL             FAIL IF SO
         SLA   A1+1,2             MULTIPLY COUNT BY FOUR
         BNP   FAILRL             FAIL IF ZERO OR NEGATIVE
         LH    R0,FNARGS(,A2+1)   PICK UP NUMBER OF ARGS
         AR    R0,R0              *2
         AR    R0,R0              *4
         AR    A1+1,R0            ADD IN OFFSET FOR ARGS
         L     A1,FARGS-4(A2+1,A1+1)        LOAD LOCAL POINTER
         LM    A1,A1+1,VNAME(A1)  LOAD ITS NAME
         B     EXIT               RETURN TO CALLER
LOCAL    ENDFUNC   ,              END OF LOCAL FUNCTION
         TITLE 'SPITBOLF -- LPAD FUNCTION'
LPAD     FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED
         LM    A1,A1+1,TEM#3(PDR)           LOAD THIRD ARGUMENT
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFIER
         XERR  01,075             THIRD ARG TO LPAD NOT A STRING
         MVI   PADCHAR,C' '       PROVISIONALLY SET BLANK AS PAD CHAR
         LTR   A1+1,A1+1          TEST FOR NO THIRD ARG (NULL)
         BM    *+10               SKIP IF NULL (BLANK IS DEFAULT)
         MVC   PADCHAR(1),SCHARS(A1)        ELSE ACQUIRE PAD CHARACTER
         LM    A1,A1+1,TEM#2(PDR)           NOW GET SECOND ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         XERR  01,076             SECOND ARG TO LPAD IS NOT AN INTEGER
         C     A1+1,V$MAXLN       IS STRING TOO LONG?
         BNH   *+8                SKIP IF OK
         XERR  11,011             LPAD CALL RESULTS IN A STRING LONGER
*                                 THAN &MAXLNGTH CHARACTERS
         LR    A2,A1+1            SAVE INTEGER LENGTH IN A2
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETSTGS     GET A TEMPORARY STRING
         XERR  01,077             FIRST ARGUMENT TO LPAD NOT A STRING
*
*        CHECK FOR SPECIAL CASE OF NULL PADDED TO LENGTH ZERO
*
         LTR   A1+1,A1+1          IS STRING NULL?
         BNM   LPAD1              SKIP IF NOT
         LTR   A2,A2              IF STRING IS NULL, IS PAD LENGTH 0?
         BZ    LPAD1A             JUMP TO RETURN NULL ARG IF SO
         LA    A1,PADCHAR-SCHARS  ELSE SET TO USE PAD CHAR AS ARG
         SR    A1+1,A1+1          SET LENGTH AS ONE CHAR
*
*        COME HERE TO PERFORM ACTUAL PAD OPERATION
*
LPAD1    STE   ZR,0(,FR)          PREPARE DTYPE=SCODE=0, GCOLPTR=0
         LA    R1,SCHARS+BOUND(,A2)         CALCULATE SBLOK LENGTH
         N     R1,FULLWRD         ADJUST TO FULL WORD BOUNDARY
         STH   R1,STLENGTH(,FR)   STORE AS SBLOK LENGTH
         AR    R1,FR              SEE WHERE FR WILL END UP
         CR    R1,PDR             WILL WE HAVE ENOUGH ROOM
         BNL   GBGCLF             GARBAGE COLLECT & TRY AGAIN IF NOT
         BCTR  A2,0               ADJUST TOTAL COUNT FOR 360
         LR    R2,A2              SAVE LENGTH OF NEW STRING
         LR    A2+1,FR            SAVE START OF NEW SBLOK
         LA    R0,256             GET LOOP CRANK CONSTANT
         SR    A2,A1+1            GET REAL NUMBER OF PAD CHARACTERS
         BNM   LPADPL             SKIP IF PADDING TO BE DONE
*
*        MERGE HERE TO RETURN FIRST ARG AS RESULT
*
LPAD1A   LM    A1,A1+1,TEM#1(PDR) RELOAD FIRST ARG
         B     EXIT               RETURN TO CALLER
         EJECT
*
*        LOOP TO PAD 256 CHARS AT A TIME
*
LPADPL   MVC   SCHARS(1,FR),PADCHAR         MOVE IN FIRST PAD CHAR
         CR    A2,R0              HOW MANY TO GO?
         BL    LPADPE             SKIP IF 256 OR LESS
         MVC   SCHARS+1(256,FR),SCHARS(FR)  PROPOGATE 256 CHARS
         SR    A2,R0              CRANK COUNT DOWN
         BXLE  FR,R0,LPADPL       BUMP PTR & LOOP (FR < R1)
*
*        COME HERE TO PROPOGATE LAST CHUNK
*
LPADPE   EX    A2,LPADPP          PROPOGATE REMAINING CHARS
         AR    FR,A2              BUMP DESTINATION POINTER
*
*        HERE TO COPY 256 CHAR CHUNKS OF STRING INTO NEW SBLOK
*
LPADSL   CR    A1+1,R0            HOW MANY CHARS LEFT?
         BL    LPADSE             SKIP IF 256 OR LESS
         MVC   SCHARS(256,FR),SCHARS(A1)    ELSE MOVE 256 CHARS
         AR    A1,R0              BUMP SOURCE POINTER
         SR    A1+1,R0            DECREASE COUNT
         BXLE  FR,R0,LPADSL       CRANK DESTIN PTR & LOOP (FR<R1)
*
*        COME HERE TO COPY LAST CHUNK (256 CHARS OR LESS)
*
LPADSE   EX    A1+1,LPADSMV       MOVE LAST CHARACTERS
*
*        EXIT POINT
*
LPADX    LR    FR,R1              SET NEW FREE POINTER
         LR    A1,A2+1            RECALL START OF SBLOK
         AL    A1,SCODEBT         SUPPLY STRING TYPE BYTE
         LR    A1+1,R2            RECALL SLENGTH
         B     EXIT               RETURN TO CALLER
*
LPADPP   MVC   SCHARS+1(*-*,FR),SCHARS(FR)  PROP LAST CHARS + 2 EXTRA
LPADSMV  MVC   SCHARS(*-*,FR),SCHARS(A1)    MOVE LAST CHARS IN COPY
LPAD     ENDFUNC                  END OF LPAD FUNCTION
         TITLE 'SPITBOLF -- OPSYN FUNCTION'
OPSYN    FUNCTION  3              ENTRY POINT -- THREE ARGS
         LM    A1,A1+1,TEM#2(PDR) LOAD OPSYN SECOND ARGUMENT
         BAL   RETURN,GETNAME     CONVERT TO A NAME
         XERR  01,079             SECOND ARGUMENT TO OPSYN IS NOT A
*                                 LEGAL FUNCTION NAME
         LR    A2,A1              SAVE FUNCTION ADDRESS
         LM    A1,A1+1,TEM#3(PDR) LOAD THIRD ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         B     OPSYNF             JUMP FOR NORMAL OPSYN IF NOT INTEGER
         CH    A1+1,H1            ELSE TEST FOR UNARY OPERATOR OPSYN
         BE    OPSYNU             SKIP IF SO
         CH    A1+1,H2            ELSE TEST FOR BINARY OPERATOR OPSYN
         BNE   OPSYNF             NORMAL FUNCTION OPSYN IF NOT
*
*        HERE FOR BINARY OPERATOR OPSYN
*
         BAL   A2+1,OPSYNO        JUMP TO MERGE POINT, SETTING TBL ADDR
*
*        CONTROL TABLE FOR REDEFINABLE BINARY OPERATORS
*
         DC    AL1(C'',$$NOT2-OPTRTABL)    BINARY 
         DC    AL1(C'?',$$QUS2-OPTRTABL)    BINARY ?
         DC    AL1(C'%',$$PCT2-OPTRTABL)    BINARY %
         DC    AL1(C'#',$$PND2-OPTRTABL)    BINARY #
         DC    AL1(C'@',$$ATS2-OPTRTABL)    BINARY @
         DC    AL1(C'&&',$$AMP2-OPTRTABL)   BINARY &
         DC    X'0000'            END OF TABLE MARKER
*
*        HERE FOR UNARY OPERATOR OPSYN
*
OPSYNU   BAL   A2+1,OPSYNO        JUMP TO MERGE POINT, SETTING TBL ADDR
*
*        CONTROL TABLE FOR REDEFINABLE UNARY OPERATORS
*
         DC    AL1(C'!',$$EXC1-OPTRTABL)    UNARY EXCLAMATION
         DC    AL1(C'%',$$PCT1-OPTRTABL)    UNARY %
         DC    AL1(C'/',$$SLS1-OPTRTABL)    UNARY /
         DC    AL1(C'#',$$PND1-OPTRTABL)    UNARY #
         DC    AL1(C'|',$$BAR1-OPTRTABL)    UNARY |
         DC    X'0000'            END OF TABLE MARKER
*
*        MERGE POINT TO UNARY AND BINARY OPERATOR OPSYN
*
OPSYNO   LM    A1,A1+1,TEM#1(PDR) LOAD FIRST ARGUMENT
         BAL   RETURN,GETSTGS     CONVERT TO (TEMPORARY) STRING
         B     OPSYNF             NORMAL CIRCUIT IF NOT A STRING
         LTR   A1+1,A1+1          TEST 360 LENGTH
         BNZ   OPSYNF             NORMAL CIRCUIT IF NOT ONE CHARACTER
         EJECT
*
*        LOOP TO SEARCH FOR ENTRY IN OPERATOR CONTROL TABLE
*
OPSYNL   CLC   0(1,A2+1),SCHARS(A1)         IS THIS A MATCH?
         BE    OPSYNM             SKIP IF SO
         LA    A2+1,2(,A2+1)      ELSE BUMP TABLE POINTER
         CLI   0(A2+1),0          CHECK FOR END OF TABLE
         BNE   OPSYNL             LOOP BACK IF MORE ENTRIES TO CHECK
         B     OPSYNF             ELSE NOT FOUND, DO NORMAL FUNC OPSYN
*
*        HERE WHEN WE FIND THE TABLE ENTRY
*
OPSYNM   SR    A1,A1              PREPARE FOR IC
         IC    A1,1(,A2+1)        LOAD ENTRY OFFSET IN OPTRTABL
         LA    A1,OPTRTABL-VFUNC(A1)        MAKE A DUMMY VBLOK POINTER
         B     OPSYNS             JUMP TO PERFORM OPSYN
*
*        HERE FOR NORMAL FUNCTION OPSYN
*
OPSYNF   LM    A1,A1+1,TEM#1(PDR) LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     CONVERT TO NAME
         XERR  01,078             FIRST ARGUMENT TO OPSYN IS NOT A
*                                 LEGAL FUNCTION NAME
*
*        MERGE HERE TO PERFORM ACTUAL OPSYN
*
OPSYNS   L     A1+1,VFUNC(,A2)    LOAD FUNCTION POINTER TO BE COPIED
         BAL   RETURN,OPSYN$      PERFORM OPSYN
         B     EXITNULL           RETURN NULL AS RESULT
OPSYN    ENDFUNC   ,              END OF OPSYN FUNCTION
         TITLE 'SPITBOLF -- OUTPUT FUNCTION'
OUTPUT   FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK
         XERR  01,080             FIRST ARG TO OUTPUT IS NOT A NAME
         NI    VFLAGS(A1),X'FF'-VOUA        TURN OFF ACTIVE IN CASE ERR
         TM    VFLAGS(A1),VOUP    HAVE THE INTERCEPTS BEEN POSTED?
         BO    OUTPUT2            SKIP IF YES
         L     DB4,AIOASSOC       GET ADDR OF ROUTINE TO INSERT THEM
         LA    DB3,OUTFLAG        SET FLAG FOR OUTPUT CALL
         BALR  RETURN,DB4         AND CALL ROUTINE TO SET THEM
*
*        COME HERE WHEN INTERCEPTS HAVE BEEN SET FOR THIS VARIABLE
*
OUTPUT2  BALR  DB4,0              SET UP BASE REGISTER
         USING *,DB4              TELL ASSEMBLER
         CE    ZR,VIOPTR(,A1)     DO WE ALREADY HAVE AN IOBLOK?
         BNE   OUTPUT3            SKIP IF YES
         LA    R1,IOBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP
         CR    R1,PDR             DO WE NEED A COLLECT?
         BNL   GBGCLF             EXIT IF COLLECT NEEDED
         IC    R0,VIOPTR(,A1)     SAVE POSSIBLE FLAG BYTE
         ST    FR,VIOPTR(,A1)     STORE ADDRESS OF NEW IOBLOK
         STC   R0,VIOPTR(,A1)     RESTORE FLAG BYTE
         XC    0(IOBSIZE,FR),0(FR)          CLEAR OUT AREA FOR IOBLOK
         MVI   0(FR),IOBLOK       SET DATA BLOCK TYPE CODE FOR IOBLOK
         LR    FR,R1              UPDATE FREE CORE ADDRESS
         EJECT
*
*        COME HERE WITH IOBLOK SET UP
*
OUTPUT3  L     A2,VIOPTR(,A1)     LOAD IOBLOK ADDRESS
         LR    A2+1,A1            SAVE VARIABLE BLOCK ADDRESS
         LM    A1,A1+1,TEM#2(PDR) GET SECOND ARG TO OUTPUT
         BAL   RETURN,GETSTGS     AND GET A STRING FOR THE FILE NAME
         XERR  01,081             FILE NAME (SECOND ARGUMENT) FOR
*                                 OUTPUT CALL IS NOT A STRING
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER OF NAME
         L     R0,PRINTDCB        LOAD PTR TO PRINT FILE IN CASE
         AH    A1+1,H1            GET REAL LENGTH + TEST FOR NULL
         BZ    OUTPUT4            IF NULL, SKIP TO USE PRINT FILE
*
*        HERE WE CALL SYSDCB TO GET THE PTR FOR A NON-NULL FILENAME
*
         L     R2,VOPEN           GET ADDRESS OF OPEN ROUTINE
         BALR  R1,R2              CALL ROUTINE TO LOCATE FILE POINTER
         B     SYSERROR           GIVE ERROR IF ERROR IN FILENAME
*
*        MERGE HERE WITH FILE (DCB) POINTER IN (R0)
*
OUTPUT4  ST    R0,OFILE(,A2)      SAVE POINTER IN IOBLOK
         LM    A1,A1+1,TEM#3(PDR) GET FORMAT ARGUMENT
         BAL   RETURN,GETSTG      CONVERT TO A STRING
         XERR  01,082             FORMAT SPECIFICATION (THIRD ARGUMENT)
*                                 FOR OUTPUT FUNCTION IS NOT A STRING
         STM   A1,A1+1,OFORMAT(A2)          SAVE THE FORMAT
         OI    VFLAGS(A2+1),VOUP+VOUA       SET ACTIVE OUTPUT FLAGS
         B     EXITNULL           RETURN NULL AS RESULT
*
OUTPUT   ENDFUNC ,                END OF OUTPUT FUNCTION
         TITLE 'SPITBOLF -- PROTOTYPE FUNCTION'
PROTOTYP FUNCTION  1              ENTRY POINT -- ONE ARG REQUIRED
         L     A1,TEM#1(,PDR)     LOAD ARGUMENT POINTER
         CLI   TEM#1(PDR),ACODE   CHECK FOR ARRAY ARGUMENT
         BE    PROARRAY           OFF TO GET ARRAY PROTOTYPE IF ARRAY
         CLI   TEM#1(PDR),TCODE   ELSE IT MUST BE A TABLE
         BE    *+10               SKIP OVER ERROR MSG IF TABLE
         XERR  01,083             ARGUMENT TO PROTOTYPE FUNCTION IS NOT
*                                 A TABLE OR AN ARRAY
         L     A1+1,TBDIVIDE(,A1) LOAD NUMBER OF SLOTS*4
         SRL   A1+1,2             GET NUMBER OF SLOTS
         SR    A1,A1              INDICATE INTEGER RESULT
         B     EXIT               RETURN TO CALLER
*
*        COME HERE TO LOAD ARRAY PROTOTYPE
*
PROARRAY LM    A1,A1+1,ASPEC(A1)  LOAD ARRAY SPECIFIER
         B     EXIT               RETURN TO CALLER
PROTOTYP ENDFUNC   ,              END OF PROTOTYPE FUNCTION
         TITLE 'SPITBOLF -- REMDR FUNCTION'
REMDR    FUNCTION 2               GET TWO ARGUMENTS
         LM    A1,A1+1,TEM#2(PDR) GET DIVISOR
         BAL   RETURN,GETINT      CONVERT IT TO INTEGER
         XERR  01,084             SECOND ARGUMENT TO REMDR FUNCTION IS
*                                 NOT AN INTEGER
         LPR   A2,A1+1            MAKE POSITIVE AND TEST FOR / 0
         BNZ   *+8                SKIP IF NOT ZERO
         XERR  10,015             ATTEMPTED DIVISION BY ZERO IN
*                                 REMDR FUNCTION
         LM    A1,A1+1,TEM#1(PDR) GET QUOTIENT
         BAL   RETURN,GETINT      GET AN INTEGER VALUE
         XERR  01,085             FIRST ARGUMENT TO REMDR FUNCTION IS
*                                 NOT AN INTEGER
         LR    A1,A1+1            COPY TO FILL IN SIGN BIT
         SRDA  A1,32              GET LEFT REG SIGN FILLED
         DR    A1,A2              DO THE DIVIDE
         LR    A1+1,A1            GET REMAINDER IN PROPER REG
         SR    A1,A1              INDICATE INTEGER RESULT
         B     EXIT               RETURN TO CALLER
REMDR    ENDFUNC ,                END OF REMAINDER FUNCTION
         TITLE 'SPITBOLF -- REPLACE FUNCTION'
REPLACE  FUNCTION  3              ENTRY POINT -- THREE ARGS
         CLI   TEM#1(PDR),NCODE   TEST FOR NULL RIGHT AWAY
         BE    EXITNULL           RETURN NULL IF FIRST ARG NULL
         L     R1,=A(ALPHPTR)     MAKE ALPHPTR & ALPHBET ADDRESSABLE
         USING ALPHPTR,R1         TELL ASSEMBLER
         CLC   TEM#2(8,PDR),ALPHPTR         IS 2ND ARG &ALPHABET?
         BNE   REPLC2             SKIP IF NOT
*
*        IF SECOND ARG IS &ALPHABET AND THIRD ARG IS OK, THEN WE CAN
*        USE THIRD ARG AS THE TRANSLATE TABLE (SAVING MUCH TIME)
*
         CLI   TEM#3(PDR),SCODE   IS THIRD ARG STRING?
         BNE   REPLC2             MERGE WITH STANDARD CIRCUIT IF NOT
         LA    R0,256-1           GET ALPHABET SLENGTH FOR CHECK
         C     R0,TEM#3+4(,PDR)   CHECK 3RD ARG SLENGTH=255,SOFFSET=0
         L     A2,TEM#3(,PDR)     LOAD 3RD ARG PTR (TRANSLATE TABLE)
         BE    REPLC4             SKIP ON &ALPHABET CASE
*
*        COME HERE FOR ALL OTHER CASES
*
REPLC2   L     R1,ALPHPTR         LOAD PTR TO &ALPHABET DATA
         MVC   512(256,PDR),SCHARS(R1)      COPY &ALPHABET TO WORK AREA
         DROP  R1                 DON'T NEED THIS BASE REG ANYMORE
         LM    A1,A1+1,TEM#3(PDR) LOAD THIRD ARG
         BAL   RETURN,GETSTGT     CONVERT TO STRING
         XERR  01,086             3RD ARGUMENT TO REPLACE NOT A STRING
         LTR   A1+1,A1+1          TEST FOR 3RD ARGUMENT NULL
         BM    FAILRL             FAIL RETURN IF SO
         EJECT
*
*        COME HERE WITH THIRD ARGUMENT CONVERTED TO STRING
*
REPLC2A  LR    A2,A1              SAVE 3RD ARG STRING POINTER
         LR    A2+1,A1+1          SAVE 3RD ARG 360 LENGTH
         STC   A2+1,REPSV         SAVE LOW ORDER BIT FOR LATER TEST
         LM    A1,A1+1,TEM#2(PDR) LOAD SECOND ARG
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFICATION
         XERR  01,087             2ND ARGUMENT TO REPLACE NOT A STRING
         CR    A1+1,A2+1          CHECK LENGTHS
         BNE   FAILRL             FAIL IF LENGTHS UNEQUAL
*
*        NOW PREPARE TO PLUG COPY OF &ALPHABET TO USE AS TR TABLE
*
         SR    A2+1,A2+1          CLEAR FOR IC USE IN LOOP
         SR    R1,R1              INITIALIZE CHARACTER OFFSET
         LR    R2,A1              SAVE 2ND ARG POINTER
         LA    A1,2               SET 2 CHAR INCREMENT FOR BXLE
*
*        LOOP TO PLUG CHARACTERS IN COPY OF &ALPHABET
*        WE DO TWO CHARACTERS AT A TIME TO MINIMIZE THE SLOW BXLE
*
         TM    REPSV,X'01'        TEST LENGTH EVEN/ODD
         BO    REPLC3             SKIP IF 360 LENGTH ODD - LENGTH EVEN
         BCT   R1,REPLC3A         SKIP TO DO ODD CHAR FUDGING POINTER
*
*        COME HERE TO PICK UP ODD REPLACE CHARACTER
*
REPLC3   IC    R0,SCHARS(A2,R1)   PICK UP 1ST REPLACE CHARACTER
         IC    A2+1,SCHARS(R2,R1)           PICK UP 1ST LOCATION CHAR
         STC   R0,512(PDR,A2+1)   PERFORM INDICATED REPLACEMENT
*
*        JUMP HERE FIRST TIME FOR CASE OF ODD NUMBER OF CHARACTERS
*
REPLC3A  IC    R0,SCHARS+1(A2,R1) PICK UP 2ND REPLACE CHARACTER
         IC    A2+1,SCHARS+1(R2,R1)         PICK UP 2ND LOCATION CHAR
         STC   R0,512(PDR,A2+1)   PERFORM INDICATED REPLACEMENT
         BXLE  R1,A1,REPLC3       LOOP BACK IF MORE CHARS TO GO
         LA    A2,512-SCHARS(,PDR)          LOAD TRANSLATE TABLE ADDRES
*
*        NOW PICK UP FIRST ARGUMENT
*
REPLC4   LM    A1,A1+1,TEM#1(PDR) LOAD FIRST ARGUMENT
         BAL   RETURN,GETSTGS     ELSE CONVERT TO STRING
         XERR  01,088             1ST ARGUMENT TO REPLACE NOT A STRING
         EJECT
*
*        NOW PREPARE TO MAKE NEW SBLOK
*
REPLC4A  LA    R0,BOUND+SCHARS+1(A1+1)      GET SBLOK LENGTH WITH FUDGE
         N     R0,FULLWRD         ADJUST TO FULL WORD BOUNDARY
         STE   ZR,0(,FR)          SET DTYPE=SBLOK=0 GCOLPTR=0
         STH   R0,STLENGTH(,FR)   STORE SBLOK LENGTH
         AR    R0,FR              CALCULATE NEW FR LOCATION
         CR    R0,PDR             CHECK FOR MEMORY OVERFLOW
         BNL   GBGCLF             GARBAGE COLLECT IF NO ROOM
*
*        COME HERE TO CREATE NEW SBLOK
*
REPLC5   LR    R2,A1              SAVE FIRST ARG POINTER
         LR    A1,FR              SET ADDRESS OF NEW SBLOK
         A     A1,SCODEBT         ADD SCODE FOR STRING
         LR    A2+1,A1+1          COPY LENGTH TO CRANK DOWN
         LA    R1,256             GET CRANK CONSTANT FOR LOOP
         CR    A2+1,R1            CHECK FOR 256 CHARS OR LESS
         BL    REPLC7             SKIP IF 256 CHARS OR LESS
*
*        LOOP TO MOVE AND TRANSLATE ARG 256 CHARS AT A TIME
*
REPLC6   MVC   SCHARS(256,FR),SCHARS(R2)    MOVE 256 CHARS TO NEW SBLOK
         TR    SCHARS(256,FR),SCHARS(A2)    TRANSLATE CHARACTERS MOVED
         AR    R2,R1              BUMP SOURCE POINTER
         AR    FR,R1              BUMP DESTINATION POINTER
         SR    A2+1,R1            DECREMENT COUNT
         CR    A2+1,R1            CHECK FOR STILL MORE THAN 256 CHARS
         BNL   REPLC6             LOOP BACK IF SO
*
*        COME HERE TO MOVE AND TRANSLATE LAST (OR ONLY) SECTION
*
REPLC7   EX    A2+1,REPLCM        MOVE REMAINING CHARS
         EX    A2+1,REPLCT        TRANSLATE REMAINING CHARS
         LR    FR,R0              SET NEW FREE POINTER LOCATION
         B     EXIT               RETURN TO CALLER
*
REPLCM   MVC   SCHARS(*-*,FR),SCHARS(R2)    MOVE REMAINING CHARS
REPLCT   TR    SCHARS(*-*,FR),SCHARS(A2)    TRANSLATE REMAINING CHARS
REPLACE  ENDFUNC   ,              END OF REPLACE FUNCTION
         TITLE 'SPITBOLF -- REVERSE FUNCTION'
REVERSE  FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFICATION
         XERR  01,089             ARGUMENT TO REVERSE IS NOT A STRING
         LR    A2,A1              MOVE STRING POINTER TO A2
         LTR   A1+1,A1+1          TEST FOR NULL
         BM    EXITNULL           RETURN NULL IF ARGUMENT IS NULL
         LA    R1,SCHARS+BOUND+1(,A1+1)     GET LENGTH OF NEW SBLOK
         N     R1,FULLWRD         ADJUST TO FULL WORD BOUNDARY
         STH   R1,STLENGTH(,FR)   STORE AS LENGTH OF NEW SBLOK
         STE   ZR,0(,FR)          SET DTYPE=SCODE=0 , GCOLPTR=0
         AR    R1,FR              SEE WHERE FR WILL END UP
         CR    R1,PDR             WILL WE RUN OUT OF STORAGE?
         BNL   GBGCLF             GARBAGE COLLECT & RETRY IF YES
         LR    A1,FR              ELSE COPY START OF SBLOK
         A     A1,SCODEBT         SUPPLY STRING TYPE CODE
         LA    A2+1,1(,A1+1)      GET NUMBER OF CHARS TO REVERSE
*
*        LOOP TO REVERSE CHARS ONE AT A TIME
*
         BALR  R2,0               POINT R2 TO START OF LOOP FOR SPEED
         IC    R0,SCHARS-1(A2,A2+1)         PICK UP NEXT LAST CHARACTER
         STC   R0,SCHARS(,FR)     STORE AS NEXT BEGIN CHARACTER
         LA    FR,1(,FR)          PUSH DESTINATION POINTER
         BCTR  A2+1,R2            LOOP BACK CRANKING COUNTER
         LR    FR,R1              SET NEW FREE CORE POINTER
         B     EXIT               AND RETURN TO CALLER
REVERSE  ENDFUNC                  END OF REVERSE FUNCTION
         TITLE 'SPITBOLF -- REWIND FUNCTION'
REWIND   FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         BAL   RETURN,GETSTGS     GET A STRING
         XERR  01,090             ARGUMENT TO REWIND IS NOT A STRING
         LA    A1,SCHARS(,A1)     POINT TO FIRST CHARACTER OF FILE NAME
         AH    A1+1,H1            GET REAL LENGTH, TEST FOR NULL
         BP    *+8                SKIP IF NON NULL
         XERR  13,048             ARGUMENT TO REWIND IS NULL
         L     R2,=V(SYSDCB)      LOAD PTR TO FIND DCB ROUTINE
         BALR  R1,R2              LOCATE DCB
         B     SYSERROR           SIGNAL ERROR IF GIVEN
         L     R2,=V(SYSRWIND)    POINT TO REWIND ROUTINE
         BALR  R1,R2              CALL IT
         B     SYSERROR           ERROR RETURN IF COME HERE
         B     EXITNULL           RETURN NULL AS RESULT
REWIND   ENDFUNC ,                END OF REWIND FUNCTION
         TITLE 'SPITBOLF -- RPAD FUNCTION'
RPAD     FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED
         LM    A1,A1+1,TEM#3(PDR)           LOAD THIRD ARGUMENT
         BAL   RETURN,GETSTGS     CONVERT TO STRING SPECIFIER
         XERR  01,091             THIRD ARGUMENT TO RPAD NOT A STRING
         MVI   PADCHAR,C' '       PROVISIONALLY SET BLANK AS PAD CHAR
         LTR   A1+1,A1+1          TEST FOR NO THIRD ARG (NULL)
         BM    *+10               SKIP IF NULL (BLANK IS DEFAULT)
         MVC   PADCHAR(1),SCHARS(A1)        ELSE ACQUIRE PAD CHARACTER
         LM    A1,A1+1,TEM#2(PDR)           NOW GET SECOND ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         XERR  01,092             2ND ARG TO RPAD IS NOT AN INTEGER
         C     A1+1,V$MAXLN       WILL THIS BE TOO LONG?
         BNH   *+8                SKIP IF NOT
         XERR  11,012             STRING FORMED BY RPAD EXCEEDS
*                                 &MAXLNGTH CHARACTERS IN LENGTH
         LR    A2,A1+1            SAVE INTEGER LENGTH IN A2
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETSTGS     GET A TEMPORARY STRING
         XERR  01,093             1ST ARGUMENT TO RPAD IS NOT A STRING
*
*        CHECK FOR SPECIAL CASE OF NULL PADDED TO LENGTH ZERO
*
         LTR   A1+1,A1+1          IS STRING NULL?
         BNM   RPAD1              SKIP IF NOT
         LTR   A2,A2              IF STRING IS NULL, IS PAD LENGTH 0?
         BZ    RPAD1A             SKIP TO RETURN NULL ARG IF SO
         LA    A1,PADCHAR-SCHARS  ELSE SET TO USE PAD CHAR AS FIRST ARG
         SR    A1+1,A1+1          LENGTH IS ONE CHAR
*
*        COME HERE TO PERFORM ACTUAL PAD OPERATION
*
RPAD1    STE   ZR,0(,FR)          PREPARE DTYPE=SBLOK=0, GCOLPTR=0
         LA    R1,SCHARS+BOUND(,A2)         CALCULATE SBLOK LENGTH
         N     R1,FULLWRD         ADJUST TO FULL WORD BOUNDARY
         STH   R1,STLENGTH(,FR)   STORE AS SBLOK LENGTH
         AR    R1,FR              SEE WHERE FR WILL END UP
         CR    R1,PDR             WILL WE HAVE ENOUGH ROOM
         BNL   GBGCLF             GARBAGE COLLECT & TRY AGAIN IF NOT
         BCTR  A2,0               ADJUST TOTAL COUNT FOR 360
         LR    R2,A2              SAVE LENGTH OF NEW STRING
         LR    A2+1,FR            SAVE START OF NEW SBLOK
         LA    R0,256             LOAD CRANK CONSTANT FOR LONG STRINGS
         SR    A2,A1+1            GET NUMBER OF PAD CHARS
         BNM   RPADSL             SKIP IF ROOM FOR PAD CHARS
*
*        MERGE HERE TO RETURN FIRST ARG AS RESULT
*
RPAD1A   LM    A1,A1+1,TEM#1(PDR) RELOAD FIRST ARG
         B     EXIT               AND RETURN IT AS RESULT
         EJECT
*
*        LOOP TO COPY 256 CHARACTERS AT A TIME
*
RPADSL   CR    A1+1,R0            HOW MANY CHARS LEFT?
         BL    RPADSE             SKIP IF 256 OR LESS
         MVC   SCHARS(256,FR),SCHARS(A1)    ELSE MOVE 256 CHARS
         AR    A1,R0              BUMP SOURCE POINTER
         SR    A1+1,R0            DECREMENT COUNT
         BXLE  FR,R0,RPADSL       BUMP DEST PTR & LOOP BACK (FR<R1)
*
*        COME HERE TO MOVE LAST CHUNK (256 CHARS OR LESS)
*
RPADSE   EX    A1+1,RPADSMV       MOVE REMAINING CHARS
         AR    FR,A1+1            BUMP FREE POINTER
*
*        LOOP TO PAD 256 CHARACTERS AT A TIME
*
RPADPL   MVC   SCHARS+1(1,FR),PADCHAR       MOVE IN FIRST PAD CHAR
         CR    A2,R0              HOW MANY TO GO?
         BL    RPADPE             SKIP IF 256 OR LESS
         MVC   SCHARS+1+1(256,FR),SCHARS+1(FR)   PROPOGATE 256 CHARS
         SR    A2,R0              CRANK COUNT DOWN
         BXLE  FR,R0,RPADPL       BUMP PTR & LOOP (FR<R1)
*
*        COME HERE TO PROPOGATE LAST CHUNK AND EXIT
*
RPADPE   EX    A2,RPADPP          PROPAGATE REMAINING CHARS
         LR    FR,R1              SET NEW FREE POINTER LOCATION
         LR    A1,A2+1            RECALL START OF SBLOK
         AL    A1,SCODEBT         SUPPLY STRING TYPE BYTE
         LR    A1+1,R2            RECALL SLENGTH
         B     EXIT               RETURN
*
RPADPP   MVC   SCHARS+1+1(*-*,FR),SCHARS+1(FR) LAST CHRS + 2 EXTRA
RPADSMV  MVC   SCHARS(*-*,FR),SCHARS(A1)    COPY LAST CHARS
RPAD     ENDFUNC                  END OF RPAD FUNCTION
         TITLE 'SPITBOLF -- SETEXIT FUNCTION'
SETEXIT  FUNCTION  1              ENTRY POINT -- ONE ARGUMENT
         L     A2,EXITLOC         LOAD OLD POINTER
         LTR   A2,A2              WAS THERE ONE?
         LA    A2,VNAME-VALUE(,A2)          POINT TO NAME FIELD IN CASE
         BNZ   *+6                SKIP IF THERE WAS
         SR    A2,A2              ELSE SET FOR NULL RETURNED RESULT
         CLI   TEM#1(PDR),NCODE   IS ARGUMENT NULL?
         BNE   SETXIT2            JUMP IF NOT
*
*        CASE OF NULL ARGUMENT -- CLEAR EXIT LOCATION
*
         STE   ZR,EXITLOC         ZERO OUT EXIT LOCATION
         B     SETXITX            JUMP TO COMMON EXIT POINT
*
*        COME HERE FOR CASE OF SETTING A NEW EXIT LOCATION
*
SETXIT2  LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT
         BAL   RETURN,GETNAME     FIND VARIABLE BLOCK
         XERR  01,094             ARGUMENT TO SETEXIT IS NOT A LABEL
         CLC   VLABL+1(3,A1),=AL3($$NOGO)   IS LABEL UNDEFINED?
         BE    *-10               ERROR IF SO
         ST    A1,EXITLOC         IF ALL OK, STORE POINTER
*
*        COMMON EXIT POINT
*
SETXITX  LTR   A2,A2              SHOULD WE RETURN NULL?
         BZ    EXITNULL           RETURN NULL IF SO
         LA    A1,0(,A2)          ELSE COPY BLOCK ADDR (STRIP UPPER BY)
         AL    A1,MCODEBT         SUPPLY PROPER TYPE CODE
         B     EXIT               AND RETURN TO CALLER
SETEXIT  ENDFUNC   ,              END OF SETEXIT FUNCTION
         TITLE 'SPITBOLF -- SIZE FUNCTION'
SIZE     FUNCTION  1              ENTRY POINT -- ONE ARGUMENT
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         L     PDR,PDRLOC         RESTORE STACK POINTER
         BAL   RETURN,GETSTGS     GET STRING ADDR/LENGTH
         XERR  01,037             ARGUMENT TO SIZE IS NOT A STRING
         LA    A1+1,1(,A1+1)      IF STRING, CONVERT 360 TO REAL LENGTH
         SR    A1,A1              SET TYPE = INTEGER
         L     RETURN,RETLOC      RELOAD RETURN LOCATION
         BR    RETURN             RETURN TO CALLER
SIZE     ENDFUNC ,                END OF SIZE FUNCTION
         TITLE 'SPITBOLF -- STOPTR FUNCTION'
STOPTR   FUNCTION  2              ENTRY POINT -- TWO ARGS REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     FIND ASSOCIATED VARIABLE BLOCK
         B     EXITNULL           RETURN NULL IF NOT A NAME
         LR    A2,A1              SAVE VARIABLE BLOCK POINTER
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT
         BAL   RETURN,GETSTGS     GET A TEMPORARY STRING
         B     EXITNULL           RETURN NULL IF SECOND ARG NOT STRING
         LA    RETURN,EXITNULL    SET TO RETURN NULL ON EXIT
         LTR   A1+1,A1+1          TEST FOR NULL SECOND ARGUMENT
         BM    STOPTRV            ASSUME STOP VALUE TRACE IF NULL
         CLI   SCHARS(A1),C'V'    IS IT A VALUE
         BE    STOPTRV            SKIP TO STOP VALUE TRACE IF SO
         CLI   SCHARS(A1),C'L'    IS IT A LABEL?
         BE    STOPTRL            SKIP IF SO TO STOP LABEL TRACE
         CLI   SCHARS(A1),C'K'    IS IT A KEYWORD?
         BE    STOPTRK            SKIP IF SO TO STOP KEYWORD TRACE
         CLI   SCHARS(A1),C'F'    IS IT FUNCTION?
         BE    STOPTRF            SKIP IF SO TO STOP FUNCTION TRACE
         CLI   SCHARS(A1),C'C'    IS IT CALL?
         BE    STOPTRC            SKIP IF SO TO STOP TRACE OF FUNC CALL
         CLI   SCHARS(A1),C'R'    IS IT RETURN?
         BCR   NE,RETURN          IGNORE STOPTR CALL IF NOT
*
*        STOP TRACE OF FUNCTION RETURN
*
         NI    VFLAGS(A2),X'FF'-VFTR        RESET RETURN TRACE FLAG
         LA    R1,FRTRCCHN-TRCLINK          POINT TO CHN HEAD
         BAL   A2+1,STPDCHN1      AND GO OFF TO REMOVE FROM CHAIN
         BR    RETURN             AND RETURN TO CALLER
*
*        STOP TRACE OF FUNCTION (CALL AND RETURN)
*
STOPTRF  NI    VFLAGS(A2),X'FF'-VFTR        TURN OFF RETURN TRACE
         LA    R1,FRTRCCHN-TRCLINK          POINT TO RETURN TRACE CHN
         BAL   A2+1,STPDCHN1      AND GO OFF TO REMOVE FROM CHAIN
*
*        STOP TRACE OF FUNCTION CALL (FUNCTION CASE MERGES)
*
STOPTRC  NI    VFLAGS(A2),X'FF'-VFTC        RESET CALL TRACE FLAG
         LA    R1,FCTRCCHN-TRCLINK          POINT TO CALL CHAIN
         BAL   A2+1,STPDCHN1      AND GO OFF TO REMOVE FROM CHAIN
         BR    RETURN             AND RETURN TO CALLER
         EJECT
*
*        SUBROUTINE TO SEARCH DOWN CHAIN TO REMOVE REFERENCE TO
*        SPECIFIED VARIABLE BLOCK IF ONE IS PRESENT
*        (A2)  VARIABLE BLOCK ADDRESS
*        BAL   A2+1,STPDCHN1      NORMAL ENTRY
*
STPDCHN  C     A2,TRVBLK(,R2)     IS THIS A REFERENCE TO OUR VARIABLE?
         BE    STPDCHN2           OFF TO DELETE FROM CHAIN IF SO
         LR    R1,R2              SAVE BACK POINTER FOR DECHAIN
*
*        INITIAL ENTRY IS HERE - (R1) IS CHAIN HEAD
*
STPDCHN1 L     R2,TRCLINK(,R1)    MOVE OUT ON CHAIN
         CE    ZR,TRCLINK(,R1)    ARE WE AT CHAIN END?
         BNE   STPDCHN            LOOP BACK IF NOT CHAIN END
         BR    A2+1               ELSE RETURN TO CALLER
*
*        COME HERE TO REMOVE A TRBLOCK FROM CHAIN
*
STPDCHN2 MVC   TRCLINK(4,R1),TRCLINK(R2)    MOVE LINK FROM NEXT BLOCK
         BR    A2+1               AND RETURN TO CALLER
*
*        STOP KEYWORD TRACE
*
STOPTRK  LA    R1,FNCLTRC         ASSUME FNCLEVEL TRACE
         CLI   VKEY(A2),K$FNCLEV  IS IT FNCLEVEL?
         BE    STOPTRK1           SKIP IF SO
         LA    R1,ETYPTRC         ASSUME ERRTYPE
         CLI   VKEY(A2),K$ERRTYP  IS IT ERRTYPE?
         BE    STOPTRK1           SKIP IF SO
         CLI   VKEY(A2),K$STCOUN  LAST TRY IS STCOUNT
         BCR   NE,RETURN          ALL DONE IF NOT STCOUNT
         L     R1,STCNTTRC        LOAD &STCOUNT TRACE INFORMATION
         LTR   R1,R1              IS IT BEING TRACED?
         BCR   Z,RETURN           EXIT IF NOT BEING TRACED
         STE   ZR,SCNTSAVE        PREVENT INVALID PAT CONCAT OPTIMIZATN
         L     R1,V$STLIM         LOAD STLIMIT
         S     R1,V$STCNT         DECREMENT BY NUMBER OF STMTS EXECUTED
         LER   SCNT,SINC          SET SCNT TO MINIMUM VALUE IN CASE
*                                 NUMBER OF STMTS LEFT GE 2**24
         C     R1,=X'00FFFFFF'    CHECK AGAINST MAXIMUM SETTABLE VALUE
         BNL   STSTCNT            SKIP IF THIS IS VALUE TO USE
         LE    SCNT,SPINMX        SET TO MAXIMUM VALUE
         ST    R1,STSTART         STORE STLIMIT VALUE
         MVI   STSTART,X'7F'      SET UP EXPONENT
         SU    SCNT,STSTART       AND GET VALUE FOR SCNT
*
*        COME HERE WITH SCNT SET UP TO ENTER CODE
*
STSTCNT  STE   SCNT,STSTART       SAVE STARTING VALUE OF SCNT
         LA    R1,STCNTTRC        SET FOR STCOUNT STOPTR
         EJECT
*
*        COME HERE WITH R1 POINTING TO PROPER KEYWORD INFORMATION
*
STOPTRK1 STE   ZR,0(,R1)          END KEYWORD TRACE
         BR    RETURN             AND RETURN TO CALLER
*
*        STOP LABEL TRACE
*
STOPTRL  L     R1,VLABL(,A2)      GET STATEMENT ADDRESS
         CLI   0(R1),LTBLOK       IS THERE A LABEL TRACE BLOCK?
         BCR   NE,RETURN          EXIT IF NOT
         MVC   VLABL+1(3,A2),LTGOTO+1(R1)   RESTORE THE CODE ADDRESS
         BR    RETURN             RETURN TO CALLER
*
*        STOP VALUE TRACE
*
STOPTRV  NI    VFLAGS(A2),X'FF'-VTRC        TURN OFF TRACE FLAG
         TM    VFLAGS(A2),VINA+VOUA         IS ANY I/O ACTIVE?
         BCR   NZ,RETURN          KEEP IOBLOK IF SO (KEEPS TAG AROUND
         XC    VIOPTR+1(3,A2),VIOPTR+1(A2)  GET RID OF IOBLOK
STOPTR   ENDFUNC                  END OF STOPTR FUNCTION
         TITLE 'SPITBOLF -- SUBSTR FUNCTION'
SUBSTR   FUNCTION  3              ENTRY POINT -- THREE ARGS REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETSTG      CONVERT TO STRING
         XERR  01,095             FIRST ARG TO SUBSTR NOT A STRING
         STM   A1,A1+1,TEM#1(PDR)           STORE CONVERTTED STRING
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         XERR  01,096             2ND ARG TO SUBSTR IS NOT AN INTEGER
         LTR   A2,A1+1            SAVE AND TEST SECOND ARG
         BNP   FAILRL             FAIL IF NOT > 0
         LM    A1,A1+1,TEM#3(PDR)           LOAD THIRD ARGUMENT
         BAL   RETURN,GETINT      CONVERT TO INTEGER
         XERR  01,097             THIRD ARG TO SUBSTR NOT AN INTEGER
         LTR   A1+1,A1+1          CHECK THIRD ARGUMENT
         BNP   SUBSTR1            CHECK FOR NULL IF 3RD ARG NOT > 0
         CLI   TEM#1(PDR),NCODE   CHECK FOR NULL FIRST ARGUMENT
         BE    FAILRL             FAIL IF NULL FIRST ARG
         BCTR  A2,0               DECREMENT SECOND ARG
         BCTR  A1+1,0             DECREMENT THIRD ARG FOR 360
         LA    R2,0(A2,A1+1)      GET (ARG2 + ARG3 - 2)
         CH    R2,TEM#1+SLENGTH(,PDR)       CHECK FOR IN RANGE
         BH    FAILRL             FAIL IF NOT IN RANGE
         AH    A2,TEM#1+SOFFSET(,PDR)       CALCULATE NEW OFFSET
         STH   A2,TEM#1+SOFFSET(,PDR)       STORE NEW OFFSET
         STH   A1+1,TEM#1+SLENGTH(,PDR)     STORE NEW SLENGTH
         LM    A1,A1+1,TEM#1(PDR)           LOAD RESULT
         B     EXIT               RETURN TO CALLER
*
*        COME HERE IF NEW LENGTH EQUALS ZERO (NULL)
*        NOTE THAT WE ALLOW ARG2 TO POINT TO FIRST NON-EXISTANT CHAR
*
SUBSTR1  BM    FAILRL             FAIL IF NEGATIVE POSITION REQUIRED
         SH    A2,H2              DECREMENT FOR TEST VS LENGTH
         BM    EXITNULL           IF OFFSET = CHAR 1, OK, RETURN NULL
         CLI   TEM#1(PDR),NCODE   WAS FIRST ARGUMENT NULL?
         BE    FAILRL             FAIL IF NULL (ONLY PERMIT ARG2=1)
         CH    A2,TEM#1+SLENGTH(,PDR)       COMPARE FOR WITHIN OLD STRG
         BNH   EXITNULL           OK IF IN STRING, RETURN NULL
         B     FAILRL             ELSE FAIL
SUBSTR   ENDFUNC   ,              END OF SUBSTR FUNCTION
         TITLE 'SPITBOLF -- TABLE FUNCTION'
*
*        FUNCTION TO GENERATE A TABLE
*
*        SEE DESCRIPTION OF TABLE STRUCTURE (TBBLOK)
*
TABLE    FUNCTION  1              ENTRY POINT -- ONE ARG
         LM    A1,A1+1,TEM#1(PDR) ELSE LOAD ARGUMENT
         BAL   RETURN,GETINT      GET AN INTEGER FROM IT
         XERR  01,098             ARGUMENT TO TABLE IS NOT AN INTEGER
         SLA   A1+1,2             ARGUMENT * 4 + TEST IT
         BP    TABLE2             SKIP IF SIZE GIVEN
         BM    TABLERR            ERROR IF NEGATIVE
         LA    A1+1,11*4          ELSE DEFAULT SIZE IS 11 HEADERS
*
*        COME HERE WITH POSITIVE INTEGER ARGUMENT (*4)
*
TABLE2   LA    R0,4               GET CONSTANT 4
         OR    A1+1,R0            MAKE SURE ARGUMENT IS ODD
         LA    R0,TBLPTRS(FR,A1+1)          FIND WHERE FR WILL END UP
         CR    R0,PDR             WILL WE HAVE ROOM?
         BL    TABLE3             SKIP IF YES
         B     GBGCLF             ELSE DO GARBAGE COLLECTION
*
*        COME HERE WITH ROOM
*
TABLE3   STE   ZR,0(,FR)          ZERO GARBAGE COLLECTION FIELD
         MVI   0(FR),TBBLOK       SET TABLE BLOCK CODE
         LR    A1,FR              SET ADDRESS OF TABLE INRESULT REG
         ST    A1+1,TBDIVIDE(,FR) STORE NUMBER OF ENTRIES * 4
         SR    R0,FR              GET LENGTH OF BLOCK
         ST    R0,TBLENGTH(,FR)   AND SAVE IT IN BLOCK
         SRL   A1+1,2             GET BACK NUMBER OF ENTRIES
*
*        LOOP TO ZERO ENTRIES
*
TABLE4   STE   ZR,TBLPTRS(,FR)    CLEAR AN ENTRY
         LA    FR,4(,FR)          BUMP POINTER TO NEXT ENTRY
         BCT   A1+1,TABLE4        KEEP GOING TILL ALL ENTRIES ZEROD
         AL    A1,TCODEBT         ADD IN CODE
         LA    FR,TBLPTRS(,FR)    ADJUST FOR FIELDS AT START
         B     EXIT               RETURN TO CALLER
TABLERR  XERR  13,049             ARGUMENT TO TABLE IS ZERO OR NEGATIVE
TABLE    ENDFUNC   ,              END OF TABLE FUNCTION
         TITLE 'SPITBOLF -- TIME FUNCTION'
TIME     FUNCTION  0,N            ENTRY POINT -- NO ARGUMENTS REQUIRED
         L     R2,VSYSTIME        LOAD INTERFACE ROUTINE ADDRESS
         BALR  R1,R2              CALL IT
         B     SYSERROR           ERROR IF COME HERE (IMPOSSIBLE)
         S     R0,TIME            SUBTRACT STARTING TIME
         LR    A1+1,R0            COPY TIME
         SR    A1,A1              SET ICODE = 0 FOR INTEGER RESULT
         L     PDR,PDRLOC         RESET STACK POINTER
         BR    RETURN             RETURN TO CALLER
*
TIME     ENDFUNC   ,              END OF THE TIME FUNCTION
         TITLE 'SPITBOLF -- TRACE FUNCTION'
TRACE    FUNCTION  4              ENTRY POINT -- FOUR ARGS REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD FIRST ARGUMENT
         BAL   RETURN,GETNAME     FIND ASSOCIATED VARIABLE BLOCK
         B     EXITNULL           LEAVE IF NOT A PROPER NAME
         LR    A2,A1              SAVE POINTER TO VARIABLE BLOCK
         LM    A1,A1+1,TEM#2(PDR)           LOAD SECOND ARGUMENT
         BAL   RETURN,GETSTGS     CONVERT TO TEMPORARY STRING
         B     EXITNULL           LEAVE IF GARBAGE SECOND ARG
         LA    RETURN,EXITNULL    SET TO RETURN NULL ON EXIT
         LTR   A1+1,A1+1          TEST FOR NULL (NO SECOND ARG)
         BM    TRACEV             ASSUME VALUE TRACE IF NULL
         CLI   SCHARS(A1),C'V'    IS IT VALUE?
         BE    TRACEV             SKIP IF VALUE TRACE
         CLI   SCHARS(A1),C'L'    IS IT LABEL?
         BE    TRACEL             SKIP IF LABEL TRACE
         CLI   SCHARS(A1),C'K'    IS IT KEYWORD?
         BE    TRACEK             SKIP IF KEYWORD TRACE
         CLI   SCHARS(A1),C'F'    IS IT FUNCTION?
         BE    TRACEF             SKIP IF FUNCTION TRACE
         CLI   SCHARS(A1),C'C'    IS IT CALL?
         BE    TRACEC             SKIP IF CALL TRACE
         CLI   SCHARS(A1),C'R'    IS IT RETURN?
         BCR   NE,RETURN          IGNORE CALL IF NOT
*
*        TRACE FUNCTION RETURN
*
         OI    VFLAGS(A2),VFTR    SET FUNCTION RETURN TRACE FLAG
         B     TRACEFR            AND MERGE WITH 'FUNCTION' TRACE
*
*        TRACE FUNCTION CALL
*
TRACEC   OI    VFLAGS(A2),VFTC    SET FUNCTION CALL TRACE FLAG
         LA    DB2,FCTRCCHN-TRCLINK         POINT TO TRACE CHAIN
         B     TRACEFC            JUMP TO CHECK FOR DEFINED FUNCTION
*
*        TRACE FUNCTION (CALL & RETURN)
*
TRACEF   OI    VFLAGS(A2),VFTC+VFTR         SET CALL AND RETURN FLAGS
         LA    DB2,FCTRCCHN-TRCLINK         PT TO CALL TRC CHAIN
         BAL   A2+1,MAKETRB       CHECK FOR AND CHAIN PD TRACE REQUEST
*
*        COME HERE TO CHECK FOR PROG DEF TRACE CALL FOR 'RETURN' TRACE
*
TRACEFR  LA    DB2,FRTRCCHN-TRCLINK         PT TO RETURN TRACE CHAIN
         EJECT
*
*        MERGE TO CHECK FOR PROG DEFINED FUNC, SET TRACE FLAGS IN FBLOK
*
TRACEFC  BAL   A2+1,MAKETRB       CHECK FOR FOURTH ARGUMENT
         L     R1,VFUNC(,A2)      LOAD FUNCTION POINTER
         CLC   FCODE(4,R1),FBLOKI USER DEFINED FUNCTION?
         BCR   NE,RETURN          RETURN IF NOT
         OC    FFLAGS(1,R1),VFLAGS(A2)      ELSE SET FLAGS IN FBLOK
         BR    RETURN             AND THEN RETURN TO CALLER
*
*        TRACE LABEL TRANSFER
*
TRACEL   CLI   TEM#4(PDR),NCODE   WAS A PROG TRACE FUNCTION GIVEN?
         BE    TRACEL1            SKIP TO GET ZERO ADDR IF NOT
         LM    A1,A1+1,TEM#4(PDR) LOAD FOURTH ARGUMENT VALUE
         BAL   RETURN,GETNAME     AND TRY TO GET VAR BLOCK ADDR
*
*        COME HERE IF NO LEGAL FOURTH ARGUMENT GIVEN, SET ADDR = 0
*
TRACEL1  SR    A1,A1              SET VARIABLE BLOCK ADDR = ZERO
         SR    A1+1,A1+1          CLEAR OFFSET PORTION OF NAME
         L     R1,VLABL(,A2)      LOAD LABEL ADDRESS OR LTBLOK ADDR
         CLI   0(R1),LTBLOK       ARE WE POINTING TO AN LTBLOK
         BNE   *+8                SKIP IF NOT (R1 IS CODE ADDRESS)
         L     R1,LTGOTO(,R1)     ELSE LOAD CODE ADDRESS FROM LTBLOK
         LA    R0,LTSIZE(,FR)     GET FINAL FREE CORE LOCATION
         CR    R0,PDR             CHECK FOR OVERFLOW
         BNL   GBGCLF             OFF TO COLLECT IF OVERFLOW
         ST    FR,LTLOC(,FR)      SAVE POINTER TO THIS BLOK FOR GBGCOL
         MVC   0(8,FR),LTMODL     MOVE IN MODEL TRACE CODE
         MVC   LTTAG(8,FR),TEM#3(PDR)       MOVE IN POSSIBLE TAG
         ST    A1,LTFUNC(,FR)     SAVE ADDRESS OF FUNCTION NAME
         ST    R1,LTGOTO(,FR)     SAVE GO TO ADDRESS IN BLOCK
         ST    A2,LTBLOCK(,FR)    SAVE VARIABLE BLOCK ADDRESS
         IC    R1,VLABL(,A2)      SAVE LEFT BYTE IN VARIABLE BLOCK
         ST    FR,VLABL(,A2)      SAVE NEW TRANSFER ADDRESS (TO LTBLOK)
         STC   R1,VLABL(,A2)      RESTORE LEFT BYTE IN VLABL FIELD
         LR    FR,R0              COPY NEW FREE CORE ADDRESS
         B     EXITNULL           AND EXIT RETURNING NULL AS RESULT
*
*        MODEL TO CONSTRUCT LTBLOK (LABEL TRACE BLOCK) IN FREE CORE
*
LTMODL   DC    AL1(LTBLOK)        BLOCK CODE FOR LABEL TRACE
         DC    AL3(0)             GARBAGE COLLECTION FIELD
         BAL   DB2,LABTRAC        CALL TO LABEL TRACE ROUTINE
         EJECT
*
*        TRACE KEYWORD
*
TRACEK   LA    R1,FNCLTRC-TRCLINK POINT FOR FNCLEVEL TRACE
         CLI   VKEY(A2),K$FNCLEV  IS THIS FNCLEVEL?
         BE    TRACEK1            OFF TO PROCESS IF SO
         LA    R1,ETYPTRC-TRCLINK SET FOR ERRTYPE TRACE CALL
         CLI   VKEY(A2),K$ERRTYP  IS THIS ERRTYPE CALL?
         BE    TRACEK1            OFF TO PROCESS IF ERRTYPE
         CLI   VKEY(A2),K$STCOUN  CHECK FOR STCOUNT CALL
         BCR   NE,RETURN          NOT VALID CALL IF NOT
         STE   ZR,SCNTSAVE        STOP INVALID PAT CONCAT OPTIMIZATION
         SU    SCNT,STSTART       CALULATE NO. OF STMTS EXECUTED
         STE   SCNT,STSTART       SAVE IN TEMPORARY LOCATION
         L     R1,STSTART         LOAD INTO GENERAL REGISTER
         LA    R1,0(,R1)          CLEAR OUT X'7F' EXPONENT
         A     R1,V$STCNT         ADD IN STMTS ALREADY COUNTED
         ST    R1,V$STCNT         AND SAVE UPDATED VALUE
         LE    SCNT,SPINMX        LOAD MAXIMUM SCNT VALUE
         STE   SCNT,STSTART       SET UP VALID STSTART
         LA    R1,STCNTTRC-TRCLINK          SET FOR STCOUNT TRACE
*
*        COME HERE WITH R1 POINTING TO KEYWORD TRACE WORD -TRCLINK
*
TRACEK1  LR    DB2,R1             SET UP DB2 FOR MAKETRB CALL
         STE   ZR,TRCLINK(,DB2)   CLEAR OUT OLD TRACE STATUS
         MVI   TRCLINK(DB2),X'FF' TURN ON STD TRACE IN CASE NO 4TH ARG
         BAL   A2+1,MAKETRB       SET UP TRB AND CLEAR LEFT BYTE IF 4TH
         BR    RETURN             AND RETURN TO CALLER
*
*        TRACE VALUE
*
TRACEV   CE    ZR,VIOPTR(,A2)     MIGHT WE HAVE ACTIVE TRACE INFO?
         BE    TRACEV1            NOTHING TO DO IF NO IOBLOK PRESENT
         L     R1,VIOPTR(,A2)     ELSE LOAD IOBLOK ADDRESS
         STE   ZR,IOFUNC(,R1)     CLEAR OUT POSSIBLE TRACE FUNC ADDR
         STE   ZR,IOTAG(,R1)      CLEAR OUT POSSIBLE TRACE TAG
*                                 IF THIS FREES IOB, PROBABLY USED SOON
*                                 SO DON'T BOTHER TO GET RID OF IOBLOK
         EJECT
*
*        COME HERE WHEN OLD TRACE INFORMATION HAS BEEN DISCARDED
*
TRACEV1  CLI   TEM#4(PDR),NCODE   IS THERE A FOURTH ARGUMENT?
         BE    TRACEV3            SKIP IF NOT
         LM    A1,A1+1,TEM#4(PDR) LOAD NAME OF FUNCTION
         BAL   RETURN,GETNAME     GET VARIABLE BLOCK ADDRESS
         B     TRACEV3            TREAT ILLEGAL NAME AS NO NAME
         CE    ZR,VIOPTR(,A2)     DO WE ALREADY HAVE AN IOBLOK?
         BNE   TRACEV2            SKIP IF ONE ALREADY BUILT
         LA    R2,IOBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP
         CR    R2,PDR             WILL WE NEED A COLLECT FIRST?
         BNL   GBGCLF             EXIT IF COLLECT NEEDED
         XC    0(IOBSIZE,FR),0(FR)          CLEAR OUT AN IOBLOK
         MVI   0(FR),IOBLOK       SET TYPE CODE IN BLOCK
         IC    R0,VIOPTR(,A2)     SAVE LEFT BYTE OF IOPTR
         ST    FR,VIOPTR(,A2)     SAVE ADDRESS OF IOBLOK
         STC   R0,VIOPTR(,A2)     RESTORE LEFT BYTE OF VIOPTR
         LR    FR,R2              UPDATE FREE CORE POINTER
*
*        COME HERE WITH ADDRESS OF IOBLOK IN VIOPTR
*
TRACEV2  L     R1,VIOPTR(,A2)     LOAD ADDRESS OF IOBLOK
         ST    A1,IOFUNC(,R1)     SAVE ADDRESS OF FUNCTION TO BE INVOKE
         ST    A2,IOVBLK(,R1)     SAVE ADDRESS OF TRACED VARIABLE
         MVC   IOTAG(8,R1),TEM#3(PDR)       SAVE TAG FOR CALLS
*
*        COME HERE TO SET UP INTERCEPTS
*
TRACEV3  LR    A1,A2              COPY BLOCK ADDRESS
         TM    VFLAGS(A1),VOUP    ARE THE INTERCEPTS SET?
         BO    TRACEV4            SKIP IF ALREADY SET
         L     DB4,AIOASSOC       GET ADDRESS OF SETUP ROUTINE
         LA    DB3,OUTFLAG        SET CALL FOR OUTPUT CASE
         BALR  RETURN,DB4         AND SET UP INTERCEPTS
*
*        COME HERE WITH INTERCEPTS SET
*
TRACEV4  OI    VFLAGS(A1),VTRC+VOUP         SET FLAGS INDICATING SETUP
         B     EXITNULL           RETURN NULL AS VALUE, ALL DONE
         EJECT
*
*        THIS SUBROUTINE IS USED TO ADD A TRBLOK TO THE CHAIN
*        INDICATED BY TRCLINK(DB2) IF A FUNCTION NAME IS GIVEN FOR THIS
*        CALL.  NO CHECK IS MADE FOR DUPLICATE NAME ENTRIES AS THESE
*        WILL NOT INTERFERE. MULTIPLE STOPTR CALLS WILL DELETE DUP NMS
*        DO NOT SAVE LEFT BYTE OF CHAIN PTR WORD - SEE KEYWORD CALL
*
*        LA    DB2,(CHAIN HEAD)-TRCLINK     SET UP DB2 FOR CALL
*        BAL   A2+1,MAKETRB       CALL TO THIS ROUTINE
*
MAKETRB  CLI   TEM#4(PDR),NCODE   IS A FOURTH ARGUMENT PRESENT?
         BE    MAKETRBX           OFF TO EXIT IF NO FOURTH ARGUMENT
         LM    A1,A1+1,TEM#4(PDR) LOAD FOURTH ARG = TRACE FUNCTION
         BAL   RETURN,GETNAME     LOCATE VARIABLE BLOCK FOR NAME
         B     MAKETRBX           EXIT IF ILLEGAL NAME
         STE   ZR,0(,FR)          CLEAR FIRST WORD OF TRBLOK
         MVI   0(FR),TRBLOK       SET BLOK CODE
         ST    A1,TRFUNC(,FR)     SAVE NAME OF FUNCTION TO BE CALLED
         ST    A2,TRVBLK(,FR)     SAVE NAME OF ITEM TO BE TRACED
         MVC   TRTAG(8,FR),TEM#3(PDR)       MOVE TAG INTO TRACE BLOCK
         LA    R2,TRBSIZE(,FR)    SEE WHERE FREE CORE WILL END UP
         CR    R2,PDR             WILL WE NEED A COLLECT?
         BNL   GBGCLF             OFF TO COLLECT & RE-ENTER IF YES
         L     A1+1,TRCLINK(,DB2) LOAD HEAD OF CHAIN ADDRESS
         LA    A1+1,0(,A1+1)      CLEAR POSSIBLE UPPER BYTE
         ST    A1+1,TRCLINK(,FR)  CONTINUE CHAIN THROUGH NEW BLOCK
         ST    FR,TRCLINK(,DB2)   PUT NEW BLOCK AT HEAD OF CHAIN
         LR    FR,R2              UPDATE FREE CORE POINTER
*
*        COME HERE TO EXIT (LOAD NULL AND RESTORE DB2)
*
MAKETRBX L     DB2,$$BAS2         RESTORE DB2
         B     EXITNULL           RETURN TO CALLER
TRACE    ENDFUNC                  END OF TRACE FUNCTION
         TITLE 'SPITBOLF -- TRIM FUNCTION'
TRIM     FUNCTION 1               ENTRY POINT -- ONE ARGUMENT REQUIRED
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         BAL   RETURN,GETSTG      CONVERT TO STRING
         XERR  01,099             ARGUMENT TO TRIM IS NOT A STRING
         C     A1,NCODEBT         CHECK FOR NULL
         BNL   EXITNULL           RETURN NULL IF NULL
         STM   A1,A1+1,TRIMSV     SAVE SPECIFIER
         AH    A1,TRIMSV+SOFFSET  ADD STRING OFFSET
         LH    R1,TRIMSV+SLENGTH  LOAD 360 LENGTH
         AR    A1,R1              POINT TO LAST CHARACTER
         LA    R1,1(,R1)          GET REAL LENGTH
*
*        LOOP TO BACK OFF ONE CHARACTER AT A TIME
*
         BALR  R2,0               SET LOOP ADDRESS FOR SPEED
TRIML    CLI   SCHARS(A1),C' '    IS THIS CHARACTER BLANK?
         BNE   TRIMD              SKIP IF WE FIND A NON-BLANK
         BCTR  A1,0               IF BLANK, BACK OFF POINTER
         BCTR  R1,R2              BACK TO TEST NEXT CHARACTER
         B     EXITNULL           RETURN NULL IF WE FALL THROUGH
*
*        COME HERE TO SETUP A NEW SPECIFIER FOR THE TRIMMED STRING
*
TRIMD    BCTR  R1,0               GET 360 LENGTH OF RESIDUAL STRING
         STH   R1,TRIMSV+SLENGTH  STORE IN LENGTH FIELD
         LM    A1,A1+1,TRIMSV     LOAD MODIFIED SPECIFIER
         B     EXIT               RETURN TO CALLER
TRIM     ENDFUNC ,                END OF TRIM FUNCTION
         TITLE 'SPITBOLF -- UNLOAD FUNCTION'
UNLOAD   FUNCTION  1              ENTRY POINT -- ONE ARGUMENT REQUIRED
         LM    A1,A1+1,TEM#1(PDR)           LOAD ARGUMENT
         BAL   RETURN,GETNAME     GET POINTER TO VARIABLE BLOCK
         XERR  01,100             ARGUMENT TO UNLOAD IS NOT THE NAME OF
*                                 A VARIABLE
         L     A1+1,=A($$NOFN-FCODE)        GET NEW FUNCTION ADDR=NOFN
         BAL   RETURN,OPSYN$      STORE NEW FUNCTION ADDRESS
         B     EXITNULL           RETURN NULL AS RESULT
UNLOAD   ENDFUNC ,                END OF UNLOAD FUNCTION
         TITLE 'SPITBOLF -- VALUE FUNCTION'
VALUE    FUNCTION  1,N            MAKE SURE NO CODE IN THIS MACRO
*
*        THE VALUE FUNCTION IS ESSENTIALLY A PECULIAR TYPE OF FFBLOK
*        WHICH ACCEPTS NAMES AS ARGUMENTS INSTEAD OF PROGRAM DATATYPES.
*        THE COMMENTS BELOW SHOW HOW THE INSTRUCTIONS IN THE VALUE
*        FUNCTION ARE ARRANGED SO THAT CONTROL PASSES CORRECTLY.
*
*        THIS FIRST INSTRUCTION SERVES NO PURPOSE EXCEPT TO MAKE THIS
*        LOOK LIKE AN FFBLOK WHEN THE DATA FUNCTION IS LINKING FFBLOKS
*
         CLI   TEM#1(PDR),DCODE   PRETEND WE ARE AN FFBLOK
*
*        WE CAN COME TO THE FOLLOWING LOCATION EITHER BY EXECUTING THE
*        ABOVE INSTRUCTION (WHEN THERE IS NO OTHER FIELD FUNCTION
*        CALLED VALUE), OR THE NEXT INSTRUCTION MAY BE THE SUBJECT OF
*        THE EXECUTE INSTRUCTION IN THE $$FLCN CIRCUIT. $$FLCN NORMALLY
*        EXPECTS AN LA INSTRUCTION IN THE LOCATION. SINCE VALUE IS
*        NOT A STANDARD FFBLOK, IT MUST RETAIN CONTROL IN THIS CASE.
*        THIS IS ACHEIVED BY THE BRANCH INSTRUCTION.
*
         B     *+4                MAKE SURE WE RETAIN CONTROL
*
*        NOW COMPUTE RESULT. THIS ESSENTIALLY DUPLICATES UNARY $
*
         LM    A1,A1+1,TEM#1(PDR) LOAD ARGUMENT
         CLI   TEM#1(PDR),MCODE   IS ARGUMENT A NAME?
         BE    VALUENM            SKIP IF SO
         ST    RETURN,RETLOC      ELSE SAVE RETURN LOCATION
         BAL   RETURN,GETNAME     CONVERT TO NAME
         XERR  01,049             THE ARGUMENT TO VALUE IS NOT A NAME
*                                 OR PROGRAM DEFINED DATATYPE.
         L     RETURN,RETLOC      IF OK, RELOAD RETURN POINT
         L     PDR,PDRLOC         RESTORE STACK POINTER
*
*        MERGE HERE WITH NAME IN (A1,A1+1)
*
VALUENM  CLC   0(4,RETURN),BFRVN  WAS THIS CALLED BY NAME?
         BE    VALUENN            SKIP IF SO
         AR    A1,A1+1            ELSE ADD OFFSET TO BASE ADDRESS
         LM    A1,A1+1,VALUE(A1)  LOAD VALUE
         BR    RETURN             AND RETURN TO CALLER
*
*        HERE IF VALUE FUNCTION WAS CALLED BY NAME
*
VALUENN  LA    RETURN,4(,RETURN)  BUMP RETURN PAST ERROR BRANCH
         BR    RETURN             RETURN WITH NAME IN (A1,A1+1)
VALUE    ENDFUNC   ,              END OF VALUE FUNCTION
         TITLE 'SPITBOLD -- START OF DSECT, SYSTEM AREA'
*        THE SPITBOLD DSECT IS THE MAIN DATA AREA ALLOCATED BY THE
*        SYSTEM INTERFACE. THE FIRST SECTION IS USED TO HOLD
*        STANDARD WORK AREAS AND ALTERABLE CONTANTS AS DESCRIBED BY
*        THE FOLLOWING PAGES, THE REMAINDER IS USED FOR DYNAMIC STORAGE
*
SPITBOLD DSECT ,                  START OF DSECT
*
*        THE FIRST FOUR BYTES ARE NOT USED BY THE SYSTEM INTERFACE
*        IN SPITBOL, A B $$DOIO INSTRUCTION AT THIS LOCATION ALLOWS
*        A TWO BYTE (BALR) INSTRUCTION LINKAGE TO THE I/O ROUTINES
*
         B     $$DOIO             TRANSFER TO EXECUTION I/O ROUTINE
*
*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE INTERFACE
*        WORK AREA. IT IS USED BY THE INTERFACE TO RELOAD THE POINTER
*
SYSCONS  EQU   *                  START OF SYSTEM CONSTANTS ETC.
WORKLOC  DS    F                  POINTER TO INTERFACE WORK AREA
*
*        THE FOLLOWING AREA IS USED TO SAVE ENTRY REGISTERS ON CALLS
*        TO THE SYSTEM INTERFACE, IT MAY BE USED FOR ANY OTHER
*        PURPOSE BETWEEN CALLS
*
SAVE1    DS    18F                REGISTER SAVE AREA
*
*        THE FOLLOWING AREA IS USED WHEN A PROGRAM CHECK OCCURS
*
SYSPSW   DS    D                  SAVE INTERRUPT PSW
SYSREGS  DS    12D                SAVE REG VALUES (0-15, FR0-FR6)
*
*        THE FOLLOWING LOCATIONS ARE INITIALIZED BY THE INTERFACE
*
DATASIZE DS    F                  TOTAL LENGTH OF DATA AREA
PRINTDCB DS    A                  POINTER TO DCB FOR SYSPRINT
PUNCHDCB DS    A                  POINTER TO DCB FOR SYSPUNCH
READDCB  DS    A                  POINTER TO SYSIN DCB
PGDEPTH  DS    F                  NUMBER OF LINES PER PAGE
STARTADR DS    A                  ADDRESS OF SYSSTART
INTFLAG  DS    A                  0/1 FOR PRECISE/IMPRECISE INTERRUPTS
LSYS     EQU   *-SYSCONS          LENGTH OF SYSTEM CONSTANTS
USERD    DS    0D                 START OF USER SECTION
*
*        THE FOLLOWING LOCATIONS CONTAIN THE ADDRESSES OF THE VARIOUS
*        SPITBOL CONTROL SECTIONS. THIS INFORMATION IS USED FOR
*        DEBUGGING AND BY THE DUMP AND SYSTEM RELOAD ROUTINES.
*
CSECTAD  DS    0F                 START OF CSECT ADDRESSES
SPITCAD  DC    A(SPITBOLC)        COMPILER
SPITRAD  DC    A(SPITBOLR)        ROOT PHASE
SPITPAD  DC    A(SPITBOLP)        PATTERN ROUTINES
SPITXAD  DC    A(SPITBOLX)        NON-ADDRESSABLE EXECUTION ROUTINES
SPITAAD  DC    A(SPITBOLA)        ADDRESSABLE EXECUTION ROUTINES, DATA
SPITFAD  DC    A(SPITBOLF)        STANDARD FUNCTION DEFINITIONS
SPITLAD  DS    A (SPITBOLL)       LOW CORE OF DATA AREA (RELOAD)
SPITHAD  DS    A (SPITBOLH)       HIGH CORE OF DATA AREA (RELOAD)
         TITLE 'SPITBOLD -- DATA AREA BASE REGISTER TABLE'
*
*        VARIABLE BLOCKS ARE ALLOCATED IN 4K SEGMENTS
*        THE FOLLOWING LOCATIONS CONTAIN POINTERS TO THE FIRST
*        THREE 4K BLOCKS. REGISTERS DB1,DB2,DB3 CONTAIN THESE VALUES
*        DURING EXECUTION OF GENERATED CODE
*
$$BAS1   DS    A                  LOCATION OF 1ST BLOCK (= DB1)
$$BAS2   DS    A                  LOCATION OF 2ND BLOCK (= DB2)
*
*        THE FOLLOWING ENTRY ($$BAS3) IS A SPECIAL CASE. THE UPPER BYTE
*        IS SET TO X'FF'. THIS IS BECAUSE I/O ASSOCIATIONS CAUSE
*        GENERATION OF THE INSTRUCTION BALR DB3,DB1, AND ALSO FAILURES
*        SOMETIMES BRANCH VIA DB1. THE NEGATIVE SETTING OF DB3 ALLOWS
*        THE CASES TO BE DISTINGUISHED (SEE TEST LOCATED AT $$DOIO)
*        NOTE THAT DB3 CAN HAVE THE VALUE OF ZERO EVEN AFTER A VALUE
*        HAS BEEN STORED IN $$BAS3 (AS A RESULT OF UNARY $). THIS
*        PRECLUDES THE USE OF MORE OBVIOUS TESTS SUCH AS C DB3,$$BAS3.
*
$$BAS3   DS    A                  LOCATION OF 3RD BLOCK (= DB3)
*
*        THE REMAINING LOCATIONS IN THIS TABLE ARE FILLED IN AS
*        THE BLOCKS ARE ALLOCATED AND THE APPROPRIATE VALUES LOADED
*        INTO THE FOURTH (VARIABLE) BASE REGISTER DB4 AS REQUIRED.
*
$$BAS4   DS    A                  LOCATION OF 4TH BLOCK
$$BAS5   DS    A                  LOCATION OF 5TH BLOCK
$$BAS6   DS    A                  LOCATION OF 6TH BLOCK
$$BAS7   DS    A                  LOCATION OF 7TH BLOCK
$$BAS8   DS    A                  LOCATION OF 8TH BLOCK
$$BAS9   DS    A                  LOCATION OF 9TH BLOCK
$$BAS10  DS    A                  LOCATION OF 10TH BLOCK
$$BAS11  DS    A                  LOCATION OF 11TH BLOCK
$$BAS12  DS    A                  LOCATION OF 12TH BLOCK
$$BAS13  DS    A                  LOCATION OF 13TH BLOCK
$$BAS14  DS    A                  LOCATION OF 14TH BLOCK
$$BAS15  DS    A                  LOCATION OF 15TH BLOCK
$$BAS16  DS    A                  LOCATION OF 16TH BLOCK
$$BAS17  DS    A                  LOCATION OF 17TH BLOCK
$$BAS18  DS    A                  LOCATION OF 18TH BLOCK
$$BAS19  DS    A                  LOCATION OF 19TH BLOCK
$$BAS20  DS    A                  LOCATION OF 20TH BLOCK
$$BAS21  DS    A                  LOCATION OF 21ST BLOCK
$$BAS22  DS    A                  LOCATION OF 22ND BLOCK
$$BAS23  DS    A                  LOCATION OF 23RD BLOCK
$$BAS24  DS    A                  LOCATION OF 24TH BLOCK
$$BAS25  DS    A                  LOCATION OF 25TH BLOCK
$$BAS26  DS    A                  LOCATION OF 26TH BLOCK
$$BAS27  DS    A                  LOCATION OF 27TH BLOCK
$$BAS28  DS    A                  LOCATION OF 28TH BLOCK
$$BAS29  DS    A                  LOCATION OF 29TH BLOCK
$$BAS30  DS    A                  LOCATION OF 30TH BLOCK
$$BAS31  DS    A                  LOCATION OF 31ST BLOCK
$$BAS32  DS    A                  LOCATION OF 32ND BLOCK
         TITLE 'SPITBOLD -- AREAS COMMON TO EXECUTION AND COMPILATION'
*
*        THE FOLLOWING BYTE CONTROLS COMMUNICATION TO COMMON COMPILE-
*        EXECUTE ROUTINES AND PROVIDES OTHER GLOBAL COMMUNICATIONS
*
STAGE    DS    X                  FLAGS AS BELOW
$COMPILE EQU   1                  WE ARE IN COMPILATION
$EXECUTE EQU   2                  WE ARE IN EXECUTION
$GBGCLF  EQU   4                  IF OUT OF ROOM, CALL GBGCLF
$OVERTIM EQU   8                  FLAG SET IF WE RUN OUT OF TIME
$CLEARFG EQU   16                 FLAG SET FOR CLEAR CALL TO VARLOC
*
*        SYSTEM CONSTANT ADDRESSES ETC.
*
TIME     DS    F                  SAVE VALUE OF TIMER
SCNTTSAV DS    F                  SAVE SCNT ON TIMER TRAP
DYNAMB   DS    A                  START OF DYNAMIC EXECUTION AREA
SUBEXBOT DS    A                  START OF CONSTANT EXPR CODE
SUBEXTOP DS    A                  END OF CONSTANT EXPR CODE
ESTACKS  DS    A                  END OF COMPILER WORK STACKS
HICINUSE DS    A                  START OF ALLOCATED HIGH CORE AREA
CONSCHAN DS    F                  PTR TO FREELIST OF CONSTANT BLOCKS
CURBASE  DS    H                  CURRENT OFFSET INTO BASE TABLE
BSTMNO   DS    H                  BINARY STATEMENT NUMBER
STMNO    DS    PL3                DECIMAL STATEMENT NUMBER
SUPRXEQ  DS    X                  SET NONZERO FOR ERROR, -NOERRORS ON
BYPASXEQ DS    X                  SET NONZERO FOR -NOEXECUTE OPTION
CRELFLG  DS    X                  #0 => GCOL MUST RELOCATE 'CONSTANTS'
*
*        THE FOLLOWING DATA AREA POINTERS ARE RELOCATED ON A RELOAD
*
FDRELOC  DS    0F                 ADDRESS OF FIRST DATA AREA POINTER
CODEADR  DS    A                  ADDRESS OF MAIN GENERATED CODE
TRAADR   DS    A                  LOC IN CODE FOR START OF EXECUTION
ENDCODAD DS    A                  ADDRESS OF END OF MAIN GENERATED CODE
DATACUR  DS    A                  POINTER TO CURRENT 4K BLOCK
HASHTBAD DS    A                  ADDR OF VARIABLE HASH TABLE - VLINK
HASHTBNS EQU   127                NUMBER OF SLOTS IN VARIABLE HASH TBL
HASHTBEN DS    A                  END OF HASH TBL (HASHTBAD+4*HASHTBNS)
NDRELOC  EQU   (*-FDRELOC)/4      NUMBER OF DATA AREA POINTERS
*
*        SAVE AREAS FOR VARLOC
*
VARLOCHS DS    D                  HASH WORK AREA IN VARLOC
VARLOCSV DS    4F                 SAVE ENTRY REGS IN VARLOC
VARLOCSL DS    A                  SAVE HASH SLOT LOCATION
VARLOCLK DS    2A                 SAVE VARLOC LINKAGE / ADDRESS
         EJECT
*
*        SAVE AREAS FOR GET4KBLK
*
GET4KSV  DS    2F                 SAVE R4,R5 IN GET4KBLK
GET4KLK  DS    A                  SAVE LINKAGE TO GET4KBLK
*
*        SAVE AREAS FOR HICORE
*
HICORESV DS    3F                 GENERAL REG SAVE
HICORPDR DS    A                  SAVE PDR IN HIGHCORE (CODE,EVAL CASE)
*
*        WORK AREAS FOR NUMERIC CONVERSION ROUTINES
*
STNWRK   DS    D                  WORK AREA FOR STGTONUM
NTSWRK   EQU   STNWRK             WORK AREA FOR NUMTOSTG
NTSWRK2  DS    D                  WORK AREA FOR NUMTOSTG
STNSV    DS    5F                 SAVE REGS IN STGTONUM
STNSV2   EQU   NTSWRK2            ADDTNL REG SAVE FOR STGTONUM
NTSSAV   EQU   STNSV              SAVE REGS FOR NUMTOSTG
NTSRTN   DS    A                  SAVE NUMTOSTG LINKAGE
STNRTN   EQU   NTSRTN             SAVE STGTONUM LINKAGE
NTSRSL   DS    CL22               RESULT AREA FOR NUMTOSTG
         DS    0H                 ALLIGN NTSFRM
NTSFRM   DS    X                  FORMAT NUMBER FOR NUMTOSTG
NTSDGS   DS    X                  NUMBER OF DIGITS FOR NUMTOSTG
STNFLG   DS    C                  FLAGS FOR STGTONUM
STNM     EQU   1                  FLAG FOR NEGATIVE MAGNITUDE
STND     EQU   2                  FLAG FOR DREAL RESULT
STNEM    EQU   4                  FLAG FOR NEGATIVE EXPONENT
*
*        THE FOLLOWING LOCATIONS ARE USED FOR OPERATORS WHICH ARE
*        NORMALLY UNDEFINED. WHEN ONE OF THESE OPERATORS IS DEFINED
*        USING OPSYN WITH A THIRD ARGUMENT, ITS CORRESPONDING ENTRY
*        IN THIS TABLE IS SET TO POINT TO THE APPROPRIATE FUNCTION.
*        BY DEFAULT, THESE LOCATIONS ARE INITIALIZED TO POINT TO THE
*        ERROR ROUTINE 'UNDEFOPR' IN SPITBOLA (SEE CODING FOR DETAILS).
*
OPTRTABL DS    0F                 START OF TABLE
$$SLS1   DS    A                  UNARY /
$$AMP2   DS    A                  BINARY &
$$NOT2   DS    A                  BINARY 
$$ATS2   DS    A                  BINARY @
$$BAR1   DS    A                  UNARY |
$$PND1   DS    A                  UNARY #
$$PND2   DS    A                  BINARY #
$$QUS2   DS    A                  BINARY ?
$$PCT1   DS    A                  UNARY %
$$PCT2   DS    A                  BINARY %
$$EXC1   DS    A                  UNARY EXCLAMATION
NOPTRS   EQU   (*-OPTRTABL)/4     NUMBER OF ENTRIES
         TITLE 'SPITBOLD -- EXECUTION AREAS REQUIRING INITIALIZATION'
*
*        THE FOLLOWING FOUR BYTES GET INSERTED INTO THE CODE FOR I/O
*        CALLS -- SEE IOASSOC ROUTINE FOR DETAILS
*
XEQVALS  DS    0F                 DEFINE START AND ALLIGN
IOASSCOD BALR  DB3,DB1            CALL TO I/O ROUTINE
         DS    XL2                SPACE FOR I/O CALL PARAMETERS
*
*        PATREGS -- INITIAL SETTINGS OF PATTERN MATCH REGS
*
ANCHMODE DC    X'00000000'        HIGH ORDER BIT SET ON FOR &ANCHOR = 1
SCANMODE DC    A(QPATSUBS)        SET TO FPATSUBS IF &FULLSCAN = 1
*
*        DATA TO BUILD ANY,NOTANY PATTERN
*
ANYTPTR  DC    A(0)               POINTER TO CURRENT ANY TABLE
ANYMASK  EQU   *+1                LOCATION OF BIT MASK
         TM    CTCHARS(R2),0      ANYMASK=0 AT START TO FORCE NEW TABLE
ANYPARAM EQU   ANYTPTR            PARAMS FOR ANY,NOTANY BLOCK
*
*        THE FOLLOWING LA INSTRUCTIONS ARE USED TO ACQUIRE S ADDRESSES
*
FTRCLA   LA    DB2,*-*            USED BY THE TRACE ROUTINES
GBGLA    EQU   FTRCLA             LA GR1,*-* (GR1=DB2) USED BY GCOL
*
*        COUNT OF GARBAGE COLLECTIONS
*
GCOLCNT  DC    PL3'-1'            COUNT OF GARBAGE COLLECTIONS
*                                 FUDGED TO NOT COUNT CALL IN ECONC
*
*        IF THE FOLLOWING BYTE IS NON-ZERO, THE GARBAGE COLLECTOR WILL
*        RETURN TO ITS CALLER EVEN IF IT WOULD NORMALLY FAIL
*
CLLCTFL  DC    X'00'              SET BY COLLECT FUNCTION
*
*        STARTING VALUE OF SCNT STATEMENT COUNT REG
*
STSTART  DC    X'7FFF3CAF'        = OVERFLOW - 50000
*
*        THE FOLLOWING ERROR CALL IS FOR SYSTEM ERRORS (MAJOR=12)
*        THE MINOR CODE IS RETURNED BY THE INTERFACE AND FILLED IN
*
SYSERCOD DS    F                  SYSTEM ERROR CALL (XERR *-*,*-*)
*
LXEQVALS EQU   *-XEQVALS          LENGTH OF ABOVE VALUES
         EJECT
*
*        VALUES OF KEYWORD VARIABLES
*
V$FNCLEV DC    F'0'               VALUE OF &FNCLEVEL
V$TRACE  DC    F'0'               VALUE OF &TRACE
V$FTRACE DC    F'0'               VALUE OF &FTRACE
V$ABEND  DC    F'0'               VALUE OF &ABEND
V$CODE   DC    F'0'               VALUE OF &CODE
V$DUMP   DC    F'0'               VALUE OF &DUMP
V$ERRLIM DC    F'0'               VALUE OF &ERRLIMIT
V$INPUT  DC    F'1'               VALUE OF &INPUT
V$OUTPUT DC    F'1'               VALUE OF &OUTPUT
V$TRIM   DC    F'0'               VALUE OF &TRIM
V$MAXLN  DC    F'5000'            VALUE OF &MAXLNGTH
V$STLIM  DC    F'50000'           VALUE OF &STLIMIT
V$ANCHOR DC    F'0'               VALUE OF &ANCHOR
V$SCAN   DC    F'0'               VALUE OF &FULLSCAN
V$ERRTYP DC    F'0'               VALUE OF &ERRTYPE
V$STCNT  DC    F'0'               SPECIAL VALUE USED WITH &STCOUNT
V$RETYPE DC    X'00'              VALUE OF &RTNTYPE (048-RET,FRET,NRET)
LKEYS    EQU   *-V$ABEND          LENGTH OF KEYWORD VALUES
         EJECT
*
*        LINKAGE SAVE LOCATIONS
*
*        THE FOLLOWING LOCATIONS ARE USED AT EXECUTION TIME TO SAVE
*        LINKAGE LOCATIONS. SOME OR ALL OF THESE VALUES MAY POINT TO
*        CODE IN DYNAMIC MEMORY AND THUS REQUIRE RELOCATION.
*
*        THEY MUST BE SET ZERO AT THE START OF EXECUTION AND IN ECONC
*        TO STOP THE COLLECTOR FROM RELOCATING GARBAGE VALUES
*
LINKLOCS DS    0D                 START OF LINKAGE SAVE LOCATIONS
*
FRETLOC  DS    F                  SAVE FRETURN
RETLOC   DS    F                  SAVE RETURN (MUST FOLLOW FRETLOC)
*
SETXTFRT DS    F                  SAVE FRETURN FROM LAST ERROR (D BDRY)
SETXTRET DS    F                  SAVE RETURN FROM LAST ERROR
*
DOLLSAV  DS    F                  SAVE RETURN POINT TO UNARY $ ROUTINE
*
CRETSAVE DS    F                  SAVE RETURN POINT TO CONCATENATION
*
PRETLOC  DS    F                  SAVE RET POINT TO PATTERN CONCAT
*
WRETLOC  DS    F                  SAVE RETURN POINT TO WRITE ROUTINE
*
*        THE FOLLOWING LOCATION IS USED TO SAVE THE VALUE OF RETURN
*        ON ENTRY TO A STATEMENT INVOLVING A KEYWORD REFERENCE.
*        RETURN ALWAYS POINTS TO THE LAST STATEMENT EXECUTED.
*        THIS ALLOWS THE VALUE OF THE KEYWORD &LASTNO TO BE OBTAINED.
*
$$LAST   DS    F                  SAVE RETURN
*
*        THE FOLLOWING LOCATION IS USED TO HOLD THE CODE ADDRESS IN
*        SITUATIONS WHERE RETLOC IS SET WRONG ON ENTRY TO THE
*        ERROR MESSAGE ROUTINE. IT MUST BE RESET TO ZERO WHEN
*        THE ROUTINE REQUIRING IT TERMINATES.
*
ALTLOC   DS    F                  ALTERNATE CODE RETURN LOCATION
*
ENDLINKS EQU   *                  END OF LINKAGE LOCATIONS
         TITLE 'SPITBOLD -- EXECUTION AREAS CONTAINING PERMANENT INFO'
*
*        THE FOLLOWING AREAS ARE USED AT EXECUTION TIME AND SAVE
*        VALUES WHICH MUST BE KEPT AROUND. HENCE THEY CANNOT
*        BE OVERLAPPED WITH THE COMPILER WORK AREAS SINCE CALLS
*        TO THE CODE FUNCTION OR EVAL WOULD DESTROY THEM
*        ALL THESE AREAS ARE CLEARED TO ZERO AT THE START OF EXECUTION
*
PERMWORK DS    0D                 ALLIGN
*
*        SAVE LOCATIONS FOR PATTERN,STRING CONSTRUCTION OPTIMIZATION
*        BY REMEMBERING INFORMATION ABOUT THE LAST STRING OR PATTERN
*        BUILT, TIME CAN BE SAVED IN BUILDING STRUCTURES
*
SCNTSAVE DS    F                  SCNT WHEN LAST PATTERN WAS BUILT
PCFRSAVE DS    F                  SAVE FR VALUE WHEN SCNT WAS SAVED
*
CONCFRSV DS    3F                 FR,A1,A1+1 FOR LAST STRING BUILT
*
*        LOCATION OF VARIABLE BLOCK FROM MOST RECENT SETEXIT CALL
*        LABEL IN BLOCK IS EXIT ADDRESS FOR EXECUTION ERROR
*
EXITLOC  DS    F                  INITIAL VALUE = ZERO = NO INTERCEPT
*
*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE CURRENT
*        PDR FOR THIS LEVEL. THIS MAY BE DIFFERENT FROM THE
*        ACTUAL VALUE OF PDR WHEN A FUNCTION CALL PUSHES PDR
*        OR WHEN AN EXPANSION OF THE PATTERN MATCHING STACK OCCURS
*
PDRLOC   DS    A                  POINTER TO CURRENT STACK LEVEL
*
*        THE FOLLOWING LOCATIONS ARE POINTERS TO TRBLOKS USED FOR
*        FUNCTION CALL AND RETURN TRACING, AND TRACING OF THE KEYWORDS
*        &STCOUNT,&ERRTYPE, AND &FNCLEVEL.  THE KEYWORD LOCATIONS
*        CAN INDICATE A TRACE WITHOUT A TRBLOK (NO 4TH ARGUMENT) IF
*        THE CORRESSPONDING LOCATION IS NEGATIVE
*
FCTRCCHN DS    F                  HEAD OF CHAIN FOR CALL TRACING
*
FRTRCCHN DS    F                  HEAD OF CHAIN FOR RETURN TRACING
*
FNCLTRC  DS    F                  FLAG/POINTER FOR &FNCLEVEL TRACE
*
STCNTTRC DS    F                  FLAG/POINTER FOR &STCOUNT TRACE
*
ETYPTRC  DS    F                  FLAG/POINTER FOR &ERRTYPE TRACE
*
LPERMWRK EQU   *-PERMWORK         LENGTH OF AREA (CLEARED TO ZERO)
         TITLE 'SPITBOLD -- COMPILER WORK AREAS'
*
*        THE FOLLOWING WORK AREAS ARE USED AT COMPILE TIME OR DURING
*        A CALL TO THE CODE FUNCTION, THEY ARE OVERLAYED BY SOME
*        OF THE EXECUTION WORK AREAS
*
COMPWORK EQU   *                  START OF COMPILER AREAS
*
*        WORK AREAS FOR COMPILATION CONTROL CIRCUIT
*
         DS    0D                 ALLIGN
RITESIDE DS    A                  BLOCK PTR FOR RIGHT SIDE EXPR
LEFTSIDE DS    F                  BLOCK PTR FOR LEFT SIDE EXPR
FGOTO    DS    A                  BLOCK PTR FOR FAILURE GOTO EXPR
UNCONDF  EQU   X'01'              FLG SET IN UPPER BYTE OF FGOTO FOR
*                                 UNCONDITIONAL GOTO WITH -NOFAIL SET
SGOTO    DS    A                  BLOCK PTR FOR SUCCESS GOTO EXPR
NGOTOFLG EQU   X'02'              FLAG SET IN UPPER BYTE OF SGOTO,FGOTO
*                                 FOR NORMAL (NOT DIRECT) GOTO
FGOINAD  DS    F                  SAVE CODE LOC FOR FGOTO GENERATION
CMPILBLK DS    3F                 SPACE TO BUILD BINARY OPTR BLOCK
GOSCANSV DS    2F                 SAVE CALLING REG IN GOSCAN
STMCODE  DS    A                  LOC OF START OF CODE FOR STMNT
FAILFLAG DS    X                  SET TO X'FF' FOR LA TYPE FGOTO
FRETOPT  DS    X                  1 IF LR FRETURN,SYS IN EFFECT
*                                 2 IF LR FRETURN,DB1 IN EFFECT
*                                 0 IF NEITHER IN EFFECT
PREDFUNC DS    X                  NON-ZERO IF PREDICATE FUNCTION REF
*
*        WORK AREAS FOR SCAN
*
SCANWRK  DS    D                  GENERAL SCRATCH AREA
FLAGLOC  DS    A                  LOCATION FOR ERROR FLAG
SCANLOC  DS    A                  CURRENT SCAN POINTER
SCANAD   DS    A                  ADDRESS RETURNED BY SCAN
LABSAVE  DS    A                  SAVE LABEL LOC FOR & SPECIAL CODE
SCANHSV  DS    4F                 SAVE REGS IN SCAN HASH ROUTINE
STOPLOC  DS    F                  LOCATION OF X'00' END OF CARD CHAR
SCANFL   DS    X                  SAVE TYPE OF SCANNED ITEM
SCANCHR  DS    C                  SAVE CHARACTER BEFORE SCANNED ITEM
GOTOFLG  DS    X                  FLAG TO PERMIT DETECTION OF S( & F(
NUMTYPE  DS    C                  SAVE TERMINATOR TYPE IN SCANNUM
RESCAN   DS    X                  SET NON-ZERO TO OBTAIN RESCAN
AMPFLAG  DS    X                  FLAG FOR & CODE GENERATED
*
*        WORK AREAS FOR EXPAN
*
EXPSAV   DS    4F                 SAVE ENTRY REGS
EXPINIT  DS    A                  ADDRESS OF AREA TO BUILD BLOCKS
WRKSTKAD DS    A                  ADDRESS OF EXPAN OPERATOR STACK
         DS    A                  ADDRESS OF EXPAN POINTER STACK
EXPNUMBR DS    H                  STORES 200 - NUM OF ITEMS IN EXPR
STATE    DS    X                  CURRENT EXPAN STATE
PATFLG   DS    X                  SET NONZERO FOR PATTERN MATCH
         EJECT
*
*        WORK AREAS FOR CODGEN
*
CONCODAD DS    F                  SAVE LC BEFORE GENERATING CONS CODE
CONSTAK  DS    F                  SAVE STACK PTR OVER CONS EXPR
CALSDSV  DS    3F                 SAVE REGS IN CALCSAD
LASTOPN  DS    A                  PTR TO SAVE VALUE LOADED INTO A1,A1+1
LASTNOP  DS    A                  ADDR OF LAST NOP'S GENERATED
OLDBASE  DS    H                  SAVE DB4 VALUE (OFFSET INTO BASE TBL)
SOLDBASE DS    H                  SAVE OLDBASE OVER CONS EXPR
AUR$     AUR   SCNT,SINC          AUR AT START OF EACH STATEMENT
*                                 OPCODE SET TO X'3D' FOR -CODE ON
CONGEN   DS    X                  SET NONZERO FOR CONSTANT EXPR
*
*        WORK AREAS FOR CONTROL CARD PROCESSOR
*
CONCSAV  DS    2F                 SAVE ENTRY REGISTERS
*
*        WORK AREAS FOR INPUT AND OUTPUT ROUTINES
*
LASTSEQ  DS    D                  LAST SEQUENCE NUMBER
IOHOLD   DS    4F                 SAVE REGS OVER I/O CALL
SYSAVE   DS    5F                 SAVE REGS OVER SYS INTERFACE CALL
MAXCOPY  EQU   4                  MAX NESTING LEVELS (-COPY)
INPUTDCB DS    (MAXCOPY+1)A       STACK FOR INPUT FILE POINTERS
RDDCBOFS DS    H                  OFFSET INTO INPUTDCB STACK
LINELEFT DS    H                  NUMBER OF LINES LEFT ON PAGE
ERRFLG   DS    X                  FLAG FOR ERROR INSIDE ERROR DETECT
FATAL    DS    X                  FLAG FOR FATAL ERROR
PAGENO   DS    PL2                CURRENT PAGE NUMBER
OUTTITB  DS    C'1'               PAGE TITLE BUFFER
OUTITLE  DS    CL66               TITLE AREA
         DC    CL36' '            FILLER
         DS    C'PAGE '           PAGE NUMBER CAPTION
OUTPAGE  DS    CL3                SPACE FOR PAGE NUMBER
         DS    C'0'               CONTROL CHARACTER FOR SUBTITLE
OUSTITL  DS    CL66               SUBTITLE
INBUF    DS    CL80               INPUT BUFFER
         DS    X                  ROOM FOR SCAN TERMINATE CHAR -IN80
EOF      DS    X                  FLAG FOR END OF FILE
         DS    0F                 ALLIGN FOR CODSVREG EQUATE
         DS    C' '               CONTROL CHAR FOR OUTPUT BUFFER
BUFR     DS    CL133              OUTPUT BUFFER
         ORG   BUFR+6+72+2        POSITION TO SERIALIZATION FIELD
SERIAL   DS    CL8                SERIALIZATION FIELD (-IN72)
         ORG   BUFR+133           POSITION PAST BUFFER
*
*        SAVE AREAS FOR EXECUTE TIME ENTRY TO COMPILER
*
CODSVREG DS    16F                SAVE AREA FOR REGS
CODXSW   DS    X                  =ECODE,CCODE -- CONVERT TO EXPR, CODE
CODEOS   DS    X                  SET NON-ZERO AT END OF STRING
         EJECT
*
*        SAVE AREAS FOR ACCUMULATION OF STATISTICS
*
STRUSED  DS    F                  BYTES USED FOR STRINGS
VARUSED  DS    F                  BYTES USED FOR VARIABLE BLOCKS
CONUSED  DS    F                  BYTES USED FOR CONSTANTS
ERRCOUNT DS    PL3                COUNT OF COMPILATION ERRORS
*
*        SAVE AREAS FOR CODE LISTER (PRCODE)
*
PRWRK    DS    D                  GENERAL SCRATCH AREA
PRLOCSV  DS    A                  SAVE CODE LOC WHILE PRINTING EXPRS
CEXPCNT  DS    F                  COUNT OF CONSTANT EXPRESSIONS
VEXOFS   DS    H                  OFFSET TO END OF EXPRESSION QUEUE
VEXPTR   DS    H                  POINTER TO CURRENT ITEM IN EXPR STK
LADR     DS    A                  POINTER INTO LABEL STACK
CODBASE  DS    A                  SAVE CURRENT DB4 VALUE
VEXNUM   DS    H                  NUMBER OF CURRENT EXPR BEING PRINTED
LCNT     DS    PL3                LABEL COUNT
*
*        SETTINGS FOR CONTROL CARD SWITCHES
*
SWITCHES EQU   *                  START OF SWITCHES
CODESW   DS    X                  SET NON-ZERO FOR -CODE
DUBLFLG  DS    X                  SET NON-ZERO FOR -DOUBLE
FAILSET  DS    X                  SET NON-ZERO FOR -FAIL
IN72     DS    X                  SET NON-ZERO FOR -IN72
LISTSW   DS    X                  SET NON-ZERO FOR -LIST
NOXEQE   DS    X                  SET NON-ZERO FOR -NOERRORS
OPTFLAG  DS    X                  SET NON-ZERO FOR -OPTIMIZE
PRINFLG  DS    X                  SET NON-ZERO FOR -PRINT
SEQFLG   DS    X                  SET NON-ZERO FOR -SEQUENCE
LSWITCH  EQU   *-SWITCHES         LENGTH OF SWITCHES
         TITLE 'SPITBOLD -- VOLATILE EXECUTION WORK AREAS'
*
*        THE FOLLOWING LOCATIONS ARE USED BY VARIOUS EXECUTION ROUTINES
*        WHILE THEY ARE EXECUTING. SINCE NO PERMANENT VALUES ARE
*        STORED, THESE AREAS MAY OVERLAP THE COMPILER WORK AREAS
*
         ORG   COMPWORK           OVERLAY COMPILER AREAS
*
*        SAVE AREAS FOR GET (TYPE CONVERT) ROUTINES
*
GETSVV   DS    D                  SAVE ARG TO CVNUM + OTHER USES
GETSV    DS    2F                 SAVE ARGUMENT ON ENTRY
GETPATSV DS    2F                 SAVE DB2,DB3 IN GETPAT
GETPSV   DS    2F                 SEVERAL USES IN GETPAT
*
*        SAVE AREAS FOR LPAD,RPAD
*
PADCHAR  DS    C                  SAVE PAD CHARACTER
*
*        SAVE AREAS FOR TRIM FUNCTION
*
TRIMSV   DS    2F                 SAVE ARGUMENT TO TRIM
*
*        SAVE AREAS FOR ARITHMETIC OPERATOR ROUTINES
*
ARITHSV  DS    2D                 SAVE ARGUMENTS + OTHER USES
*
*        SAVE AREAS FOR MPBLOK (CONSTRUCT PATTERN BLOCK)
*
PBLOKSW  DS    X                  SET TO X'00' FOR RETURN TO CODE
*
*        SAVE AREAS FOR IDENT
*
IDNTSV   DS    2D                 SAVE IDENT ARGUMENTS
*
*        SAVE AREAS FOR CONCATENATION ROUTINE
*
CONCATSF DS    F                  SAVE FR (+4 = CONCATSV)
CONCATSV DS    4F                 SAVE ARGUMENTS
PATFLAG  DS    X                  FF=CONCATENATION, 00=ALTERNATION
PATCNLN  DS    H                  SAVE LENGTH OF LEFT PATTERN
*
*        SAVE AREAS FOR PATTERN REPLACEMENT
*
PART1    DS    2F                 UNMATCHED INITIAL STRING SPEC
PART2    DS    2F                 REPLACEMENT STRING
*
*        SAVE AREAS FOR ETEST (USED BY BREAK,SPAN ETC.)
*
ETESTSV  DS    F                  STORE ARGUMENT
*
*        SAVE AREAS FOR PATTERN MATCHING
*
FRSAVE   DS    F                  SAVE FR VALUE DURING PATTERN MATCH
         EJECT
*
*        SAVE AREAS FOR $EVAL
*
EVALSV   DS    F                  STORE RESULT OF UNEVAL EXPR (TYPETST)
EVALVAR  DS    F                  SAVE VARBLK ADDR FOR PATTERN MATCH IO
*
*        SAVE AREAS FOR $ (INDIRECT ADDRESSING) ROUTINE
*
DOLLFLG  DS    X                  FLAGS FOR CALL
$BYVAL   EQU   1                  CALL BY VALUE
$BYNAM   EQU   2                  CALL BY NAME
$GETNM   EQU   4                  CALL FROM GETNAME
DOLLWORK DS    F                  WORKAREA FOR UNARY DOLLARS
*
*        SAVE AREAS FOR READ
*
READSAVE DS    2F                 SAVE A2,A2+1 OVER CALL
READFLG  DS    X                  =1=>RETURN RESULT IN A1,A1+1, ELSE A2
*
*        SAVE AREAS FOR WRITE
*
WDB4SAV  DS    F                  SAVE DB4 OVER WRITE CALL
*
*        SAVE AREAS FOR DEFINE
*
FMOD     DS    X                  DISTINGUISH BETWEEN LOCALS,ARGS
FCONCST  DS    3F                 SAVE MISC REGS
         EJECT
*
*        SAVE AREAS FOR KEYWORD ACCESS ROUTINES
*
KGETSV   DS    F                  USED TO LOAD &STCOUNT
*
*        SAVE AREAS FOR DATATYPE ROUTINE
*
DATATSV  DS    F                  SAVE ARG TO CHECK DATATYPE
*
*        DATA AREAS FOR XSCAN (EXECUTION SCAN ROUTINE)
*
XSCANSV  DS    2F                 SAVE LENGTH LEFT, LOCATION
XSCANFLG DS    X                  FLAGS AS FOLLOWS
XSIGNRO  EQU   1                  IGNORE RUNOUT (I.E. RUNOUT OK)
XSIGNGN  EQU   2                  INHIBIT CALL TO GETNAME
*
*        SAVE AREAS FOR TABLE, ARRAY REFERENCE ROUTINES
*
         DS    0D                 ALLIGN FOLLOWING CONSTANTS FOR LM,STM
SRETFSV  DS    F                  SAVE FRETURN IN TABLE ROUTINE
SRETSV   DS    F                  SAVE RETURN (MAY BE RELOCATABLE)
SUBSCSV  DS    4F                 SAVE ARG + OTHER USES
TBLSV    DS    F                  COMPUTE TABLE HASH, SAVE TABLE ADDR
NAMEFL   DS    X                  00 = BY NAME, FF = BY VALUE
*
*        SAVE AREAS FOR CONVERT FUNCTION
*
CVTSAVE  DS    F                  TABLE PTR FOR CONVERT TO TABLE
CVTEND   DS    F                  END OF ARRAY PTR, CONVERT TO TABLE
         EJECT
*
*        SAVE AREAS FOR REPLACE
*
REPSV    DS    X                  SAVE LENGTH FOR EVEN/ODD LENGTH TEST
*
*        SAVE AREAS FOR TRACE,ERROR,EXIT ROUTINES
*
STOPSV   DS    D                  USED FOR NUMERIC CONVERSIONS
DTESAVE  DS    4F                 SAVE REGS IN LINETERM
LINESV   DS    3F                 SAVE REGS OVER LINEVAL
LINEIDSV DS    3F                 SAVE CALLING REGS IN LINEID
FUNCSAVE DS    F                  SAVE FUNC BLOCK ADDR OVER CALL TRACE
TRCSVDB4 DS    F                  SAVE DB4 OVER LABEL TRACE CALL
*
*        SAVE AREAS FOR DUMP FUNCTION
*
DMPSV1   DS    F                  SAVE SUBSCRIPT VALUES + OTHER USES
DMPBSAV  DS    F                  SAVE BLK ADDR WHEN GOING THROUGH CORE
DMPARG   DS    X                  SAVE ARGUMENT TO DUMP FUNCTION
VARCHAIN DS    F                  POINTS TO SORTED CHAIN OF VAR BLKS
DMNAMSV  DS    F                  SAVE VAR BLK ADDR FOR NAMED ARRAY/TBL
*
*        SAVE AREAS FOR TBCHRON
*
TBCHRSV  DS    F                  POINT TO CHRONOLOGICAL LIST OF TBL EL
*
*        SAVE AREAS FOR OPSYN$
*
OPSYNSV  DS    2F                 SAVE A1,A1+1 OVER SYSUNLOD CALL
*
*        SAVE AREAS FOR GARBAGE COLLECTOR
*
         DS    0D                 ALLIGN FOLLOWING 2 WORDS FOR STD
GPCHAIN  DS    F                  PTR TO CHAIN OF PATTERN EXPR PTRS
GECHAIN  DS    F                  PTR TO CHAIN OF ECODE EXPR PTRS
PASS3S   DS    F                  POINTER TO CHAIN OF BLOCKS IN USE
GCOLSV   DS    16F                SAVE ALL REGS ON ENTRY
GCOLNRG  DS    X                  FLAGS AS FOLLOWS --
GRELOC1  EQU   X'01'              ON => RELOCATE (A1,A1+1)
GRELOC2  EQU   X'02'              ON => RELOCATE (A2,A2+1)
GGBGCLF  EQU   X'04'              ON => GBGCLF CALL
GCMPRSS  EQU   X'08'              ON => SPECIAL COMPRESSION PROCEDURE
LABRLFLG DS    X                  FLAG FOR RELOCATABLE LABELS PRESENT
*
*        SAVE AREAS FOR NUMERICAL, LEXICAL COMPARISON FUNCTIONS
*
CMPRSAVE DS    F                  SAVE RETURN POINT
*
*        SAVE AREAS FOR PATSET (USED BY LEN,POS,TAB,RTAB,RPOS)
*
PATSETSV DS    F                  SAVE ARGUMENT TO TEST IT
         EJECT
*
*        SAVE AREAS FOR EXTERNAL FUNCTION CALL CIRCUIT
*
LOADF0   DS    D                  STORE FR0 ON RETURN (POSSIBLE RESULT)
LOADF1   DS    E                  SAVE SCNT OVER EXTERNAL FUNCTION CALL
LOADSW   DS    X                  00 DURING ARGS, FF DURING RESULT SCAN
*
*        SAVE AREAS FOR DUPL FUNCTION
*
DUPLSAV  DS    2F                 SAVE STRING POINTER
*
*        WORK AREA TO BUILD OUT OF LINE CODE FOR USE IN DOLLAR/DOT RTNS
*
DOLDOTX  BAL   R1,MPBLOK          CALL TO MAKE PATTERN BLOCK ROUTINE
         DS    CL6                PARAMS FILLED IN BEFORE USE
         B     DOLDOTR            RETURN TO INLINE CODE
*
*        THE FOLLOWING TABLE AREA SERVES A DUAL PURPOSE --
*
*        1)    THE 256 BYTES AT ZTBL ARE NORMALLY ALL ZERO AND ARE
*              USED FOR VARIOUS PURPOSES AS SUCH. THE TABLE IS ALSO
*              USED AS A TRT TABLE BY PLUGGING SELECTED CHARS
*              (SEE XSCAN). IN THE LATTER CASE, CARE MUST BE TAKEN TO
*              ENSURE THAT THE TABLE IS CORRECTLY UNPLUGGED,
*              ESPECIALLY IN THE CASE OF A SETEXIT ERROR TRAP.
*
*        2)    THE ENTIRE 511 BYTE AREA IS USED AS A MASTER BREAK
*              TABLE IN WHICH ALL BREAK TABLES FOR ONE CHARACTER ARE
*              ALLOCATED. FOR THIS PURPOSE, THERE ARE 255 ZEROS,
*              FOLLOWED BY A SINGLE NONZERO BYTE, FOLLOWED BY
*              255 ADDITIONAL ZERO BYTES. THE CORRECT TABLE
*              ADDRESS FOR THE CHARACTER X IS (BREAKTBL-X)
*
         ORG   ,                  POSITION TO HIGHEST POINT
         DS    0D                 ALLIGN FOR FAST COPIES
ZTBL     DS    XL256'00'          256 BYTES OF ZEROS
*
*        THIS IS THE REFERENCE POINT FOR THE MASTER BREAK TABLE
*
BREAKTBL EQU   *-CTCHARS          SUPPLY THE PROPER TBLOK OFFSET
         DC    X'FF'              ONE NON-ZERO BYTE
         DC    256X'00'           256 ADDITIONAL ZERO BYTES
*
*        THE ABOVE TABLES ARE ALSO USED AT COMPILE TIME AS FOLLOWS
*
SCANTB4  EQU   BREAKTBL+1         LITERAL SCAN TBL, ' " ENTRIES PLUGGED
CHASH    EQU   ZTBL               HASH TABLE FOR CONSTANTS (SEE SCAN)
         TITLE 'SPITBOLD -- WORK AREAS FOR OBJECT MODULE GENERATOR'
*
*        THE FOLLOWING AREAS ARE USED DURING GENERATION OF OBJECT
*        MODULES AND CAN OVERLAP OTHER VOLATILE AREAS
*
         ORG   COMPWORK           OVERLAY COMPILER AREAS
OBJDCB   DS    A                  ADDR OF SYSOBJ FILE
OBJBUFR  DS    CL80               OUTPUT BUFFER FOR OBJECT MODULE
OBJSER   DS    PL4                SERIALIZATION COUNTER
OBJWSAV  DS    6F                 SAVE REGS IN OBJWRITE
         TITLE 'SPITBOLD -- END OF DSECT'
*
*        THE REST OF THE FIRST 4K IS USED TO STORE VARIABLES AND
*        CONSTANTS. DATABGN SHOWS THE START OF THE AVAILABLE AREA
*
         ORG   ,                  REPOSITION TO HIGHEST LOC IN SPITBOLD
         ORG   (*-SPITBOLD+31)/32*32+SPITBOLD ADJUST TO 32 BYTE BDRY
DATABGN  EQU   *                  START OF AREA AVAILABLE FOR VARS/CONS
*
*        THE FOLLOWING DEFINITIONS GIVE THE LOCATIONS OF THE FIRST
*        THREE VARIABLE BLOCKS WHICH ARE ALWAYS CONSTRUCTED.
*
         ORG   *-VALUE            ADJUST FOR VALUE OFFSET
B$INPUT  DS    (VARSIZ)X          BLOCK FOR INPUT
B$OUTPUT DS    (VARSIZ)X          BLOCK FOR OUTPUT
B$PUNCH  DS    (VARSIZ)X          BLOCK FOR PUNCH
         END   ,                  END OF EVERYTHING
