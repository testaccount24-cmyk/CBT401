         TITLE 'OSINT -- OS INTERFACE -- DESCRIPTION'
*
*        O    S    I    N    T
*        ---------------------
*
*        GENERAL INTERFACE FOR OS/360
*
*        VERSION 2.3
*
*        ROBERT B. K. DEWAR
*        KENNETH E. BELCHER
*        ILLINOIS INSTITUTE OF TECHNOLOGY
*
*    COPYRIGHT (C) 1971, 2001 ROBERT B. K. DEWAR AND KENNETH E. BELCHER
*
*        NEITHER AUTHOR IS CURRENTLY ASSOCIATED WITH ILLINOIS
*        INSTITUTE OF TECHNOLOGY. FOR CURRENT INFORMATION ABOUT
*        ABOUT SPITBOL 360 VISIT HTTP://WWW.SNOBOL4.COM
*        --------------------------------------------------------------
*
*
*        THIS FILE IS PART OF SPITBOL 360
*
*        SPITBOL 360 IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
*        MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE
*        AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2
*        OF THE LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.
*
*        SPITBOL 360 IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
*        BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
*        MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
*        GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
*
*        YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC
*        LICENSE ALONG WITH SPITBOL 360; IF NOT, WRITE TO THE FREE
*        SOFTWARE FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330,
*        BOSTON, MA  02111-1307  USA
*
*        -------------------------------------------------------------
*
*
*        CHANGE LOG:
*
*        2.3   8/14/2001 BOB GOLDBERG
*
*              PREPARED SOURCE FOR GPL DISTRIBUTION:
*              - UPDATED COMMENTS
*              - APPLIED TFS 1 TO 6 TO SOURCE (OS MACROS PRODUCE
*                DIFFERENT CODE NOW THAN IN '71; OFFSETS CHANGED)
*              - FIXED CONDITIONAL BRANCHES USED TO ABORT EXECUTION
*                AFTER EXPIRATION OF TRIAL VERSION (1999 = Y2K-1 BUG)
*        --------------------------------------------------------------
*
*
*        THIS PROGRAM PROVIDES A RANGE OF EASILY USEABLE ENTRY
*        POINTS FOR SYSTEM FUNCTIONS AND ALLOWS A PROGRAM TO BE
*        WRITTEN IN AN ESSENTIALLY SYSTEM INDEPENDENT MANNER.
*        IT WAS ORIGINALLY WRITTEN FOR USE WITH SPITBOL/360 BUT
*        NO PART DEPENDS ON THIS USE, SO OTHER USES ARE POSSIBLE
*
*        THE FOLLOWING PAGES DESCRIBE THE REQUIREMENTS FOR
*        OPERATING UNDER CONTROL OF THE INTERFACE. NOTE THE GENERAL
*        REQUIREMENT THAT NO SYSTEM MACRO CALLS ARE TO BE USED.
         TITLE 'OSINT -- OS INTERFACE -- SYSTEM PARAMETERS'
*
*        ON ENTRY TO OSINT FROM THE CONTROL PROGRAM, A PARAMETER
*        FIELD MAY BE PROVIDED. THE PARAMETER FIELD IS OF THE FORM --
*
*        'X=NNN,X=NNN,X=NNN,...'
*
*        WHERE X ARE THE CHARACTERS INDICATING THE PARAMETER TYPE
*        AND NNN ARE THE ASSIGNED VALUES. NNN IS EITHER AN UNSIGED
*        OR AN UNSIGNED INTEGER FOLLOWED BY K TO INDICATE
*        MULTIPLICATION BY 1024. THE FOLLOWING IS A LIST OF PARAMETERS
*
*        NAME  DEFAULT            MEANING
*        ----  -------            -------
*
*        R     8K                 MEMORY TO BE RESERVED TO SYSTEM
*        L     16K                MINIMUM ACCEPTABLE DATA AREA SIZE
*        H     1000K              MAXIMUM DATA AREA TO BE ALLOCATED
*        T     55                 TIME LIMIT IN SECONDS
*        P     100000             PAGE LIMIT (1 PAGE = N LINE RECORDS)
*        C     100000             CARD LIMIT (SYSPUNCH)
*        D     10                 MAX NUMBER OF OSINT DUMPS
*        N     58                 NUMBER OF LINES PER PAGE
*        I     0                  0/1 FOR PRECISE/IMPRECISE INTERRUPTS
*
*        THE DEFAULT VALUE IS USED IF THE PARAMETER IS NOT SUPPLIED.
*
*        T,P,L LIMITS ARE ENFORCED SEPARATELY FOR EACH JOB IN A BATCH.
*
*        THE VALUE OF D IS DECREMENTED FOR EVERY CALL TO SYSABEND.
*        IF THE VALUE IS ZERO ON ENTRY TO SYSABEND, A STANDARD SYSTEM
*        ABEND DUMP IS GIVEN.
         TITLE 'OSINT -- OS INTERFACE -- MAIN PROGRAM ENTRY POINTS'
*
*        THE FOLLOWING ENTRY POINTS MUST BE PROVIDED IN THE MAIN PROGRM
*
*        SYSSTART
*        --------
*
*        THIS IS THE ENTRY POINT TO THE MAIN PROGRAM. OSINT PASSES
*        CONTROL TO SYSSTART AS FOLLOWS AFTER INITIALIZATION
*
*        (8)                      POINTS TO THE ALLOCATED DATA AREA
*
*        (15)                     ADDRESS OF SYSSTART
*
*        (REMAINING REGISTERS)    NOT USED, MAY BE DESTROYED
*
*        NOTE THAT OSINT RECOGNIZES THE SYMBOLS ./* IN COLUMNS 1-3
*        OF A SYSIN IMAGE TO REPRESENT AN END OF FILE SEPARATING JOBS
*        WHICH ARE BATCHED TOGETHER. IF THE MAIN PROGRAM IS NOT
*        REUSABLE, IT MUST RECOGNIZE SUBSEQUENT ENTRIES AFTER THE
*        FIRST AND RETURN WITHOUT ANY PROCESSING.
*
*        THE ALLOCATED DATA AREA IS TO BE USED TO MEET ALL VOLATILE
*        STORAGE REQUIREMENTS OF THE MAIN PROGRAM. FOR A DESCRIPTION
*        OF THE FORMAT OF THE DATA AREA, SEE THE DATA DSECT AT THE END
*        OF THE LISTING. THE LARGEST AVAILABLE CONTINGUOUS AREA OF
*        STORAGE (NOT EXCEEDING THE H PARAMETER) IS USED, RESERVING
*        ONLY THAT SPECIFIED BY THE R PARAMETER FOR OTHER USES.
*        THE MAIN PROGRAM IS EXPECTED TO DO ITS OWN STORAGE
*        MANAGEMENT WITHIN THIS AREA (GETMAIN,FREEMAIN MAY NOT BE USED)
*
*        SYSHEAD
*        -------
*
*        THE DATA AT THE ENTRY POINT SYSHEAD SPECIFIES THE HEADING
*        TO BE PRINTED BY OSINT AT THE START OF A RUN. IT CONSISTS OF
*        A SERIES OF LINES STARTING WITH AN ASA CONTROL CHARACTER.
*        EACH LINE IS PRECEEDED BY A ONE BYTE COUNT GIVING THE ACTUAL
*        LENGTH OF THE LINE. A BYTE OF ZEROS (X'00') ENDS THE LIST
*
*        THE FOLLOWING IS AN EXAMPLE OF A TYPICAL HEADING
*
*        ENTRY SYSHEAD
*SYSHEAD DC    AL1(L'HED1)
*HED1    DC    C'1DOODLETRAN VERSION 9.9'
*        DC    AL1(L'HED1)
*        DC    C'+______________________'
*        DC    AL1(0)
*
*        SYSBATCH
*        --------
*
*        A SINGLE BYTE WHICH IS SET TO 1 IF THE MODULE PERMITS SYSIN
*        BATCHING (VIA ./*) OR ZERO IF NO BATCHING IS PERMITTED
         EJECT
*
*        SYSINTR
*        -------
*
*        THIS ENTRY POINT RECEIVES CONTROL AS FOLLOWS AFTER THE
*        OCCURENCE OF A PROGRAM CHECK.
*
*        (15)                     POINTS TO SYSINTR
*
*        (8)                      POINTS TO ALLOCATED DATA AREA
*                                 SYSPSW,SYSREGS STORED
*
*        (REMAINING REGS)         UNPREDICTABLE
*
*        SYSINTR CAN DETERMINE THE CAUSE OF THE INTERRUPT BY EXAMINING
*        THE INTERRUPT PSW AND REGISTER VALUES STORED IN THE DATA AREA
*        (AT SYSPSW AND SYSSTART). IT THEN TAKES APPROPRIATE ACTION.
*
*        NOTES.
*
*        SYSINTR RECEIVES CONTROL AFTER LEAVING TRAP STATE, THUS THERE
*        IS NO PROVISION FOR 'RETURNING' VIA THE SYSTEM.
*
*        IF THE INTERRUPT IS AN ERROR, THEN SYSINTR SHOULD PRINT
*        AN APPROPRIATE MESSAGE AND EXIT VIA SYSABEND. NOTE THAT THE
*        PSW AND REG VALUES ARE IN THE DATA AREA AND WILL BE DUMPED.
*
*        REGISTER 8 IS SET CORRECTLY TO POINT TO THE DATA AREA EVEN IF
*        IT WAS NOT SO SET AT THE TIME OF THE INTERRUPT.
         EJECT
*
*        SYSOVTM
*        -------
*
*
*        THIS ENTRY POINT RECEIVES CONTROL ON AN OVERTIME TRAP
*        (I.E. T PARAMETER EXCEEDED) AS FOLLOWS --
*
*        (15)                     ADDRESS OF SYSOVTM
*
*        (8)                      POINTER TO ALLOCATED DATA AREA
*
*        (14)                     RETURN POINT TO INTERFACE
*
*        (REMAINING REGS)         UNPREDICTABLE, NEED NOT BE SAVED
*
*        UNLIKE SYSINTR, THIS ROUTINE RECEIVES CONTROL WITHIN TRAP
*        STATE AND MUST RETURN CONTROL VIA REGISTER 14. THUS THE
*        ROUTINE SHOULD SET FLAGS ETC. WHICH THE MAIN STREAM ROUTINE
*        RECOGNIZES AS SIGNIFYING THAT AN OVERTIME TRAP HAS OCCUED.
*
*        NOTE THAT THE GENERAL REGISTERS DO NOT CONTAIN USEABLE
*        VALUES SINCE THE INTERRUPT MAY OCCUR DURING EXECUTION OF
*        A ROUTINE WITHIN THE SYSTEM INTERFACE. HOWEVER, THE
*        FLOATING POINT REG VALUES ARE UNCHANGED AND MAY BE MODIFIED.
         TITLE 'OSINT -- OS INTERFACE -- INTERFACE ENTRY POINTS'
*
*        THE INTERFACE PROVIDES A SERIES OF ENTRY POINTS FOR PERFORMING
*        VARIOUS SYSTEM DEPENDENT FUNCTIONS. A COMMON CALLING
*        SEQUENCE IS USED AS FOLLOWS --
*
*        (8)                      POINTS TO THE ALLOCATED DATA AREA
*
*        (2)                      ADDRESS OF SYSTEM INTERFACE ROUTINE
*                                 LOADED VIA A VCON
*
*        (1)                      RETURN POINT TO MAIN PROGRAM
*
*        (0,4,5,6,7)              PARAMETER VALUES AS REQUIRED BY
*                                 THE PARTICULAR CALL
*
*        (REMAINING REGS)         NOT RELEVANT
*
*        ON RETURN, ALL REGISTERS, WITH THE POSSIBLE EXCEPTION
*        OF (0) ARE RESTORED. IF AN ERROR OCCURED, AN ERROR CODE
*        IS POSTED IN REGISTER (0) AND CONTROL IS RETURNED TO 0(1).
*        IF THE CALL IS SUCCESSFUL, CONTROL RETURNS TO 4(1). IN SOME
*        CASES, A RESULT IS RETURNED IN REGISTER (0).
*
*        NORMAL PRACTICE IS TO KEEP REGISTER (8) POINTING TO THE
*        ALLOCATED DATA AREA AT ALL TIMES, ALTHOUGH THE VALUE IS
*        ONLY REQUIRED TO BE LOADED WHEN AN INTERFACE CALL IS MADE.
*        THUS A TYPICAL CALL TO AN OSINT ENTRY POINT IS AS FOLLOWS
*
*        L     2,=V(SYSXXX)
*        LA    0,PARAM
*        BALR  1,2
*        B     ERROR
*        -->   NORMAL RETURN
*
*        NOTE THAT THE SPACE FOR THE ERROR RETURN MUST BE PROVIDED EVEN
*        FOR CALLS WHICH CANNOT GIVE AN ERROR RETURN.
         EJECT
*
*        SYSABEND
*        --------
*
*        PURPOSE:                 TERMINATE EXECUTION WITH AN ERROR
*                                 INDICATION. A SYSTEM DUMP OR AN OSINT
*                                 DUMP IS GIVEN DEPENDING ON THE
*                                 SETTING OF THE D PARAMETER. THE OSINT
*                                 DUMP INCLUDES THE ALLOCATED DATA
*                                 AREA, DCB'S AND INTERFACE WORK AREA.
*                                 AFTER AN OSINT DUMP, AN ATTEMPT
*                                 IS MADE TO INITIATE THE NEXT JOB
*                                 IN A BATCH.
*
*        ENTRY PARAMETERS:        NONE
*
*        RESULT RETURNED:         NONE (DOES NOT RETURN)
*
*
*        SYSCLOSE
*        --------
*
*        PURPOSE:                 CLOSE FILE AND RELEASE ITS ASSOCIATED
*                                 STORAGE (BUFFER POOLS ETC.)
*                                 SYSDCB MUST BE CALLED BEFORE ANY
*                                 FURTHER OPERATIONS ARE PERFORMED
*                                 ON THE FILE. SYSTEM FILES (SYSPUNCH,
*                                 SYSIN, SYSPRINT) CANNOT BE CLOSED.
*
*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE
*
*        RESULT RETURNED:         ZERO
*
*
*        SYSDATE
*        -------
*
*        PURPOSE:                 OBTAIN CURRENT DATE (MM/DD/YY)
*
*        ENTRY PARAMETERS:        NONE
*
*        RESULT RETURNED:         POINTER TO 8 CHAR DATE (MM/DD/YY)
*
*
*        SYSSETP
*        -------
*
*        PURPOSE:                 TO INFORM THE INTERFACE THAT THE
*                                 DATA AREA POINTER HAS BEEN CHANGED
*
*        ENTRY PARAMETERS         NONE (REG 8 POINTS TO NEW DATA AREA)
*
*        RESULT RETURNED:         NONE
         EJECT
*
*        SYSDCB
*        ------
*
*        PURPOSE:                 TO OBTAIN A DCB POINTER FOR A FILE
*                                 FROM A FILENAME FOR USE IN
*                                 SUBSEQUENT CALLS. SEE SEPARATE
*                                 SECTION FOR DISCUSSION OF FILENAMES
*
*        ENTRY PARAMETERS:        (4)       ADDRESS OF FILE NAME
*                                 (5)       NUMBER OF CHARS IN FILENAME
*
*        RESULT RETURNED:         POINTER TO DCB. NOTE THAT THE USER
*                                 MUST NOT USE THIS POINTER EXCEPT
*                                 FOR INTERFACE COMMUNICATION. THIS IS
*                                 TO ENSURE COMPATABILITY WITH
*                                 OTHER SYSTEMS SUCH AS DOS.
*                                 THE POINTER IS VALID UNTIL THE FILE
*                                 IS CLOSED USING SYSCLOSE.
*
*
*        SYSDUMP
*        -------
*
*        PURPOSE:                 PROVIDE A SPECIAL DUMP OF THE
*                                 ALLOCATED DATA AREA, DCB'S AND THE
*                                 INTERFACE WORK AREA. THE DUMP GIVES
*                                 BOTH ABSOLUTE AND RELATIVE ADDRESSES
*                                 IN EACH AREA. NOTE THAT THE REGISTER
*                                 VALUES ARE NOT DUMPED AND MUST
*                                 THEREFORE BE STORED IN THE DATA AREA
*                                 PRIOR TO THE SYSDUMP CALL.
*
*        ENTRY PARAMETERS:        NONE
*
*        RESULT RETURNED:         NONE
*
*
*        SYSEOJ
*        ------
*
*        PURPOSE:                 NORMAL TERMINATION OF EXECUTION
*                                 IF ON READING SYSIN, A ./* IS
*                                 ENCOUNTERED, OSINT STARTS A NEW JOB
*                                 BY REINITIALIZING AND PASSING
*                                 CONTROL TO SYSSTART.
*
*        ENTRY PARAMETERS:        (0)       SYSTEM RETURN CODE
*                                           LAST JOB IN A BATCH ONLY
*
*        RESULT RETURNED:         NONE (DOES NOT RETURN)
         EJECT
*
*        SYSLOAD
*        -------
*
*        PURPOSE:                 LOAD AN EXTERNAL MODULE
*
*        ENTRY PARAMETERS:        (4)       ADDRESS OF MODULE NAME
*                                 (5)       NUMBER OF CHARS IN NAME
*
*        RESULT RETURNED:         STARTING ADDRESS OF LOADED MODULE
*
*
*        SYSMAXL
*        -------
*
*        PURPOSE:                 TO DETERMINE THE MAXIMUM POSSIBLE
*                                 LENGTH OF AN INPUT RECORD FROM A FILE
*                                 SO THAT THE CALLER CAN PROVIDE A
*                                 SUITABLE BUFFER FOR A SYSREAD CALL
*
*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE
*
*        RESULT RETURNED:         MAX RECORD LENGTH IN BYTES
*
*
*        SYSPHASE
*        --------
*
*        PURPOSE:                 LOAD A PHASE IN A MULTIPHASE PROGRAM
*                                 NOTE THAT THE INTERFACE MUST BE IN
*                                 THE ROOT PHASE.
*
*        ENTRY PARAMETERS:        (0)       VCON OF PHASE TO BE LOADED
*                                 (4)       ADDR OF 8 CHR PHASE NAME
*
*        RESULT RETURNED:         NONE
*
*
*        SYSREAD
*        -------
*
*        PURPOSE:                 READ A RECORD FROM A FILE
*
*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE
*                                 (4)       ADDRESS OF BUFFER
*
*        RESULT RETURNED:         LENGTH OF RECORD READ
*                                 SET NEGATIVE ON END OF FILE
*
         EJECT
*        SYSRWIND
*        --------
*
*        PURPOSE:                 REWIND A FILE, I.E. CLOSE FILE AND
*                                 REPOSITION AT START OF FILE. SYSTEM
*                                 FILES (SYSPUNCH, SYSIN, SYSPRINT)
*                                 CANNOT BE REWOUND. THE STORAGE
*                                 (BUFFER POOLS ETC.) IS NOT RELEASED.
*
*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE
*
*        RESULT RETURNED:         NONE
*
*
*        SYSTIME
*        -------
*
*        PURPOSE:                 GET CURRENT TIMER VALUE
*
*        ENTRY PARAMETERS:        NONE
*
*        RESULT RETURNED:         TIME IN MILLISECONDS SINCE
*                                 SYSSTART RECEIVED CONTROL
*
*
*        SYSUNLOD
*        --------
*
*        PURPOSE:                 UNLOAD AN EXTERNAL MODULE
*                                 (I.E. RELEASE CONTROL)
*
*        ENTRY PARAMETERS         (4)       ADDRESS OF MODULE NAME
*                                 (5)       NUMBER OF CHARS IN NAME
*
*        RESULT RETURNED:         NONE
*
*
*        SYSWRITE
*        --------
*
*        PURPOSE:                 WRITE A RECORD TO A FILE
*
*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE
*                                 (4)       ADDRESS OF RECORD
*                                 (5)       LENGTH OF RECORD (BYTES)
*                                 (6)       ADDRESS OF FORMAT STRING
*                                 (7)       LENGTH OF FORMAT (0 = NONE)
*
*        RESULT RETURNED:         ZERO IF TOO MANY RECORDS WRITTEN
*                                 ELSE UNCHANGED DCB POINTER
         TITLE 'OSINT -- OS INTERFACE -- NOTES ON I/O'
*
*        ALL I/O IS DONE USING QSAM. ALL RECORD FORMATS ARE SUPPORTED.
*
*        A FILE IS OPENED WHEN THE FIRST READ OR WRITE OPERATION IS
*        PERFORMED (I.E. CALL TO SYSREAD OR SYSWRITE).
*
*        IT IS NOT PERMISSIBLE TO SWITCH FROM READING TO WRITING OR
*        VICE VERSA WITHOUT FIRST REWINDING OR CLOSING THE FILE.
*
*        RECORDS EXCEEDING THE LRECL VALUE ARE SUBDIVIDED AS REQUIRED.
*        IN THE CASE OF FIXED LENGTH RECORDS, TRAILING BLANKS ARE
*        SUPPLIED AS REQUIRED.
*
*        ZERO LENGTH RECORDS MAY BE WRITTEN AND ARE HANDELED AS FOLLOWS
*        FIXED LENGTH             A BLANK RECORD IS WRITTEN
*        VARIABLE,UNDEFINED       A ONE BYTE RECORD X'00' IS WRITTEN
*
*        THE FOLLOWING POSSIBILITIES ARE RECOGNIZED FOR FILENAMES
*
*        DDNAME                   REFERS TO FILE WITH DDNAME GIVEN
*
*        INTEGER NN               REFERS TO FILE WITH DDNAME FTNNF001
*                                 WITH THE FOLLOWING SPECIAL EXCEPTIONS
*                                 05 -> SYSIN IF FT05F001 NOT GIVEN
*                                 06 -> SYSPRINT IF FT06F001 NOT GIVEN
*                                 07 -> SYSPUNCH IF FT07F001 NOT GIVEN
*
*        DDNAME(ELNAME)           FOR A PARTIONED DATASET, ELNAME IS A
*                                 MEMBER NAME. FOR A TAPE FILE, ELNAME
*                                 IS A SEQUENCE (FILE) NUMBER.
         TITLE 'OSINT -- OS INTERFACE -- MACRO DEFINITIONS'
*
*        MACRO TO IMPLEMENT ONE CHARACTER PARAMETERS (NUMERIC)
*        FIRST ARGUMENT = PARAMETER CHARACTER
*        SECOND ARGUMENT IS ADDRESS WHERE VALUE IS TO BE STORED
*
         MACRO
&LBL     PARAM &LTR,&ADDR
         CNOP  0,4
&LBL     DC    C'&LTR',AL3(&ADDR-WORK)
         MEND
*
*        COMMON ENTRY MACRO
*
         MACRO
&NAME    ENTER
         ENTRY &NAME
&NAME    DS    0H
         USING *,2
         DROP  11,12
         STM   0,15,SAVE1
         LM    11,12,=A(OSINT,OSINT+4096)
         USING OSINT,11,12
         L     13,WORKLOC
         DROP  2
         MEND
*
*        XERR -- DEFINE ERROR CODE
*
         MACRO
&NAME    XERR
         GBLA  &ERRC
&ERRC    SETA  &ERRC+1
&NAME    BCTR  12,0
         MEND
         EJECT
*
*        MACRO TO GENERATE MESSAGE LINES
*
         MACRO
&NAME    MSG   &TEXT
         LCLA  &K
&NAME    EQU   *
&K       SETA  K'&TEXT-2
         DC    AL1(&K)
         DC    C&TEXT
         MEND
*
*        MACRO TO PRINT A LINE GENERATE BY THE ABOVE MSG CALL
*
         MACRO
&LABEL   PRT   &MESSAGE
&LABEL   MVC   BUFR(70),&MESSAGE
         BAL   5,PRNTLNB
         MEND
*
         GBLA  &ERRC              COUNT OF ERROR CODES
&ERRC    SETA  0                  INITIALIZE ERROR COUNT
         PRINT NOGEN              NO GARBAGE PLEASE
         TITLE 'OSINT -- OS INTERFACE -- DEFINITIONS'
DEFS     DSECT ,                  START OF DEFINITIONS
*
*        DEFINITIONS FOR RR BRANCH MENOMONICS
*
E        EQU   8                  EUQAL
Z        EQU   8                  ZERO, ZEROS
NE       EQU   7                  NOT EQUAL
NZ       EQU   8                  NOT ZERO, NOT ZEROS
O        EQU   1                  OVERFLOW, ONES
NO       EQU   14                 NO OVERFLOW, NOT ONES
P        EQU   2                  POSITIVE
H        EQU   2                  HIGH
NP       EQU   13                 NOT POSITIVE
NH       EQU   13                 NOT HIGH
M        EQU   4                  MINUS
L        EQU   4                  LOW
NM       EQU   11                 NOT MINUS
NL       EQU   11                 NOT LOW
         TITLE 'OSINT -- OS INTERFACE -- INITIALIZATION'
*
*        ENTRY POINT FROM CONTROL PROGRAM
*
OSINT    CSECT ,                  START OF INTERFACE
         SAVE  (14,12)            SAVE ENTRY REGISTERS
         USING OSINT,15           INITIAL BASE SET BY SYSTEM
         LM    11,12,=A(OSINT,OSINT+4096)   SET BASE REGS
         DROP  15                 DROP TEMPORARY BASE
         USING OSINT,11,12        STANDARD BASE REG FOR INTERFACE
         L     4,0(,1)            GET ADDRESS OF EXEC PARAMETERS
         GETMAIN   R,LV=LWORK     GET SPACE FOR INTERFACE WORK AREA
         USING WORK,1             TEMPORARY BASE FOR WORK AREA
         XC    WORK(256),WORK               ZERO INTERFACE WORK AREA
         MVC   WORK+256(LWORK-256),WORK     . . . .
         LA    5,FSTAKEND         GET END OF STACK ADDESS FOR FORMATS
         LA    6,FORMSTAK-4       BOTTOM OF STACK ADDRESS
         STM   5,6,FSTAKEND       INITIALIZE FORMAT STACK INFORMATION
         MVC   LIMS(LLIMS),LIMSINIT         SET INITIAL VALUE OF LIMITS
         ST    1,8(,13)           SET SAVE AREA FORWARD PTR
         OI    8+3(13),1          SET OUR SPECIAL SAVE AREA FLAG BIT
         ST    13,ENT13SV         SAVE POINTER TO PREVIOUS SAVE AREA
         LR    13,1               SET WORK ADDRESS IN CORRECT REGISTER
         USING WORK,13            TELL ASSEMBLER
         USING IHADCB,10          REG TO POINT TO DCB'S
         DROP  1                  DROP      TEMPORARY BASE
         EXTRN SYSSTART           MAIN PROGRAM ENTRY POINT
         MVC   STARTLOC,=A(SYSSTART)        SET IN WORK AREA FOR DUMPS
*
*        PROCESS PARAMETER FIELD
*
         LH    2,0(,4)            GET LENGTH OF PARAMETER FIELD
         LA    1,2(,4)            POINT TO FIRST PARAMETER CHARACTER
*
*        LOOP THROUGH PARAMETERS
*
PARLOOP  CH    2,=H'3'            INSIST ON AT LEAST THREE CHARACTERS
         BL    NOPARMS            IGNORE FIELD IF NOT THAT BIG
         MVC   PTYPE(1),0(1)      MOVE PARAMETER NAME
         CLI   1(1),C'='          NEXT CHARACTER MUST BE =
         BNE   NOPARMS            IGNORE REST IF NOT
         LA    1,2(,1)            POINT TO START OF NUMBER
         LR    3,1                COPY STARTING ADDRESS
         SR    0,0                INITIALIZE RESULT TO ZERO
         SH    2,=H'2'            DECR COUNT OF CHARS LEFT FOR X=
*
*        LOOP TO CONVERT NUMBER
*
PARLOOP1 CLI   0(1),C','          COMMA FOR END OF PARAMETER?
         BE    PARFND             B IF END OF FIELD
         CLI   0(1),C'K'          K FOR *1024 ?
         BNE   PARLOOPN           SKIP IF NOT
         SLL   0,10               ELSE MULTIPLY WHAT WE HAVE BY 1024
         B     PARLOOPE           JUMP TO END OF LOOP
         EJECT
*
*        HERE TO CHECK FOR A DIGIT
*
PARLOOPN CLI   0(1),C'0'          CHECK FOR NUMERIC
         BL    NOPARMS            SKIP IF TOO LOW
         MH    0,=H'10'           SHIFT PREVIOUS TOTAL
         IC    9,0(,1)            LOAD DIGIT
         N     9,=X'0000000F'     MASK DIGIT VALUE
         AR    0,9                ADD TO WHAT WE HAVE ALREADY
*
*        HERE AT END OF LOOP
*
PARLOOPE LA    1,1(,1)            BUMP POINTER
         BCT   2,PARLOOP1         DECR COUNT, LOOP IF MORE TO GO
*
*        COME HERE WITH PARAMETER VALUE CONVERTED IN (0)
*
PARFND   LA    9,PARMNO           GET NUMBER OF PARAMETERS IN TABLE
         LA    8,FSTPARM          GET START OF TABLE
*
*        LOOP TO FIND PROPER PARAMETER
*
PELOOP   CLC   PTYPE,0(8)         IS THIS THE PARAMETER?
         BE    PENTRY             B IF FOUND
         LA    8,4(,8)            POINT TO NEXT ENTRY
         BCT   9,PELOOP           LOOP TO CHECK NEXT ENTRY
         B     NEXTPRM            IF NO MATCH, IGNORE THIS PARAMETER
*
*        HERE WE HAVE FOUND THE APPROPRIATE PARAMETER
*
PENTRY   L     9,0(,8)            LOAD ADDRESS OFFSET OF PARAM VALUE
         ST    0,WORK(9)          STORE PARAMETER VALUE
*
*        HERE TO MOVE TO NEXT PARAMETER
*
NEXTPRM  LA    1,1(,1)            SKIP PAST COMMA
         BCT   2,PARLOOP          LOOP BACK IF WE HAD A COMMA
*
*        HERE AFTER PROCESSING PARAMS, ALLOCATE DYNAMIC MEMORY
*
NOPARMS  L     0,RESERV           MEMORY TO BE RESERVED TO SYSTEM
         GETMAIN R,LV=(0)         RESERVE SYSTEM SPACE
         ST    1,RESERV0          SAVE ADDRESS OF AREA
         MVC   MLIST(LGETLIST),GETLIST      MOVE GETMAIN LIST
         GETMAIN   LA=DYNALLOC,A=ALLOC,     ATTEMPT TO ALLOCATE IN LCS X
               HIARCHY=1,MF=(E,MLIST)       . . . .
         LTR   15,15              TEST RETURN CODE
         BZ    ALLOCGO            SKIP IF LCS OBTAINED
         GETMAIN   HIARCHY=0,MF=(E,MLIST)   IF NO LCS, GET NORMAL MEMRY
         EJECT
*
*        COME HERE WITH MEMORY OBTAINED
*
ALLOCGO  LM    0,1,RESERV         GET LENGTH/ADDRESS OF SYSTEM AREA
         FREEMAIN  R,LV=(0),A=(1) FREE SYSTEM AREA
         GETMAIN   R,LV=140       GET WORK BUFFER (ENOUGH FOR SYSPRINT)
         ST    1,OUTWBF           STORE POINTER TO BUFFER OBTAINED
         LA    1,140              GET LENGTH
         STH   1,OUTWBFLN         STORE LENGTH OF WORK BUFFER
         LM    1,2,ALLOC          GET ADDRESS AND LENGTH ALLOCATED
         LR    8,1                COPY ADDRESS
         USING DATA,8             TELL ASSEMBLER
         ST    8,DATAPTR          STORE PTR TO DATA AREA IN OUR AREA
         ST    2,DATASIZE         STORE ALLOCATED LENGTH
         ST    13,WORKLOC         STORE PTR TO INTERFACE WORK AREA
*
*        NOW WE BUILD DCB'S FOR ALL DATASETS DEFINED BY DD CARDS
*
         MVC   MLIST(LEXTLIST),EXTLIST      MOVE EXTRACT LIST
         EXTRACT   TIOTLOC,MF=(E,MLIST)     GET TIOT ADDRESS
         SR    5,5                GET A ZERO
         ST    5,PTRDCB           SET INITIAL DCB POINTER = 0
         L     6,TIOTLOC          POINT TO START OF TIOT
         USING TIOT,6             TELL ASSEMBLER
*
*        LOOP THROUGH ENTRIES IN TIOT
*
TIOTLOOP C     5,TIOENTRY         IS THIS THE END OF THE LIST?
         BZ    ENDTIOTL           SKIP IF END OF LOOP
         CLC   TIOEDDNM,=CL8' '   IS DDNAME BLANK (CONCATENATION)?
         BE    TIOTSKP            IF SO, DO NOT BOTHER TO BUILD DCB
         GETMAIN   R,LV=LMODDCB   ALLOCATE MEMORY FOR DCB
         LR    10,1               COPY POINTER
         MVC   0(LMODDCB,10),MODDCB         MOVE MODEL DCB INTO PLACE
         MVC   DCBDDNAM,TIOEDDNM  COPY DDNAME INTO DCB
         MVC   DDNAME,TIOEDDNM    SET OUR COPY OF DDNAME
         MVC   FILENAME(8),TIOEDDNM         SET DDNAME AS FILENAME
         L     1,PTRDCB           LOAD CURRENT CHAIN POINTER
         ST    1,DCBNEXT          STORE AS FORWARD POINTER
         ST    10,PTRDCB          STORE NEW HEADER PTR (THIS DCB)
*
*        HERE AFTER BUILDING DCB IF REQUIRED
*
TIOTSKP  SR    0,0                CLEAR FOR IC
         IC    0,TIOELNOH         LOAD LENGTH OF TIOT ENTRY
         AR    6,0                POINT TO NEXT ENTRY
         B     TIOTLOOP           AND LOOP BACK
         DROP  6                  DROP TIOT BASE REG
         EJECT
*
*        ALL DCBS ARE NOW BUILT, FIND SYSPRINT DCB AND FIX IT UP
*
ENDTIOTL LA    2,SYSDCB           POINT TO SYSTEM DCB LOCATE ROUTINE
         LA    4,=C'SYSPRINT'     POINT TO NAME OF PRINT FILE
         LA    5,8                NAME LENGTH = 8 CHARACTERS
         BALR  1,2                CALL ROUTINE TO LOCATE SYSPRINT DCB
         B     DDBOMB             ERROR IF NO SYSPRINT FILE
         LR    10,0               MOVE DCB PTR TO STANDARD REGISTER
         MVI   OFLAGS,PRINTER     SET SPECIAL FLAG FOR SYSPRINT
         MVC   DCBEXLST+1(3),=AL3(EXLPRT)   SET PROPER EXIT LIST ADDR
         ST    10,PRINTDCB        STORE ADDRESS OF DCB
*
*        FIND SYSPUNCH DCB AND FIX IT UP
*
         LA    4,=C'SYSPUNCH'     SET SYSPUNCH NAME (LENGTH IS SET)
         BALR  1,2                CALL ROUTINE TO LOCATE SYSPUNCH DCB
         B     DDBOMB             ERROR IF DD CARD MISSING
         LR    10,0               ELSE MOVE DCB PTR TO STANDARD REG
         MVI   OFLAGS,PUNCHER     SET SPECIAL SYSPUNCH FLAG
         MVC   DCBEXLST+1(3),=AL3(EXLPCH)   SET PROPER EXIT LIST ADDR
         ST    10,PUNCHDCB        STORE ADDRESS OF PUNCH DCB
*
*        FIND SYSIN DCB AND FIX IT UP
*
         LA    4,=CL8'SYSIN'      POINT TO SYSIN NAME (LENGTH = 8 SET)
         BALR  1,2                CALL ROUTINE TO LOCATE SYSIN DCB
         B     DDBOMB             ERROR IF MISSING DD CARD
         LR    10,0               SET DCB PTR IN STANDARD REG
         MVI   OFLAGS,READER      SET SPECIAL SYSIN FLAG
         MVC   DCBEXLST+1(3),=AL3(EXLRDR)   SET PROPER EXIT LIST ADDR
         ST    10,READDCB         STORE ADDRESS OF READER DCB
*
*        IF SYSOBJ FILE IS GIVEN, FIX IT UP
*
         LA    4,=CL8'SYSOBJ'     POINT TO NAME (LENGTH=8 IS SET)
         BALR  1,2                CALL ROUTINE TO GET SYSOBJ DCB
         B     SETPCEX            SKIP IF FILE NOT GIVEN
         LR    10,0               ELSE SET DCB PTR IN STANDARD REG
         MVC   DCBEXLST+1(3),=AL3(EXLOBJ)   SET PROPER EXIT LIST ADDR
         EJECT
*
*        SET PROPER PSW AND INTERRUPT INTERCEPT
*
SETPCEX  SPIE  PCEXIT,((1,15))    GET CONTROL ON ALL INTERRUPTS
         SR    0,0                GET 0
         SPM   0                  MASK MASKABLE PC'S
         ST    1,PICASAV          SAVE CALLER'S PICA ADDRESS
*
*        PRINT HEADING AND OTHER INFORMATION
*
         EXTRN SYSHEAD            GAIN ACCESS TO HEADER
         L     9,=A(SYSHEAD)      POINT TO HEADING
*
*        LOOP TO PRINT SUPPLIED HEADING
*
HEADL    SR    6,6                CLEAR FOR IC
         IC    6,0(,9)            LOAD LINE LENGTH
         LTR   6,6                CHECK FOR END OF HEADERS
         BZ    HEAD2              SKIP IF END OF HEADERS
         EX    6,HEADMVC          MOVE HEADER TO PRINT BUFFER
         BAL   5,PRNTLNB          PRINT HEADING LINE FROM BUFFER
         LA    9,1(6,9)           POINT TO NEXT HEADER LINE
         B     HEADL              LOOP BACK
*
HEADMVC  MVC   BUFR(*-*),0(9)     MOVE HEADER LINE TO BUFFER
*
*        HERE WHEN LINES OF HEADER HAVE BEEN PRINTED
*
HEAD2    PRT   OSMSG              IDENTIFY SYSTEM AS OS
         PRT   BLANKL             PRINT AN EXTRA BLANK LINE
         PRT   PARMHEAD           PRINT HEADER FOR PARAMS
         PRT   BLANKL             PRINT A BLANK LINE
         LA    9,PARMNO           NUMBER OF PARAMETERS
         LA    6,FSTPARM          POINT TO PARAMETER TABLE
         MVC   BUFR(28),PARMPRT   MOVE MODEL TO BUFFER
*
*        LOOP TO PRINT PARAMETER VALUES
*
PARMPL   MVC   BUFR+2(1),0(6)     MOVE CHARACTER NAME
         L     3,0(,6)            WORK OFFSET OF PARAM ADDRESS VALUE
         L     3,WORK(3)          LOAD PARAMETER VALUE
         LA    2,BUFR+6           POINT TO CONVERT LOCATION
         BAL   7,CONVOUT          CONVERT NUMBER FOR OUTPUT
         BAL   5,PRNTLNB          PRINT BUFFER
         LA    6,4(,6)            PUSH TO NEXT PARAMETER
         BCT   9,PARMPL           LOOP UNTIL ALL PARAMETERS PRINTED
         EJECT
*
*        PRINT LENGTH OF MEMORY OBTAINED
*
         PRT   BLANKL             PRINT A BLANK LINE
         L     3,ALLOC+4          LENGTH ALLOCATED
         MVC   BUFR(50),PRTMEM    MOVE MESSAGE TO BUFFER
         LA    2,BUFR+29          POINT TO CONVERT LOCATION
         BAL   7,CONVOUT          CONVERT IT
         BAL   5,PRNTLNB          PRINT ALLOCATED MEMORY
         PRT   BLANKL             PRINT A BLANK LINE
*
*        ACQUIRE BYTE FOR ALLOWING BATCHING (SYSBATCH)
*
         EXTRN SYSBATCH           FLAG BYTE IS IN MAIN MODULE
         L     1,=A(SYSBATCH)     LOAD ADDRESS OF BYTE
         MVC   BATCHFLG,0(1)      MOVE FLAG BYTE TO INTERFACE WORK AREA
*
*        CONVERT TIME LIMIT TO TIMER UNITS
*
         L     1,TLIMIT           LOAD TIME LIMIT IN SECONDS
         M     0,=F'38400'        CONVERT TO TIMER UNITS           V2.3
         ST    1,TLIMIT           STORE BACK IN TIME LIMIT
*
*        NOW MAKE SURE WE HAVE ENOUGH ROOM
*
         C     3,DYNAMIN          IS IT ENOUGH?
         BNL   TFIXCHK            SKIP IF WE HAVE ROOM
*
*        HERE IF WE HAVE INSUFFICIENT MEMORY
*
         PRT   DYNAMSG            PRINT COMPLAINT
         ABEND 200,DUMP           GIVE PROPER ABEND
*
*        HERE IF WE ARE MISSING A DD CARD FOR A STANDARD SYSTEM FILE
*
DDBOMB   ABEND 400,DUMP           GIVE PROPER ABEND
         EJECT
*
*        HERE WE CHECK FOR POSSIBLE TF'S (TEMPORARY FIXES)
*
TFIXCHK  PRT   BLANKL             PRINT A BLANK LINE
         SR    6,6                INITIALIZE OFFSET INTO TFIXES LIST
         LA    9,NFIXES           SET MAX POSSIBLE NUMBER OF FIXES
*
*        LOOP TO CHECK FOR FIXES
*
FIXLOOP  LH    3,TFIXES(6)        LOAD POSSIBLE TF NUMBER
         LTR   3,3                IS THIS ONE IN USE (APPLIED)?
         BZ    EFIXL              SKIP IF NOT
         MVC   BUFR(39),TFIXMSG   IF SO, MOVE MESSAGE TO BUFFER
         LA    2,BUFR+17          POINT TO LOCATION FOR CONVERT
         BAL   7,CONVOUT          CONVERT CODE NUMBER
         BAL   5,PRNTLNB          PRINT MESSAGE FROM BUFFER
*
*        HERE TO LOOP TO THE NEXT ONE
*
EFIXL    LA    6,2(,6)            BUMP POINTER
         BCT   9,FIXLOOP          LOOP BACK IF MORE TO GO
         EJECT
*
*        NOW CHECK FOR PAST CUTOFF DATE
*
         PACK  BUFR(3),DATECUT    PACK CUTOFF DATE
         LA    2,0                GET ZERO
         L     2,16(,2)           LOAD ADDRESS OF CVT
         CP    56+1(3,2),BUFR(3)  COMPARE DATES
         B     DATECK             SKIP IF OK           ALWAYS OK - V2.3
*
*        HERE WE HAVE EXCEEDED THE CUTOFF DATE -- TELL HIM
*
         PRT   EXPIRE             PRINT EXPIRATION MESSAGE
         ABEND 111                GIVE A FUNNY ABEND
*
*        HERE WE RECOMPUTE THE DATE CHECK DIGIT
*
DATECK   SR    0,0                CLEAR ACCUMULATOR
         IC    1,DATECUT          FIRST DIGIT
         AR    0,1                ADD IT IN
         IC    1,DATECUT+1        SECOND DIGIT
         AR    0,1                ADD IT IN
         IC    1,DATECUT+2        THIRD DIGIT
         AR    0,1                ADD IT IN
         IC    1,DATECUT+3        FOURTH DIGIT
         AR    0,1                ADD IT IN
         IC    1,DATECUT+4        FIFTH DIGIT
         AR    0,1                ADD IT IN
         STC   0,CKDIGITC         STORE FOR LATER CHECK
         B     NEWJOB             JUMP TO START NEW JOB
         EJECT
*
*        CONVOUT                  CONVERT NUMBER FOR OUTPUT
*
*        (2)                      OUTPUT LOCATION
*        (3)                      NUMBER TO CONVERT
*        BAL   7,CONVOUT
*
CONVOUT  MVC   0(11,2),=X'2020202020202020202120' SET EDIT PATTERN
         CVD   3,SAVE2            CONVERT ARGUMENT TO DECIMAL
         LA    1,10(,2)           PRESET REGISTER 1 IN CASE NO SIGCHR
         EDMK  0(11,2),SAVE2+2    EDIT TO CHARACTERS
         BNM   *+10               SKIP IF NON-NEGATIVE
         BCTR  1,0                POINT BEHIND CONVERTED NUMBER
         MVI   0(1),C'-'          AND SET NEGATIVE SIGN
         MVC   0(11,2),0(1)       LEFT JUSTIFY
         BR    7                  RETURN TO CALLER
*
*        ROUTINE TO PRINT A LINE FROM THE PRINT BUFFER
*
*        BUFR                     ONE BYTE COUNT OF DATA CHARS
*        BUFR+1 -- BUFR+N         DATA CHARACTERS FOR PRINT LINE
*        BAL   5,PRNTLNB          CALL TO PRINT LINE
*
PRNTLNB  STM   5,7,PRNSAVE        SAVE WORK REGS
         SR    5,5                CLEAR FOR IC
         IC    5,BUFR             LOAD LENGTH OF IMAGE
         LA    4,BUFR+1           POINT TO DATA CHARACTERS
         SR    7,7                SET FORMAT LENGTH = 0 (UNFORMATTED)
         L     0,PRINTDCB         LOAD POINTER TO PRINTER DCB
         LA    2,SYSWRITE         POINT TO SYSTEM WRITE ROUTINE
         BALR  1,2                CALL SYSTEM OUTPUT ROUTINE
         NOP   0                  ERROR RETURN ON SYSPRINT NOT ALLOWED
         LM    5,7,PRNSAVE        RESTORE REGS
         BR    5                  RETURN TO CALLER
*
*        TABLE OF PARAMETERS
*
FSTPARM  PARAM L,DYNAMIN          MINIMUM DYNAMIC CORE
         PARAM H,DYNAMAX          MAXIMUM DYNAMIC CORE
         PARAM R,RESERV           RESERVED DYNAMIC CORE
         PARAM C,CLIMIT           CARD LIMIT
         PARAM P,PLIMIT           PAGE LIMIT
         PARAM T,TLIMIT           TIME LIMIT
         PARAM D,DLIMIT           DUMP LIMIT
         PARAM N,PAGEDPTH         NUMBER OF LINES PER PAGE
         PARAM I,INTVAL           INTERRUPT TYPE INDICATOR
PARMNO   EQU   (*-FSTPARM)/4      CALC NUMBER OF PARAMETERS IN TABLE
         EJECT
*
*        MESSAGES
*
OSMSG    MSG   '0SYSTEM = OS/360'
PARMHEAD MSG   '0PARAMETER VALUES FOR THIS RUN'
PARMPRT  MSG   ' X = XXXXXXXXXXX          '
PRTMEM   MSG   '0DYNAMIC MEMORY AVAILABLE = XXXXXXXXXXX         '
DYNAMSG  MSG   '0INADEQUATE DYNAMIC MEMORY -- RUN TERMINATED'
TFIXMSG  MSG   ' TF APPLIED 2.3.XXXXXXXXXXX            '           V2.3
         ORG   TFIXMSG                                             V2.3
         DC    X'14'                                               V2.3
         ORG   ,                                                   V2.3
BLANKL   MSG   ' '
HEDM0    MSG   '1INTERNAL SYSTEM ERROR ABORT'
HEDM1    MSG   '0DUMP OF INTERFACE WORK AREA'
HEDM2    MSG   '1DUMP OF ALLOCATED DATA AREA'
EXPIRE   MSG   '0TRIAL PERIOD OVER, RETURN SYSTEM TO AUTHOR'
*
         LTORG ,                  LITERALS FOR INITIALIZATION CIRCUIT
         TITLE 'OSINT -- OS INTERFACE -- INITIATE NEW JOB'
*
*        COME HERE TO INITIATE NEW JOB
*
NEWJOB   MVI   EOFLAG,0           RESET EOF FLAGS, SET NO DATA READ YET
         L     10,READDCB         LOAD POINTER TO SYSIN DCB
         NI    OFLAGS,X'FF'-EOFE  CLEAR POSSIBLE END OF FILE FLAG
         MVC   PGDEPTH,PAGEDPTH   MOVE PAGE DEPTH TO DATA AREA
         MVC   INTFLAG,INTVAL     MOVE INTERRUPT FLAG TO DATA AREA
         L     10,PRINTDCB        POINT TO SYSPRINT DCB
         L     1,PLIMIT           GET PAGE LIMIT
         M     0,PAGEDPTH         CONVERT TO LINE (RECORD) LIMIT
         ST    1,MAXRECW          STORE IN SYSPRINT DCB
         L     10,PUNCHDCB        POINT TO SYSPUNCH DCB
         MVC   MAXRECW,CLIMIT     SET LIMIT ON CARDS IN SYSPUNCH DCB
         MVC   TSTART,TLIMIT      SAVE INITIAL TIME (SEE SYSTIME)
*
*        CLEAR ALLOCATED DATA AREA TO ZEROS
*
         SDR   0,0                GET DOUBLE WORD ZERO
         LA    2,USERD            POINT TO USER SECTION OF DATA AREA
         L     3,DATASIZE         LENGTH OF AREA
         SH    3,=Y(USERD-DATA)   ADJUST FOR OUR STUFF AT START
         LA    4,USERD-24(3)      POINT TO LAST 24 BYTES OF AREA
         XC    0(24,4),0(4)       ZERO LAST 24 BYTES
         SRL   3,5                /32 = NUMBER OF LOOPS
*
*        LOOP TO CLEAR 32 BYTES AT A TIME
*
CLEARC   STD   0,0(,2)            CLEAR 32 BYTES WITH FAST STD
         STD   0,8(,2)            . . . .
         STD   0,16(,2)           . . . .
         STD   0,24(,2)           . . . .
         LA    2,32(,2)           PUSH ADDRESS
         BCT   3,CLEARC           LOOP BACK TILL ALL CLEARED
*
*        NOW SET TIMER AND INITIATE RUN
*
         STIMER TASK,OVERTIME,TUINTVL=TLIMIT SET PROPER TIME LIMIT
         L     15,=V(SYSSTART)    POINT TO MAIN PROGRAM ENTRY POINT
         ST    15,STARTADR        STORE ADDRESS OF SYSSTART
         CLC   CKDIGIT,CKDIGITC   CHECK DATE CHECK DIGIT
         BR    15                 OFF TO EXECUTE IF OK   ALWAYS OK V2.3
*
*        HERE HE HAS FIDDLED WITH THE DATE, GIVE A NASTY BOMB
*
         LM    0,15,2000(8)       CLEAR ALL REGS TO ZEROS
         BR    15                 JUMP TO LOCATION ZERO
         TITLE 'OSINT -- OS INTERFACE -- SYSDATE'
*
*        OBTAIN DATE IN MM/DD/YY FORMAT
*
*        ENTRY CONDITIONS
*
*        NO PARAMETERS PASSED
*
*        EXIT CONDITIONS
*
*        (0)                      POINTER TO DATE MM/DD/YY
*
*        ERROR CODES RETURNED
*
*        NONE
*
SYSDATE  ENTER ,                  ENTRY POINT
         TIME  ,                  GET DATE IN YY/DDD FORM
         ST    1,SAVE2+8          SAVE VALUE TO WORK WITH IT
         ZAP   SAVE2(8),SAVE2+10(2)         MOVE IN DDD+SIGN, CLEAR
         CVB   0,SAVE2            BINARY DAY TO (0)
         SRL   1,4*3              RIGHT JUSTIFY YY + GARBAGE DIGIT
         ST    1,SAVE2+4          STORE YY
         OI    SAVE2+7,X'0F'      MAKE GARBAGE DIGIT A PLUS SIGN
         CVB   1,SAVE2            BINARY YEARS TO (1)
         LR    3,1                SAVE YEAR FOR LATER
         L     5,=X'CEEFBB00'     LOAD BIT MASK FOR MONTH LENGTHS
         N     1,=X'00000003'     GET 4'S RESIDUE FOR LEAP YEAR TEST
         BNZ   *+8                SKIP IF NOT LEAP YEAR
         O     5,=X'10000000'     SET FEB DAYS = 29 IN MONTH MASK
         SR    2,2                INITIALIZE MONTHS REGISTER
*
*        NOW LOOP THROUGH MONTHS -- IN THE BIT MASK, EACH MONTH HAS
*        TWO BITS -- ADDING THESE BITS TO 28 GIVES THE LENGTH
*
MONTHL   LA    2,1(,2)            BUMP COUNT OF MONTHS
         SR    4,4                CLEAR DAYS IN MONTH REGISTER
         SLDL  4,2                SHIFT IN ADJUSTING BITS
         LA    4,28(,4)           ADD STANDARD BASE
         SR    0,4                CRANK DAYS DOWN
         BP    MONTHL             AND LOOP BACK IF MORE TO GO
         AR    0,4                ELSE REPAIR DAYS COUNT & MERGE
*
*        EXIT POINT -- HERE WE ARE ALL SET WITH MONTH IN (2) DAY IN (0)
*
         MH    2,=H'100'          MM*100
         AR    2,0                MM*100+DD
         MH    2,=H'100'          MM*10000+DD*100
         AR    2,3                MM*10000+DD*100+YY
         CVD   2,SAVE2            CONVERT TO DECIMAL
         MVC   DATE,DATEPAT       MOVE DATE EDIT PATTERN INTO PLACE
         ED    DATE,SAVE2+4       EDIT TO MM/DD/YY FORM
         LA    0,DATE+2           POINT TO DATE
         B     EXIT0              EXIT PRESERVING (0) = ADDRESS OF DATE
*
DATEPAT  DC    X'F0212020612020612020'      EDIT PATTERN FOR DATE
         TITLE 'OSINT -- OS INTERFACE -- SYSLOAD'
*
*        LOAD A MODULE
*
*        ENTRY CONDITIONS
*
*        (4)                      ADDRESS OF MODULE NAME
*
*        (5)                      LENGTH OF MODULE NAME
*
*        EXIT CONDITIONS
*
*        (0)                      ADDRESS OF LOADED CODE
*
*        ERROR CODES RETURNED
*
*        E$MODN                   MODULE NAME LONGER THAN 8 CHARS
*        E$LIOE                   I/O ERROR DURING LOAD
*        E$LNFN                   ENTRY NOT FOUND
*
SYSLOAD  ENTER ,                  ENTRY POINT
         LA    7,E$MODN           SET PROPER ERROR IN CASE > 8 CHARS
         BAL   2,GETNAME          MOVE MODULE NAME TO 'NAME'
         MVC   BLDLIST(4),=X'0001003A'      SET 1 ENTRY, LENGTH = 58
         LR    3,0                COPY PARAMETER ADDRESS
         BLDL  0,BLDLIST          SEARCH DIRECTORY
         SH    15,=H'4'           TEST RETURN CODE
*
*        CHECK HERE FOR ERROR
*
         BZ    E$LNFN             B IF NOT FOUND
         BP    E$LIOE             ELSE I/O ERROR
*
*        HERE IF WE FOUND THE ENTRY
*
LODER1   LOAD  DE=NAME            LOAD THE MODULE
         B     EXIT0              EXIT PRESERVING (0) = CODE ADDRESS
         TITLE 'OSINT -- OS INTERFACE -- SYSUNLOD'
*
*        UNLOAD A LOAD MODULE
*
*        ENTRY CONDITIONS
*
*        (4)                      POINTER TO MODULE NAME
*
*        (5)                      LENGTH OF MODULE NAME
*
*        EXIT CONDITIONS
*
*        NO RESULTS RETURNED
*
*        ERROR CODES RETURNED
*
*        E$DELE                   MODULE NOT CURRENTLY LOADED
*        E$MODN                   MODULE NAME LONGER THAN 8 CHARS
*
SYSUNLOD ENTER ,                  ENTRY POINT
         LA    7,E$MODN           SET MESSAGE IN CASE NAME LENGTH > 8
         BAL   2,GETNAME          ACQUIRE NAME
         DELETE EPLOC=NAME        RELEASE THE MODULE
         LTR   15,15              TEST RETURN CODE
         BZ    EXIT               SUCCESS RETURN IF OK
         B     E$DELE             ELSE ERROR RETURN
         TITLE 'OSINT -- OS INTERFACE -- SYSPHASE'
*
*        LOAD A PHASE IN A MULTIPHASE ENVIRONMENT
*
*        ENTRY CONDITIONS
*
*        (0)                      CONTAINS VCON FOR PHASE
*
*        (4)                      POINTS TO 8 CHARACTER PHASE NAME
*
*        EXIT CONDITIONS
*
*        REQUESTED PHASE LOADED
*
*        ERROR CODES RETURNED
*
*        NONE
*
*        THE PHASE NAME IS NOT REQUIRED IN OS. IT IS INCLUDED IN THE
*        CALLING SEQUENCE FOR USE IN OTHER SYSTEMS (E.G. DOS/360)
*
SYSPHASE ENTER ,                  ENTRY POINT
         LR    1,0                COPY VCON TO OS PARAMETER REGISTER
         LA    0,1                INDICATE SEGWT
         SVC   37                 ISSUE SEGWT SVC
         B     EXIT               RETURN TO CALLER
         TITLE 'OSINT -- OS INTERFACE -- SYSSETP'
*
*        INFORM INTERFACE OF CHANGE IN DATA AREA POINTER
*
*        ENTRY CONDITIONS
*
*        (8)                      POINTS TO NEW DATA AREA
*
*        EXIT CONDITIONS
*
*        NO RESULTS RETURNED
*
*        ERROR CODES RETURNED
*
*        NONE
*
*        THIS ENTRY POINT IS USED IF THE EXECUTING PROGRAM WISHES TO
*        REGARD SOME OTHER AREA THAN THE ALLOCATED DYNAMIC AREA AS
*        THE DATA REGION USED FOR COMMUNICATION WITH THE INTERFACE.
*        BEFORE THIS ROUTINE IS CALLED. THE CALLER MUST COPY ALL THE
*        STANDARD INFORMATION FROM THE START OF THE ORIGINAL DATA
*        AREA ALLOCATED BY THE INTERFACE INTO THE NEW AREA.
*
SYSSETP  ENTER ,                  ENTRY POINT
         ST    8,DATAPTR          STORE NEW DATA AREA POINTER
         B     EXIT               RETURN TO CALLER
         TITLE 'OSINT -- OS INTERFACE -- SYSDCB'
*
*        LOCATE DCB FOR GIVEN FILENAME
*
*        ENTRY CONDITIONS
*
*        (4)                      POINTER TO FILENAME
*        (5)                      LENGTH OF FILENAME
*
*        EXIT CONDITIONS
*
*        (0)                      POINTER TO DCB
*
*        ERROR CODES RETURNED
*
*        E$MSDD                   MISSING DD CARD
*        E$FILG                   ILLEGAL FILENAME
*
SYSDCB   ENTER ,                  ENTRY POINT
         LA    7,E$FILG           SET ERROR MESSAGE IF BAD NAME
         BAL   2,GETNAME          ASSEMBLE FILENAME
         L     10,PTRDCB          POINT TO FIRST DCB
*
*        LOOP TO CHECK FOR DCB WITH MATCHING NAME
*
SYSDCBL  LTR   0,10               COPY AND TEST POINTER
         BZ    E$MSDD             MISSING DD CARD IF AT END OF CHAIN
         CLC   NAME(8),FILENAME   ELSE COMPARE NAMES
         BE    EXIT0              EXIT WITH DCB PTR SET IF MATCH
         L     10,DCBNEXT         ELSE POINT TO NEXT DCB ON CHAIN
         B     SYSDCBL            AND LOOP BACK TO CHECK NEXT
         TITLE 'OSINT -- OS INTERFACE -- SYSMAXL'
*
*        GET MAXIMUM RECORD LENGTH FOR INPUT RECORD
*
*        ENTRY CONDITIONS
*
*        (0)                      POINTER TO DCB
*
*        EXIT CONDITIONS
*
*        (0)                      MAXIMUM LENGTH OF DATA RECORD
*
*        ERROR CODES RETURNED
*
*        NONE
*
SYSMAXL  ENTER ,                  ENTRY POINT
         LR    10,0               COPY DCB POINTER
         LH    0,MAXRECL          LOAD MAX DATA RECORD LENGTH
         TM    OFLAGS,OPENI       MAKE SURE WE ARE OPEN FOR INPUT
         BO    EXIT0              RETURN WITH RESULT IN (0) IF SO
*
*        IF NOT OPEN FOR INPUT WE MUST OPEN THE FILE FIRST
*
         TM    OFLAGS,OPENO       ARE WE OPEN FOR OUTPUT?
         BO    E$READ             GIVE ERROR RETURN IF SO
         MVC   MLIST(LOPNLIST),OPNLIST      MOVE LIST INTO PLACE
         OPEN  ((10),INPUT),MF=(E,MLIST)    EXECUTE OPEN
         TM    DCBOFLGS,OPENOK    WAS OPEN SUCESSFUL?
         BZ    E$OPNI             GIVE ERROR IF NOT
         OI    OFLAGS,OPENI       ELSE SET OPEN FOR INPUT FLAG
         LH    0,MAXRECL          LOAD MAX DATA RECORD LENGTH
         B     EXIT0              RETURN RESULT IN REG (0)
         TITLE 'OSINT -- OS INTERFACE -- SYSREAD'
*
*        READ A RECORD
*
*        CALLING CONDITIONS
*
*        (0)                      POINTER TO SPITBOL DCB
*        (4)                      POINTER TO BUFFER TO RECEIVE RECORD
*
*        EXIT CONDITIONS
*
*        (0)                      LENGTH OF RECORD ACTUALLY READ
*                                 SET TO ZERO FOR A NULL RECORD
*                                 SET NEGATIVE FOR END OF FILE
*
*        ERROR CODES RETURNED
*
*        E$READ                   FILE OPENED FOR OUTPUT
*        E$EOFR                   PREVIOUS END OF FILE ENCOUNTERED
*        E$IERR                   PERMANENT INPUT ERROR
*        E$NOIN                   ATTEMPTED READ FROM WRITE ONLY FILE
*        E$OPNI                   ERROR IN OPENING FILE FOR INPUT
*
SYSREAD  ENTER ,                  ENTRY POINT
         LR    10,0               COPY POINTER TO DCB INTO PROPER REG
         TM    OFLAGS,OPENI       ARE WE OPEN FOR INPUT?
         BO    SYSREAD2           SKIP IF SO
         TM    OFLAGS,OPENO       ARE WE OPEN FOR OUTPUT?
         BO    E$READ             GIVE ERROR IF FILE OPENED FOR OUTPUT
*
*        HERE TO OPEN FILE FOR INPUT
*
SYSREAD1 MVC   MLIST(LOPNLIST),OPNLIST      MOVE LIST INTO PLACE
         OPEN  ((10),INPUT),MF=(E,MLIST)    EXECUTE OPEN
         TM    DCBOFLGS,OPENOK    WAS OPEN SUCCESSFUL?
         BZ    E$OPNI             GIVE ERROR IF NOT
         OI    OFLAGS,OPENI       SET OPEN FOR INPUT FLAG
*
*        HERE WITH FILE OPEN FOR INPUT
*
SYSREAD2 TM    OFLAGS,EOFE        PREVIOUS END OF FILE
         BO    E$EOFR             GIVE ERROR MSG IF SO
*
*        HERE TO MOVE THE RECORD
*
SYSREAD3 MVI   REREAD,0           RESET FLAG FOR REREAD
         TM    DCBRECFM,F         CHECK RECORD FORMAT
         BZ    SYSREADV           SKIP IF RECORD IS VARIABLE LENGTH
         GET   (10),(4)           TRANSMIT RECORD
         CLI   REREAD,0           MUST WE REREAD
         BNZ   SYSREAD3           LOOP BACK IF SO
         EJECT
*
*        HERE FOR F AND U TYPE RECORDS
*
         LH    0,DCBLRECL         LOAD RECORD LENGTH
*
*        HERE TO EXIT WITH CHECK FOR ./* EOF ON SYSIN
*
SYSREADX TM    OFLAGS,READER      STANDARD READ FILE?
         BNO   SYSREADZ           SKIP IF NOT
         CH    0,=H'80'           CHECK FOR RECORD TOO LONG ON SYSIN
         BH    E$SSIN             GIVE ERROR IF SO
         CLI   BATCHFLG,0         IS BATCHING ALLOWED?
         BE    SYSREADZ           SKIP IF NOT
         CLC   0(3,4),=C'./*'     ELSE TEST FOR TEMPORARY EOF ON READER
         BNE   SYSREADZ           SKIP IF NOT
         OI    EOFLAG,TEMPEOF     IF SO, SET FLAG
         TM    EOFLAG,DATAIN      DID WE READ ANYTHING?
         BNO   NEWJOB             IF NOT, SKIP TO IGNORE NULL PROGRAM
         B     EOF1               AND MERGE WITH EOF CIRCUIT
*
*        HERE FOR VARIABLE LENGTH RECORD
*
SYSREADV SH    4,=H'4'            POINT 4 BYTES BEHIND RECORD
         MVC   SAVEBF,0(4)        SAVE CHARS THERE NOW
         GET   (10),(4)           TRANSMIT V TYPE RECORD
         MVC   SAVE2(2),0(4)      MOVE RECORD LENGTH
         MVC   0(4,4),SAVEBF      RESTORE 4 BYTES BEFORE BUFFER
         LA    4,4(,4)            POINT TO DATA
         CLI   REREAD,0           MUST WE REREAD?
         BNZ   SYSREAD3           LOOP BACK IF SO
         LH    0,SAVE2            LOAD RECORD LENGTH
         SH    0,=H'4'            GET LENGTH OF DATA BYTES
         CH    0,=H'1'            CHECK FOR ONE CHARACTER RECORD
         BH    SYSREADX           JUMP IF NOT 1 CHAR RECORD
         CLI   0(4),X'00'         IF SO, IS IT HEX ZERO RECORD?
         BNE   SYSREADZ           SKIP IF NOT
         SR    0,0                ELSE TREAT 1 CHAR X'00' AS NULL
*
*        HERE TO RETURN TO CALLER
*
SYSREADZ OI    EOFLAG,DATAIN      RECORD SOME DATA HAS BEEN READ
         B     EXIT0              EXIT TO CALLER
         TITLE 'OSINT -- OSINTERFACE -- SYSWRITE'
*
*        WRITE A RECORD
*
*        CALLING CONDITIONS --
*
*        (0)                      POINTER TO SPITBOL DCB
*        (4)   SADR               ADDRESS OF STRING TO BE WRITTEN
*        (5)   SLEN               LENGTH OF STRING TO BE WRITTEN
*        (6)   FADR               ADDRESS OF FORMAT (UNUSED IF FLEN=0)
*        (7)   FLEN               LENGTH OF FORMAT STRING
*
*        ERROR CODE RETURNED
*
*        E$WRIT                   FILE OPENED FOR INPUT
*        E$OERR                   PERMANENT OUTPUT ERROR
*        E$NOUT                   ATTEMPTED WRITE TO READ ONLY FILE
*        E$OPNO                   ERROR IN OPENING FILE FOR OUTPUT
*
SYSWRITE ENTER ,                  ENTRY POINT
         LR    10,0               COPY DCB POINTER
         TM    OFLAGS,OPENO       ARE WE OPEN FOR OUTPUT?
         BO    SYSWRIT1           SKIP IF SO
         TM    OFLAGS,OPENI       ARE WE OPEN FOR INPUT?
         BO    E$WRIT             GIVE ERROR MESSAGE IF SO
*
*        HERE TO OPEN FILE FOR OUTPUT
*
SYSWRIT0 MVC   MLIST(LOPNLIST),OPNLIST      MOVE OPEN PARAMETER LIST
         OPEN  ((10),OUTPUT),MF=(E,MLIST)   EXECUTE OPEN
         TM    DCBOFLGS,OPENOK    WAS OPEN SUCCESSFUL?
         BZ    E$OPNO             GIVE ERROR IF NOT
         OI    OFLAGS,OPENO       SET OPEN FOR OUTPUT FLAG
*
*        HERE TO PERFORM THE OUTPUT
*
SYSWRIT1 LTR   SLEN,SLEN          TEST STRING LENGTH
         BNZ   SYSWRIT2           JUMP IF NON-NULL
*
*        HERE FOR A NULL STRING, WRITE AS 1 CHAR X'00'
*
         LA    SADR,=X'00'        POINT TO DUMMY RECORD
         LA    SLEN,1             SET DUMMY RECORD LENGTH = 1
         TM    DCBRECFM,V         TEST RECORD FORMAT TYPE
         BZ    SYSWRITG           IF NOT V RECORD WRITE BLANK REC  V2.3
         TM    DCBRECFM,A         IF V WITH ASA WRITE BLANK REC    V2.3
         BZ    SYSWRIT2           ELSE V NO ASA WRITE X'00' REC    V2.3
SYSWRITG LA    SADR,=C' '         ELSE SET TO WRITE A BLANK RECORD V2.3
*
*        HERE AFTER TAKING CARE OF NULL POSSIBILITY
*
SYSWRIT2 CH    FLEN,=H'1'         CHECK FORMAT LENGTH
         BNH   SYSWRITS           SKIP IF NOT FORTRAN FORMAT
         EJECT
*
*        HERE FOR CASE OF FORTRAN FORMAT
*
         BAL   3,FORMAT           CALL FORMAT PROCESSING ROUTINE
         B     EXIT               ALL DONE
*
*        HERE FOR UNFORMATTED OR SINGLE CHAR FORMAT (CONTROL CHAR)
*
SYSWRITS LTR   FLEN,FLEN          CHECK FOR FORMAT (CONTROL CHAR)
         BNZ   SYSWRITM           SKIP IF FORMATTED
         LA    FADR,SAVE2         ELSE SET GARBAGE LOC FOR CHAR RESTORE
         B     SYSWRITL           AND JUMP TO CALL WRITREC
*
*        COME HERE FOR FORMATTED RECORD
*
SYSWRITM BCTR  SADR,0             POINT TO CHAR BEHIND RECORD
         LA    SLEN,1(,SLEN)      ADJUST LENGTH FOR CONTROL CHARACTER
         MVC   SAVCHR,0(SADR)     SAVE CURRENT BYTE BEHIND RECORD
         MVC   0(1,SADR),0(FADR)  SET CONTROL CHARACTER
         LR    FADR,SADR          SAVE LOC TO REPLACE CHAR
*
*        MERGE HERE FOR UNFORMATTED RECORDS
*
SYSWRITL LH    R1,MAXRECL         LOAD MAX RECORD LENGTH
         LR    R2,SADR            POINT TO THIS RECORD
         CR    R1,SLEN            WILL THIS BE A FULL RECORD?
         BNH   *+6                SKIP IF SO
         LR    R1,SLEN            ELSE SET TO WRITE REST
         AR    SADR,R1            BUMP STRING POINTER
         SR    SLEN,R1            DECREMENT COUNT LEFT
         BAL   LINK1,WRITREC      OUTPUT RECORD
         MVC   0(1,FADR),SAVCHR   REPLACE SAVED CHAR BEHIND RECORD
*                                 NOTE: HARMLESS STORE IN SAVE2
*                                 IF UNFORMATTED
         LTR   SLEN,SLEN          MORE TO GO?
         BNP   EXIT               IF NOT, JUMP TO EXIT
         TM    DCBRECFM,A         ASA CONTROL CHARACTERS?
         BNO   SYSWRITL           IF NOT, BACK TO TREAT AS UNFORMATTED
         LA    FADR,=C' '         FOR ASA CONTROL CHARS, POINT TO BLANK
         B     SYSWRITM           AND BACK TO TREAT AS FORMATTED
         EJECT
*
*        LOCATE                   OBTAIN A BLANK BUFFER
*
*        BAL   LINK1,LOCATE
*        (BADR)                   POINTS TO BUFFER
*        BUFSTART                 POINTS TO BUFFER
*        (BLEN)                   MAX RECORD LENGTH
*
LOCATE   LH    R2,MAXRECL         GET MAXIMUM RECORD LENGTH
         LR    BLEN,R2            SAVE FOR RETURN
         AH    R2,=H'4'           BUMP POINTER FOR EXTRA STUFF
         CH    R2,OUTWBFLN        IS CURRENT WORK BUFFER LONG ENOUGH?
         BNH   LOCATE1            SKIP IF SO
*
*        HERE IF WE MUST GET A NEW LARGER WORK BUFFER
*
         LH    R0,OUTWBFLN        LOAD OLD BUFFER LENGTH
         FREEMAIN  R,LV=(0),A=OUTWBF        FREE OLD AREA
         LR    R0,R2              COPY NEW LENGTH REQUIRED
         GETMAIN   R,LV=(0)       ALLOCATE NEW AREA
         ST    R1,OUTWBF          STORE BUFFER POINTER
         STH   R2,OUTWBFLN        STORE NEW LENGTH
*
*        MERGE HERE TO CLEAR BUFFER OBTAINED
*
LOCATE1  L     BADR,OUTWBF        POINT TO BUFFER
         AH    BADR,=H'4'         ALLOW 4 EXTRA BYTES AT START
         LA    R0,256+1           CONSTANT TO CLEAR
         LR    R1,BADR            COPY STARTING ADDRESS
         LR    R2,BLEN            GET NUMBER OF CHARACTERS TO BLANK
*
*        LOOP TO CLEAR 257 CHARACTERS AT A TIME
*
LOCATEL  MVI   0(R1),C' '         SET BLANK AT START
         CR    R2,R0              HOW MANY CHARS LEFT?
         BNH   LOCATEX            JUMP IF ONLY ONE CHUNK LEFT
         MVC   1(256,R1),0(R1)    ELSE BLANK 256 CHARS (+ 1 = 257)
         AR    R1,R0              PUSH POINTER
         SR    R2,R0              DECREMENT COUNT OF CHARS LEFT
         B     LOCATEL            LOOP BACK
*
*        HERE FOR LAST CHUNK
*
LOCATEX  BCTR  R2,0               ADJUST COUNT FOR 360
         BCTR  R2,0               -1 FOR BLANK INSERTED
         EX    R2,LOCATEM         CLEAR REMAINING CHARACTERS
         ST    BADR,BUFSTART      SAVE LOC OF START OF BUFFER
         BR    LINK1              RETURN TO CALLER
*
LOCATEM  MVC   1(*-*,R1),0(R1)    BLANK LAST CHARACTERS
         EJECT
*
*        WRITREC                  SUBROUTINE TO WRITE A RECORD
*
*        (R1)                     RECORD LENGTH IN CHARACTERS
*        (R2)                     STARTING ADDRESS OF RECORD
*        BAL   LINK1,WRITREC
*        THIS ROUTINE DESTROYES REGISTERS 3,9
*
*
WRITREC  ST    LINK1,WRITRECS     SAVE LINKAGE
         CH    R1,=H'1'           ONE CHARACTER RECORD?
         BH    WRITREC2           SKIP IF NOT
*
*        HERE WE HAVE A ONE CHARACTER RECORD. THIS CAUSES TROUBLE ON
*        PRINTERS WITH ASA CONTROL, SO PAD AN EXTRA BLANK IF ASA CNTRL
*
         TM    DCBRECFM,A         ASA CONTROL CHARACTERS?
         BNO   WRITREC2           SKIP IF NOT
         MVC   BUFR+10(1),0(2)    ELSE MOVE THE ONE CHAR TO BUFFER
         MVI   BUFR+11,C' '       SUPPLY A BLANK PAD CHARACTER
         LA    R1,2               SET NEW RECORD LENGTH TWO CHARACTERS
         LA    R2,BUFR+10         POINT TO NEW RECORD
*
*        MERGE HERE AFTER DEALING WITH ONE CHARACTER RECORDS
*
WRITREC2 TM    DCBRECFM,V         CHECK RECORD FORMAT
         BZ    WRITRECF           SKIP IF FIXED LENGTH RECORDS
         TM    DCBRECFM,U         FURTHER CHECK
         BO    WRITRECU           SKIP IF UNDEFINED RECORDS
*
*        HERE FOR VARIABLE LENGTH RECORDS
*
         SH    R2,=H'4'           POINT FOUR BYTES BEHIND BUFFER
         MVC   SAVEBF,0(R2)       SAVE THE FOUR BYTES THERE
         LA    R1,4(,R1)          ADD IN LENGTH OF CONTROL FIELD
         SLL   R1,16              LEFT JUSTIFY RECORD LENGTH
         ST    R1,SAVE2           STORE RECORD LENGTH + 2 ZERO BYTES
         MVC   0(4,R2),SAVE2      SET AS HEADER FOR V TYPE RECORD
         B     WRITRECM           JUMP TO MERGE POINT
*
*        HERE FOR UNDEFINED RECORDS
*
WRITRECU STH   R1,DCBLRECL        STORE ACTUAL LENGTH IN DCB
         B     WRITRECM           MERGE
         EJECT
*
*        WRITREC (CONTINUED)
*
*        HERE FOR FIXED LENGTH RECORDS
*
WRITRECF CH    R1,DCBLRECL        DO WE NEED BLANK PADDING?
         BE    WRITRECM           IF NOT, JUMP TO MERGE
*
*        HERE IF WE MUST BLANK PAD A FIXED LENGTH RECORD
*
         STM   R1,R2,SAVE2        SAVE REGS
         BAL   LINK1,LOCATE       GET A BLANK BUFFER
         LM    R1,R2,SAVE2        RESTORE REGS
         BAL   LINK1,FORMMOVE     MOVE PARTIAL RECORD TO THIS BUFFER
         L     R2,BUFSTART        POINT TO START OF BUFFER, MERGE
*
*        MERGE HERE TO MOVE RECORD TO SYSTEM BUFFERS
*
WRITRECM L     0,MAXRECW          FIRST GET OUTPUT RECORD COUNTER
         SH    0,=H'1'            DECREMENT
         ST    0,MAXRECW          STORE DECREMENTED COUNT
         BZ    EXIT0              IMMEDIATE EXIT IF TOO MANY RECORDS
         PUT   (10),(2)           ELSE MOVE RECORD TO SYSTEM BUFFERS
         L     LINK1,WRITRECS     RESTORE WRITREC LINKAGE
         TM    DCBRECFM,F         CHECK RECORD FORMAT
         BCR   1,LINK1            ALL DONE UNLESS V TYPE RECORD
         MVC   0(4,R2),SAVEBF     ELSE RESTORE 4 BYTES BEFORE V RECORD
         BR    LINK1              AND THEN RETURN TO CALLER
         TITLE 'OSINT -- OS INTERFACE -- FORTRAN FORMAT PROCESSOR'
*
*        THIS ROUTINE PROCESSES FORTRAN FORMATS CONTAINING ANY OF
*        THE FOLLOWING FORMAT TYPES A,X,H,',T,/,(). THE LOCATE ROUTINE
*        IS USED TO FIND WHERE THE CONVERTED RECORD IS TO BE MOVED
*
*        CALLING SEQUENCE
*
*        (4)                      POINTER TO STRING TO BE OUTPUT
*        (5)                      REAL LENGTH OF OUTPUT STRING
*        (6)                      POINTER TO OUTPUT FORMAT
*        (7)                      REAL LENGTH OF FORMAT
*        BAL   3,FORMAT
*
*        REGISTER DEFINITIONS FOR FORMAT ROUTINE
*
R0       EQU   0                  SCRATCH
R1       EQU   1                  SCRATCH
R2       EQU   2                  SCRATCH
SADR     EQU   4                  ADDRESS OF NEXT CHARACTER IN STRING
SLEN     EQU   5                  NUMBER OF CHARACTERS LEFT IN STRING
FADR     EQU   6                  ADDRESS OF NEXT CHARACTER IN FORMAT
FLEN     EQU   7                  NUMBER OF CHARACTERS LEFT IN FORMAT
BADR     EQU   3                  ADDRESS OF NEXT AVAILABLE LOC IN BUFR
BLEN     EQU   9                  NUMBER OF POSITIONS LEFT IN BUFFER
LINK1    EQU   14                 INTERNAL CALLING REGISTER
*
*        ENTRY POINT
*
FORMAT   MVC   FSTAKADR,FSTAKBOT  INITIALIZE STACK ADDRESS
         ST    3,FORMRTN          SAVE RETURN POINT
         CLI   0(FADR),C'('       IS FIRST CHARACTER A (?
         BNE   E$FNLP             ERROR IF NOT
         LA    R1,0(FLEN,FADR)    POINT PAST FORMAT
         BCTR  R1,0               POINT TO LAST CHARACTER
         CLI   0(R1),C')'         DOES IT END WITH A )?
         BNE   E$FNRP             ERROR IF NOT
         BAL   LINK1,LOCATE       POINT TO BUFFER (SET BADR,BLEN)
         LA    R1,1               SET REPEAT COUNT FOR OUTER LEVEL
         EJECT
*
*        COME HERE FOR LEFT PAREN -- PUT ENTRY ON STACK
*
FORMLP   L     R2,FSTAKADR        GET CURRENT STACK LEVEL
         LA    R2,4(,R2)          PUSH STACK LEVEL
         C     R2,FSTAKEND        HAVE WE OVERFLOWED?
         BNL   E$FSOV             OFF TO GIVE ERR MSG IF SO
         ST    R2,FSTAKADR        ELSE STORE PUSHED POINTER
         ST    FADR,0(,R2)        ELSE STORE PAREN ADDRESS
         STC   R1,0(,R2)          AND SAVE REPEAT COUNT
         ST    FADR,FLASTLP       SAVE FOR FORMAT REPEAT
*
*        COME HERE TO DECREASE FORMAT COUNT AND PUSH FADR
*
FORMLP0  BCTR  FLEN,0             DECREASE NUMBER OF CHARS LEFT
*
*        COME HERE TO JUST PUSH FADR PAST 1 CHAR
*
FORMLP1  LA    FADR,1(,FADR)      BUMP PAST CHARACTER
*
*        COME HERE TO EXAMINE NEXT ELEMENT IN FORMAT
*
FORMLOOP BAL   LINK1,FORMNUM      TRY TO GET A NUMBER
         B     FNODIG             TRY SOMETHING ELSE IF NO NUMBER
         CLI   0(FADR),C'A'       IS THIS AN A TYPE FORMAT?
         BNE   FORMNOTA           SKIP IF NOT
*
*        COME HERE TO PROCESS AN A TYPE FORMAT, R1=REPEAT COUNT
*
FORMA    LR    R2,R1              SAVE FOR POSSIBLE NEW NUMBER
         LA    FADR,1(,FADR)      PUSH PAST THE 'A'
         BCTR  FLEN,0             DECREASE REMAINING SIZE
         BAL   LINK1,FORMNUM      TRY TO GET ANOTHER NUMBER
         LA    R1,1               SET DEFAULT LENGTH TO 1
         MR    R0,R2              A FIELD WIDTH IS PRODUCT OF 2 NUMBERS
         EJECT
*
*        COME HERE WITH 'A' FIELD WIDTH IN (R1)
*
FORMA1   SR    SLEN,R1            SUB NUMBER OF CHARS TO BE USED
         BNM   *+10               SKIP IF ENOUGH CHARACTERS
         AR    R1,SLEN            ELSE SET MOVE AMOUNT TO NO. OF CHARS
         BZ    FORMA2             SKIP IF NO CHARACTERS TO MOVE
         LR    R2,SADR            FROM ADDRESS IS START OF STRING
         AR    SADR,R1            PUSH PAST MOVED CHARACTERS
         BAL   LINK1,FORMMOVE     AND MOVE THE CHARACTERS
         LTR   SLEN,SLEN          DID WE HAVE AN UNFILLED A FIELD?
         BNM   FNODIG             GET NEXT ELEMENT IF NOT
*
*        COME HERE ON END OF FORMAT PROCESSING
*
FORMA2   BAL   LINK1,RECOUT       OUTPUT RECORD
         L     3,FORMRTN          RELOAD RETURN POINT
         BR    3                  RETURN TO CALLER
*
*        COME HERE TO CHECK FOR X TYPE FORMAT
*
FORMNOTA CLI   0(FADR),C'X'       IS IT X TYPE?
         BNE   FORMNOTX           JUMP IF NOT
*
*        COME HERE FOR 'X' FORMAT WITH COUNT IN (R1)
*
FORMX    AR    BADR,R1            PUSH BUFFER POINTER
         SR    BLEN,R1            DECREMENT COUNT OF CHARS LEFT IN BFR
         B     FORMLP0            LOOP BACK FOR NEXT ITEM
*
*        COME HERE TO CHECK FOR H TYPE FORMAT
*
FORMNOTX CLI   0(FADR),C'H'       IS IT H TYPE FORMAT?
         BNE   FORMNOTH           SKIP IF NOT
         BCTR  FLEN,0             DECREASE COUNT FOR 'H'
         SR    FLEN,R1            IS THIS A LEGITIMATE NUMBER?
         BNP   E$FHLN             GIVE ERROR MESSAGE IF NOT
         LA    R2,1(,FADR)        POINT TO FIRST DATA CHARACTER
         AR    FADR,R1            SKIP PAST DATA
         BAL   LINK1,FORMMOVE     MOVE CHARACTERS
         B     FORMLP1            AND PUSH FORMAT ADDRESS WHEN DONE
*
*        COME HERE TO CHECK FOR (
*
FORMNOTH CLI   0(FADR),C'('       IS IT LEFT PARENTHESIS?
         BE    FORMLP             MAKE STACK ENTRY IF SO
         B     E$FILL             ELSE ILLEGAL FORMAT TYPE
         EJECT
*
*        COME HERE IF FORMAT TYPE NOT STARTED WITH DIGITS
*
FNODIG   CLI   0(FADR),C' '       IS IT A BLANK?
         BE    FORMLP0            SKIP IT AND CONTINUE IF SO
         CLI   0(FADR),C','       IS IT A COMMA?
         BE    FORMLP0            SKIP PAST IT IF SO
         LA    R1,1               SET DEFAULT COUNT FOR 'A' OR '('
         CLI   0(FADR),C'A'       IS IT A TYPE FORMAT?
         BE    FORMA              MERGE IF SO
         CLI   0(FADR),C'('       IS IT LEFT PARENTHESIS?
         BE    FORMLP             MAKE STACK ENTRY IF SO
         CLI   0(FADR),C'X'       CHECK FOR AN X WITH NO COUNT
         BE    FORMX              JUMP BACK IF SO TO GET ONE SPACE
         CLI   0(FADR),C')'       IS IT RIGHT PARENTHESIS?
         BNE   FORMNTRP           SKIP IF NOT
*
*        HERE FOR ) -- LOOP BACK IF REPEAT COUNT NOT EXHAUSTED
*
         L     R2,FSTAKADR        GET ADDRESS OF CURRENT STACK ENTRY
         SR    R0,R0              CLEAR FOR IC
         IC    R0,0(,R2)          GET REPEAT COUNT
         BCT   R0,FORMRP1         DECREMENT AND TEST REPEAT COUNT
*
*        COME HERE IF LOOP DONE
*
         SH    R2,=H'4'           UNCONVER PREVIOUS ENTRY
         ST    R2,FSTAKADR        STORE FOR NEXT REFERENCE
         C     R2,FSTAKBOT        HAVE WE GONE PAST BOTTOM?
         BH    FORMLP0            SKIP PAST ) IF NOT
*
*        COME HERE IN CASE OF TOO MANY )'S OR END OF FORMAT
*
         BCT   FLEN,E$FUBP        TEST FOR END OF FMT, ERROR IF NOT
         BAL   LINK1,RECOUT       OUTPUT RECORD
         LTR   SLEN,SLEN          ARE WE AT END OF STRING?
         L     3,FORMRTN          RELOAD RETURN POINT IN CASE
         BCR   Z,3                RETURN IF SO TO CALLER
         BAL   LINK1,LOCATE       ELSE GET BUFFER PTRS FOR NEXT RECORD
         LA    R2,FORMSTAK        GET ADDR IF ONLY ONE ENTRY
         CLC   FLASTLP+1(3),FORMSTAK+1      WERE THERE ANY OTHER LPS?
         BE    *+8                SKIP IF NOT (LEAVE 1 STACK ENTRY)
         LA    R2,FORMSTAK+4      INDICATE 2 ENTRIES
         ST    R2,FSTAKADR        STORE STACK POINTER
         LA    FLEN,1(,FADR)      POINT PAST END OF FORMAT FOR AD CALC
         L     FADR,FLASTLP       POINT TO PREVIOUS LEFT PAREN
         SR    FLEN,FADR          CALCULATE NEW LENGTH REMAINING
         B     FORMLP0            JUMP TO GET NEXT FORMAT CHARACTER
         EJECT
*
*        COME HERE IF MORE LOOPING TO GO FOR THIS PAREN CASE
*
FORMRP1  STC   R0,0(,R2)          STORE UPDATED REPEAT COUNT
         AR    FLEN,FADR          POINT OFF STRING
         L     FADR,0(,R2)        GET STACK ENTRY
         LA    FADR,1(,FADR)      SKIP OVER LP, CLEAR UPPER BYTE
         SR    FLEN,FADR          CALCULATE CHARACTERS REMAINING
         B     FORMLOOP           AND OFF TO PROCESS FORMAT LOOP
*
*        COME HERE TO CHECK FOR /
*
FORMNTRP CLI   0(FADR),C'/'       IS IT SLASH?
         BNE   FORMNSLH           SKIP IF NOT
*
*        COME HERE TO PROCESS / (NEW RECORD)
*
FORMSLSH BAL   LINK1,RECOUT       OUTPUT RECORD
         BAL   LINK1,LOCATE       GET NEW POINTERS
         B     FORMLP0            BACK FOR NEXT FORMAT ITEM
*
*        COME HERE TO TEST FOR LITERAL
*
FORMNSLH CLI   0(FADR),C''''      IS IT A QUOTE?
         BNE   FORMNTQT           SKIP IF NOT
         LA    R2,1(,FADR)        POINT TO FIRST CHAR TO BE MOVED
*
*        COME HERE TO PAST PAST FORMAT ON NEW MOVE CASE
*
FQUOTE0  AR    FLEN,FADR          POINT PAST FORMAT STRING
*
*        LOOP TO SKIP NON QUOTE CHARACTERS
*
FQUOTE   LA    FADR,1(,FADR)      SKIP OVER CHARACTER
         CLI   0(FADR),C''''      IS NEXT CHARACTER A QUOTE?
         BNE   FQUOTE             SKIP IT IF NOT
         LR    R1,FADR            PREPARE LENGTH CALC
         SR    FLEN,FADR          GET REMAINING LENGTH OF FORMAT
         SR    R1,R2              GET LENGTH TO MOVE
         BZ    *+8                SKIP MOVE IF NO CHARACTERS
         BAL   LINK1,FORMMOVE     MOVE DATA CHARACTERS
         CLI   1(FADR),C''''      ARE THER TWO QUOTES?
         BNE   FORMLP0            SKIP PAST SINGLE QUOTE IF NOT
         LA    FADR,1(,FADR)      PUSH PAST FIRST QUOTE
         LR    R2,FADR            POINT TO QUOTE TO BE MOVED
         BCT   FLEN,FQUOTE0       DECREASE SIZE FOR QUOTE AND LOOP
         EJECT
*
*        COME HERE TO TEST FOR .
*
FORMNTQT CLI   0(FADR),C'.'       IS IT POSSIBLE END OF FORMAT?
         BNE   FORMNDOT           SKIP IF NOT
         LTR   SLEN,SLEN          ARE WE AT END OF STRING?
         BP    FORMLP0            SKIP . IF NOT
         B     FORMA2             ELSE MERGE WITH END OF STRING CODE
*
*        COME HERE TO CHECK FOR T TYPE FORMAT
*
FORMNDOT CLI   0(FADR),C'T'       IS IT T TYPE FORMAT?
         BNE   E$FILL             ILLEGAL TYPE IF NOT
         LA    FADR,1(,FADR)      SKIP PAST 'T'
         BAL   LINK1,FORMNUM      GET THE FOLLOWING NUMBER
         B     E$FTNM             GIVE ERR IF NOT NUMERIC
         BCTR  R1,0               GET TAB LOC AS OFFSET
         LH    BLEN,MAXRECL       GET MAX RECORD SIZE
         SR    BLEN,R1            CHARS LEFT = MAX - TAB
         A     R1,BUFSTART        TAB TO LOCATION IN BUFFER
         LR    BADR,R1            COPY NEW BUFFER LOCATION
         BCT   FLEN,FNODIG        -1 FOR T, CHECK NEXT CASE=¬NUMERIC
         EJECT
*
*        FORMMOVE                 MOVE CHARACTERS TO BUFFER
*
*        (R1)                     NUMBER OF CHARACTERS TO MOVE
*        (BADR)                   POINTER TO LOCATION IN BUFFER
*        (R2)                     POINTER TO DATA TO BE MOVED
*        BAL   LINK1,FORMMOVE
*        (BADR)                   UPDATED PAST MOVED CHARS
*        (BLEN)                   LENGTH REMAINING -- DECREMENTED
*
*        ANY CHARACTERS WHICH WOULD FALL BEYOND THE BUFFER ARE IGNORED
*
FORMMOVE LTR   BLEN,BLEN          ARE WE AT END OF RECORD?
         BCR   13,LINK1           RETURN IF NO ROOM IN BUFFER
         SR    BLEN,R1            DECREMENT FOR CHARS TO BE MOVED
         BNM   *+6                SKIP IF ENOUGH ROOM
         AR    R1,BLEN            ELSE SET MOVE SIZE TO BUFFER ROOM
*
*        COME HERE WITH REGISTERS SET UP FOR MOVE
*
FORMMOV1 BCTR  R1,0               GET 360 LENGTH
         LA    R0,256             GET VITAL CONSTANT
*
*        LOOP TO MOVE 256 CHARACTERS AT A TIME
*
FORMLMOV CR    R1,R0              ARE WE SMALL ENOUGH FOR ONE MOVE?
         BL    FORMSMOV           SKIP IF SO
         MVC   0(256,BADR),0(R2)  MOVE LARGE PIECE
         AR    R2,R0              PUSH FROM POINTER
         AR    BADR,R0            PUSH TO ADDRESS
         SR    R1,R0              BACK UP LENGTH
         B     FORMLMOV           CHECK LENGTH AND MOVE REST
*
*        COME HERE TO MOVE <= 256 BYTES
*
FORMSMOV EX    R1,FORMMVC         MOVE IN LAST CHARACTERS
         LA    BADR,1(BADR,R1)    UPDATE BUFFER ADDRESS
         BR    LINK1              RETURN TO FORMMOVE CALLER
*
FORMMVC  MVC   0(*-*,BADR),0(R2)  MOVE IN VARIABLE LENGTH PIECE
         EJECT
*
*        FORMNUM                  SCAN OUT NUMBER
*
*        (FADR)                   FORMAT POINTER
*        (FLEN)                   NUMBER OF CHARS REMAINING IN FORMAT
*        BAL   LINK1,FORMNUM
*        -->                      RETURN HERE IF NON-NUMERIC
*        -->                      NORMAL RETURN
*        (R1)                     VALUE OF NUMBER IN BINARY
*        (FADR)                   UPDATED PAST NUMBER
*        (FLEN)                   UPDATED PAST NUMBER
*
*        --> E$FZER               ERROR RETURN FOR ZERO RESULT
*
FORMNUM  CLI   0(FADR),C'0'       IS FIRST CHARACTER A DIGIT?
         BCR   L,LINK1            RETURN IF NOT
         SR    R1,R1              CLEAR RESULT REGISTER
*
*        LOOP TO PICK UP DIGIT AND COMBINE WITH RESULT
*
FNUMLOOP IC    R0,0(,FADR)        GET NEXT DIGIT
         N     R0,=X'0000000F'    REMOVE ZONE + OTHER GARBAGE
         MH    R1,=H'10'          SHIFT LEFT CURRENT NUMBER ONE DIGIT
         AR    R1,R0              AND ADD IN THIS DIGIT
         LA    FADR,1(,FADR)      SKIP PAST DIGIT
         BCTR  FLEN,0             DECREASE LENGTH REMAINING
         CLI   0(FADR),C'0'       IS NEXT CHARACTER AT LEAST DIGIT?
         BNL   FNUMLOOP           LOOP IF DIGIT
*
*        COME HERE TO CHECK FOR ZERO RESULT
*
FNUMXIT  LTR   R1,R1              IS RESULT ZERO?
         BP    4(,LINK1)          RETURN TO CALLER IF NOT
         B     E$FZER             ELSE GIVE ERROR MESSAGE
*
*
*        RECOUT                   OUTPUT FORMATTED RECORD
*
*        (BADR)                   POINTER PAST LAST CHAR IN BUFFER
*        BAL   LINK1,RECOUT
*        -->   RETURN WITH RECORD OUTPUT
*        (BLEN,BADR,R1,R2)        DESTROYED
*
RECOUT   L     R2,BUFSTART        POINT TO START OF RECORD
         LR    R1,BADR            COPY CURRENT POINTER
         SR    R1,R2              SUBTRACT TO GET RECORD LENGTH
         TM    DCBRECFM,V         CHECK RECORD FORMAT
         BO    WRITREC            JUMP TO OUTPUT ROUTINE IF U OR V REC
         LH    R1,DCBLRECL        ELSE SET LENGTH OF FULL REC IF F TYPE
         B     WRITREC            JUMP TO OUTPUT ROUTINE
         TITLE 'OSINT -- OS INTERFACE -- SYNCHRONOUS ERROR ROUTINES'
*
*        HERE FOR I/O ERROR (SYNAD ROUTINE)
*
SYNAD    TM    OFLAGS,READER      IS THIS SYSIN?
         BNO   *+8                SKIP IF NOT
         OI    EOFLAG,PERMEOF     ELSE SET SPECIAL SYSIN EOF FLAG
         TM    OFLAGS,OPENI       IS THIS INPUT CASE?
         BO    E$IERR             GIVE INPUT ERROR IF SO
         B     E$OERR             ELSE GIVE OUTPUT ERROR MESSAGE
*
*        ROUTINE ENTERED ON ENCOUNTERING END OF FILE (EODAD ROUTINE)
*
EOF      TM    OFLAGS,READER      IS THIS AN EOF ON SYSIN?
         BNO   EOF1               SKIP IF NOT
         OI    EOFLAG,PERMEOF     ELSE SET SPECIAL SYSIN EOF
         SR    0,0                SET RETURN CODE = 0 IN CASE OF EOJ
         TM    EOFLAG,DATAIN      HAS ANY DATA BEEN READ?
         BNO   SYSEOJM            IF NOT, TREAT AS EOJ, ELSE MERGE
*
*        HERE AFTER SPECIAL PROCESSING FOR SYSIN
*
EOF1     OI    OFLAGS,EOFE        SET END OF FILE FLAG
         LCR   0,11               SET (0) = NEGATIVE = END OF FILE
         B     EXIT0              JUMP TO EXIT
*
*        HERE FOR ERROR ON SYSPRINT FILE
*
PRNERROR WTO   'ERROR ON SYSPRINT FILE'     TELL OPERATOR
         ABEND 300,DUMP           GIVE ABEND
         TITLE 'OSINT -- OS INTERFACE -- SYSTIME'
*
*        GET TIMER VALUE
*
*        NO PARAMETERS
*
*        EXIT CONDITIONS
*
*        (0)                      ELAPSED TIME IN MILLISECONDS
*
*        ERROR CODES RETURNED
*
*        NONE
*
SYSTIME  ENTER ,                  ENTRY POINT
         TTIMER ,                 GET CURRENT TIMER
         S     0,TSTART           SUBTRACT STARTING TIME
         LCR   1,0                MOVE AND COMPLEMENT
         M     0,=F'26040'        CONVERT TO NANOSECS
         D     0,=F'1000000'      CONVERT TO MILLESECS
         LR    0,1                PUT IN PROPER REGISTER
         B     EXIT0              JUMP TO EXIT
         TITLE 'OSINT -- OS INTERFACE -- SYSDUMP'
*
*        DUMP MEMORY
*
*        NO ENTRY PARAMETERS
*
*        NO RESULT RETURNED
*
*        ERROR CODES              NONE
*
SYSDUMP  ENTER ,                  ENTRY POINT
         MVC   SYSREGS(64),SAVE1  SAVE ENTRY REGS & SET FOR DUMP
         BAL   14,DUMP            CALL DUMP ROUTINE
         MVC   SAVE1(64),SYSREGS  RESTORE ENTRY REGS TO ENTRY SAVE AREA
         B     EXIT               GIVE NORMAL EXIT
         TITLE 'OSINT -- OS INTERFACE -- SYSRWIND'
*
*        REWIND FILE
*
*        CALLING CONDITIONS
*
*        (0)                      POINTER TO DCB FOR FILE
*
*        EXIT CONDITIONS
*
*        NO RESULTS RETURNED
*
*        ERROR CODES RETURNED
*
*        E$RSYS                   ATTEMPT TO REWIND SYSTEM FILE
*
SYSRWIND ENTER ,                  ENTRY POINT
         LR    10,0               COPY DCB POINTER
         TM    OFLAGS,PRINTER+PUNCHER+READER SYSTEM FILE?
         BNZ   E$RSYS             GIVE ERROR IF SO
         TM    OFLAGS,OPENI+OPENO IS FILE ACTUALLY OPEN?
         BZ    EXIT               IMMEDIATE EXIT IF NOT
         MVC   MLIST(LCLSLIST),CLSLIST      MOVE CLOSE PARAMETER LIST
         CLOSE ((10),REREAD),MF=(E,MLIST)   EXECUTE CLOSE
         NI    OFLAGS,X'FF'-OPENI-OPENO-EOFE RESET OPEN, EOF FLAGS
         B     EXIT               EXIT TO CALLER
         TITLE 'OSINT -- OS INTERFACE -- SYSCLOSE'
*
*        CLOSE FILE
*
*        ENTRY CONDITIONS
*
*        (0)                      POINTER TO DCB FOR FILE
*
*        EXIT CONDITIONS
*
*        NO RESULTS RETURNED
*
*
*        ERROR CODES RETURNED
*
*        NONE
SYSCLOSE ENTER ,                  ENTRY POINT
         LR    10,0               MOVE DCB POINTER TO STANDARD REGISTER
         TM    OFLAGS,READER+PRINTER+PUNCHER SYSTEM FILE?
         BNZ   EXIT               IGNORE CALL TO CLOSE SYSTEM FILE
         BAL   2,CLOSER           ELSE CLOSE FILE
         B     EXIT               RETURN TO CALLER
*
*        UTILITY ROUTINE TO CLOSE A FILE
*
*        (10)                     POINTS TO DCB
*        BAL   2,CLOSER
*
CLOSER   TM    OFLAGS,OPENI+OPENO IS FILE OPEN?
         BCR   Z,2                IMMEDIATE RETURN IF NOT
         MVC   MLIST(LCLSLIST),CLSLIST      MOVE CLOSE PARAMETER LIST
         CLOSE ((10),DISP),MF=(E,MLIST)     EXECUTE CLOSE
         FREEPOOL  (10)           FREE BUFFER POOL
         NI    OFLAGS,X'FF'-OPENI-OPENO-EOFE RESET OPEN, EOF FLAGS
         BR    2                  RETURN TO CALLER
         TITLE 'OSIN0 -- OS INTERFACE -- DCB EXIT ROUTINES'
*
*        DCB EXIT ROUTINE FOR SYSPRINT
*
EXPRT    BAL   2,FILLIN           CALL COMMON ROUTINE
         DC    Y(V+B+A)           DEFAULT RECFM=VBA
         DC    Y(1782)            DEFAULT BLKSIZE=1782
         DC    Y(137)             DEFAULT LRECL=137
*
*        DCB EXIT ROUTINE FOR SYSPUNCH
*
EXPCH    BAL   2,FILLIN           CALL COMMON ROUTINE
         DC    Y(V+B)             DEFAULT RECFM=VB
         DC    Y(88)              DEFAULT BLKSIZE=88
         DC    Y(84)              DEFAULT LRECL=80
*
*        DCB EXIT ROUTINE FOR SYSIN
*
EXRDR    BAL   2,FILLIN           CALL COMMON ROUTINE
         DC    Y(F+B)             DEFAULT RECFM=FB
         DC    Y(400)             DEFAULT BLKSIZE=400
         DC    Y(80)              DEFAULT LRECL=80
*
*        DCB EXIT ROUTINE FOR SYSOBJ
*
EXOBJ    BAL   2,FILLIN           CALL COMMON ROUTINE
         DC    Y(F+B)             DEFAULT RECFM=FB
         DC    Y(400)             DEFAULT BLKSIZE=400
         DC    Y(80)              DEFAULT LRECL=80
*
*        DCB EXIT ROUTINE FOR NON-SYSTEM FILES
*
EXALL    BAL   2,FILLIN           CALL COMMON ROUTINE
         DC    Y(V+B+S)           DEFAULT RECFM=VBS
         DC    Y(1782)            DEFAULT BLKSIZE=1782
         DC    Y(2004)            DEFAULT LRECL=2004
         EJECT
*
*        COMMON ROUTINE TO FILL IN MISSING FIELDS
*
FILLIN   LR    10,1               POINT TO DCB
         CLI   DCBRECFM,0         WAS RECFM GIVEN?
         BNZ   FILLIN1            SKIP IF SO (ASSUME OTHER PARAMS)
         MVC   DCBRECFM(1),1(2)   ELSE SET PROPER DEFAULT RECFM
         LH    3,DCBBLKSI         GET BLKSIZE?
         LTR   3,3                WAS ONE GIVEN?
         BNZ   *+10               SKIP IF SO
         MVC   DCBBLKSI,2(2)      ELSE SET PROPER DEFAULT
         LH    3,DCBLRECL         LOAD LRECL
         LTR   3,3                WAS LRECL GIVEN?
         BNZ   *+10               SKIP IF SO
         MVC   DCBLRECL,4(2)      ELSE SET PROPER DEFAULT
*
*        NOW GET AND SET MAXRECL
*
FILLIN1  LH    3,DCBLRECL         GET LRECL
         LTR   3,3                DO WE HAVE LRECL GIVEN?
         BNZ   *+8                SKIP IF SO
         LH    3,DCBBLKSI         ELSE GET BLKSIZE
         TM    DCBRECFM,F         CHECK RECFM
         BO    *+8                SKIP IF F OR U
         SH    3,=H'4'            ELSE ADJUST FOR LENGTH OF V RECORD
         STH   3,MAXRECL          STORE MAX RECORD LENGTH
         OI    DCBOFLGS,X'08'     SET FOR POSSIBLE CONCATENATION
         MVI   REREAD,1           SET REREAD FLAG
         BR    14                 CONTINUE WITH OPEN PROCESSING
         TITLE 'OSINT -- OS INTERFACE -- SYSABEND'
*
*        ABEND TERMINATION
*
*        ENTRY CONDITIONS
*
*        NONE
*
*        EXIT CONDITIONS
*
*        SYSABEND DOES NOT RETURN TO ITS CALLER
*
*        ERROR CODES
*
*        NONE
*
SYSABEND ENTER ,                  ENTRY POINT
         L     1,DLIMIT           LOAD CURRENT VALUE OF D PARAMETER
         LTR   1,1                TEST IT
         BZ    SYSABOMB           JUMP IF HE WANTS SYSTEM BOMB
*
*        HERE WE GIVE AN OSINT DUMP
*
         BCTR  1,0                DECREMENT D PARAMETER
         ST    1,DLIMIT           STORE DECREMENTED VALUE
         BAL   14,DUMP            GIVE OSINT DUMP
         LA    2,SYSEOJ           POINT TO END OF JOB ROUTINE
         MVI   BOMBFLG,1          SET FLAG FOR BOMB OCCURED
         BALR  1,2                JUMP TO END OF JOB ROUTINE
*
*        HERE IF HE WANTS A SYSTEM DUMP
*
SYSABOMB ABEND 100,DUMP           GIVE DUMP CODE=U100
         TITLE 'OSINT -- OS INTERFACE -- SYSEOJ'
*
*        END OF JOB
*
*        ENTRY CONDITIONS
*
*        (0)                      COMPLETION CODE
*
*        EXIT CONDITIONS
*
*        SYSEOJ DOES NOT RETURN EXCEPT TO INITIATE A NEW JOB IN A
*        BATCHED RUN (SEE NEWJOB)
*
*        ERROR CODES RETURNED
*
*        NONE (SYSEOJ DOES NOT RETURN)
*
SYSEOJ   ENTER ,                  ENTRY POINT
*
*        MERGE HERE AFTER NULL JOB (NO INPUT)
*
SYSEOJM  LR    6,0                SAVE COMPLETION CODE
         L     0,PTRDCB           POINT TO FIRST DCB ON CHAIN
         LA    2,SYSCLOSE         POINT TO CLOSE ROUTINE
*
*        LOOP TO CLOSE ANY FILES LEFT OPEN (EXCEPT SYSTEM FILES)
*
SYSEOJ1  BALR  1,2                CALL CLOSE ROUTINE
         NOP   0                  NO ERROR POSSIBLE FROM CLOSE
         LR    10,0               COPY DCB PTR TO STANDARD REG
         L     0,DCBNEXT          POINT TO NEXT DCB ON CHAIN
         LTR   0,0                END OF CHAIN?
         BNZ   SYSEOJ1            LOOP BACK IF NOT
*
*        ALL FILES CLOSED, NOW CHECK FOR POSSIBILITY OF BATCHED JOB
*
         CLI   BATCHFLG,0         TEST FOR BATCHING ALLOWED
         BE    SYSEOJX            IF NOT, SKIP TO REAL END OF JOB
*
*        HERE TO SEE IF WE HAVE ANOTHER JOB IN THE BATCH
*
SYSEOJ2  TM    EOFLAG,PERMEOF     PERMANENT (SYSTEM) EOF?
         BO    SYSEOJX            NO NEW JOB IF NO NEW INPUT
         TM    EOFLAG,TEMPEOF     DID WE READ A ./* ?
         BO    NEWJOB             IF SO, JUMP TO INITIATE NEW JOB
*
*        HERE WE READ TO AN EOF (./* OR /*)
*
         L     4,OUTWBF           POINT TO WORK BUFFER
         AH    4,=H'4'            ADJUST FOR POSSIBLE LENGTH FLD
         LA    2,SYSREAD          POINT TO READ ROUTINE
         L     0,READDCB          POINT TO READER DCB
         BALR  1,2                READ A CARD
         B     SYSEOJX            JUMP TO END OF RUN ON INPUT ERROR
         B     SYSEOJ2            ELSE BACK TO TEST FOR EOF
         EJECT
*
*        COME HERE TO TERMINATE, FIRST CLOSE SYSTEM FILES
*
SYSEOJX  L     10,PRINTDCB        POINT TO SYSPRINT DCB
         BAL   2,CLOSER           CLOSE IT
         L     10,PUNCHDCB        POINT TO SYSPUNCH DCB
         BAL   2,CLOSER           CLOSE IT
         L     10,READDCB         POINT TO SYSIN DCB
         BAL   2,CLOSER           CLOSE IT
*
*        RELEASE MAIN DYNAMIC STORAGE AREA TO SYSTEM
*
         LM    1,2,ALLOC          ADDRESS / LENGTH ORIGINALLY OBTAINED
         LR    0,2                PUT LENGTH IN PROPER REGISTER
         FREEMAIN  R,LV=(0),A=(1) FREE MAIN DYNAMIC AREA
         L     10,PTRDCB          LOAD POINTER TO FIRST DCB
*
*        LOOP TO FREE AREAS FOR DCBS
*
SYSEOJL  LR    1,10               MOVE DCB ADDRESS TO PROPER REG
         LA    0,LMODDCB          SET PROPER DCB LENGTH
         L     10,DCBNEXT         POINT TO NEXT DCB
         FREEMAIN  R,LV=(0),A=(1) FREE AREA FOR DCB
         LTR   10,10              END OF CHAIN?
         BNZ   SYSEOJL            LOOP TILL ALL FREED
*
*        NOW WE ARE READY TO RETURN TO THE SYSTEM
*
         L     5,PICASAV          LOAD POINTER TO CALLER'S PICA
         SPIE  MF=(E,(5))         RESTORE PICA FOR CALLER, FREE OURS
         CLI   BOMBFLG,0          DID WE HAVE A BOMB?
         BNZ   SYSEOJB            JUMP IF SO TO GIVE ABEND
         LR    1,13               ELSE SAVE ADDRESS OF WORK AREA
         L     13,ENT13SV         RELOAD PTR TO CALLERS SAVE AREA
         FREEMAIN  R,LV=LWORK,A=(1)         FREE WORK AREA
         LR    15,6               GET RETURN CODE (ITS STILL THERE)
         RETURN    (14,12),RC=(15)          RETURN TO SYSTEM
*
*        HERE IF WE HAD A BOMB, GIVE A U100 ABEND
*
SYSEOJB  ABEND 100                GIVE ABEND (NO DUMP)
         TITLE 'OSINT -- OS INTERFACE -- EXIT'
*
*        COME HERE TO EXIT TO INTERFACE CALLER
*
*        USE THIS ENTRY POINT IF (0) CONTAINS A RESULT TO BE RETURNED
*
EXIT0    ST    0,SAVE1            SAVE RESULT SO WE CAN MERGE
*
*        USE THIS ENTRY POINT IF ALL REGS ARE TO BE RESTORED
*
EXIT     LM    0,15,SAVE1         RESTORE ALL REGS
         B     4(,1)              RETURN TO CALLER PAST ERROR RETURN
*
*        CUTOFF DATE -- GETS WRITTEN WHEN TAPES ARE GENERATED
*
         ORG   *                  PUT ON NEW TEXT CARD
DATECUT  DC    C'99000'           YYDDD CUTOFF DATE
*
*        DATE CHECK DIGIT, ALSO SET ON A COPY
*
CKDIGIT  DC    X'C2'              SEE CHECK CIRCUIT FOR DETAILS
         TITLE 'OSINT -- OS INTERFACE -- GETNAME'
*
*        AUXILIARY SUBROUTINE TO CONSTRUCT NAME
*
*        (4,5)                    STRING NAME (FROM SPITBOL)
*        (7)                      ADDRESS OF ERROR ROUTINE IF NAME > 8
*        BAL   2,GETNAME
*        -->   NORMAL RETURN
*        NAME                     CONTAINS NAME RIGHT BLANK PADDED
*
*        IF NAME IS LONGER THAN 8 CHARACTERS AN ERROR RETURN USING
*        THE ERROR MESSAGE WHOSE ADDRESS IS GIVEN IN (7)
*
GETNAME  BCTR  5,0                GET 360 LENGTH OF NAME
         CH    5,=H'7'            CHECK FOR TOO LONG
         BCR   2,7                GIVE ERROR IF TOO LONG
         CH    5,=H'1'            IS IT MORE THAN 2 CHARACTER NAME?
         BH    GETNAME1           SKIP IF YES
*
*        HERE WE MAY HAVE AN INTEGER, IN WHICH CASE WE USE THE
*        FORTRAN TYPE NAME FTXXF001 AS THE DDNAME FOR COMPATABILITY
*
         MVC   NAME,=C'FT00F001'  MOVE IN FORTRAN NAME MODEL
         LA    1,NAME+3           SET UP POINTER IF ONE CHAR NAME
         SR    1,5                BACK UP IF 2 CHARACTER NAME
         EX    5,GETNAMBL         MOVE IN POSSIBLE DIGITS
         CLI   NAME+3,X'F0'       IS SECOND CHARACTER NUMERIC?
         BL    GETNAME1           SKIP IF NOT (NOT FORTRAN NAME)
         CLI   NAME+2,X'F0'       ELSE IS FIRST DIGIT NUMERIC?
         BCR   H,2                EXIT IF YES AND NON-ZERO
         BE    GETNAMEC           SKIP FOR SPECIAL CHECK IF ZERO
*
*        COME HERE TO USE NAME EXACTLY AS GIVEN
*
GETNAME1 MVC   NAME+1(7),=C'       '        PREBLANK NAME AREA
         EX    5,GETNAMEM         MOVE CHARS OF NAME
         BR    2                  EXIT TO CALLER
*
GETNAMEM MVC   NAME(*-*),0(4)     MOVE NAME
*
GETNAMBL MVC   0(*-*,1),0(4)      TO CONSTRUCT FORTRAN TYPE NAME
         EJECT
*
*        COME HERE FOR FORTRAN NAME WHERE DATASET REFERENCE NUMBER
*        IS ONLY ONE DIGIT. IF A SYSTEM FILE IS REFERENCED (5,6,7)
*        AND THERE IS NO DD CARD WITH THE PROPER DDNAME, THEN THE
*        STANDARD DDNAME IS SUBSTITUTED, E.G. SYSIN FOR FT05F001
*
GETNAMEC CLI   NAME+3,C'5'        FT05F001?
         LA    9,=CL8'SYSIN'      GET SYSIN NAME IN CASE
         BE    GETNAMET           SKIP IF POSSIBLE SUBSTITUTION
         CLI   NAME+3,C'6'        FT06F001?
         LA    9,=CL8'SYSPRINT'   GET SYSPRINT NAME IN CASE
         BE    GETNAMET           SKIP IF POSSIBLE SUBSTITUTION
         CLI   NAME+3,C'7'        FT07F001?
         LA    9,=CL8'SYSPUNCH'   GET SYSPUNCH NAME IN CASE
         BCR   NE,2               IF NONE OF THESE, EXIT (USE FTXXF001)
*
*        HERE IF WE HAVE A POSSIBLE SUBSTITUTION
*
GETNAMET LR    0,2                SAVE GETNAME LINKAGE
         BAL   2,DDCHEK           SEE IF DD CARD WAS ALREADY GIVEN
         LR    2,0                RESTORE GETNAME LINKAGE
         BCR   Z,2                IF DD CARD SUPPLIED, EXIT TO USE IT
         MVC   NAME,0(9)          ELSE USE SUBSTITUTE NAME
         BR    2                  AND THEN EXIT
         TITLE 'OSINT -- OS INTERFACE -- DDCHEK'
*
*        SUBROUTINE TO CHECK FOR PRESENCE OF A GIVEN DDNAME
*
*        NAME                     DDNAME TO BE SEARCHED FOR
*        BAL   2,DDCHEK
*        -->   RETURN HERE WITH CC SET EQUAL IF FOUND, ELSE UNEQUAL
*
*        USES REGISTERS 1,7
*
DDCHEK   L     7,TIOTLOC          POINT TO TIOT
         USING TIOT,7             TELL ASSEMBLER
*
*        LOOP TO SEARCH TIOT
*
DDCHEKL  CLC   NAME,TIOEDDNM      IS THIS THE ONE?
         BCR   E,2                RETURN IF SO WITH CC EQUAL
         SR    1,1                ELSE CLEAR 1 FOR IC
         IC    1,TIOELNOH         LOAD TIOT ENTRY LENGTH
         LTR   1,1                TEST FOR END OF TIOT (LENGTH = 0)
         LA    7,0(1,7)           PUSH TO NEXT ENTRY IF IT EXISTS
         BNZ   DDCHEKL            LOOP BACK IF MORE ENTRIES TO GO
*
*        HERE IF WE DID NOT FIND IT
*
         CR    11,12              COMPARE BASE REGS TO GET CC = UNEQUAL
         BR    2                  RETURN TO CALLER
         DROP  7                  DROP TIOT BASE REG
         TITLE 'OSINT -- OS INTERFACE -- PATCH SPACE'
         DC    20F'0'             INTERFACE PATCH SPACE
*
*        THE FOLLOWING LOCATIONS ARE PATCHED TO CONTAIN TF NUMBERS
*        WHENEVER A TF IS APPLIED (HALFWORD CODES)
*
TFIXES   DC    35H'0'             ASSEMBLE AS ZEROS                V2.3
*
NFIXES   EQU   35                 NUMBER OF POSSIBLE FIXES
         TITLE 'OSINT -- OS INTERFACE -- INTERVAL TIMER INTERRUPT'
*
*        THIS ROUTINE RECEIVES CONTROL ON A TIMER TRAP
*
         USING OVERTIME,11        BASE REG FOR OVERTIME ROUTINE
         DROP  12                 DROP STANDARD BASE REG
OVERTIME SAVE  (14,12)            SAVE REGISTERS
         LR    11,15              SET BASE REGISTER
         LR    0,13               SAVE REG 13
         L     2,16               POINT TO CVT
         L     2,CVTTCBP(,2)      POINT TO TCB POINTERS
         L     2,4(,2)            POINT TO CURRENT TCB
         L     13,TCBFSA(,2)      POINT TO HIGHEST SAVE AREA
*
*        LOOP TO LOCATE OUR SAVE AREA (LOW ORDER BIT OF FORWARD PTR ON)
*
OVERTIMA TM    8+3(13),1          IS THIS OUR SAVE AREA?
         L     13,8(,13)          POINT TO NEXT SAVE AREA ANYWAY
         BNO   OVERTIMA           LOOP BACK IF NOT THE ONE WE WANT
*
*        HERE WHEN WE HAVE FOUND OUR SAVE AREA
*
OVERTIMB BCTR  13,0               REMOVE GARBAGE LOW ORDER BIT
         L     8,DATAPTR          LOAD POINTER TO DATA AREA
         ST    0,SYSREGS          SAVE POINTER TO PREVIOUS SAVE AREA
         STIMER    TASK,OVERTIME,TUINTVL=TINC  KEEP TIMER GOING
         L     15,TINC            LOAD INCREMENTAL TIME VALUE
         A     15,TSTART          ADD TO OLD STARTING VALUE
         ST    15,TSTART          STORE MODIFIED STARTING VALUE
         L     15,=V(SYSOVTM)     POINT TO OVERTIME ROUTINE
         BALR  14,15              PASS CONTROL TO ROUTINE
         L     13,SYSREGS         RELOAD POINTER TO PREVIOUS SAVE AREA
         RETURN (14,12)           RETURN VIA CONTROL PROGRAM
         DROP  11                 DROP TEMPORARY BASE REGISTER
*
TINC     DC    F'999999999'       INCREMENT TO KEEP TIMER GOING
         TITLE 'OSINT -- OS INTERFACE -- PROGRAM CHECK ROUTINE'
*
*        THIS ROUTINE RECEIVES CONTROL ON ANY PROGRAM INTERRUPT
*        REGISTER (1) POINTS TO THE PROGRAM INTERRUPTION ELEMENT
*
*        THE MAIN PROGRAM MUST PROVIDE AN ENTRY POINT 'SYSINTR'
*        WHICH RECEIVES CONTROL AS FOLLOWS
*
*        (8)                      POINTS TO THE DATA AREA
*                                 (EVEN IF NOT SET AT INTERRUPT TIME)
*        (15)                     POINTS TO SYSINTR
         BR    15
*
         USING PCEXIT,15          BASE REG SET BY CALLER
PCEXIT   LR    0,13               SAVE REG 13
         L     2,16               POINT TO CVT
         L     2,CVTTCBP(,2)      POINT TO TCB POINTERS
         L     2,4(,2)            POINT TO CURRENT TCB
         L     13,TCBFSA(,2)      POINT TO HIGHEST SAVE AREA
*
*        LOOP TO LOCATE OUR SAVE AREA (LOW ORDER BIT OF PTR ON)
*
PCEXITL  TM    8+3(13),1          IS THIS OUR SAVE AREA?
         L     13,8(,13)          POINT TO NEXT SAVE AREA ANYWAY
         BNO   PCEXITL            LOOP BACK IF NOT THE ONE WE WANT
*
*        HERE WHEN WE FIND OUR SAVE AREA
*
PCEXIT2  BCTR  13,0               REMOVE GARBAGE LOW ORDER BIT
         LR    2,8                SAVE OLD REG 8 VALUE
         L     8,DATAPTR          LOAD POINTER TO ALLOCATED DATA AREA
         MVC   SYSPSW,4(1)        SAVE INTERRUPT PSW
         MVC   SYSREGS(3*4),20(1) SAVE REGS 0,1,2
         MVC   SYSREGS+14*4(2*4),12(1)      SAVE REGS 14,15
         STM   3,12,SYSREGS+3*4   SAVE REGS 3-12
         ST    0,SYSREGS+13*4     SAVE REG 13
         ST    2,SYSREGS+8*4      SAVE REG 8
         STD   0,SYSREGS+16*4     SAVE FR0
         STD   2,SYSREGS+16*4+8   SAVE FR2
         STD   4,SYSREGS+16*4+16  SAVE FR4
         STD   6,SYSREGS+16*4+24  SAVE FR6
         EXTRN SYSINTR            INTERRUPT ROUTINE IS EXTERNAL
         L     15,=A(SYSINTR)     POINT TO INTERRUPT HANDLING ROUTINE
         ST    15,16(1)           SET TO BE RESTORED AS REG 15
         ST    15,8(1)            SAVE AS NEW PSW EXIT ADDRESS
         BR    14                 RETURN TO SYSINTR VIA SYSTEM
         DROP  15                 DROP PCEXIT BASE REGISTER
         TITLE 'OSINT -- OS INTERFACE -- DUMP'
*
*        TO ASSIST IN DEBUGGING, THE INTERFACE PROVIDES THE FOLLOWING
*        DUMP ROUTINE WHICH DUMPS THE FOLLOWING AREAS --
*
*        1)    INTERFACE SAVE AREA
*        2)    MAIN DATA AREA
*        3)    ACTIVE DCB'S IN FREE CORE
*
*        EACH BLOCK IS DUMPED 48 BYTES/LINE WITH ABSOLUTE AND
*        RELATIVE ADDRESSES. ALL ZERO LINES ARE OMITTED FROM THE DUMP
*
*        BAL   14,DUMP
*
         USING OSINT,11,12        STANDARD BASE REGS
DUMP     ST    14,DMPRTN          SAVE LINKAGE
         PRT   HEDM0              PRINT HEADING FOR DUMP
         PRT   HEDM1              PRINT TITLE FOR INTERFACE WORK AREA
         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE
         LR    6,13               START OF SAVE AREA ADDRESS
         LA    7,LWORK(,6)        END OF SAVE AREA
         BAL   14,DUMPER          DUMP INTERFACE SAVE AREA
         PRT   HEDM2              PRINT HEADING FOR DATA AREA
         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE
         LR    6,8                COPY POINTER TO START OF DATA AREA
         LR    7,8                ANOTHER COPY
         A     7,DATASIZE         POINT TO END OF DATA AREA
         BAL   14,DUMPER          DUMP DATA AREA
         L     10,PTRDCB          LOAD POINTER TO FIRST DCB
         MVI   BUFR+1,C'1'        FIRST DCB IS ON NEW PAGE
         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE
*
*        LOOP TO DUMP DCB'S
*
DUMP1    L     14,DMPRTN          RELOAD RETURN POINT IN CASE ALL DONE
         LTR   10,10              DCB'S ALL DUMPED?
         BCR   Z,14               RETURN TO DUMP CALLER IF SO
         MVC   BUFR+2(15),=C'DUMP OF DCB FOR'    SET HEADING
         MVC   BUFR+18(20),FILENAME         SET PROPER FILE NAME
         MVI   BUFR,17+20         SET PROPER LENGTH
         BAL   5,PRNTLNB          PRINT HEADING
         LR    6,10               POINT TO DCB
         LA    7,LMODDCB(,6)      POINT TO END OF DCB
         BAL   14,DUMPER          DUMP DCB
         L     10,DCBNEXT         POINT TO NEXT DCB ON CHAIN
         MVI   BUFR+1,C'0'        SET FOR NEXT HEADING DOUBLE SPACED
         B     DUMP1              LOOP BACK TO DUMP IT
         EJECT
*
*        SUBROUTINE TO DUMP ONE REGION OF MEMORY
*
*        (6)                      STARTING ADDRESS
*        (7)                      ENDING ADDRESS
*        BAL   14,DUMPER
*
DUMPER   PRT   BLANKL             PRINT A BLANK LINE
         ST    6,DUMPBAS          STORE STARTING ADDRESS
         MVI   BUFR,132           REMAINING LINES ARE 132 CHARS LONG
         LA    9,DUMPHEX          POINT TO HEX CONVERSION ROUTINE
*
*        HERE IS THE LOOP THROUGH LINES (48 BYTES/LINE)
*
DUMPER1  LA    0,48(,6)           POINT 48 BYTES AHEAD
         CR    0,7                PAST END?
         BH    DUMPERY            FORCE PRINT IF LAST LINE OF DUMP
         CLI   0(6),X'00'         FIRST BYTE ZERO?
         BNZ   DUMPERY            DEFINITELY DUMP IF SO
         CLC   1(47,6),0(6)       ELSE IS REST OF LINE ZEROS?
         BZ    DUMPERL2           SKIP IF SO, DO NOT PRINT IT
*
*        HERE IF WE HAVE AT LEAST A PARTIAL LINE TO BE PRINTED
*
DUMPERY  MVI   BUFR+1,C' '        BLANK BUFFER
         MVC   BUFR+2(131),BUFR+1 . . . .
         BCT   15,DUMPERL1        SKIP IF ROOM ON THIS PAGE
         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE
         MVI   BUFR+1,C'1'        SET FOR NEW PAGE
*
*        HERE AFTER CLEARING BUFFER AND DEALING WITH LINE COUNT
*
DUMPERL1 LA    2,BUFR+2           POINT TO FIRST LOCATION
         LR    0,6                COPY POINTER TO DATA
         LR    1,6                AND AGAIN
         S     1,DUMPBAS          ABSOLUTE ADDR->(0), RELATIVE->(1)
         STM   0,1,DUMPWRK        STORE ABSOLUTE/RELATIVE ADDRESS
         LA    3,DUMPWRK          POINT TO ADDRESSES
         BALR  1,9                CONVERT ABSOLUTE ADDRESS
         MVC   BUFR+2(8),BUFR+4   POSITION LAST 6 HEX DIGITS
         BALR  1,9                CONVERT RELATIVE ADDRESS TO HEX
         MVC   BUFR+10(9),BUFR+13 POSITION LAST 6 HEX DIGITS
         EJECT
*
*        HERE WE CONVERT THE ACTUAL DATA (48 BYTES IN 3 GROUPS OF 16)
*
         LA    2,BUFR+20          POINT TO STARTING LOCATION FOR DATA
         LR    3,6                POINT TO DATA TO BE DUMPED
         BALR  1,9                DUMP FIRST GROUP OF 16 BYTES
         BALR  1,9                . . . .
         BALR  1,9                . . . .
         BALR  1,9                . . . .
         CR    3,7                MORE TO GO?
         BNL   DUMPERLP           SKIP IF NOT
         LA    2,3(,2)            ALLOW 2 EXTRA BLANKS
         BALR  1,9                DUMP SECOND GROUP OF 16 BYTES
         BALR  1,9                . . . .
         BALR  1,9                . . . .
         BALR  1,9                . . . .
         CR    3,7                MORE TO GO?
         BNL   DUMPERLP           SKIP IF NOT
         LA    2,3(,2)            TWO EXTRA BLANKS
         BALR  1,9                DUMP THIRD GROUP OF 16 BYTES
         BALR  1,9                . . . .
         BALR  1,9                . . . .
         BALR  1,9                . . . .
*
*        HERE TO PRINT FORMATTED DUMP LINE
*
DUMPERLP BAL   5,PRNTLNB          PRINT BUFR CONTAINING LINE
*
*        HERE AFTER DUMPING LINE, MERGE FOR ALL ZERO LINE
*
DUMPERL2 LA    6,3*16(,6)         POINT PAST DATA DUMPED
         CR    6,7                ALL DONE YET?
         BL    DUMPER1            LOOP BACK FOR NEXT LINE IF NOT
         BR    14                 ELSE RETURN TO DUMPER CALLER
*
*        SUBROUTINE TO CONVERT TO HEX
*
*        (2)                      BUFFER POINTER
*        (3)                      POINTS TO 4 BYTES OF DATA
*        BALR  1,9                (9) POINTS TO DUMPHEX
*        (2)                      BUMPED PAST 8 HEX DIGS + BLANK
*        (3)                      BUMPED PAST 4 BYTES DATA
*
DUMPHEX  UNPK  0(8+1,2),0(4+1,3)  SPREAD DIGITS
         TR    0(8,2),DUMPTR-C'0' TRANSLATE TO HEX
         MVI   8(2),C' '          BLANK LAST GARBAGE DIGIT
         LA    2,8+1(,2)          BUMP PAST 8 DIGITS + 1 BLANK
         LA    3,4(,3)            BUMP PAST FOUR BYTES DATA
         BR    1                  RETURN TO CALLER
*
DUMPTR   DC    C'0123456789ABCDEF'          TABLE TO TRANSLATE TO HEX
         TITLE 'OSINT -- OS INTERFACE -- MODEL DCB'
*
*        MODEL DCB USED TO CONSTRUCT DCBS IN FREE CORE
*
MODDCB   DCB   DDNAME=XXXXXXXX,DSORG=PS,MACRF=(GM,PM),                 X
               EODAD=EOF,SYNAD=SYNAD,EXLST=EXLALL
         DC    CL8' '                       DDNAME
         DC    X'0000000000000000'          MEMNAME
         DC    CL20' '                      FILENAME
         DS    Y                  MAXRECL
         DC    X'00'              ALL FLAGS ARE RESET
         DC    A(0)               DUMMY CHAIN POINTER
         DC    X'7FFFFFFF'        MAX WRITE RECORD COUNT (INFINITE)
LMODDCB  EQU   *-MODDCB           LENGTH OF MODEL DCB
*
*
*        DCB EXIT LISTS
*
         DS    0F                 ALLIGN
EXLPRT   DC    X'85',AL3(EXPRT)   EXIT LIST FOR SYSPRINT
EXLPCH   DC    X'85',AL3(EXPCH)   EXIT LIST FOR SYSPUNCH
EXLRDR   DC    X'85',AL3(EXRDR)   EXIT LIST FOR SYSIN
EXLOBJ   DC    X'85',AL3(EXOBJ)   EXIT LIST FOR SYSOBJ
EXLALL   DC    X'85',AL3(EXALL)   EXIT LIST FOR ALL OTHER FILES
         TITLE 'OSINT -- OS INTERFACE -- ERROR CODES'
*
*        THESE ERROR CODES GENERATE A BCTR 12,0. THE ROUTINE AT THE
*        END COMPUTES THE PROPER ERROR CODE FROM THE VALUE IN (12)
*
E$FILG   XERR  12                 INVALID FILE NAME
*
E$MSDD   XERR  12                 MISSING DD CARD FOR REFERENCED FILE
*
E$MODN   XERR  12                 MODULE NAME FOR LOAD OR UNLOAD
*                                 LONGER THAN 8 CHARACTERS
*
E$IERR   XERR  12                 UNCORRECTABLE INPUT ERROR
*
E$OERR   XERR  12                 UNCORRECTABLE OUTPUT ERROR
*
E$EOFR   XERR  12                 ATTEMPT TO READ PAST END OF DATA
*
E$LIOE   XERR  12                 UNCORRECTABLE INPUT ERROR DURING
*                                 LOADING OF AN EXTERNAL FUNCTION
*
E$LNFN   XERR  12                 MODULE FOR EXTERNAL FUNCTION NOT
*                                 FOUND IN LIBRARY (POSSIBLE MISSING
*                                 JOBLIB DD CARD)
*
E$DELE   XERR  12                 MODULE TO BE UNLOADED IS NOT
*                                 CURRENTLY LOADED
*
E$RSYS   XERR  12                 ATTEMPT TO REWIND SYSTEM FILE
*                                 (DDNAME = SYSPRINT,SYSPUNCH,SYSIN)
*
E$READ   XERR  12                 ATTEMPT TO READ FILE PREVIOUSLY
*                                 WRITTEN WITHOUT INTERVENING REWIND
*
E$WRIT   XERR  12                 ATTEMPT TO WRITE A FILE PREVIOUSLY
*                                 READ FROM WITHOUT INTERVENING REWIND
         EJECT
*
E$FZER   XERR  12                 DUPLICATION FACTOR OR TAB LOCATION
*                                 IN FORMAT EQUALS ZERO
*
E$FILL   XERR  12                 ILLEGAL CHARACTER IN OUTPUT FORMAT
*
E$FSOV   XERR  12                 TOO MANY LEVELS OF PARENTHESIS IN
*                                 FORMAT -- LIMIT IS 10
*
E$FUBP   XERR  12                 TOO MANY RIGHT PARENTHESIS IN FORMAT
*
E$FTNM   XERR  12                 MISSING NUMBER AFTER T FORMAT
*
E$FHLN   XERR  12                 LENGTH SPECIFIED IN H TYPE FORMAT
*                                 EXCEEDS LENGTH OF FORMAT
*
*
E$FNLP   XERR  12                 FORTRAN TYPE OUTPUT FORMAT IS
*                                 MISSING AN INITIAL LEFT PARENTHESIS
*
E$FNRP   XERR  12                 A FORTRAN TYPE OUTPUT FORMAT IS
*                                 MISSING A FINAL RIGHT PARENTHESIS
*
E$SSIN   XERR  12                 A SYSIN RECORD EXCEEDS 80
*                                 CHARACTERS IN LENGTH
*
E$OPNO   XERR  12                 ERROR IN OPENING FILE FOR OUTPUT
*
E$OPNI   XERR  12                 ERROR IN OPENING FILE FOR INPUT
*
*        COME HERE TO CALCULATE ERROR CODE
*        WE ENTER HERE FROM TABLE OF BCTR 12,0'S AND SUBTRACTED AMOUNT
*        TELLS US WHICH ERROR MESSAGE WE ARE GIVING
*        ERROR CODE = (12)-(11)-4095+&ERRC
*
         LA    1,4095(,11)        (11)+4095
         LA    0,&ERRC.(,12)      (12)+&ERRC
         SR    0,1                CALCULATE ERROR CODE
         LM    1,15,SAVE1+4       SAVE REGS PRESERVING ERROR CODE
         BR    1                  GIVE ERROR RETURN
         TITLE 'OSINT -- OS INTERFACE -- MACRO CALL PARAMETER LISTS'
*
*        LISTS FOR SYSTEM MACRO CALLS (MOVED TO MLIST FOR USE)
*
GETLIST  GETMAIN   VC,HIARCHY=1,MF=L         GETMAIN LIST
LGETLIST EQU     *-GETLIST         LENGTH OF LIST
*
OPNLIST  OPEN    (,),MF=L          OPEN LIST
LOPNLIST EQU     *-OPNLIST         LENGTH OF LIST
*
CLSLIST  CLOSE   (,),MF=L          CLOSE LIST
LCLSLIST EQU     *-CLSLIST         LENGTH OF LIST
*
EXTLIST  EXTRACT   ,'S',FIELDS=(TIOT),MF=L  EXTRACT LIST
LEXTLIST EQU   *-EXTLIST          LENGTH OF LIST
         TITLE 'OSINT -- OS INTERFACE -- INITIAL LIMIT VALUES'
*
*        THIS TABLE OF VALUES IS MOVED TO 'LIMS' IN THE INTERFACE
*        WORK AREA AFTER OBTAINING THE REQUIRED MEMORY
*
LIMSINIT DS    0F                 START OF LIMITS
         DC    F'55'              TIME LIMIT (DEFAULT = 55 SECONDS)
         DC    F'100000'          CARD LIMIT = 100000
         DC    F'100000'          PAGE LIMIT = 100000
         DC    A(8*1024)          SPACE TO RESERVE FOR SYSTEM = 8K
         DC    F'0'               ADDRESS OF SYSTEM AREA
         DC    F'8'               MINIMUM MEMORY REQUESTED = 8 BYTES
         DC    A(1000*1024)       MAX MEMORY REQUIRED AND REQUESTED
         DC    A(16*1024)         MINIMUM MEMORY REQUIRED
         DC    2A(0)              ADDRESS LENGTH ACTUALLY ALLOCATED
         DC    A(10)              DEFAULT NUMBER OF OSINT DUMPS
         DC    A(58)              DEFAULT IS 58 LINES PER PAGE
         DC    A(0)               DEFAULT IS PRECISE INTERRUPTS
         TITLE 'OSINT -- OS INTERFACE -- LITERAL POOL'
*
*        NOTE THAT IF THE INTERFACE GETS BIGGER, WE MUST WATCH THE
*        POSITIONING OF THE LITERAL TABLES SINCE THE LITERAL USED TO
*        LOAD BASE REGISTERS MUST BE WITHIN 4K OF THE FIRST ENTRY POINT
*
         LTORG ,                  PLACE LITERALS HERE
         TITLE 'OSINT -- OS INTERFACE -- WORK DSECT'
*
*        THE WORK DSECT CONTAINS THE GENERAL WORK AREAS FOR THE
*        INTERFACE. A POINTER TO THIS AREA IS STORED IN THE DATA AREA
*        AT WORKLOC. THIS ADDRESS IS LOADED INTO REGISTER (13)
*        ON ENTRY TO ANY OF THE SYSTEM INTERFACE ENTRY POINTS.
*
WORK     DSECT ,                  START OF DSECT, (13) POINTS HERE
*
*        SINCE (13) ALWAYS POINTS TO THIS AREA, THE FIRST 18 WORDS ARE
*        RESERVED FOR USE AS A SAVE AREA BY THE NEXT LEVEL OF ROUTINES
*
SAVE2    DS    9D                 SAVE AREA FOR NEXT LEVEL
*
*        WORK AREAS FOR DUMP ROUTINE
*
DUMPWRK  DS    2F                 SAVE ADDRESSES IN DUMPER
DMPRTN   DS    F                  RETURN LINKAGE TO DUMP ROUTINE
DUMPBAS  DS    A                  BASE ADDRESS IN DUMPER
*
*        THE FOLLOWING IS USED TO BUILD DUMP LINES & OTHER MESSAGES
*
BUFR     DS    CL134              132 + CTL CHAR + LENGTH
*
*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE DATA AREA
*
DATAPTR  DS    F                  POINTER TO ALLOCATED DATA AREA
*
*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE MAIN PROGRAM
*
STARTLOC DS    A                  POINTER TO SYSSTART
*
*        REGISTER SAVE AREAS
*
ENT13SV  DS    A                  SAVE REG 13 ON ENTRY TO INTERFACE
SAVEX    DS    8F                 SAVE AREA FOR INTERRUPT ROUTINE
PRNSAVE  DS    3F                 SAVE REGS IN PRNTLN
BOMBSV   DS    2F                 SAVE REGS 0,1 ON A BOMB
BOMBPSW  DS    F                  SAVE CODE/ADDR FROM PSW ON A BOMB
WRITRECS DS    A                  SAVE WRITREC LINKAGE
FORMSAVE DS    2F                 SAVE REGS FOR FORMMOVE
*
*        AREA TO SAVE POINTER TO PICA FOR CALLER
*
PICASAV  DS    A                  POINTER TO CALLER'S PICA
*
*        LOCATION USED TO STORE STARTING (INITIAL) TIMER VALUE
*
TSTART   DS    F                  INITIAL TIMER VALUE
         EJECT
*
*        LIST FOR BLDL
*
         ORG   SAVEX              OVERLAP UNUSED REG SAVE AREAS
BLDLIST  DS    H'1'               SET TO 1 FOR ONE ENTRY
         DS    H'58'              SET TO 58 = LENGTH OF ENTRY
NAME     DS    CL8                NAME FOR LOAD,UNLOAD,OPEN, ETC.
         DS    CL50               WORK AREA FOR BLDL
         ORG   ,                  REPOSITION
*
*        AREA TO BUILD PARAMETER LISTS FOR SYSTEM MACRO CALLS
*
MLIST    DS      0D                START OF AREA
         GETMAIN   VC,HIARCHY=1,MF=L
         ORG     MLIST
         OPEN    (,),MF=L
         ORG     MLIST
         CLOSE   (,),MF=L
         ORG   MLIST
         EXTRACT   ,'S',FIELDS=(TIOT),MF=L
         ORG     ,                 REPOSITION PAST LONGEST LIST
*
*        USER PROGRAM LIMITS (INITIALIZED FROM LIMSINIT)
*
LIMS     DS    0F                 START OF INITIALIZED LIMIT VALUES
TLIMIT   DS    F                  TIME LIMIT (TIMER UNITS)
CLIMIT   DS    F                  CARD LIMIT
PLIMIT   DS    F                  PAGE LIMIT
RESERV   DS    F                  SPACE TO RESERVE TO SYSTEM (BYTES)
RESERV0  DS    A                  ADDRESS OF AREA TO RESERVE TO SYSTEM
DYNALLOC DS    A                  MINIMUM MEMORY REQUESTED (BYTES)
DYNAMAX  DS    A                  MAX MEMORY REQUIRED & REQUESTED
DYNAMIN  DS    F                  MINIMUM MEMORY REQUIRED
ALLOC    DS    2A                 ADDRESS/LENGTH ACTUALLY ALLOCATED
DLIMIT   DS    F                  NUMBER OF OSINT DUMPS ON SYSABEND
PAGEDPTH DS    F                  NUMBER OF LINES PER PAGE
INTVAL   DS    F                  INTERRUPT TYPE INDICATOR
LLIMS    EQU   *-LIMS             LENGTH OF LIMIT VALUES
         EJECT
*
*        MISCELLANEOUS WORK AREAS
*
TIOTLOC  DS    F                  LOCATION OF TIOT FOR THIS TASK
PTRDCB   DS    A                  ADDRESS OF FIRST DCB ON DCB CHAIN
SYSTEM   DS    A                  SAVE EXIT ADDRESS IN INTRUP ROUTINE
OUTWBF   DS    A                  POINTER TO OUTPUT WORK BUFFER
OUTWBFLN DS    H                  LENGTH OF OUTPUT WORK BUFFER
REREAD   DS    X                  REREAD FLAG FOR DATASET CONCATENATION
SAVEBF   DS    CL4                SAVE CHRS BEHIND READ BFR (SYSREAD)
EOFLAG   DS    X                  END OF FILE FLAG
TEMPEOF  EQU   X'80'              FLAG FOR TEMPORARY (./*) EOF
PERMEOF  EQU   X'40'              FLAG FOR PERMANENT EOF (/*)
DATAIN   EQU   X'20'              FLAG FOR SOME DATA READ
PTYPE    DS    C                  OPTION LETTER (PARAMETER SCAN)
RECFLAG  DS    X                  FLAG FOR UNKNOWN RECLEN (SYSWRITE)
SAVCHR   DS    C                  SAVE CHAR BEHIND RECORD IN SYSWRITE
BOMBFLG  DS    X                  SET NONZERO IF ANY SYSABEND CALLS
DATE     DS    CL10               SPACE TO BUILD DATE (SYSDATE)
CKDIGITC DS    C                  COMPUTED DATE CHECK DIGIT
BATCHFLG DS    AL1(*-*)           BATCHING FLAG COPIED FROM SYSBATCH
*
*        WORK AREAS FOR FORMAT PROCESSOR
*
FORMFLGS DS    C                  FLAG BYTE FOR FORMAT PROCESSOR
XFORM    EQU   X'80'              FLAG FOR MOVE OF BLANKS
FBLKCC   EQU   X'40'              FLAG FOR BLANK CTL CHAR REQUIRED
FSPECL   EQU   X'20'              FLAG FOR NO FORMAT GIVEN
BUFSTART DS    A                  ADDRESS OF CURRENT BUFFER
FLASTLP  DS    A                  ADDR AND REPEAT COUNT FOR LAST LP
FSTAKADR DS    F                  ADDRESS OF CURRENT STACK ENTRY
FORMSTAK DS    10F                ROOM FOR 10 PAREN LEVELS
FSTAKEND DS    A(*)               END OF STACK ADDRESS
FSTAKBOT DS    A(FORMSTAK-4)      BOTOOM OF LP STACK
FORMRTN  DS    F                  SAVE RETURN POINT TO FORMAT PROCESSOR
LWORK    EQU   *-WORK             LENGTH OF WORK AREA
         TITLE 'OSINT -- OS INTERFACE -- DATA DSECT'
*
*        THE DATA AREA IS ALWAYS POINTED TO BY REGISTER (8). THIS
*        REGISTER MUST BE SET CORRECTLY ON ALL CALLS TO THE INTERFACE.
*        THIS AREA IS PRIMARILY FOR THE USE OF THE MAIN PROGRAM.
*        HOWEVER, THE FIRST FEW LOCATIONS ARE RESERVED TO THE INTERFACE
*        AS INDICATED BELOW.
*
DATA     DSECT ,                  START OF DATA DSECT
*
         DS    F                  FOUR BYTES UNUSED BY INTERFACE
WORKLOC  DS    A                  POINTER TO INTERFACE WORK AREA
SAVE1    DS    18F                SAVE AREA FOR REGS ON ENTRY
*
*        THE FOLLOWING AREAS ARE USED IF A PROGRAM CHECK OCCURS
*
SYSPSW   DS    D                  SAVE INTERRUPT PSW
SYSREGS  DS    12D                REG VALS ON INTERRUPT (0-15,FR0-FR6)
*
*        THE FOLLOWING CONSTANTS ARE SET BY THE INTERFACE
*
DATASIZE DS    F                  LENGTH OF DATA AREA ALLOCATED
PRINTDCB DS    A                  POINTER TO DCB FOR SYSPRINT
PUNCHDCB DS    A                  POINTER TO DCB FOR PUNCH
READDCB  DS    A                  POINTER TO SYSIN DCB
PGDEPTH  DS    F                  NUMBER OF LINES PER PAGE
STARTADR DS    A                  ADDRESS OF SYSSTART
INTFLAG  DS    F                  INTERRUPT TYPE INDICATOR
*
*        THE REMAINING SECTION OF THE DATA AREA MAY BE USED BY THE MAIN
*        PROGRAM IN ANY WAY IT DESIRES.
*
USERD    DS    0D                 START OF USER AREA
         TITLE 'OSINT -- OS INTERFACE -- TIOT DSECT'
*
*        THIS DSECT DESCRIBES THE FIELDS IN A TIOT ENTRY WHICH ARE
*        REFERENCED BY THE INTERFACE.
*
TIOT     DSECT ,                  START OF DSECT
*
         DS    CL24               FILLER (JOB/STEP NAMES, UNUSED)
TIOENTRY DS    0F                 START OF ENTRY (0 = END OF CHAIN)
TIOELNOH DS    AL1                LENGTH OF ENTRY
         DS    CL3                FILLER (UNUSED)
TIOEDDNM DS    CL8                DDNAME
*
*
*        ADDITIONAL CONTROL PROGRAM FIELDS REFERENCED
*
CVTTCBP  EQU   0                  OFFSET TO TCB BLOCK PTR IN CVT
TCBFSA   EQU   112                OFFSET TO PTR TO 1ST SAVE AREA IN TCB
         TITLE 'OSINT -- OS INTERFACE -- DCB DSECT'
*
*        THE FOLLOWING DSECT DESCRIBES THE DCB FORMAT USED BY THIS
*        INTERFACE, WHICH CONSISTS OF A STANDARD SYSTEM DCB FOLLOWED
*        BY A SET OF SPECIAL FIELDS
*
         DCBD  DSORG=QS,DEVD=DA   PROVIDE SYMBOLIC NAMES FOR DCB
DDNAME   DS    CL8                DDNAME
MEMNAME  DS    CL8                MEMBER NAME (ZERO IF NONE)
FILENAME DS    CL20               FULL FILE NAME AS SUPPLIED
MAXRECL  DS    Y                  MAXIMUM INPUT RECORD LENGTH
OFLAGS   DS    X                  FLAGS AS FOLLOWS
OPENI    EQU   1                  DCB IS OPEN FOR INPUT
OPENO    EQU   2                  DCB IS OPEN FOR OUTPUT
EOFE     EQU   4                  END OF FILE HAS BEEN READ
PRINTER  EQU   8                  FLAG FOR SYSPRINT
PUNCHER  EQU   16                 FLAG FOR SYSPUNCH
READER   EQU   32                 FLAG FOR SYSIN
DCBNEXT  DS    A                  POINTER TO NEXT DCB ON CHAIN
MAXRECW  DS    F                  MAXIMUM RECORDS TO BE WRITTEN
*
OPENOK   EQU   X'10'              FLAG FOR SUCCESSFUL OPEN IN DCBOFLGS
*
F        EQU   X'80'              FLAG FOR F TYPE RECORDS (ALSO U)
V        EQU   X'40'              FLAG FOR V TYPE RECORDS (ALSO U)
U        EQU   F+V                FLAG FOR U TYPE RECORDS
B        EQU   X'10'              FLAG FOR B (BLOCKED) RECORDS
S        EQU   X'08'              FLAG FOR S TYPE RECORDS
A        EQU   X'04'              FLAG FOR A (ASA CTL) TYPE RECORDS
*
         END   OSINT              END OF INTERFACE
