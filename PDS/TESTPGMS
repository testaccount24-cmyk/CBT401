-TITLE SPITBOL TEST PROGRAM #1 -- DIAGNOSTICS PHASE ONE
*
*        THIS IS A STANDARD TEST PROGRAM FOR SPITBOL WHICH TESTS
*        OUT FUNCTIONS, OPERATORS AND DATATYPE MANIPULATIONS
*
         &DUMP = 2
         TRACE(.TEST)
         &TRACE = 1000000
         STARS =                     '  ERROR DETECTED          ***'
         &ERRLIMIT = 1000
         SETEXIT(.ERRORS)         ;*        SET INTERRUPT LOCATION
         OUTPUT = '************************************************'
         OUTPUT = '**** S P I T B O L    D I A G N O S T I C S ****'
         OUTPUT = '****          P H A S E    O N E            ****'
         OUTPUT = '************************************************'
         OUTPUT = '****  ANY TRACE OUTPUT INDICATES AN ERROR   ****'
         OUTPUT = '************************************************'
-EJECT
*
*        TEST REPLACE FUNCTION
*
         TEST = DIFFER(REPLACE('AXXBYYY','XY','01'),'A00B111') STARS
         A = REPLACE(&ALPHABET,'XY','AB')
         TEST = DIFFER(REPLACE('AXY',&ALPHABET,A),'AAB') STARS
*
*        TEST LPAD,RPAD FUNCTIONS
*
         TEST = DIFFER(LPAD('ABC',5,'X'),'XXABC') STARS
         TEST = DIFFER(RPAD('ABC',5,'X'),'ABCXX') STARS
         TEST = DIFFER(LPAD(12,5),'   12') STARS
         TEST = DIFFER(RPAD(10,4),'10  ') STARS
         TEST = DIFFER(LPAD('ABC',2),'ABC') STARS
         TEST = DIFFER(RPAD('AB',1),'AB') STARS
         TEST = DIFFER(LPAD('AB',2),'AB') STARS
         TEST = DIFFER(LPAD()) STARS
         TEST = DIFFER(LPAD(,5),'     ') STARS
*
*        TEST CONVERT FUNCTION
*
         TEST = DIFFER(CONVERT('12','INTEGER') , 12) STARS
         TEST = DIFFER(CONVERT(2.5,'INTEGER'),2)       STARS
         TEST = DIFFER(CONVERT(2,'REAL'),2.0) STARS
         TEST = DIFFER(CONVERT('.2','REAL'),0.2) STARS
-EJECT
*
*        TEST REVERSE FUNCTION
*
         TEST = DIFFER(REVERSE('123'),'321') STARS
         TEST = DIFFER(REVERSE()) STARS
         TEST = DIFFER(REVERSE(12),'21') STARS
*
*        TEST DATATYPE FUNCTION
*
         TEST = DIFFER(DATATYPE('JKL'),'STRING') STARS
         TEST = DIFFER(DATATYPE(12),'INTEGER') STARS
         TEST = DIFFER(DATATYPE(1.33),'REAL') STARS
         TEST = DIFFER(DATATYPE(NULL),'STRING') STARS
-EJECT
*
*        TEST ARITHMETIC OPERATORS
*
         TEST = DIFFER(3 + 2,5) STARS
         TEST = DIFFER(3 - 2,1) STARS
         TEST = DIFFER(3 * 2,6) STARS
         TEST = DIFFER(5 / 2,2) STARS
         TEST = DIFFER(2 ** 3,8) STARS
         TEST = DIFFER(3 + 1,4) STARS
         TEST = DIFFER(3 - 1,2) STARS
         TEST = DIFFER('3' + 2,5) STARS
         TEST = DIFFER(3 + '-2',1) STARS
         TEST = DIFFER('1' + '0',1) STARS
         TEST = DIFFER(5 + NULL,5) STARS
         TEST = DIFFER(-5,0 - 5) STARS
         TEST = DIFFER(+'4',4) STARS
         TEST = DIFFER(2.0 + 3.0,5.0) STARS
         TEST = DIFFER(3.0 - 1.0,2.0) STARS
         TEST = DIFFER(3.0 * 2.0,6.0) STARS
         TEST = DIFFER(3.0 / 2.0,1.5) STARS
         TEST = DIFFER(3.0 ** 3,27.0) STARS
         TEST = DIFFER(-1.0,0.0 - 1.0) STARS
*
*        TEST MIXED MODE
*
         TEST = DIFFER(1 + 2.0,3.0) STARS
         TEST = DIFFER(3.0 / 2,1.5) STARS
-EJECT
*
*        TEST FUNCTIONS
*
*        FIRST, A SIMPLE TEST OF A FACTORIAL FUNCTION
*
         DEFINE('FACT(N)')                  :(FACTEND)
FACT     FACT = EQ(N,1) 1         :S(RETURN)
         FACT = N * FACT(N - 1)             :(RETURN)
FACTEND  TEST = NE(FACT(5),120) STARS
         TEST = DIFFER(OPSYN(.FACTO,'FACT')) STARS
         TEST = DIFFER(FACTO(4),24) STARS
*
*        SEE IF ALTERNATE ENTRY POINT WORKS OK
*
         DEFINE('FACT2(N)',.FACT2ENT)       :(FACT2ENDF)
FACT2ENT FACT2 = EQ(N,1) 1        :S(RETURN)
         FACT2 = N * FACT2(N - 1) :(RETURN)
FACT2ENDF OUTPUT = NE(FACT(6),720) STARS
*
*        TEST FUNCTION REDEFINITION AND CASE OF ARGUMENT = FUNC NAME
*
         TEST = DIFFER(DEFINE('FACT(FACT)','FACT3')) STARS
.                                           :(FACT2END)
FACT3    FACT = NE(FACT,1) FACT * FACT(FACT - 1)
.                                           :(RETURN)
FACT2END
         TEST = NE(FACT(4),24) STARS
*
*        TEST OUT LOCALS
*
         DEFINE('LFUNC(A,B,C)D,E,F')        :(LFUNCEND)
LFUNC    TEST = ¬(IDENT(A,'A') IDENT(B,'B') IDENT(C,'C')) STARS
         TEST = ¬(IDENT(D) IDENT(E) IDENT(F)) STARS
         A = 'AA' ; B = 'BB' ; C = 'CC' ; D = 'DD' ; E = 'EE' ; F = 'FF'
.                                 :(RETURN)
LFUNCEND AA = 'A' ; BB = 'B' ; CC = 'C'
         D = 'D' ; E = 'E' ; F = 'F'
         A = 'X' ; B = 'Y' ; C = 'Z'
         TEST = DIFFER(LFUNC(AA,BB,CC)) STARS
         TEST = ¬(IDENT(A,'X') IDENT(B,'Y') IDENT(C,'Z')) STARS
         TEST = ¬(IDENT(AA,'A') IDENT(BB,'B') IDENT(CC,'C')) STARS
         TEST = ¬(IDENT(D,'D') IDENT(E,'E') IDENT(F,'F')) STARS
*
*        TEST NRETURN
*
         DEFINE('NTEST()')                  :(ENDNTEST)
NTEST    NTEST = .A                         :(NRETURN)
ENDNTEST A = 27
         TEST = DIFFER(NTEST(),27) STARS
.              :F(ST59)            ;ST59
         NTEST() = 26
.              :F(ST60)            ;ST60
         TEST = DIFFER(A,26) STARS
-EJECT
*
*        CONTINUE TEST OF FUNCTIONS
*
*
*        TEST FAILURE RETURN
*
         DEFINE('FAILURE()')                :(FAILEND)
FAILURE                           :(FRETURN)
FAILEND  TEST = FAILURE() STARS
-EJECT
*
*        TEST OPSYN FOR OPERATORS
*
         OPSYN('@',.DUPL,2)
         OPSYN('|',.SIZE,1)
         TEST = DIFFER('A' @ 4,'AAAA') STARS
         TEST = DIFFER(|'STRING',6) STARS
*
*        TEST OUT ARRAY FACILITY
*
         A = ARRAY(3)
         TEST = DIFFER(A<1>) STARS
         A<2> = 4.5
         TEST = DIFFER(A<2>,4.5) STARS
         TEST = ?A<4> STARS
         TEST = ?A<0> STARS
         TEST = DIFFER(PROTOTYPE(A),3) STARS
         B = ARRAY(3,10)
         TEST = DIFFER(B<2>,10) STARS
         B = ARRAY('3')
         B<2> = 'A'
         TEST = DIFFER(B<2>,'A') STARS
         C = ARRAY('2,2')
         C<1,2> = '*'
         TEST = DIFFER(C<1,2>,'*') STARS
         TEST = DIFFER(PROTOTYPE(C),'2,2') STARS
         D = ARRAY('-1:1,2')
         D<-1,1> = 0
         TEST = DIFFER(D<-1,1>,0) STARS
         TEST = ?D<-2,1> STARS
         TEST = ?D<2,1> STARS
-EJECT
*
*        TEST PROGRAM DEFINED DATATYPE FUNCTIONS
*
         DATA('NODE(VAL,LSON,RSON)')
         A = NODE('X','Y','Z')
         TEST = DIFFER(DATATYPE(A),'NODE') STARS
         TEST = DIFFER(VAL(A),'X') STARS
         B = NODE()
         TEST = DIFFER(RSON(B)) STARS
         LSON(B) = A
         TEST = DIFFER(RSON(LSON(B)),'Z') STARS
         TEST = DIFFER(VALUE('B'),B) STARS
*
*        TEST MULTIPLE USE OF FIELD FUNCTION NAME
*
         DATA('CLUNK(VALUE,LSON)')
         TEST = DIFFER(RSON(LSON(B)),'Z') STARS
         TEST = DIFFER(VALUE('B'),B) STARS
         C = CLUNK('A','B')
         TEST = DIFFER(LSON(C),'B') STARS
-EJECT
*
*        TEST NUMERICAL PREDICATES
*
         TEST = LT(5,4) STARS
         TEST = LT(4,4) STARS
         TEST = ¬LT(4,5) STARS
         TEST = LE(5,2) STARS
         TEST = ¬LE(4,4) STARS
         TEST = ¬LE(4,10) STARS
         TEST = EQ(4,5) STARS
         TEST = EQ(5,4) STARS
         TEST = ¬EQ(5,5) STARS
         TEST = NE(4,4) STARS
         TEST = ¬NE(4,6) STARS
         TEST = ¬NE(6,4) STARS
         TEST = GT(4,6) STARS
         TEST = GT(4,4) STARS
         TEST = ¬GT(5,2) STARS
         TEST = GE(5,7) STARS
         TEST = ¬GE(4,4) STARS
         TEST = ¬GE(7,5) STARS
         TEST = NE(4,5 - 1) STARS
         TEST = GT(4,3 + 1) STARS
         TEST = LE(20,5 + 6) STARS
         TEST = EQ(1.0,2.0) STARS
         TEST = GT(-2.0,-1.0) STARS
         TEST = GT(-3.0,4.0) STARS
         TEST = NE('12',12) STARS
         TEST = NE('12',12.0) STARS
         TEST = ¬CONVERT(BAL,'PATTERN') STARS
-EJECT
*
*        TEST INTEGER
*
         TEST = INTEGER('ABC') STARS
         TEST = ¬INTEGER(12) STARS
         TEST = ¬INTEGER('12') STARS
*
*        TEST SIZE
*
         TEST = NE(SIZE('ABC'),3) STARS
         TEST = NE(SIZE(12),2) STARS
         TEST = NE(SIZE(NULL),0) STARS
*
*        TEST LGT
*
         TEST = LGT('ABC','XYZ') STARS
         TEST = LGT('ABC','ABC') STARS
         TEST = ¬LGT('XYZ','ABC') STARS
         TEST = LGT(NULL,'ABC') STARS
         TEST = ¬LGT('ABC',NULL) STARS
*
*        TEST INDIRECT ADDRESSING
*
         TEST = DIFFER($'BAL',BAL) STARS
         TEST = DIFFER($.BAL,BAL) STARS
         $'QQ' = 'X'
         TEST = DIFFER(QQ,'X') STARS
         TEST = DIFFER($'GARBAGE') STARS
         A = ARRAY(3)
         A<2> = 'X'
         TEST = DIFFER($.A<2>,'X') STARS
-EJECT
*
*        TEST CONCATENATION
*
         TEST = DIFFER('A' 'B','AB')        STARS
         TEST = DIFFER('A' 'B' 'C','ABC') STARS
         TEST = DIFFER(1 2,'12') STARS
         TEST = DIFFER(2 2 2,'222') STARS
         TEST = DIFFER(1 3.4,'13.4') STARS
         TEST = DIFFER(BAL NULL,BAL)        STARS
         TEST = DIFFER(NULL BAL,BAL) STARS
*
*        TEST DREALS
*
         TEST = DIFFER(1.0D2 + 2.0D2,3.0D2) STARS
         TEST = DIFFER(2.5D0 * 2.0D0,5.00D0) STARS
         TEST = DIFFER(3.0D0 / 3.0D0,1.0D0) STARS
         TEST = DIFFER(4.0D0 - 3.0D0,1.0D0) STARS
         TEST = DIFFER(3.D0 + 1.,4.D0) STARS
         TEST = DIFFER(1. + 3.D0,4.D0) STARS
         TEST = DIFFER(1.0D0 + 1,2.0D0) STARS
         TEST = DIFFER(3 + 1.0D0,4.0D0) STARS
         TEST = DIFFER(3.0D0 ** 3,27.0D0) STARS
-EJECT
*
*        TEST REMDR
*
         TEST = DIFFER(REMDR(10,3),1) STARS
         TEST = DIFFER(REMDR(11,10),1) STARS
*
*        TEST DUPL
*
         TEST = DIFFER(DUPL('ABC',2),'ABCABC') STARS
         TEST = DIFFER(DUPL(NULL,10),NULL) STARS
         TEST = DIFFER(DUPL('ABCDEFG',0),NULL) STARS
         TEST = DIFFER(DUPL(1,10),'1111111111')  STARS
*
*        TEST TABLE FACILITY
*
         T = TABLE(10)
         TEST = DIFFER(T<'CAT'>) STARS
         T<'CAT'> = 'DOG'
         TEST = DIFFER(T<'CAT'>,'DOG')   STARS
         T<7> = 45
         TEST = DIFFER(T<7>,45)   STARS
         TEST = DIFFER(T<'CAT'>,'DOG')  STARS
         TA = CONVERT(T,'ARRAY')
         TEST = DIFFER(PROTOTYPE(TA),'2,2') STARS
         ATA = CONVERT(TA,'TABLE')
         TEST = DIFFER(ATA<7>,45) STARS
         TEST = DIFFER(ATA<'CAT'>,'DOG') STARS
*
*        TEST ITEM FUNCTION
*
         AAA = ARRAY(10)
         ITEM(AAA,1) = 5
         TEST = DIFFER(ITEM(AAA,1),5) STARS
         TEST = DIFFER(AAA<1>,5) STARS
         AAA<2> = 22
         TEST = DIFFER(ITEM(AAA,2),22) STARS
         AMA = ARRAY('2,2,2,2')
         ITEM(AMA,1,2,1,2) = 1212
         TEST = DIFFER(ITEM(AMA,1,2,1,2),1212) STARS
         TEST = DIFFER(AMA<1,2,1,2>,1212) STARS
         AMA<2,1,2,1> = 2121
         TEST = DIFFER(ITEM(AMA,2,1,2,1),2121) STARS
-EJECT
*
*        TEST EVAL
*
         EXPR = *('ABC' 'DEF')
         TEST = DIFFER(EVAL(EXPR),'ABCDEF') STARS
         Q = 'QQQ'
         SEXP = *Q
         TEST = DIFFER(EVAL(SEXP),'QQQ') STARS
         FEXP = *IDENT(1,2)
         TEST = EVAL(FEXP) STARS
*
*        TEST SUBSTR
*
         TEST = DIFFER(SUBSTR('ABC',2,1),'B') STARS
         TEST = DIFFER(SUBSTR('ABCDEF',1,5),'ABCDE') STARS
         TEST = SUBSTR('ABC',50,1) STARS
         TEST = SUBSTR('ABC',81,50) STARS
         TEST = SUBSTR(NULL,1,1) STARS
*
*        TEST ARG
*
JLAB     DEFINE('JLAB(A,B,C)D,E,F')
         TEST = DIFFER(ARG(.JLAB,1),'A') STARS
         TEST = DIFFER(ARG(.JLAB,3),'C') STARS
         TEST = ARG(.JLAB,0) STARS
         TEST = ARG(.JLAB,4) STARS
*
*        TEST LOCAL
*
         TEST = DIFFER(LOCAL(.JLAB,1),'D') STARS
         TEST = DIFFER(LOCAL(.JLAB,3),'F') STARS
         TEST = LOCAL(.JLAB,0) STARS
         TEST = LOCAL(.JLAB,4) STARS
*
*        TEST APPLY
*
         TEST = APPLY(.EQ,1,2) STARS
         TEST = ¬APPLY(.EQ,1,1) STARS
         TEST = ¬APPLY(.EQ,0) STARS
         TEST = ¬APPLY(.EQ,1,1,1) STARS
         TEST = ¬IDENT(APPLY(.TRIM,'ABC '),'ABC') STARS
-EJECT
*
*        FINAL PROCESSING
*
         OUTPUT = '************************************************'
         DIAGNOSTICS = 1000000 - &TRACE
         EQ(DIAGNOSTICS,0)        :S(TERMINATE)
         &DUMP = 2
         OUTPUT = '****    NUMBER OF ERRORS DETECTED  '
.                                 LPAD(DIAGNOSTICS,5) '    ****'
         OUTPUT = '**** E N D    O F     D I A G N O S T I C S ****'
         OUTPUT = '************************************************'
.                                           :(END)
TERMINATE OUTPUT = '**** N O     E R R O R S    D E T E C T E D ****'
         OUTPUT = '**** E N D    O F     D I A G N O S T I C S ****'
         OUTPUT = '************************************************'
 :(END)
*
*        ERROR HANDLING ROUTINE
*
ERRORS   OUTPUT = '****  ERROR AT '
.        LPAD(&LASTNO,4)   '      &ERRTYPE = ' LPAD(&ERRTYPE,7,' ')
.                                           ' ****'
         &TRACE = &TRACE - 1
         SETEXIT(.ERRORS)                   :(CONTINUE)
END
./*
-TITLE SPITBOL TEST PROGRAM #2 -- DIAGNOSTICS PHASE TWO
*
*        THIS IS THE STANDARD TEST PROGRAM FOR SPITBOL WHICH
*        TESTS PATTERN MATCHING USING BOTH FULLSCAN AND QUICKSCAN
*
         &DUMP = 2
         DEFINE('ERROR()')
         &TRACE = 1000
         &ERRLIMIT = 100
         TRACE(.ERRTYPE,'KEYWORD')
         &FULLSCAN = 0
         OUTPUT = '**********************************************'
         OUTPUT = '**** SPITBOL DIAGNOSTICS -- PHASE TWO     ****'
         OUTPUT = '**********************************************'
FLOOP    ERRCOUNT = 0
         OUTPUT = '****           &FULLSCAN = ' &FULLSCAN
.        '              ****'
         TEST = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
*
*        TEST PATTERN MATCHING AGAINST SIMPLE STRING
*
         TEST  'ABC' :S(S01) ; ERROR()
S01      TEST 'BCD' :S(S02) ; ERROR()
S02      TEST 'XYZ' :S(S03) ; ERROR()
S03      TEST 'ABD' :F(S04) ; ERROR()
S04      &ANCHOR = 1
         TEST 'ABC' :S(S05) ; ERROR()
S05      TEST 'BCD' :F(S06) ; ERROR()
S06      TEST TEST :S(S06A) ; ERROR()
*
*        TEST SIMPLE CASES OF $
*
S06A     TEST 'ABC' $ VAR :S(S07) ; ERROR()
S07      IDENT(VAR,'ABC') :S(S08) ; ERROR()
S08      TEST 'ABC' . VARD :S(S09) ; ERROR()
S09      IDENT(VARD,'ABC') :S(S10) ; ERROR()
*
*        TEST LEN
*
S10      &ANCHOR = 0
         TEST LEN(3) $ VARL :S(S11) ; ERROR()
S11      IDENT(VARL,'ABC') :S(S12) ; ERROR()
S12      TEST LEN(26) $ VARL :S(S13) ; ERROR()
S13      IDENT(VARL,TEST) :S(S14) ; ERROR()
S14      TEST LEN(27) :F(S15) ; ERROR()
*
*        TEST TAB
*
S15      TEST TAB(3) $ VART :S(S16) ; ERROR()
S16      IDENT(VART,'ABC') :S(S17) ; ERROR()
S17      TEST TAB(26) $ VART :S(S18) ; ERROR()
S18      IDENT(TEST,VART) :S(S19) ; ERROR()
S19      TEST TAB(0) $ VART :S(S20) ; ERROR()
S20      IDENT(VART) :S(S21) ; ERROR()
-EJECT
*
*        TEST ARB
*
S21      TEST ARB $ VARA 'C' :S(S22) ; ERROR()
S22      IDENT(VARA,'AB') :S(S23) ; ERROR()
S23      &ANCHOR = 1
         TEST ARB $ VARA POS(60) :F(S24) ; ERROR()
S24      IDENT(VARA,TEST) :S(S25) ; ERROR()
*
*        TEST POS
*
S25      TEST ARB $ VARA POS(2) $ VARP :S(S26) ; ERROR()
S26      (IDENT(VARA,'AB') IDENT(VARP)) :S(S27) ; ERROR()
S27      &ANCHOR = 0
         TEST ARB $ VARA POS(26) $ VARP :S(S28) ; ERROR()
S28      (IDENT(VARA,TEST) IDENT(VARP)) : S(S29) ; ERROR()
S29      TEST ARB $ VARA POS(0) $ VARP :S(S30) ; ERROR()
S30      IDENT(VARA VARP) :S(S31) ; ERROR()
S31      TEST POS(0) ARB $ VARA POS(26) :S(S32) ; ERROR()
S32      IDENT(TEST,VARA) :S(S33) ; ERROR()
S33      TEST POS(2) ARB $ VARA POS(3) :S(S34) ; ERROR()
S34      IDENT(VARA,'C') :S(S35) ; ERROR()
S35      TEST POS(27) :F(S36) ; ERROR()
*
*        TEST RPOS
*
S36      TEST ARB $ VARA RPOS(25) :S(S37) ; ERROR()
S37      IDENT(VARA,'A') :S(S38) ; ERROR()
S38      TEST ARB $ VARA RPOS(0) :S(S39) ; ERROR()
S39      IDENT(TEST,VARA) :S(S39A) ; ERROR()
S39A     TEST ARB $ VARA RPOS(26) :S(S40) ; ERROR()
S40      IDENT(VARA) :S(S41) ; ERROR()
S41      TEST RPOS(27) :F(S42) ; ERROR()
*
*        TEST RTAB
*
S42      TEST RTAB(26) $ VARA :S(S43) ; ERROR()
S43      IDENT(VARA) :S(S44) ; ERROR()
S44      TEST RTAB(27) :F(S45) ; ERROR()
S45      TEST RTAB(0) $ VARA :S(S46) ; ERROR()
S46      IDENT(VARA,TEST) :S(S47) ; ERROR()
S47      TEST RTAB(25) $ VARA :S(S48) ; ERROR()
S48      IDENT(VARA,'A') :S(S49) ; ERROR()
*
*        TEST @
*
S49      TEST LEN(6) @VARA :S(S50) ; ERROR()
S50      IDENT(VARA,6) :S(S51) ; ERROR()
S51      TEST @VARA :S(S52) ; ERROR()
S52      IDENT(VARA,0) :S(S53) ; ERROR()
S53      TEST LEN(26) @VARA :S(S54) ; ERROR()
S54      IDENT(VARA,26) :S(S55) ; ERROR()
-EJECT
*
*        TEST BREAK
*
S55      TEST BREAK('C') $ VARA :S(S56) ; ERROR()
S56      IDENT(VARA,'AB') :S(S57) ; ERROR()
S57      TEST BREAK('Z()') $ VARA :S(S58)     ; ERROR()
S58      IDENT(VARA,'ABCDEFGHIJKLMNOPQRSTUVWXY') :S(S59) ; ERROR()
S59      TEST BREAK(',') :F(S60) ; ERROR()
S60      LPAD(TEST,1000) BREAK('A') $ VARA :S(S61) ; ERROR()
S61      IDENT(LPAD(' ',1000 - 26),VARA) :S(S62) ; ERROR()
S62      LPAD(TEST,1000) BREAK(',') :F(S63) ; ERROR()
*
*        TEST SPAN
*
S63      TEST SPAN(TEST) $ VARA :S(S64) ; ERROR()
S64      IDENT(TEST,VARA) :S(S65) ;ERROR()
S65      TEST SPAN('CDQ') $ VARA :S(S66) ; ERROR()
S66      IDENT(VARA,'CD') :S(S67) ; ERROR()
S67      TEST SPAN(',') :F(S68) ; ERROR()
S68      LPAD(TEST,1000) SPAN(' ') $ VARA :S(S69) ; ERROR()
S69      IDENT(VARA,LPAD(' ',1000 - 26)) :S(S70) ; ERROR()
*
*        TEST BREAKX
*
S70      (TEST TEST) POS(0) BREAKX('E') $ VARA '.' :F(S71) ; ERROR()
S71      IDENT(VARA,TEST 'ABCD') :S(S72) ; ERROR()
S72      TEST BREAKX('.') :F(S73) ; ERROR()
*
*        TEST ANY
*
S73      TEST ANY('MXZ') $ VARA :S(S74) ; ERROR()
S74      IDENT(VARA,'M') :S(S75) ; ERROR()
S75      TEST ANY(',.') :F(S76) ; ERROR()
-EJECT
*
*        TEST NOTANY
*
S76      TEST NOTANY('ABCDEFGHJKLMPQRSTUWXYZ') $ VARA :S(S77) ; ERROR()
S77      IDENT(VARA,'I') :S(S78) ; ERROR()
S78      TEST NOTANY(TEST) :F(S79) ; ERROR()
*
*        TEST REM
*
S79      TEST REM $ VARA :S(S80) ; ERROR()
S80      IDENT(VARA,TEST) :S(S81) ; ERROR()
S81      TEST LEN(26) REM $ VARA :S(S82) ; ERROR()
S82      IDENT(VARA) :S(S83) ; ERROR()
*
*        TEST ALTERNATION
*
S83      TEST ('ABD' | 'AB') $ VARA :S(D84) ; ERROR()
D84      IDENT(VARA,'AB') :S(D85) ; ERROR()
D85      TEST (TEST 'A' | TEST) $ VARL :S(D86) ; ERROR()
D86      IDENT(VARL,TEST) :S(D00) ; ERROR()
*
*        TEST DEFERRED STRINGS
*
D00      TEST *'ABC' :S(D01) ; ERROR()
D01      TEST *'ABD' :F(D06) ; ERROR()
*
*        TEST $ . WITH DEFERRED NAME ARGUMENTS
*
D06      TEST 'ABC' $ *VAR :S(D07) ; ERROR()
D07      IDENT(VAR,'ABC') :S(D08) ; ERROR()
D08      TEST 'ABC' . *$'VARD' :S(D09) ; ERROR()
D09      IDENT(VARD,'ABC') :S(D10) ; ERROR()
*
*        TEST LEN WITH DEFERRED ARGUMENT
*
D10      &ANCHOR = 0
         TEST LEN(*3) $ VARL :S(D11) ; ERROR()
D11      IDENT(VARL,'ABC') :S(D15) ; ERROR()
*
*        TEST TAB WITH DEFERRED ARGUMENT
*
D15      TEST TAB(*3) $ VART :S(D16) ; ERROR()
D16      IDENT(VART,'ABC') :S(D21) ; ERROR()
-EJECT
*
*        TEST POS WITH DEFERRED ARGUMENT
*
D21      &ANCHOR = 1
         TEST ARB $ VARA POS(*2) $ VARP :S(D26) ; ERROR()
D26      (IDENT(VARA,'AB') IDENT(VARP)) :S(D27) ; ERROR()
D27      &ANCHOR = 0
         TEST ARB $ VARA POS(*0) $ VARP :S(D35) ; ERROR()
D35      IDENT(VARA VARP) :S(D36) ; ERROR()
*
*        TEST RPOS WITH DEFERRED ARGUMENT
*
D36      TEST ARB $ VARA RPOS(*25) :S(D37) ; ERROR()
D37      IDENT(VARA,'A') :S(D38) ; ERROR()
*
*        TEST RTAB WITH DEFERRED ARGUMENT
*
D38      TEST RTAB(*26) $ VARA :S(D43) ; ERROR()
D43      IDENT(VARA) :S(D49) ; ERROR()
*
*        TEST @ WITH DEFERRED ARGUMENT
*
D49      TEST LEN(6) @*VARA :S(D50) ; ERROR()
D50      IDENT(VARA,6) :S(D51) ; ERROR()
D51      TEST @*$'VARA' :S(D52) ; ERROR()
D52      IDENT(VARA,0) :S(D55) ; ERROR()
*
*        TEST BREAK WITH DEFERRED ARGUMENT
*
D55      TEST BREAK(*'C') $ VARA :S(D56) ; ERROR()
D56      IDENT(VARA,'AB') :S(D57) ; ERROR()
*
*        TEST SPAN WITH DEFERRED ARGUMENT
*
D57      TEST SPAN(*TEST) $ VARA :S(D64) ; ERROR()
D64      IDENT(TEST,VARA) :S(D70) ; ERROR()
*
*        TEST BREAKX WITH DEFERRED ARGUMENT
*
D70      (TEST TEST) POS(*0) BREAKX(*'E') $ VARA '.' :F(D71) ; ERROR()
D71      IDENT(VARA,TEST 'ABCD') :S(D73) ; ERROR()
-EJECT
*
*        TEST ANY WITH DEFERRED ARGUMENT
*
D73      TEST ANY(*'MXZ') $ VARA :S(D74) ; ERROR()
D74      IDENT(VARA,'M') :S(D75) ; ERROR()
*
*        TEST NOTANY WITH DEFERRED ARGUMENT
*
D75      TEST NOTANY(*'ABCDEFGHJKLMPQRSTUWXYZ') $ VARA :S(D77) ;
.                                                          ERROR()
D77      IDENT(VARA,'I') :S(D79) ; ERROR()
D79      :(ALLDONE)
         EJECT
*
*        ERROR HANDLING ROUTINE
*
ERROR    OUTPUT = '****** ERROR DETECTED AT ' &LASTNO ' ********'
         ERRCOUNT = ERRCOUNT + 1
         OUTPUT = '***** RESUMING EXECUTION *******'       :(RETURN)
*
*        TERMINATION ROUTINE
*
ALLDONE
         ERRCOUNT = ERRCOUNT + &ERRLIMIT - 100
         &ERRLIMIT = 100
         OUTPUT = EQ(ERRCOUNT,0)
.                 '****           NO ERRORS DETECTED         ****'
         OUTPUT = '**********************************************'
         &FULLSCAN = EQ(&FULLSCAN,0) 1           :S(FLOOP)
         OUTPUT = '****           END OF DIAGNOSTICS         ****'
         OUTPUT = '**********************************************'
END
./*
-TITLE SPITBOL TEST PROGRAM #3 -- COMPUTE FACTORIAL TABLE
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        THIS PROGRAM COMPUTES AND PRINTS A TABLE OF N FACTORIAL      *
*        FOR VALUES OF N FROM 1 THROUGH AN UPPER LIMIT "NX".          *
*                                                                     *
*        IT DEMONSTRATES A METHOD OF MANIPULATING NUMBERS WHICH ARE   *
*        TOO LARGE FOR THE COMPUTER, AS STRINGS OF CHARACTERS.  THE   *
*        COMMAS IN THE PRINTED VALUES ARE OPTIONAL, ADDED FOR READING *
*        EASE.                                                        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*        INITIALIZATION.
*
         NX = 45
         N = 1
         NSET = 1
         NUM = ARRAY(1000)
         NUM<1> = 1
         FILL = ARRAY('0:3')
         FILL<0> = '000'
         FILL<1> = '00'
         FILL<2> = '0'
*
         OUTPUT = '          TABLE OF FACTORIALS FOR 1 THROUGH ' NX
         OUTPUT =
*
*        COMPUTE THE NEXT VALUE FROM THE PREVIOUS ONE.
*
L1       I = 1
L2       NUM<I> = NUM<I> * N                           :F(ERR)
         I = LT(I,NSET) I + 1                          :S(L2)
         I = 1
L3       LT(NUM<I>,1000)                               :S(L4)
         NUMX = NUM<I> / 1000                          :F(ERR)
         NUM<I + 1> = NUM<I + 1> + NUMX                :F(ERR)
         NUM<I> = NUM<I> - 1000 * NUMX                 :F(ERR)
L4       I = LT(I,NSET) I + 1                          :S(L3)
*
*        FORM A STRING REPRESENTING THE FACTORIAL.
*
L5       NSET = DIFFER(NUM<NSET + 1>) NSET + 1
         NUMBER = NUM<NSET>                            :F(ERR)
         I = GT(NSET,1) NSET - 1                       :F(L7)
L6       NUMBER = NUMBER ',' FILL<SIZE(NUM<I>)> NUM<I>
         I = GT(I,1) I - 1                             :S(L6)
*
*        OUTPUT A LINE OF THE TABLE.
*
L7       OUTPUT = N '!=' NUMBER
         N = LT(N,NX) N + 1                            :S(L1)F(END)
*
*        ERROR TERMINATION.
*
ERR      OUTPUT = N '! CANNOT BE COMPUTED BECAUSE OF TABLE OVERFLOW.'
         OUTPUT = '     INCREASE THE SIZE OF ARRAY "NUM".'
*
END
./*
-TITLE SPITBOL TEST PROGRAM #4 -- SYNTACTIC RECOGNIZER FOR SPITBOL
*
*        THIS PROGRAM IS A SYNTACTIC RECOGNIZER FOR SPITBOL STATEMENTS
*
*      FIRST A SERIES OF PATTERNS IS BUILD CULMINATING IN A PATTERN
*      WHICH MATCHES ONLY SYNTACTICALLY CORRECT STATEMENTS.  CARD IMAGES
*      ARE THEN READ IN AND PROCESSED.  INCORRECT STATEMENTS ARE
*      IDENTIFIED BY AN ERROR MESSAGE.
*
*      THE FUNCTION OPT FORMS A PATTERN THAT MATCHES EITHER NULL OR ITS
*      ARGUMENT.
*
         DEFINE('OPT(PATTERN)')
*
         LETTERS   =   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
*
*      ON THE IBM SYSTEM/360 LETTERS INCLUDE LOWER CASE AS WELL.
*
         DIGITS   =   '0123456789'
         ALPHANUMERICS   =   LETTERS DIGITS
         BLANKS   =   SPAN(' ')
         INTEGER   =   SPAN(DIGITS)
         REAL   =   SPAN(DIGITS) '.' OPT(SPAN(DIGITS))
         IDENTIFIER   =   ANY(LETTERS) OPT(SPAN(ALPHANUMERICS '_.'))
         UNARY   =   ANY('+-&.$*?¬@%#')
         BINARY   =   ANY('-+.$*|/@*#') | '**'
         BINARYOP   =   BLANKS OPT(BINARY BLANKS)
         UNQALPHABET   =   &ALPHABET
         UNQALPHABET   '"'   =
         UNQALPHABET   "'"   =
         DLITERAL   =   '"' SPAN(UNQALPHABET "'") '"'
         SLITERAL   =   "'" SPAN(UNQALPHABET '"') "'"
         LITERAL   =   SLITERAL | DLITERAL | INTEGER | REAL
         ELEMENT   =   OPT(UNARY) (IDENTIFIER | LITERAL | *FUNCTION_CALL
.                      | '(' *EXPRESSION | OPT(BLANKS) ')' | *ARRAY_REF)
         OPERATION   =   *ELEMENT BINARYOP (*ELEMENT | *EXPRESSION)
         EXPRESSION   =   OPT(BLANKS) (*ELEMENT | *OPERATION | NULL)
.                         OPT(BLANKS)
         ARG_LIST   =   *EXPRESSION OPT(',' *ARG_LIST)
         FUNCTION_CALL   =   IDENTIFIER '(' *ARG_LIST ')'
         ARRAY_SUB   =   '<' *ARG_LIST '>' OPT(*ARRAY_SUB)
         ARRAY_REF   =   IDENTIFIER ARRAY_SUB
         LABEL   =   ANY(ALPHANUMERICS) (BREAK(' ;') | REM)
         LABEL_FIELD   =   OPT(LABEL)
         GOTO   =   '(' EXPRESSION ')'
         GOTO_FIELD   =   OPT(BLANKS ':' FENCE OPT(BLANKS) (GOTO | 'S'
.                         GOTO | 'F' GOTO | 'S' GOTO OPT(BLANKS) 'F'
.                         GOTO | 'F' GOTO OPT(BLANKS) 'S' GOTO)
.                         OPT(BLANKS))
         RULE   =   OPT(BLANKS ELEMENT (OPT(BLANKS) '=' OPT(OPT(BLANKS)
.                   EXPRESSION) | OPT(BLANKS EXPRESSION OPT(OPT(BLANKS)
.                   '=' OPT(OPT(BLANKS) EXPRESSION)))))
         EOS   =   RPOS(0) | ';'
         STATEMENT   =   LABEL_FIELD RULE GOTO_FIELD EOS
-EJECT
*
*      THE PATTERN FOR RECOGNIZING STATEMENTS IS NOW FORMED.  THE
*      PROGRAM TO ANALYZE INPUT CARDS FOLLOWS.
*
         COMMENT   =   ANY('*-')
         CONTINUE   =   ANY('.+') . CC
         &ANCHOR   =   1
         &FULLSCAN   =   1
         EOF   =
         INPUT(.INPUT,,72)
*
*      INITIALIZE PROCESS FROM FIRST CARD.
*
READI    IMAGE   =   TRIM(INPUT)                       :F(END)
         OUTPUT   =   '     ' IMAGE
*
*        DO NOT PROCESS COMMENT OR CONTINUE CARDS.
*
         IMAGE   COMMENT                               :F(READC)S(READI)
NEXTST   IDENT(EOF)                                    :F(END)
         OUTPUT   =   '     ' LINE
         IMAGE   =   LINE
READC    LINE   =   TRIM(INPUT)                        :F(ENDGAME)
         LINE   COMMENT                                :S(PRINT)
         LINE   CONTINUE   =                           :F(ANALYZE)
         OUTPUT   =   '     ' CC LINE
         IMAGE   =   IMAGE LINE                        :(READC)
ANALYZE  IMAGE   STATEMENT   =                         :F(ERROR)
         DIFFER(IMAGE)                                 :S(ANALYZE)
         OUTPUT   =   '<<< NO SYNTACTIC ERROR >>>'
SKIP     OUTPUT   =                                    :(NEXTST)
*
*      IF AN ERRONEOUS STATEMENT IS  ENCOUNTERED IN A STRING OF
*      STATEMENTS SEPARATED BY SEMICOLONS, SUBSEQUENT STATEMENTS ARE
*      NOT PROCESSED.
*
ERROR    OUTPUT   =   '<<< SYNTACTIC ERROR >>>'        :(SKIP)
*
PRINT    OUTPUT   =   '     ' LINE                     :(READC)
ENDGAME  EOF   =   1                                   :(ANALYZE)
*
*
OPT      OPT   =   NULL | PATTERN                      :(RETURN)
END
*
*      A VARIETY OF CORRECT AND INCORRECT SPITBOL STATEMENTS FOLLOW
*
-LIST
COMPUTE  X   =  Y + 3 ** -'2'
       X   =   Y+Z
         ELEMENT<I,J>= ELEMENT<I,-J> + ELEMENT<-I,J>
       ELEMENT<I><J><K>   =   ELEMENT<K><J><I>
       A<X,Y,Z + 1>   =   F(X,STRUCTURE_BUILD(TYPE,LENGTH + 1))
SETUP    PAT1   =   (BREAK(',:') $ FIRST | SPAN(' .') $ SECOND
.                   . VALUE ARBNO(BAL | LEN(1))  :($SWITCH)
       DEFINE('F(X,Y))
       L   =   LT(N,B<J> L + 1
NEWONE_TRIAL   X   =   ¬COORD<1,K> X * X
       TRIM(INPUT)   PAT1    :S(OK)  :F(BAD)
   X   =   3.01; Y = 2.    ; Z   =   X * -Y
./*
-TITLE SPITBOL TEST PROGRAM #5 -- DEMONSTRATION VERSION OF TREESORT4
-STITL DRIVER
 DEFINE('TREESORT4(DATA,NUMBER_TO_SORT)')
 DEFINE('PRINTER()')
 DATA = ARRAY(24)
         INPUT(.INPUT,,72)
READER J = J + 1
 DATA<J> = TRIM(INPUT)  :S(READER)
 OUTPUT = 'UNSORTED DATA'
 OUTPUT =
 PRINTER()
 TREESORT4(DATA,24)
 OUTPUT =
 OUTPUT = 'SORTED DATA'
 OUTPUT =
 PRINTER() :(END)
*
PRINTER J = 0
PRINTL J = J + 1
 OUTPUT = DATA<J>    :S(PRINTL)F(RETURN)
-STITL ACTUAL TREESORT4 SUBROUTINE
*             TREESORT4
*             ---------
*
*             SORTING ALGORITHM DERIVED FROM FLOYD'S TREESORT3 PUBLISHED
*             IN CACM DEC. 1967 -- THE MODIFICATIONS DEVISED BY R. DEWAR
*             AND L.FISHER REDUCE THE NUMBER OF COMPARES FROM 2NLOGN
*             TO NLOGN -- THIS VERSION CODED IN SNOBOL4 BY R. DEWAR
*
TREESORT4
.             NUMBER_IN_TREE = NUMBER_TO_SORT
              NODE_TO_SIFT = NUMBER_TO_SORT / 2
              RETURN_FROM_SIFT = .SIFT_RETURN_1
SIFT_CALL_1
.             HOLD_LOCATION = DATA<NODE_TO_SIFT> :(SIFT_NODE)
SIFT_RETURN_1
.             NODE_TO_SIFT = GT(NODE_TO_SIFT,1)
.                              NODE_TO_SIFT - 1  :S(SIFT_CALL_1)
SECOND_PHASE
.             RETURN_FROM_SIFT = .SIFT_RETURN_2
SIFT_RETURN_2
.             HOLD_LOCATION = DATA<NUMBER_IN_TREE>
              DATA<NUMBER_IN_TREE> = DATA<1>
              NUMBER_IN_TREE = GT(NUMBER_IN_TREE,1)
.                               NUMBER_IN_TREE - 1
.                                                :S(SIFT_NODE)F(RETURN)
-EJECT
SIFT_NODE
.             FATHER = NODE_TO_SIFT
PULL_UP_LARGER_SON
.             LEFT_SON = FATHER * 2
              LT(LEFT_SON,NUMBER_IN_TREE)        :S(COMPARE_SONS)
              EQ(LEFT_SON,NUMBER_IN_TREE)        :S(LEFT_SON_HIGH)
                                                 :(CHECK_FATHERS)
COMPARE_SONS
.             RIGHT_SON = LEFT_SON + 1
              LGT(DATA<LEFT_SON>,DATA<RIGHT_SON>)
.                                                :S(LEFT_SON_HIGH)
RIGHT_SON_HIGH
.             DATA<FATHER> = DATA<RIGHT_SON>
              FATHER = RIGHT_SON                 :(PULL_UP_LARGER_SON)
LEFT_SON_HIGH
.             DATA<FATHER> = DATA<LEFT_SON>
              FATHER = LEFT_SON                  :(PULL_UP_LARGER_SON)
CHECK_FATHERS
.             HOLE_IN_TREE = FATHER
TEST_NEXT_FATHER
.             FATHER_OF_HOLE = HOLE_IN_TREE / 2
              LT(FATHER_OF_HOLE,NODE_TO_SIFT)    :S(FILL_HOLE)
              LGT(DATA<FATHER_OF_HOLE>,HOLD_LOCATION)
.                                                :S(FILL_HOLE)
              DATA<HOLE_IN_TREE> = DATA<FATHER_OF_HOLE>
              HOLE_IN_TREE = FATHER_OF_HOLE      :(TEST_NEXT_FATHER)
FILL_HOLE
.             DATA<HOLE_IN_TREE> = HOLD_LOCATION
.                                                :($RETURN_FROM_SIFT)
END
SHALL
I
COMPARE
THEE
TO
A
SUMMERS
DAY
THOU
ART
MORE
LOVELY
AND
MORE
TEMPORATE
ROUGH
WINDS
DO
SHAKE
THE
DARLING
BUDS
OF
MAY
./*
-TITLE SPITBOL TEST PROGRAM #6 -- TOPOLOGICAL SORT
*
*        TOPOLOGICAL SORT
*
*   MAPS A PARTIAL ORDERING OF OBJECTS INTO A LINEAR ORDERING
*
*        A(1), A(2), ..., A(N)
*
*   SUCH THAT IF   A(S) < A(T) IN THE PARTIAL ORDERING,THEN S < T.
*   (CF. D.E.KNUTH, THE ART OF COMPUTER PROGRAMMING,VOLUME 1,
*   ADDISON-WESLEY,MASS.,1968, P.262)
*
         &DUMP = 2
         OUTPUT('OUT',6,'(121A1)')
         PAIR      = BREAK('<') . MU LEN(1) BREAK(',') . NU LEN(1)
         DATA('ITEM(COUNT,TOP)')
         DATA('NODE(SUC,NEXT)')
         DEFINE('DECR(X)')
         DEFINE('INDEX(TAU)')
         INPUT(.INPUT,,72)
*
*     READ IN THE NUMBER OF ITEMS, N, AND GENERATE AN ARRAY OF ITEMS.
*
*   EACH ITEM HAS TWO FIELDS, (COUNT,TOP), WHERE
*        COUNT = NO. OF ELEMENTS PRECEEDING IT.
         TOP = TOP OF LIST OF ITEMS SUCCEEDING IT.
*
         N         = TRIM(INPUT)
         X         = ARRAY('0:' N)
*   INITIALIZE THE ITEMS TO (0,NULL).
*
T1       X<I>      =  ITEM(0,)              :F(T1A)
         I         =  I + 1                 :(T1)
*
*   READ IN RELATIONS.
*
T1A      OUT       = '1 THE RELATIONS ARE:'
T2A      REL       = TRIM(INPUT) ','        :F(T3A)
         OUTPUT    = REL
T2       REL       PAIR  =                  :F(T2A)
         J         = INDEX(MU)
         K         = INDEX(NU)
*
*   SINCE MU < NU, INCREASE THE COUNT OF THE KTH ITEM AND ADD A
*   NODE TO THE LIST OF SUCCESSORS OF THE JTH ITEM.
*
T3       COUNT(X<K>) = COUNT(X<K>) + 1
         TOP(X<J>) = NODE(K,TOP(X<J>))      :(T2)
-EJECT
*
*    A QUEUE IS MAINTAINED OF THOSE ITEMS WITH ZERO COUNT FIELD.
*    THE LINKS FOR THE QUEUE, QLINK, ARE KEPT IN THE COUNT FIELD.
*    THE VARIABLES F,R POINT TO THE FRONT AND REAR OF THE QUEUE.
*
T3A      OPSYN('QLINK','COUNT')
*
*    INITIALIZE THE QUEUE FOR OUTPUT.
*
         R         = 0
         QLINK(X<0>) = 0
         K         = 0
T4       K         = ?X<K + 1>  K + 1       :F(T4A)
         QLINK(X<R>) = EQ(COUNT(X<K>),0)  K :F(T4)
         R         = K                      :(T4)
T4A      F         = QLINK(X<0>)
*
*    OUTPUT THE FRONT OF THE QUEUE.
*
         OUT       = '0 THE LINEAR ORDERING IS:'
T5       OUTPUT    = NE(F,0)  $(F ':')      :F(T8)
         N         = N - 1
         P         = TOP(X<F>)
*    ERASE RELATIONS.
T6       IDENT(P)                           :S(T7)
         DECR(.COUNT(X<SUC(P)>))            :S(T6A)
*
*    IF COUNT IS ZERO ADD  ITEM TO QUEUE.
*
         QLINK(X<R>) = SUC(P)
         R         = SUC(P)
T6A      P         = NEXT(P)                :(T6)
*
*    REMOVE FROM QUEUE.
*
T7       F         = QLINK(X<F>)            :(T5)
*
*    FUNCTION DEFINITIONS.
*
DECR     $X        = GT($X,1)  $X - 1       :S(RETURN)
         $X        = 0                      :(FRETURN)
*
INDEX    INDEX     = DIFFER($(TAU ':'))  $(TAU ':')  :S(RETURN)
         TERMCT    = LT(TERMCT,N)  TERMCT + 1    :F(FRETURN)
         INDEX     = TERMCT
         $(TERMCT ':')   =  TAU
         $(TAU ':')   =  TERMCT             :(RETURN)
*
T8       OUTPUT    = NE(N,0) 'THE ORDERING CONTAINS A LOOP.'
END
14
LETTERS<ALPHANUM,NUMBERS<ALPHANUM
BLANKS<OPTBLANKS
NUMBERS<REAL
NUMBERS<INTEGER
LETTERS<VARIABLE,ALPHANUM<VARIABLE
BINARY<BINARYOP,BLANKS<BINARYOP
UNQALPHABET<DLITERAL
UNQALPHABET<SLITERAL
SLITERAL<LITERAL,DLITERAL<LITERAL,INTEGER<LITERAL,REAL<LITERAL
./*
-TITLE SPITBOL TEST PROGRAM #7 -- SYMBOL TABLE GENERATOR
*
*        THIS PROGRAM DEMONSTRATES THE STORAGE OF SYMBOL TABLES
*        USING A TECHIQUE IN WHICH NAMES ARE STORED AS LINKED LISTS
*        OF CHARACTERS. THE DATA FUNCTION IS USED TO FORM THE
*        REQUIRED NODES WHICH CONTAIN APPROPRIATE POINTERS TO BE
*        USED ON FAILURE OR SUCCESS OF THE CHARACTER BY CHARACTER MATCH
*
-CODE
         DATA('SYMB(CHAR,LINK,ALT,ASSOC,SUCC)')
         INPUT(.INPUT,,72)
         SPC = '     ::'
         ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
CLEAR    HEAD =
         SWITCH1 = .FIRST
         X = 0
READA    OUTPUT =
READ     CARD = TRIM(INPUT)                      :F(END1)
         OUTPUT = CARD
         DIFFER(CARD)                            :F(BADCARD)
         CARD POS(0) '$' =                       :S(CONTROL)
         CARD NOTANY(ALPH)                       :F(INCX)
BADCARD  OUTPUT = '  CARD ABOVE IS ILLEGAL'      :(READ)
INCX     X = X + 1                               :($SWITCH1)
FIRST    SWITCH1 = .SEARCH
F1       CARD LEN(1) . CH =                      :F(ERR)
         HEAD = SYMB(CH)
         CURRENT = HEAD
F2       CARD LEN(1) . CH =                      :F(INSERT)
F3       SUCC(CURRENT) = SYMB(CH,CURRENT)
         CURRENT = SUCC(CURRENT)                 :(F2)
INSERT   ASSOC(CURRENT) = ASSOC(CURRENT) X ","   :(READ)
SEARCH   CARD LEN(1) . CH =                      :F(ERR)
         LGT(CHAR(HEAD), CH)                     :S(S7)
         IDENT(CHAR(HEAD),CH)                    :S(S5)
*
*  FIRST CHARACTER OF HEAD IS < FIRST CHAR OF CHAR JUST READ
*  IF ALT(HEAD) NULL THEN MUST EXTEND STRUCTURE
*
         IDENT(ALT(HEAD))                        :S(S3)
         CURRENT = ALT(HEAD)
S1       LGT(CHAR(CURRENT),CH)                   :S(S6)
         IDENT(CHAR(CURRENT),CH)                 :S(S4)
         IDENT(ALT(CURRENT))                     :S(S2)
         CURRENT = ALT(CURRENT)                  :(S1)
*
*  NEW ALTERNATIVE MUST BE INSERTED AT END
*
S2       ALT(CURRENT) = SYMB(CH,CURRENT)
*
*  THEN REST OF WORD STRUNG OUT
*
         CURRENT = ALT(CURRENT)                  :(F2)
*
*  NEW ALTERNATIVE MUST BE INSERTED AT HEAD OF LIST
*
S3       ALT(HEAD) = SYMB(CH,HEAD)
         CURRENT = ALT(HEAD)                     :(F2)
-EJECT
*
*  CHARACTER HAS BEEN FOUND. NOW LOOK AT NEXT HCARACTER OF WORD
*
S4       CARD LEN(1) . CH  =                     :F(INSERT)
*  IF NO SUCCESSORS, STRING OUT REST OF WORD
*
         IDENT(SUCC(CURRENT))                    :S(F3)
*
*  OTHERWISE CONTINUE EXAMINATION
*
         CURRENT = SUCC(CURRENT)                 :(S1)
S5       CURRENT = HEAD                          :(S4)
*
*  CHAR IS SMALLER THAN CURRENT ALTERNATIVE
*
S6       Y = LINK(CURRENT)
         ALT(Y) = IDENT(ALT(Y),CURRENT) SYMB(CH,Y)         :F(S6A)
         Y = ALT(Y)                              :(S6B)
S6A      SUCC(Y) = SYMB(CH,Y)
         Y = SUCC(Y)
S6B      ALT(Y) = CURRENT
         LINK(CURRENT) = Y
         CURRENT = Y                             :(F2)
*
*  NEW ALTERNATIVE MUST BE LINKED TO HEAD, AT TOP OF LIST
*
S7       Y = HEAD
         HEAD = SYMB(CH)
         LINK(Y) = HEAD
         ALT(HEAD) = Y
         CURRENT = HEAD                          :(F2)
CONTROL  IDENT(CARD,"*")                         :F(C1)
         OUTPUT =
         OUTPUT = '  (STRUCTURE IS CLEARED)'
         OUTPUT =                                :(CLEAR)
C1       IDENT(CARD,'$')                         :F(C2)
         OUTPUT =
         OUTPUT = '  (PRINTOUT OF ENTIRE STRUCTURE FOLLOWS...)'
         OUTPUT =
         IDENT(HEAD)                             :S(C4)
         HOLD =
         START = HEAD                            :(LISTEM)
C2       IDENT(CARD)                             :S(BADCARD)
         CARD NOTANY(ALPH)                       :S(BADCARD)
-EJECT
*
*  HERE TO PRINT WORDS STARTING WITH SPECIFIED HEAD
*
         OUTPUT =
         OUTPUT = '  (PRINTOUT OF ALL WORDS BEGINNING WITH "'
+          CARD '"...)'
         OUTPUT =
         HOLD = CARD
         CURRENT = HEAD
         CARD LEN(1) . CH =
C3       IDENT(CHAR(CURRENT),CH)                 :S(NEXT)
         CURRENT = ALT(CURRENT)
         IDENT(CURRENT)                          :F(C3)
C4       OUTPUT = '  (NO WORDS)'                 :(READA)
NEXT     CARD LEN(1) . CH =                      :F(SETUP)
         CURRENT = SUCC(CURRENT)
         IDENT(CURRENT)                          :S(C4)F(C3)
SETUP    OUTPUT = DIFFER(ASSOC(CURRENT)) SPC HOLD '  ' ASSOC(CURRENT)
         START = DIFFER(SUCC(CURRENT)) SUCC(CURRENT)  :F(C4)
LISTEM   N = 0
         CURRENT = START
L1       HOLD = HOLD CHAR(CURRENT)
L2       OUTPUT = DIFFER(ASSOC(CURRENT)) SPC HOLD '  ' ASSOC(CURRENT)
         CURRENT = DIFFER(SUCC(CURRENT)) SUCC(CURRENT)  :S(L1)
BACKUP   CURRENT = DIFFER(ALT(CURRENT)) ALT(CURRENT)  :F(B1)
         N = N + 1
         $('STACK' N) = LINK(CURRENT)
         HOLD LEN(1) RPOS(0) = CHAR(CURRENT)     :(L2)
B1       Y = LINK(CURRENT)
         IDENT(Y)                                :S(READA)
         IDENT(Y,START) IDENT(ALT(Y),CURRENT)    :S(READA)
         IDENT(Y,START) IDENT(ALT(Y))            :S(READA)
         CURRENT = Y
         HOLD DIFFER($('STACK' N),Y)  LEN(1) RPOS(0) =  :S(BACKUP)
         N = N - 1                               :(B1)
END1     OUTPUT =
         OUTPUT = '(ALL DATA PROCESSED)'
END
ABC
ABCD
ABCDE
BCDEF
$$
$*
ELASTIC
HAPPILY
BOX
FOX
CARS
GAITERS
ALL
DUMP
JUNE
IN
$$
$*
SISTER
SUSIE
SELLS
SEA
SHELLS
BY
THE
SEA
SHORE
$$
$S
$SH
SOME
SEA
SHELLS
SEND
SAILORS
SWIMMING
$$
$S
$SE
$*
$$
CATTLE
CARP
CAT
GORGE
MONSTER
MONEY
CAR
DOG
METAL
CAVE
CAKE
CAT
$$
$MON
$M
$C
$CA
$CAT
$CATT
$CAX
$$
./*
-TITLE SPITBOL TEST PROGRAM #8 -- BRIDGE DEALER
         DATA('CARD(NUM,NEXT)')
*
         OUTPUT('TITLE',6,'(14H1THIS IS HAND ,110A1)')
         OUTPUT('DEALER',6,'(11H DEALER IS ,110A1)')
         OUTPUT('SKIP',6,'(A1)')
*
         DEFINE('INSERT(LIST,CARD)TEMP')               :(INSERTEND)
*
INSERT   $LIST  =  IDENT($LIST)  CARD(NUM(CARD),NULL)  :S(RETURN)
         $LIST  =  GT(NUM(CARD),NUM($LIST))  CARD(NUM(CARD),$LIST)
.                                                      :S(RETURN)
         TEMP  =  $LIST
INS1     IDENT(NEXT(TEMP))                             :S(INS2)
         NEXT(TEMP)  =  GT(NUM(CARD),NUM(NEXT(TEMP)))
.                       CARD(NUM(CARD),NEXT(TEMP))     :S(RETURN)
         TEMP  =  NEXT(TEMP)                           :(INS1)
INS2     NEXT(TEMP)  =  CARD(NUM(CARD),NULL)           :(RETURN)
INSERTEND
*
*
         DEFINE('LINE(STR1,COL1,STR2,COL2)BL1,BL2')    :(LINEEND)
*
LINE     BL  LEN(COL1 - 1) . BL1
         IDENT(STR2)                                   :S(LINE1)
         BL  LEN(COL2 - (COL1 + SIZE(STR1))) . BL2
LINE1    LINE  =  BL1  STR1  BL2  STR2                 :(RETURN)
LINEEND
*
*
         DEFINE('NTH(LIST,NUM)TEMP')                   :(NTHEND)
*
NTH      NTH  =  EQ(NUM,0)  $LIST                      :F(NTH1)
         $LIST  =  NEXT($LIST)                         :(RETURN)
NTH1     TEMP  =  $LIST
NTH2     NUM  =  NUM - 1
         NTH  =  EQ(NUM,0)  NEXT(TEMP)                 :S(NTH3)
         TEMP  =  NEXT(TEMP)                           :(NTH2)
NTH3     NEXT(TEMP)  =  NEXT(NEXT(TEMP))               :(RETURN)
NTHEND
*
*
         DEFINE('RANDOM(N)')                           :(RANDOMEND)
RANDOM   RAN.VAR  =  RAN.VAR * 1061 + 3251
         RAN.VAR  ARB  RPOS(5)  =
         RANDOM  =  (RAN.VAR * N) / 100000             :(RETURN)
RANDOMEND
*
*
         DEFINE('SUITL(HAND,SUIT)')                    :(SUITLEND)
*
SUITL    SUITL  =  SUIT  '  '
SUITL1   GT(NUM($HAND),$SUIT)                          :F(RETURN)
         SUITL  =  SUITL  $(NUM($HAND) - $SUIT)
         $HAND  =  DIFFER(NEXT($HAND))  NEXT($HAND) :S(SUITL1)F(RETURN)
SUITLEND
-EJECT
*
*                  CONSTANTS
*
         BL  =  '                                        '
.               '                                        '
         S  =  39
         H  =  26
         D  =  13
         C  =  0
         $1  =  2
         $2  =  3
         $3  =  4
         $4  =  5
         $5  =  6
         $6  =  7
         $7  =  8
         $8  =  9
         $9  =  10
         $10  =  'J'
         $11  =  'Q'
         $12  =  'K'
         $13  =  'A'
         DEALSEQ  =  'NORTH,EAST,SOUTH,WEST,NORTH,'
         RAN.VAR  =  157
         DEALMAX  =  3
         NTHDEAL  =
         DEAL  =  'WEST'
NEWDEAL  NTHDEAL  =  LT(NTHDEAL,DEALMAX)  NTHDEAL + 1  :F(END)
         N  =  1
         NORTH  =
         EAST  =
         SOUTH  =
         WEST  =
         DECK  =
DLOOP    DECK  =  CARD(N,DECK)
         N  =  LT(N,52)  N + 1                         :S(DLOOP)
         DEALSEQ  DEAL  ','  BREAK(',') . DEAL         :F(ERR)
         HAND  =  DEAL
         N  =  52
NLOOP    DEALSEQ  HAND  ','  BREAK(',') . HAND         :F(ERR)
         INSERT(HAND,NTH('DECK',RANDOM(N)))
         N  =  GT(N,1)  N - 1                          :S(NLOOP)
-EJECT
*
*                  OUTPUT OF HAND
*
         TITLE  =  NTHDEAL
         DEALER  =  DEAL
         SKIP = '        '
         OUTPUT  =  LINE('NORTH',40)
         OUTPUT  =
         OUTPUT  =  LINE(SUITL('NORTH','S'),40)
         OUTPUT  =  LINE(SUITL('NORTH','H'),40)
         OUTPUT  =  LINE(SUITL('NORTH','D'),40)
         OUTPUT  =  LINE(SUITL('NORTH','C'),40)
         SKIP = '        '
         OUTPUT  =  LINE('WEST',20,'EAST',60)
         OUTPUT  =
         OUTPUT  =  LINE(SUITL('WEST','S'),20,
.                        SUITL('EAST','S'),60)
         OUTPUT  =  LINE(SUITL('WEST','H'),20,
.                        SUITL('EAST','H'),60)
         OUTPUT  =  LINE(SUITL('WEST','D'),20,
.                        SUITL('EAST','D'),60)
         OUTPUT  =  LINE(SUITL('WEST','C'),20,
.                        SUITL('EAST','C'),60)
         SKIP = '        '
         OUTPUT  =  LINE('SOUTH',40)
         OUTPUT  =
         OUTPUT  =  LINE(SUITL('SOUTH','S'),40)
         OUTPUT  =  LINE(SUITL('SOUTH','H'),40)
         OUTPUT  =  LINE(SUITL('SOUTH','D'),40)
         OUTPUT  =  LINE(SUITL('SOUTH','C'),40)
.                                                      :(NEWDEAL)
END
./*
